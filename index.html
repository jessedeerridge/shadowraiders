<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>eｒｒ</title>
<style>
  :root{
    --card-w:24px; --card-h:40px; --card-gap:3px;
    --char-w:40px; --char-h:60px;
    --item-w:50px; --item-h:75px;
    --con-w: var(--item-w); --con-h: var(--item-h); 
    --di-w:70px; --di-h:65px;
    /* テーブルの見えている枠は固定。内部だけ広げる */
    --table-h:96px; --header-h:8px;
    --content-h: calc(var(--table-h) - var(--header-h) - 6px);
    --content-extra: 18px;
    --font-card:16px; --font-weight:bold;
  }

  *,*::before,*::after{box-sizing:border-box}
  
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee}
  h1{margin:0;font-size:18px}
  .small{font-size:12px;opacity:.75}
  .bold{font-weight:700}

  main{padding:10px 12px;display:flex;gap:12px; overflow:visible;}
  .col{flex:1;min-width:0; overflow:visible;}
  .side{width:38%;max-width:420px}

  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px; font-size:16px;}
  .btn{padding:8px 12px;border:1px solid #ddd;border-radius:8px;background:#f8f8f8;cursor:pointer}
  .btn.primary{background:#111;color:#fff;border-color:#111}
  .btn.small{padding:6px 10px;font-size:12px}
  .btn.big{padding:12px 14px;font-size:16px}
  .btn.ghost{background:transparent}
  .hidden{display:none!important}

  .fab{position:fixed;right:12px;bottom:12px;width:48px;height:48px;border-radius:50%;display:grid;place-items:center;background:#111;color:#fff;cursor:pointer;z-index:10}
  .menu{position:fixed;right:12px;bottom:64px;display:flex;flex-direction:column;gap:6px;background:#fff;border:1px solid #eee;border-radius:10px;padding:8px;box-shadow:0 12px 24px rgba(0,0,0,.08);z-index:11}
  .menu .btn{width:220px;text-align:left}

  /* ★ ホスト左下の工具ボタン */
  .host-tool{position:fixed;left:12px;bottom:12px;width:48px;height:48px;border-radius:50%;display:grid;place-items:center;background:#111;color:#fff;cursor:pointer;z-index:10}

  .items-bar{display:flex;align-items:center;gap:8px;margin-top:0}
  .items{display:flex;gap:6px;align-items:center;overflow-x:auto}
  .item{
    position:relative; width:var(--item-w);height:var(--item-h);
    border:1px solid #ddd;border-radius:8px;background:#fff;
    background-size:cover;background-position:center;cursor:pointer;flex:0 0 auto
  }
  .item.used{background:#fff url('./itemback.jpg') center/cover no-repeat}
  /* ★ M12：アイテムの下に付ける小型数値バッジ */
  .num-badge{
    position:absolute; left:50%; transform:translateX(-50%);
   bottom:-14px; min-width:18px; height:18px; padding:0 4px;
    border-radius:9px; border:1px solid #ddd; background:#fff;
    font-size:12px; line-height:18px; text-align:center;
   box-shadow:0 2px 6px rgba(0,0,0,.12); pointer-events:none;
  }


 .di{ margin-left:auto;width:var(--di-w);height:var(--di-h);border-radius:10px;　border:none;　background:#fff;
    background-size:cover;background-position:center;cursor:pointer;flex:0 0 auto ;background-size:contain;}

/* ▼ 数値カードの表示帯（アイテム下など） */
  .numlane { display:flex; gap:6px; margin-top:6px; align-items:center; overflow-x:auto; }
  .numcard { width:32px; height:48px; border-radius:6px; border:1px solid #ddd; background:#fff center/cover no-repeat; flex:0 0 auto; }
  .numdeck { width:32px; height:48px; border-radius:6px; border:1px dashed #bbb; background:#fff url('./numberdeck.png') center/70% no-repeat; cursor:pointer; user-select:none; display:grid; place-items:center; }
  .numrest { font-size:11px; opacity:.7; margin-left:2px; }

  /* ★ 右2/左2/右4/左4 を横向きに（横長） */
  .rulecard { width:48px; height:32px; border-radius:6px; border:1px solid #ddd; background:#fff center/contain no-repeat; flex:0 0 auto; }

  /* ★ 数値カードの「重ね」用ホルダー＆オーバーレイ */
  .numcard-holder { position:relative; width:32px; height:48px; flex:0 0 auto; }
  .numcard.overlay { position:absolute; left:2px; top:2px; opacity:0.9; }
  .numcard.overlay:nth-child(3){ left:4px; top:4px; opacity:0.85; }
  .numcard.overlay:nth-child(4){ left:6px; top:6px; opacity:0.8; }
 .conlane { display:flex; gap:6px; margin-top:6px; align-items:center; overflow-x:auto; }
  .concard {
    /* ここから変更 */ width:var(--con-w, var(--item-w, 50px)); height:var(--con-h, var(--item-h, 75px)); /* ここまで変更 */
    border-radius:8px; border:1px solid #ddd;
    background:#fff center/cover no-repeat; flex:0 0 auto; cursor:pointer;
  }

  #conZoomOverlay{
    position:fixed; inset:0; background:rgba(0,0,0,.4);
    display:flex; align-items:center; justify-content:center;
    z-index:9999;
  }
  .conzoom-wrap{ position:relative; }
 .conzoom-card{
    /* ここから変更 */ width:var(--con-w, var(--item-w, 50px)); height:var(--con-h, var(--item-h, 75px)); /* ここまで変更 */
    transform:scale(2); transform-origin:center;
    border-radius:12px; border:2px solid #fff; background:#fff center/cover no-repeat;
    box-shadow:0 10px 30px rgba(0,0,0,.35); cursor:pointer;
  }
  .conzoom-menu{
    position:absolute; top:50%; left:50%;
    translate:-50% calc(-50% + 120px);
    background:#fff; border:1px solid #ddd; border-radius:10px;
    padding:8px 10px; display:flex; gap:8px; z-index:10000;
    box-shadow:0 6px 20px rgba(0,0,0,.2);
  }
  .conzoom-menu button{
    font-size:14px; padding:6px 10px; border-radius:8px;
    border:1px solid #ccc; background:#f7f7f7; cursor:pointer;
  }
  
  /* ★ ミッション12：アイテムの“外側の真下”に並べる帯 */
  .num-under{
    display:grid;
    grid-auto-flow:column;
    grid-auto-columns:var(--item-w); /* アイテム幅に合わせて1列=1アイテム */
    gap:6px;               /* .items の gap と合わせる */
    margin-top:4px;        /* アイテム列のすぐ下に表示 */
    align-items:start;
    justify-content:start;
    width:max-content;     /* はみ出し対策：内容幅に合わせる */
  }
  .num-under .slot{
    width:var(--item-w);
    display:grid;
    place-items:center;    /* 中央配置 */
  }
  .num-under .numcard-holder{
    position:relative;
    width:32px; height:48px;
  }
  
  .tables{display:flex;flex-direction:column;gap:8px;margin-top:6px;overflow:visible;position:relative;margin-left:-12px;}
  .table{
    position:relative;border:1px dashed #ddd;border-radius:10px;
    padding:0 8px;height:var(--table-h);display:block;background:#fff;
    overflow:hidden;width:max-content;z-index:0;
 transition: none; 
  }
  .table.anim-h{
  transition: height .25s ease;  /* ← 必要時だけ付ける */
}
  .table.elevated{ z-index:9999; }

  .t-header{height:var(--header-h);display:flex;align-items:center;gap:6px;font-size:12px;margin-top:0;}
  .title{text-decoration:underline;padding-right:4px}

  .t-content{
    position:absolute;left:8px;right:8px;top:calc(var(--header-h) + 2px);bottom:calc(4px - var(--content-extra));
    display:flex;gap:8px;align-items:flex-start;min-height:var(--content-h);overflow:visible;
  }

  .char-card{
    width:var(--char-w);height:var(--char-h);background-size:cover;background-position:center;border-radius:6px;border:1px solid #ddd;
    cursor:pointer;user-select:none;flex:0 0 auto;
  }
  /* ▼ M61: 制約カードの下に置く極小キャラ */
  .m61-mini{
    width:16px; height:20px;            /* とても小さく */
    border:1px solid #ddd; border-radius:4px;
    background:#f3f4f6 center/cover no-repeat;
    margin:2px auto 0; user-select:none; cursor:pointer;
  }
  .m61-mini.blank{ background:#f3f4f6; border:1px dashed #d1d5db; cursor:default; }
  /* 縦積みラッパー */
  .m61-stack{ display:flex; flex-direction:column; align-items:center; width:var(--char-w); }

  /* ★ #13：キャラと下部トークンを縦積みするためのラッパー */
  .char-col{
    display:flex; flex-direction:column; align-items:center; gap:2px;
    width:var(--char-w); flex:0 0 auto;
  }
  
  .char-card.blank{background:#f3f4f6;border:1px dashed #d1d5db;cursor:default;}

  .hand{
    display:flex;align-items:flex-start;gap:var(--card-gap);
    overflow-y:visible; overflow-x:visible;
    flex:0 0 auto;position:relative;
    max-height:calc(var(--content-h) - 2px + var(--content-extra));
    padding-bottom:2px;
  }

  .card-wrap{position:relative;width:var(--card-w);min-height:calc(var(--card-h) + 36px);flex:0 0 auto;}
  .card{
    width:var(--card-w);height:var(--card-h);border-radius:6px;border:1px solid #ddd;position:absolute;left:0;top:0;
    background:#bbb;display:flex;align-items:flex-start;justify-content:center;cursor:pointer;user-select:none
  }
  .card.back{background:#fff url('./codeback.jpg') center/cover no-repeat;border-color:#ccc}
    .card.back .num{display:none;}   /* ← 裏状態では数字を隠す */
  .card.open{background:#000}
  /* ★ アイテム2：選択可能カードの青枠 */
  .card.i2-selectable{outline:2px dashed #38bdf8; outline-offset:-1px;}

  .num{position:absolute;top:2px;left:0;right:0;text-align:center;font-size:var(--font-card);font-weight:var(--font-weight);color:#fff;line-height:1;text-shadow:0 1px 0 rgba(0,0,0,.15)}
  .img-bottom{position:absolute;left:1px;right:1px;bottom:1px;height:18px;border-radius:0 0 6px 6px;background-size:cover;background-position:center}

  .badge-fixed{position:absolute;left:0;right:0;top:calc(var(--card-h) + 2px);display:flex;flex-direction:column;align-items:center;z-index:10000;pointer-events:auto;}
  .alpha{width:var(--card-w);text-align:center;font-size:11px;user-select:none;line-height:1;background:#6b21a8;color:#fff;border:1px solid #4c1d95;border-radius:6px;padding:2px 0;cursor:pointer}
  .tok-col{display:flex;flex-direction:column;gap:2px;margin-top:2px}
.token{
    font-size:11px; line-height:1;
    border-radius:4px;
    /* 正方形・中央揃え */
    display:inline-grid; place-items:center;
    width:20px; height:20px;   /* ← 統一サイズ（2桁OK） */
    padding:0;                 /* 中央ぴったりに */
  }  /* ▼▼ 変更1：＝ と ≠ の色を入れ替え ▼▼ */
  .token.equal{background:#cfe8ff;color:#000}
  body[data-seated="no"] .token { display: none !important; }

  .token.black{background:#000;color:#fff}
  .token.x1{background:#e5e7eb;color:#000}
  .token.noteq{background:#ffedd5;color:#000}

/* ▼ ミッション専用トークン */
  .token.yellow { background:#000; color:#ffd400; }  /* 黄コード「▧」 */
  .token.x2 { background:#e5e7eb; color:#000; }      /* x2 */
  .token.x3 { background:#e5e7eb; color:#000; }      /* x3 */
  .token.even { background:#cfe8ff; color:#000; }    /* 偶数 2/4 */
  .token.odd  { background:#e75480; color:#000; }    /* 奇数 1/3 */
.token.yellowX { background:#ffd400; color:#000; }

.marker,.blink{
  position:absolute;left:0;right:0;top:-12px;
  text-align:center;font-size:14px;line-height:1;
  z-index:12000; pointer-events:none;
}
.blink{ animation: blink 0.6s linear infinite; }
@keyframes blink{ 0%,100%{opacity:0} 50%{opacity:1} }

/* ★ #22：名前の下に置く「選択ボタン ×3」 */
.pick3{ display:flex; gap:4px; margin-left:8px; }
.pickbtn{
  width:22px; height:22px; border:1px dashed #999; border-radius:4px;
  background:#fff; display:grid; place-items:center; font-size:12px; line-height:1;
  color:#000; user-select:none; cursor:pointer;
}
.pickbtn.readonly{ opacity:.6; cursor:default; }

/* ▼▼ ここから 追加 ▼▼ */
.m22-panel{
  display:flex; gap:6px; align-items:center; flex-wrap:wrap;
  margin-top:6px;
}
.m22-panel .cap{ font-size:12px; opacity:.75; margin-right:6px; }
.m22-panel .token{ cursor:pointer; }
.m22-panel .token.disabled{ opacity:.35; cursor:default; }

.m22-under{
  display:flex; gap:2px; margin-top:2px;
}
.m22-under .token{ width:20px; height:20px; }

/* ★ #50：キャラ下の情報トークン（4列で折返し） */
.m50-under{
  display:grid;
 grid-template-columns:repeat(3, 20px);
  gap:2px;
  margin-top:2px;
}
.m50-under .token{ width:20px; height:20px; }
  
  /* ミッション27：アイテム列の直下に並べるトークン行 */
  .m27-row{
    display:flex; gap:6px; margin-top:4px; align-items:center;
  }
  .m27-row .cap{ font-size:12px; opacity:.75; margin-right:6px; }
  .m27-row .token{ cursor:pointer; }


/* ★ #22：情報トークン表（3×4）— 黒トークン + 右に x0/x1/x2 */
.info22{
  position:fixed; left:50%; bottom:12px; transform:translateX(-50%);
  background:#fff; border:1px solid #eee; border-radius:10px; box-shadow:0 10px 24px rgba(0,0,0,.12);
  padding:8px; z-index:2147483601;
  display:grid; grid-template-columns:repeat(4, auto); gap:8px; /* ← 3行×4列になる */
}
.info22 .cell{
  display:flex; align-items:center; gap:6px;
  border:1px dashed #bbb; border-radius:6px; padding:6px 8px; background:#fff; font-size:12px;}
.info22 .cell .token{ width:22px; height:22px; } /* 既存の .token を流用（黒） */
.info22 .xlabel{ font-family:ui-monospace, SFMono-Regular, Menlo, monospace; opacity:.8; }
/* x0 セルを薄くしてクリック不可にする */
.info22 .cell.disabled { opacity: 0.5; pointer-events: none;　}

/* ★ チェック表（テーブル1の真上） */
.checklist{
  display:flex; gap:6px; margin:0 0 0 10px; align-items:center;
}
.check-item{
  position:relative; width:30px; height:30px;
  border:1px dashed #999; border-radius:4px;
  background:#fff; display:grid; place-items:center;
  font-size:12px; user-select:none; color:#000;
}
.check-mark{
  position:absolute; inset:0; margin:auto;
  width:18px; height:18px; border-radius:50%;
  background:rgba(34,197,94,.35);
  pointer-events:none;
}
  
  .pop-layer{ position:fixed;inset:0;z-index:2147483647;pointer-events:none; }
  .mini-pop{
    position:fixed;z-index:2147483647;background:#fff;border:1px solid #eee;border-radius:8px;padding:6px;box-shadow:0 8px 20px rgba(0,0,0,.08);
    display:flex;gap:6px;pointer-events:auto;flex-wrap:wrap;max-width:min(300vw,320px)
  }
  .bottom-pop{left:50%;transform:translateX(-50%);bottom:10px;}

  /* ★ 画面下部のグローバル黒枠バッジ（アイテム16表示） */
  .global-reveal{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);z-index:2147483647;}
  .global-reveal .token{cursor:pointer; box-shadow:0 4px 10px rgba(0,0,0,.12);}

  /* 追加：アイテム16のサイド表示 */
  .i16-side{
    position:absolute; left:calc(100% + 6px); top:50%; transform:translateY(-50%);
    z-index:2147483000;
  }

/* 追加：アイテム16の黒トークンをカードの真下に表示 */
.i16-below{
  position:absolute;
  left:50%;
  top:calc(100% + 4px);
  transform:translateX(-50%);
  z-index:2147483000;
}

/* 追加：アイテム16使用時はカード本体を上に持ち上げる */
.i16-lift{
  transform: translateY(-35px);
}
    
  .panel{display:flex;flex-direction:column;gap:10px}
  .list{border:1px solid #eee;border-radius:10px;padding:8px}
  .list h3{margin:0 0 6px 0;font-size:13px}
  .name{padding:4px 6px;border-radius:6px}
  .muted{opacity:.6}
  .mission{border:1px solid #eee;border-radius:10px;padding:10px}
  .mission h3{margin:0 0 8px 0;font-size:14px}

  .mission-footer{margin-top:12px;border-top:1px solid #eee;padding-top:8px}
  .mission-footer .line{font-size:13px;line-height:1.5}
  .mission-footer .line + .line{margin-top:4px}

  .restart-pop,.start-pop{
    position:fixed;left:50%;top:50%;transform:translate(-50%, -50%);
    background:#fff;border:1px solid #eee;border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:14px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px
  }
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:#fff;border:1px solid #eee;border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px
  }
  .start-pop .row,.seat-pop .row{display:flex;gap:8px;align-items:center}
  .start-pop label,.seat-pop label{width:84px;font-size:13px}
  .start-pop select{flex:1;padding:8px;border:1px solid #ddd;border-radius:8px;background:#fff}
  .restart-actions{display:flex;gap:8px;align-items:center}
  .restart-actions .btn:first-child{font-size:11px;padding:4px 8px}
  .restart-actions .btn.big{flex:1}

  .tabs{display:flex;gap:6px;flex-wrap:wrap}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none}
  .tab.active{background:#111;color:#fff;border-color:#111}
  .tab.disabled{opacity:.35;pointer-events:none}

 @media (max-width: 860px){
    main{flex-direction:column}
    .side{width:100%;max-width:none}
  }

/* ▼▼ 画面下部ミッションピッカー ▼▼ */
.mp{
  position:fixed; left:0; right:0; bottom:0;
  background:#fff; border-top:1px solid #eee;
  box-shadow:0 -10px 24px rgba(0,0,0,.08);
  z-index:2147483600;
  /* ← iPhoneのセーフエリアに合わせて余白を取る（左右/下） */
  padding-top:8px;
  padding-right: max(10px, env(safe-area-inset-right));
  padding-bottom: calc(8px + env(safe-area-inset-bottom));
  padding-left:  max(10px, env(safe-area-inset-left));
}
.mp-inner{
  max-width:100%;
  width:100%;
  margin:0 auto;
}
.mp-row{ display:flex; gap:10px; align-items:flex-start; margin:8px 0; }
.mp-label{ width:64px; font-size:12px; opacity:.75; line-height:2; }

/* ★ 横6列固定・右端が切れないよう minmax(0,1fr) を使用 */
.mp-grid{
  display:grid;
  grid-template-columns: repeat(6, minmax(0, 1fr)); /* 6列固定 */
  gap:6px;
  max-height:50vh;
  overflow-y:auto;
  overflow-x:hidden;
}

/* ★ 正方形ボタン（中身がはみ出さないよう min-width:0 も付与） */
.mp-grid .btn{
  width:100%;
  min-width:0;            /* ← これが無いと右端が押し出されがち */
  text-align:center;
  padding:10px 0;
  aspect-ratio:1 / 1;
  font-size:16px;
}

/* 小さい端末で少しだけ詰める（任意） */
@media (max-width: 360px){
  .mp-grid{ gap:4px; }
  .mp-grid .btn{ font-size:14px; padding:8px 0; }
}

.mp-actions{ display:flex; justify-content:flex-end; margin-top:6px; }
/* ▲▲ 画面下部ミッションピッカー ▲▲ */

.code-link{ text-decoration: underline; cursor: pointer; }

  /* ▼▼ nano 行（itemsBar のすぐ下） ▼▼ */
.nano-row{
  position:relative;
  height:56px;           /* nano の高さぶん */
  margin:4px 0 0 10px;   /* items と checklist の“間”に置く */
  z-index:2147483601;    /* ほぼ最前面。ただし pop よりは下でOK */
}
.m43-nano{
  position:absolute;     /* 行の中で左右だけ合わせる */
  width:56px; height:56px;
  background-size:contain; background-repeat:no-repeat; background-position:center;
  pointer-events:auto;   /* クリックで回収メニュー */
}


  
 /* ▼▼ ミッション44（酸素トークン） ▼▼ */
.token.ox{
  background:none;   /* ← 背景色を消す */
  color:transparent; /* ← テキスト色も消す */
  background-image:url('./ox.png');
  background-size:contain;
  background-repeat:no-repeat;
}
 .ox-row{
   display:flex; flex-wrap:nowrap; gap:2px; margin-top:0; /* ← 横一列＆縦位置はJSで制御 */
   max-width:none;                 /* ← 折り返し禁止 */
   width:max-content;              /* ← 中身幅に合わせる */
   flex:0 0 auto;
   align-self:flex-start;
 }
.ox-row.ox-pool{ align-items:center; gap:6px; max-width:none; }
.ox-side{
 width:var(--item-w); height:var(--item-h);
  border-radius:8px; border:1px solid #ddd;
  background:#fff url('./ox2.jpg') center/cover no-repeat;
  flex:0 0 auto;
}
.ox-wrap{
  display:flex; flex-wrap:wrap; gap:2px;
  /* 1行あたり15個（幅20px×15 + ギャップ2px×14） */
  max-width:calc(20px * 15 + 2px * 14);
}
/* ▼▼ ミッション66：ステージ＋制約カード（十字） ▼▼ */
.m66-layer{
  position:relative;
  display:grid;
  gap:6px;
  place-items:center;
  margin-top:6px;
  z-index:1; /* tables(0) より上：checklistより上に来る */
}
.m66-line{ display:flex; align-items:center; justify-content:center; gap:6px; }

.m66-slot{
  width:var(--con-w); height:var(--con-h);
  border-radius:8px; border:1px dashed #bbb;
  display:grid; place-items:center;
}
.m66-slot .concard{
  width:var(--con-w); height:var(--con-h);
  border-radius:8px; border:1px solid #ddd;
  background:#fff center/cover no-repeat; cursor:pointer;
}

/* ステージ本体：カード2倍＆横向き表示（rotate） */
.m66-stagebox{ position:relative; }
.m66-stage{
  width: calc(var(--con-w) * 3.5);
  height: calc(var(--con-h) * 1.6);
  border-radius:12px; border:1px solid #ddd;
  background:#fff center/cover no-repeat;
  user-select:none;
}

/* 右上ホットスポット（階切替） */
.m66-hot{
  position:absolute; right:2px; top:2px;
  width:12px; height:12px; cursor:pointer; z-index:2;
}

/* ラビット（1匹のみ、クリック位置に出す） */
.m66-rabit{
  position:absolute; left:50%; top:50%;
  width:30px; height:45px;
  background:url('./rabit.png') center/contain no-repeat;
  pointer-events:none;
  transform: translate(-50%, -50%) /* 見た目の横向きに合わせ微調整 */
}
/* ▲▲ ミッション66 ▲▲ */

  
</style>
</head>
<body>
<header>
  <h1>BOMB　BUSTERS</h1>
  <div class="small" id="roomInfo"></div>
</header>

<main>
  <div class="col">
<div class="join-box" id="joinBox">
  <!-- ★追加：名前（4文字以内）※未入力でも入室可 -->
  <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
  <input id="roomCode" placeholder="ルームコード" maxlength="12" />
  <button class="btn primary" id="btnJoin">入室</button>
  <button class="btn ghost" id="btnRandom">自動コード</button>
</div>


    <div id="lobby" class="hidden">

      <div class="items-bar hidden" id="itemsBar">
        <div class="items" id="items"></div>
        <div class="di" id="di"></div>
      </div>

      <div class="tables" id="tables"></div>

<div id="missionFooter" class="mission-footer hidden">
  <div id="m22PickPanel" class="m22-panel hidden">
    <span class="cap">未所持の数字から最大2つ選択：</span>
  </div>
  <div id="missionDetailTitle" class="bold line"></div>
  <div id="missionDetailBody"></div>
</div>


      <button class="fab hidden" id="gear" title="設定">⚙</button>
      <div class="menu hidden" id="menuPopup">
        <button class="btn" id="btnSit">席に座る</button>
        <button class="btn" id="btnLeaveSeat">席を立つ</button>
        <button class="btn" id="btnPickMission">ミッションを選ぶ</button>
      </div>
    </div>
  </div>

  <div class="col side">
    <div class="panel">
    </div>
  </div>
</main>

<!-- ▼▼ 画面下部ミッションピッカー ▼▼ -->
<div id="missionPicker" class="mp hidden">
  <div class="mp-inner">
    <div class="mp-row">
      <div class="mp-label">人数</div>
      <div id="mpCounts" class="tabs"></div>
    </div>
    <div class="mp-row">
      <div class="mp-label">ミッション</div>
      <div id="mpMissions" class="mp-grid"></div>
    </div>
    <div class="mp-actions">
      <button class="btn small ghost" id="btnMpBack">戻る</button>
    </div>
  </div>
</div>
<!-- ▲▲ 画面下部ミッションピッカー ▲▲ -->

<div id="miniPop" class="mini-pop hidden"></div>
<div id="popLayer" class="pop-layer"></div>
<!-- ★ アイテム16の表示先（画面下部） -->
<div id="globalReveal" class="global-reveal hidden"></div>
<!-- ★ ホスト左下 工具アイコン -->
<button id="hostTool" class="host-tool hidden" title="工具">🔧</button>

<div id="restartPop" class="restart-pop hidden">
  <div style="font-size:14px">やり直しますか？</div>
  <div class="restart-actions">
    <button class="btn" id="btnRestartOk">やり直す</button>
    <button class="btn big" id="btnRestartCancel">キャンセル</button>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="row"><label>人数</label>
    <select id="selCount"><option>2</option><option>3</option><option selected>4</option><option>5</option><option>6</option></select>
  </div>
  <div class="row"><label>ミッション</label>
<select id="selMission">
  <option value="1">#1 爆弾（赤コード）</option><option value="2">#2 黄コード</option><option value="3">#3 さらい爆弾</option>
  <option value="4">#4</option><option value="5">#5</option><option value="6">#6</option><option value="7">#7</option>
  <option value="8">#8</option>
  <option value="9">#9 aaa</option>
  <option value="10">#10 bbb</option>
  <option value="11">#11 ccc</option>
  <option value="12">#12</option>
  <option value="42">#42</option><option value="43">#43</option>
  <option value="49">#49</option>
</select>
  </div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small" id="btnStartOk">OK</button>
    <button class="btn small ghost" id="btnStartCancel">キャンセル</button>
  </div>
</div>


  
<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, get, set, update, remove, onValue, onDisconnect } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* Firebase */
const firebaseConfig = {
  apiKey: "AIzaSyBpSx_lEcg1j9ExMJsVl5lBqAxOCfmFmSnI",
  authDomain: "chat-68c4c.firebaseapp.com",
  databaseURL: "https://chat-68c4c-default-rtdb.firebaseio.com",
  projectId: "chat-68c4c",
  storageBucket: "chat-68c4c.appspot.com",
  messagingSenderId: "172284325975",
  appId: "1:172284325975:web:6f9bdd77e822c0ea39dd92"
};
const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

/* State */
const state = {
  roomCode:null, userId:crypto.randomUUID(), userName:'', // ★未入力なら入室時に採番
  isHost:false, mode:null, gameStarted:false, seatedTable:null, watching:null, seatPick:null,
  m22GaveOnce:false, // ★ #22：自分が渡した一回ガード（即時連打対策）
  _lastMissionId:null};
// ▼ #13 ヘッダートークンの遅延更新用ガード（レンダー中にDBを書かないため）
let m13HeaderUpdateScheduled = false;
let m13HeaderClearIndices = null; // null → Set(index)（消す対象のテーブルindexを貯める）
state._mpAutoOnce = false;  // 「参加」後に自動でピッカーを開いたか（ホストのみ）  


/* Elements */
const roomInfo = document.getElementById('roomInfo');
const joinBox= document.getElementById('joinBox');
const inputName = document.getElementById('userName'); // ★追加
const inputCode = document.getElementById('roomCode');

const btnJoin = document.getElementById('btnJoin');
const btnRandom=document.getElementById('btnRandom');

const lobby   = document.getElementById('lobby');
// ▼ 追加：クイックミッションピッカー起動ボタン
const btnOpenPicker = document.getElementById('btnOpenPicker');

const itemsBar= document.getElementById('itemsBar');
const itemsEl = document.getElementById('items');
const diEl    = document.getElementById('di');

try{
  const qs = new URLSearchParams(location.search);
  const qRoom = (qs.get('room')||'').trim();
  const qName = (qs.get('name')||'').trim();
  if (qRoom) inputCode.value = qRoom.slice(0, 12);
  if (qName) inputName.value = qName.slice(0, 4);
}catch(_e){}
  
const tablesEl= document.getElementById('tables');
const gear    = document.getElementById('gear');
const menuPop = document.getElementById('menuPopup');
const btnSit  = document.getElementById('btnSit');
const btnLeave= document.getElementById('btnLeaveSeat');
// ▼ やり直すを廃止し、ミッションピックに変更
const btnPickMission = document.getElementById('btnPickMission');
// ▼ 既存のrestartPop系は残すが使用しない（互換維持）
const restartPop=document.getElementById('restartPop');
const btnRestartOk=document.getElementById('btnRestartOk');
const btnRestartCancel=document.getElementById('btnRestartCancel');

// ▼ ミッションピッカー要素
const mp = document.getElementById('missionPicker');
const mpCounts = document.getElementById('mpCounts');
const mpMissions = document.getElementById('mpMissions');
const btnMpBack = document.getElementById('btnMpBack');


const miniPop = document.getElementById('miniPop');

const startPop=document.getElementById('startPop');
const selCount=document.getElementById('selCount');
const selMission=document.getElementById('selMission');
const btnStartOk=document.getElementById('btnStartOk');
const btnStartCancel=document.getElementById('btnStartCancel');


const missionFooter = document.getElementById('missionFooter');
const missionDetailTitle = document.getElementById('missionDetailTitle');
const missionDetailBody  = document.getElementById('missionDetailBody');
const m22PickPanel = document.getElementById('m22PickPanel');

const seatPop = document.getElementById('seatPop');
const seatTabs= document.getElementById('seatTabs');
const btnSeatCancel=document.getElementById('btnSeatCancel');

/* Pop layer */
const popLayer = document.getElementById('popLayer');
/* global reveal */
const globalReveal = document.getElementById('globalReveal');
/* host tool */
const hostTool = document.getElementById('hostTool');

/* helpers */
function hiragana(len=4){
  const h=[..."あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをん"];
  return Array.from({length:len},()=>h[Math.random()*h.length|0]).join('');
}
const H=(el,b)=> el.classList.toggle('hidden', !!b);
function pos(el,x,y){el.style.left=x+'px';el.style.top=y+'px';}
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]]}return a}
function cssNum(name){const v=getComputedStyle(document.documentElement).getPropertyValue(name).trim(); return parseFloat(v.replace('px',''))||0;}
const now=()=>Date.now();

function buildRoomLink(){
  const url = new URL(location.href);
  url.searchParams.set('room', state.roomCode || '');
  return url.toString();
}
async function copyText(text){
 try{
   await navigator.clipboard.writeText(text);
    alert('リンクをコピーしました');
  }catch(_e){
    // 失敗時フォールバック
    prompt('コピーできない場合はこのテキストをコピーしてください', text);
  }
}
  
/* ==== ミッション素材定義 ==== */
const MATERIALS = {
  redCodes : [1,2,3,4,5,6,7,8,9,10,11].map(n=> n + 0.5),
  yellowCodes : [1,2,3,4,5,6,7,8,9,10,11].map(n=> n + 0.1),
  numbers : [1,2,3,4,5,6,7,8,9,10,11,12]
};
// ★ 修正：文字列リテラル
const imgNumber = n => `./s${n}.jpg`;
const imgBack   = `./numbercardback.jpg`;
const imgRule   = name => `./${name}.jpg`; // right2/left2/right4/left4
const imgConstraint = L => `./${String(L).toLowerCase()}.jpg`;

const imgChallenge = id => `./${id}.png`;

/* ===== 数値カード一意管理＆重ね表示ユーティリティ ===== */
/* 同じ数字のカードが同時に存在しないように管理する */
const NUMCARD_REG = new Map(); // n -> { holder:HTMLDivElement, count:number }

/* === 前のゲームの表示物を全て掃除する === */
function clearMissionOverlays(){
document.querySelectorAll('.numlane').forEach(n => {
  if (n.id !== 'm11Row') n.remove();  // m11Rowは残す
});
 
  document.querySelectorAll('.num-pin').forEach(pin => pin.remove());
  document.querySelectorAll('.num-under').forEach(n => n.remove()); // ★ 追加
  // ★ ミッション22：情報トークン表を確実に消す
  const info22 = document.getElementById('info22');
  if (info22) info22.remove();
    // ★ ミッション27：アイテム直下の行を確実に消す
  const m27 = document.getElementById('m27Row');
  if (m27) m27.remove();
  // ★追加：制約系UI（#31/#32/#37）を丸ごと掃除
  document.querySelectorAll('.conlane').forEach(n => n.remove());   // 例：m31HandRow/m31CenterRow/m32ConRowはconlane
  ['m31HandRow','m31CenterRow','m32ConRow','conZoomOverlay'].forEach(id=>{
  const m44 = document.getElementById('m44OxPool'); if (m44) m44.remove(); // ← ox2の行を確実に掃除
  });

  document.getElementById('m57Grid')?.remove();       // 3×4グリッド
  document.querySelectorAll('.m57-grid').forEach(n=>n.remove()); // 互換
  document.getElementById('m57Sel')?.remove();        // di左の選択表示
  // ★ M59：数値帯＆nanoを掃除
document.querySelectorAll('.m59-row').forEach(n => n.remove());
  document.getElementById('m59Nano')?.remove();

  // ★ M61：各テーブル左の制約カードを掃除
  document.querySelectorAll('.m61-con').forEach(n => n.remove());

  
  // ★ M44：酸素UIを完全掃除（プール=ox2 と各テーブル所持行）
  const m44 = document.getElementById('m44OxPool');
  if (m44) m44.remove();               // 左の ox2 を含むプール行
  document.querySelectorAll('.ox-row').forEach(n => n.remove()); // 各テーブルの所持行
  
  // テーブルの高さを基準に戻す（M44で上げたものを解除）
  document.querySelectorAll('.table').forEach(tb=>{
    tb.style.removeProperty('--table-h');
  });
  
  NUMCARD_REG.clear();
}

/** mountParent配下に n のカードを「新規作成 or 既存に重ね」 */
function placeNumberCard(n, mountParent){
  const existing = NUMCARD_REG.get(n);
  if (existing) {
   // ★ 既存ホルダーを新しい親へ“移動”する（DOM外でもOK）
    mountParent.appendChild(existing);
    return;
  }
  const holder = document.createElement('div');
  holder.className = 'numcard-holder';
  const base = document.createElement('div');
  base.className = 'numcard';
  base.style.backgroundImage = `url('${imgNumber(n)}')`;
 holder.appendChild(base);
  mountParent.appendChild(holder);
  NUMCARD_REG.set(n, holder);
}

/** 未使用（＝現在テーブル上に存在しない）数字から count 枚選ぶ */
function pickUnusedNumbers(count){
  const used = new Set(NUMCARD_REG.keys());
  const pool = MATERIALS.numbers.filter(x => !used.has(x));
  shuffle(pool);
  return pool.slice(0, count);
}

/* === ミッション12用：各アイテムの“外側の真下”に一枚ずつ === */
function distributeNumbersToItemsCentered(eachCount=1){
  const itemsBar = document.getElementById('itemsBar');
  const items    = document.querySelectorAll('#items .item');
  if(!itemsBar || items.length===0) return;

  // 既存を掃除（ミッションやり直し時の二重生成防止）
  const old = document.querySelector('.num-under');
  if(old) old.remove();

  // レーンを作成してアイテム列の直下に挿入
  const under = document.createElement('div');
  under.className = 'num-under';
  itemsBar.insertAdjacentElement('afterend', under);

  // 未使用数字から必要枚数ぶん抽選
  const need  = items.length * eachCount;
  const picks = pickUnusedNumbers(need);

  // アイテム数に合わせて同数のスロットを用意し、中央にカードを配置
  let p = 0;
  items.forEach(()=> {
    const slot = document.createElement('div');
    slot.className = 'slot';
    under.appendChild(slot);

    for(let k=0; k<eachCount; k++){
      const n = picks[p++]; if(n==null) break;
      // placeNumberCard は holder を作って mountParent に追加する
      placeNumberCard(n, slot);
    }
  });
}


/* ★★★ 赤/黄コード抽選ヘルパー ★★★ */
function pickK(arr, k){
  const a = arr.slice(); shuffle(a);
  return a.slice(0, Math.max(0, Math.min(k, a.length)));
}

/**
 * ミッションごとの「赤/黄の混入仕様」をここで定義
 */
function buildMixPlan(missionId){
  const plans = {
    8:  [
    {type:'redChoose', from:2, take:1},
    {type:'yellowChoose', from:3, take:2},
    ],    
    9:  [
      {type:'redPick',    k:1},
      {type:'yellowPick', k:2},
    ],
    10: [
      {type:'redPick',    k:1},
      {type:'yellowPick', k:4},
    ],
    11: [
      {type:'redPick',    k:2},
    ],
    12: [
      {type:'redPick',    k:1},
      {type:'yellowPick', k:4},
    ],
  13: [ /* #13 は専用配布をするのでここでは赤を混ぜない */ ],
  14: [
    {type:'redPick', k:2},
    {type:'yellowChoose', from:3, take:2},
  ],
  15: [
    {type:'redChoose', from:3, take:1},
  ],
  16: [
    {type:'redPick', k:1},
    {type:'yellowChoose', from:3, take:2},
  ],
  17: [
    {type:'redChoose', from:3, take:2},
  ],
  18: [
    {type:'redPick', k:2},
  ],
  19: [
    {type:'redPick', k:1},
    {type:'yellowChoose', from:3, take:2},
  ],
  20: [
    {type:'redPick', k:2},
    {type:'yellowPick', k:2},
  ],
  21: [
    {type:'redChoose', from:2, take:1},
  ],
  22: [
    {type:'redPick',    k:1},
    {type:'yellowPick', k:4},
  ],
  23: [  // 赤3-
    {type:'redChoose', from:3, take:1},
  ],
  24: [  // 赤2
    {type:'redPick', k:2},
  ],
  25: [  // 赤2
    {type:'redPick', k:2},
  ],
  26: [  // 赤2
    {type:'redPick', k:2},
  ],
  27: [  // 赤1 黄4
    {type:'redPick',    k:1},
    {type:'yellowPick', k:4},
  ],
  28: [  // 赤2 黄4
    {type:'redPick',    k:2},
    {type:'yellowPick', k:4},
  ],
 29: [  // 赤3
    {type:'redPick', k:3},
  ],

  30: [  // 赤2-1、黄4
    {type:'redChoose',  from:2, take:1},
    {type:'yellowPick', k:4},
  ],

  31: [  // 赤3-2
    {type:'redChoose', from:3, take:2},
  ],

  32: [  // 赤2
    {type:'redPick', k:2},
  ],

  33: [  // 赤3-2
    {type:'redChoose', from:3, take:2},
  ],

  34: [  // 赤1
    {type:'redPick', k:1},
  ],

  35: [  // 赤3-2 黄4
    {type:'redChoose',  from:3, take:2},
    {type:'yellowPick', k:4},
  ],

  36: [  // 赤3-1 黄2
    {type:'redChoose',  from:3, take:1},
    {type:'yellowPick', k:2},
  ],
37: [  // 赤2
  {type:'redPick', k:2},
],
38: [  // 赤2
  {type:'redPick', k:2},
],
39: [  // 赤3-2 黄4
  {type:'redChoose', from:3, take:2},
  {type:'yellowPick', k:4},
],
40: [  // 赤3
  {type:'redPick', k:3},
],
41: [  // 赤3-1
  {type:'redChoose', from:3, take:1},
],
42: [  // 赤3-1 黄4
  {type:'redChoose', from:3, take:1},
  {type:'yellowPick', k:4},
],
  43: [  // 赤3
    {type:'redPick', k:3},
  ],
  44: [  // 赤3-1
    {type:'redChoose', from:3, take:1},
  ],
  45: [  // 赤2
    {type:'redPick', k:2},
  ],
46: [  // 黄4（5.1,6.1,7.1,8.1 固定）
    { type:'yellowFixed', list:[5.1, 6.1, 7.1, 8.1] },
  ],
  47: [  // 赤3-2
    {type:'redChoose', from:3, take:2},
  ],
  48: [  // 赤2 黄3
    {type:'redPick', k:2},
  ],
  49: [  // 赤2
    {type:'redPick', k:2},
  ],
  50: [  // 赤2 黄2
    {type:'redPick', k:2},
    {type:'yellowPick', k:2},
  ],
     50: [  // 赤2 黄2
      {type:'redPick', k:2},
      {type:'yellowPick', k:2},
    ],
    // ▼▼ ここから追加 ▼▼
    51: [  // 赤1
      {type:'redPick', k:1},
    ],
    52: [  // 赤3
      {type:'redPick', k:3},
 ],
    53: [  // 赤2
      {type:'redPick', k:2},
    ],
    54: [  // （指定なし → 空配列）
    ],
    55: [  // 赤2
      {type:'redPick', k:2},
    ],
    56: [  // 赤3-2
      {type:'redChoose', from:3, take:2},
    ],
    57: [  // 赤1
      {type:'redPick', k:1},
    ],
    58: [  // 赤2
      {type:'redPick', k:2},
    ],
    59: [  // 赤3-2
      {type:'redChoose', from:3, take:2},
    ],
    60: [  // 赤3-2
      {type:'redChoose', from:3, take:2},
    ],
    61: [  // 赤1
      {type:'redPick', k:1},
    ],
    62: [  // 赤2
      {type:'redPick', k:2},
    ],
    63: [  // 赤2
      {type:'redPick', k:2},
    ],
    64: [  // 赤1
      {type:'redPick', k:1},
    ],
    65: [  // 赤3
      {type:'redPick', k:3},
    ],
    66: [  // 赤2 黄2
      {type:'redPick', k:2},
      {type:'yellowPick', k:2},
    ],
};
return plans[missionId] || [];

}

/**
 * ミックス実行
 */
function executeMixPlan(planList){
  const toAdd = [];
  const mixLines = [];
  const chooseLines = [];

  planList.forEach(p=>{
    if(p.type==='redPick'){
      const cand = pickK(MATERIALS.redCodes, p.k);
      cand.forEach(n=> toAdd.push({num:n, kind:'red'}));
      mixLines.push('<span style="color:red;">●</span>' + cand.map(v=>`[${v}]`).join(''));
    }
    if(p.type==='yellowPick'){
      const cand = pickK(MATERIALS.yellowCodes, p.k);
      cand.forEach(n=> toAdd.push({num:n, kind:'yellow'}));
　     mixLines.push('<span style="color:gold;">▧</span>' + cand.map(v=>`[${v}]`).join(''));
    }
        if(p.type==='yellowFixed'){
      const cand = (p.list || []).slice();
      cand.forEach(n => toAdd.push({ num:n, kind:'yellow' }));
      mixLines.push('<span style="color:gold;">▧</span>' + cand.map(v=>`[${v}]`).join(''));
    }
    if(p.type==='redChoose'){
      const cand = pickK(MATERIALS.redCodes, p.from);
      chooseLines.push(`<span style="color:red;">●</span> ${cand.map(v=>`[${v}]`).join(' ')} のうち${p.take}つ`);
      const take = pickK(cand, p.take);
      take.forEach(n=> toAdd.push({num:n, kind:'red'}));
    }
    if(p.type==='yellowChoose'){
      const cand = pickK(MATERIALS.yellowCodes, p.from);
      chooseLines.push(`<span style="color:gold;">▧</span> ${cand.map(v=>`[${v}]`).join(' ')} のうち${p.take}つ`);
      const take = pickK(cand, p.take);
      take.forEach(n=> toAdd.push({num:n, kind:'yellow'}));
    }
  });

  return { toAdd, mixLines, chooseLines };
}

/* pop positioning */
function placeInsideViewport(div, x, y){
  popLayer.appendChild(div);
  const pad = 8;
  pos(div, x + 6, y + 6);
  let r = div.getBoundingClientRect();
  if (r.right > innerWidth - pad){ const nx = Math.max(pad, x - r.width - 6); pos(div, nx, y + 6); r = div.getBoundingClientRect(); }
  if (r.left < pad) pos(div, pad, r.top);
  if (r.top < pad) pos(div, r.left, pad);
  if (r.bottom > innerHeight - pad) pos(div, r.left, Math.max(pad, innerHeight - r.height - pad));
}
function openOneMini(x,y,label,cb){
  const div=document.createElement('div'); div.className='mini-pop';
  div.addEventListener('click', e=>e.stopPropagation());
  const b=document.createElement('button'); b.className='btn small'; b.textContent=label;
  b.onclick=()=>{ if(div.isConnected) div.remove(); cb&&cb(); };
  div.appendChild(b); placeInsideViewport(div,x,y);
}
function openMenu(x,y, entries){
  const div=document.createElement('div'); div.className='mini-pop';
  div.addEventListener('click', e=>e.stopPropagation());
  entries.forEach(ent=>{
    const b=document.createElement('button');
    b.className='btn small';
    b.textContent = ent.label;
    if (ent && typeof ent.action === 'function') {
      b.onclick = async ()=>{ if(div.isConnected) div.remove(); await ent.action(); };
    } else {
      // 非クリック（表示のみ）
      b.disabled = true;
      b.classList.add('ghost'); // 見た目を少し薄く
    }
    div.appendChild(b);
  });  placeInsideViewport(div, x, y);
}
function openBottomMenu(entries){
  const div=document.createElement('div'); div.className='mini-pop bottom-pop';
  div.addEventListener('click', e=>e.stopPropagation());
  entries.forEach(ent=>{ const b=document.createElement('button'); b.className='btn small'; b.textContent=ent.label; b.onclick=async ()=>{ if(div.isConnected) div.remove(); await ent.action?.(); }; div.appendChild(b); });
  popLayer.appendChild(div);
}

/* enter */
btnRandom.onclick = ()=>{ inputCode.value = String(Math.random()*1e4|0).padStart(4,'0'); };
btnJoin.onclick   = ()=>{
  const nm = (inputName?.value || '').trim();
  // ★名前は4文字以内。未入力ならひらがな4文字を自動採番
  state.userName = nm ? nm.slice(0,4) : hiragana(4);

  // ★ルームコード未入力なら0225にする
  if (!inputCode.value.trim()) {
    inputCode.value = '0225';
  }

  enter('player');
};


async function enter(mode){
  const code=(inputCode.value||"").trim();
  if(!code){ alert('コードを入力してください'); return; }
  state.roomCode = code; state.mode=mode;

  const roomRef = ref(db, `rooms/${code}`);
  const snap=await get(roomRef);
  if(!snap.exists()){ state.isHost=true; await set(roomRef, baseRoom(state.userId)); }
  else{ state.isHost = snap.val()?.hostId === state.userId; }

  await set(ref(db, `rooms/${code}/players/${state.userId}`), {name:state.userName, at:Date.now()});
  onDisconnect(ref(db, `rooms/${code}/players/${state.userId}`)).remove();
  listenRoom(code);

  H(joinBox,true); H(lobby,false); H(gear,false); updateHeaderInfo();
}

function updateHeaderInfo(){
  if (!state.roomCode){
    roomInfo.textContent = '';
    return;
 }
  // 「コード：XXXX」をクリック可能に
  const html = `
   <span id="roomCodeBtn" class="code-link">コード：${state.roomCode}</span>
    　/　あなた：${state.userName}
  `;
  roomInfo.innerHTML = html;
 const btn = document.getElementById('roomCodeBtn');
  if (btn){
    btn.title = 'クリックでリンクをコピー';
    btn.onclick = (ev)=>{
      const link = buildRoomLink();
      openMenu(ev.clientX, ev.clientY, [
        { label:'リンクをコピー', action: ()=> copyText(link) },
        { label:'リンクを開く',  action: ()=> window.open(link, '_blank') }
      ]);
    };
  }
}
/* room base */
function baseRoom(hostId){
  return { createdAt: Date.now(), hostId, started:false, tableCount:0, tables:[], items:[], di:{value:0,max:6}, captainTable:null, mission:null,
    players:{}, spectators:{},
    meta:{ itemUses:{i1:0,i2:0,i12:0,i14:0}, tokenCounts:{equal:0,noteq:0,x1:0}, i2Flow:null, i18Flow:null, i16Badge:null,
      /* ▼▼ ：ミッション44用 状態 ▼▼ */
      oxItem: 0,         // アイテム列の下（全体プール）の酸素トークン数
      oxByTable: {}      // 各テーブルごとの酸素トークン所持数 { [tableIndex]: number }
      /* ▲▲ ：ミッション44用 状態 ▲▲ */
    },
    lastActiveAt: Date.now()
  };}

/* watch */
function listenRoom(code){
  onValue(ref(db, `rooms/${code}`),(snap)=>{
    const v=snap.val(); state.watching=v;
if (v) {
  const p = Object.keys(v.players || {}).length;
  const s = Object.keys(v.spectators || {}).length;
  const empty = (p === 0 && s === 0);
  const justCreated = (Date.now() - (v.createdAt || 0) < 2000); // 作成から2秒以内は削除しない
  if (empty && !justCreated) {
   // 最後に誰かがいた時刻を記録し、30分経過後に削除
    const lastActive = v.lastActiveAt || Date.now();
   const elapsed = Date.now() - lastActive;
    if (elapsed >= 30 * 60 * 1000) {
      remove(ref(db, `rooms/${code}`));
      return;
   } else {
      // active時刻更新
      update(ref(db, `rooms/${code}`), { lastActiveAt: Date.now() });
    }
  }
}    
   renderItemsAndDi(v);  renderM29(v); renderM31(v);  renderTables(v); 
     // 席ポップアップが開いていれば、他端末の着席/離席を即時反映
     if (!seatPop.classList.contains('hidden')) { renderSeatTabs(v); }    if (v?.meta?.m22_infoShown === true) {
  showInfo22Panel(v);  // まだ無ければ一度だけ生成（あれば何もしない）
  refreshInfo22(v);    // 既存パネルの x0/x1/x2 と disabled を更新
}
if (state.seatedTable == null && v?.started && !state.gameStarted && seatPop.classList.contains('hidden')) {
   btnSit.onclick();
    }
    
    renderMissionPanels(v); renderGlobalReveal(v); renderHostTool(v);
    // ★ 追加：ミッション再選択でも未着席者に席ポップを出す（ホスト以外も）
   const midNow  = (v?.mission?.id|0);
    const midPrev = (state._lastMissionId|0);
if (state.seatedTable == null && midNow && midNow !== midPrev && seatPop.classList.contains('hidden')) {
     btnSit.onclick();
    }
    state.gameStarted=!!v?.started;
    state._lastMissionId = midNow;    renderM18(v);
    renderM39(v);
    renderM9(v);
     renderM11(v);
    renderM12(v);
    renderM15(v);
    renderM16(v);
    renderM19(v);
    renderM30(v);
    renderM32(v);
    renderM36(v);
    renderM37(v);
    renderM23(v);
    renderM26(v);
    renderM42(v);
    renderM43(v);
    renderM44(v);
    renderM49(v);
    renderM53(v);
    renderM54(v);
    renderM57(v);
renderM55(state.watching);
    renderM59(v);
    renderM61(v);
    renderM62(v);
    renderM63(v);
    renderM65(v);
    renderM66(v);



    
    // ▼ ホスト判定を最新化
    state.isHost = (v?.hostId === state.userId);
    // ★ 追加：プレイヤーが1人だけなら、その人を自動でホストにする
    const playerIds = Object.keys(v.players || {});
    if (playerIds.length === 1 && v.hostId !== playerIds[0]) {
     update(ref(db, `rooms/${code}`), { hostId: playerIds[0] });
    }

    // ▼ ホスト以外には「ミッションを選ぶ」ボタン自体を非表示
    H(btnPickMission, !state.isHost);
// 条件：ホスト && 未開始 && まだミッション未選択 && まだ未実行
    // v.started は false、v.mission は null で入ってくる
    /* ここから追加 */
    if (state.isHost && !v?.started && !v?.mission && !state._mpAutoOnce) {
      openMissionPicker();        // 下部ピッカーを表示
      state._mpAutoOnce = true;   // 以後は開かない
    }
    // ▼ 追加：ホストなら開始前後いつでもクイックピッカーを使える
    updateHeaderInfo();
    // ★ 自分の席がDB上で消えていたらローカルもクリア（やり直し直後の残留防止）
    const myIdxNow = (v?.tables||[]).findIndex(T => T.playerId === state.userId);
    if (myIdxNow < 0) state.seatedTable = null;
  });
}


// ▼ テーブル高さの差分適用（変化がある時だけ更新＆その時だけアニメ）
// ▼ テーブル高さの差分適用（“直前論理値”で判定）
// ・初回はアニメしない
// ・同じ値なら何もしない
// ・増える時だけアニメ（減る時は瞬時反映でチラつき防止）
function applyTableHeight(box, needPx){
  const prevStr = box.dataset.prevH || "";           // 直前論理値（文字列）
  const prev = prevStr === "" ? null : parseInt(prevStr, 10);

  if (prev !== null && prev === needPx) return;      // 変化なし

  const doAnimate = (prev !== null) && (needPx > prev);

  if (doAnimate){
    box.classList.add('anim-h');
  } else {
    box.classList.remove('anim-h');                  // 初回や縮む時は即時反映
  }

  box.style.setProperty('--table-h', `${needPx}px`);
  box.style.height = `${needPx}px`;

  box.dataset.prevH = String(needPx);                // 次回比較用に保存

  if (doAnimate){
    setTimeout(()=> box.classList.remove('anim-h'), 300);
  }
}


  // ▼▼ カード下トークン（.tok-col）の“実測下端”に合わせて、必要時のみテーブルを伸ばす ▼▼
// 対象：数字 / x1・x2・x3 / 偶数 / 奇数 / ＝ / ≠ （= .tok-col に並ぶ .token）
function growForCardTokens(box, basePx = 96, padPx = 6){
  // テーブル内の各カードバッジ直下にあるトークン列を全部見る
  const cols = box.querySelectorAll('.badge-fixed .tok-col');
  if (!cols.length) return;

  let needs = false;
  let maxBottom = 0;
  const rBox = box.getBoundingClientRect();

  cols.forEach(col=>{
    const cnt = col.querySelectorAll('.token').length | 0;
    // ――― 1行（=1個）以下なら一切スライドしない
    if (cnt >= 2){
      needs = true;
      const r = col.getBoundingClientRect();
      maxBottom = Math.max(maxBottom, r.bottom);
    }
  });

  if (!needs) return; // 2個以上の列が無ければ何もしない（アニメも発生しない）

  // テーブル上端から“最も下に出たトークン列の下端”までの高さに少しパディングを足す
  const needPx = Math.max(basePx, Math.ceil(maxBottom - rBox.top + padPx));
  applyTableHeight(box, needPx);
}
// ▲▲ カード下トークンでの自動伸長 ▲▲

  
/* mission panels */
function renderMissionPanels(v){
  if(!v?.mission){
    // 右サイドの missionBox を廃止したので未選択表示は出さない
    missionDetailTitle.textContent = '';
    missionDetailBody.innerHTML = '';
    H(missionFooter, true);
    return;
  }
  missionDetailTitle.textContent = v.mission.display?.[0] || '';
  missionDetailBody.innerHTML = (v.mission.display||[]).slice(1)
    .map(line=>`<div class="line">${line}</div>`).join('');

  /* ここから追加：#50 専用 OKタブ＆赤/黄のみ [?] マスク（全員に同期） */
  if ((v?.mission?.id|0) === 50) {
  document.querySelectorAll('.check-mark').forEach(el=>{
    el.style.background = 'none';
  });
    
    const hidden = v?.meta?.m50_hidden === true;

    // 赤/黄の数値だけ [ ? ] にする関数（"●" or "▧" を含む行の [ ... ] だけ置換）
    const maskRedYellowInDetails = (root)=>{
      root.querySelectorAll('.line').forEach(line=>{
        const t = line.textContent || '';
        if (t.includes('●') || t.includes('▧')) {
          line.textContent = t.replace(/\[[^\]]+\]/g, '[?]');
        }
      });
    };

    // 既に隠すフラグが立っていたら即マスク
    if (hidden) {
      maskRedYellowInDetails(missionDetailBody);
    } else {
      // まだなら「OK」タブを1回だけ出す（詳細をクリックしたタイミングで表示）
      if (!missionDetailBody.dataset.m50Hooked) {
        missionDetailBody.dataset.m50Hooked = '1';
        missionDetailBody.addEventListener('click', (ev)=>{
         if (((state?.watching?.mission?.id|0) !== 50)) return;
          if (document.getElementById('m50OkTab')) return;
          const okBtn = document.createElement('button');
          okBtn.id = 'm50OkTab';
          okBtn.className = 'tab';
          okBtn.textContent = 'OK';
          okBtn.onclick = async (e)=>{
            e.stopPropagation();
            // 全員に反映：DBにフラグを書き込む
            await update(ref(db, `rooms/${state.roomCode}/meta`), { m50_hidden: true });
          };
          missionDetailBody.appendChild(okBtn);
        }, { once:false });
      }
    }
  }
  
  H(missionFooter, !v.started);
}



/* ===== Items & DI ===== */
function renderItemsAndDi(v){
  if(!v || !v.started){ H(itemsBar,true); return; }
  // ★ #23：広げる前はアイテム列を非表示
  {
    const flags = v?.mission?.flags || {};
    const hide = !!(flags.m23_hideItemsUntilSpread && !v?.meta?.m23_spread);
    H(itemsBar, hide ? true : false);
    if (hide) return; // ここで終了（数値帯や#23のデッキUIは別途表示）
  }

  itemsEl.innerHTML='';
  const itemNodes = []; // ★ ノード参照を保持

  (v.items||[]).forEach((it, idx)=>{
    const flags = v?.mission?.flags || {};
    const div=document.createElement('div'); div.className='item' + (it.used?' used':'');
    if(!it.used){
      // #15: 最初は裏向き表示（使用可だが faceUp===false の間は裏面アートを表示）
      if(flags.itemsFaceDownStart && it.faceUp===false){
        div.style.backgroundImage = `url("./itemback.jpg")`;
      }else{
        div.style.backgroundImage = `url("./item${it.no}.jpg")`;
      }
    }


 // ★ 追加：アイテム16の情報トークンをカードの真下に表示
if(it.no===16 && v?.meta?.i16Badge && v.meta.i16Badge.num!=null){
  const below = document.createElement('div');
  below.className = 'i16-below';
  const tok = document.createElement('div');
  tok.className = 'token black';
  tok.textContent = String(v.meta.i16Badge.num);
  tok.title = 'クリックで操作';
  tok.onclick = (ev)=>{
    openMenu(ev.clientX, ev.clientY, [
      {label:'消す', action: async ()=>{ await update(ref(db, `rooms/${state.roomCode}/meta`), { i16Badge: null }); }}
    ]);
  };
  below.appendChild(tok);
  div.appendChild(below);

  // 追加：カードを上に持ち上げて下のトークンがスクロールなしで見えるように
  div.classList.add('i16-lift');
}

    div.onclick=(ev)=>{
     const flags = state.watching?.mission?.flags || {};
     // 使用済み → 「表にする」だけ
      if(it.used){
        openOneMini(ev.clientX, ev.clientY, '表にする', async ()=>{
          await update(ref(db, `rooms/${state.roomCode}/items/${idx}`), {used:false});
        });
      }else{
        // ミッション15 && 裏向き → 拡大させず「表にする」だけ
        if((state.watching?.mission?.id|0) === 15 && flags.itemsFaceDownStart && it.faceUp===false){
         openOneMini(ev.clientX, ev.clientY, '表にする', async ()=>{
           await update(ref(db, `rooms/${state.roomCode}/items/${idx}`), {faceUp:true});
          });
        }else{
         // 通常通り拡大（表状態 or 他ミッション）
         const canFaceUp = !!(flags.itemsFaceDownStart && it.faceUp===false);
          openItemZoom(it.no, idx, { canFaceUp });
        }
     }
    };

    itemsEl.appendChild(div);
    itemNodes.push(div);
  });


  // ★ 追加：#23 の残り山札アイテムをアイテム欄へ並べる
 if ((v.mission?.id|0) === 23 && v?.meta?.m23_spread === true
     && (v.items?.length ?? 0) === 0
     && Array.isArray(v?.meta?.m23_spreadRest) && v.meta.m23_spreadRest.length > 0) {
   for (const no of rest) {
      const div2 = document.createElement('div');
     div2.className = 'item m23-spread';
      div2.style.backgroundImage = `url("./item${no}.jpg")`;
      // 表示のみ（拡大は可）。ゲーム状態は変更しない
     div2.onclick = () => openItemZoom(no, -1, { canFaceUp: true });
      itemsEl.appendChild(div2);
      itemNodes.push(div2);
   }
  }
  
  const val = clamp(v.di?.value ?? v.tableCount, 0, 6);
  diEl.style.backgroundImage = `url("./di${val}.png")`;
  diEl.onclick=(ev)=>{
    openMenu(ev.clientX, ev.clientY, [
      {label:'進める', action: async ()=>{ const nowv=state.watching?.di?.value ?? val; const next=clamp(nowv-1,0,6); await update(ref(db, `rooms/${state.roomCode}/di`), {value:next}); }},
      {label:'戻す', action: async ()=>{ const nowv=state.watching?.di?.value ?? val; const next=clamp(nowv+1,0,6); await update(ref(db, `rooms/${state.roomCode}/di`), {value:next}); }},
    ]);
  };
}

/* ===== Global badge (item16) ===== */
function renderGlobalReveal(v){
  // 変更：サイド表示に切り替えたため常に非表示
  globalReveal.innerHTML='';
  H(globalReveal,true);
}

/* ===== Host tool (odd-open normal codes) ===== */
function renderHostTool(v){
  if(!v?.tables){ H(hostTool,true); return; }
  const openCountByNum = {};
  (v.tables||[]).forEach(T=>{
    (T.hand||[]).forEach(c=>{
      if(c?.kind==='normal' && c.open===true){
        const n = c.num|0;
        openCountByNum[n] = (openCountByNum[n]||0) + 1;
      }
    });
  });
  const hasOdd = Object.values(openCountByNum).some(cnt => (cnt % 2)===1);
  H(hostTool, !hasOdd);
}
hostTool.onclick = ()=> alert('全体公開されている通常コードの枚数に奇数が含まれています。');

/* ===== Tables ===== */
function renderTables(v){
  tablesEl.innerHTML=''; if(!v) return;
    const seatedNow = (v?.tables||[]).some(T => T.playerId === state.userId);
  document.body.setAttribute('data-seated', seatedNow ? 'yes' : 'no');
  
  if (!(v.meta?.m22_infoShown)) {
    const old = document.getElementById('info22');
    if (old) old.remove();
  }
  
  /* ★ 全体公開中の通常コードの「数字別枚数」を集計 */
  const openCountByNum = {};
  (v.tables||[]).forEach(T=>{
    (T.hand||[]).forEach(c=>{
      if(c?.kind==='normal' && c.open===true){
        const n = c.num|0; // 1..12
        openCountByNum[n] = (openCountByNum[n]||0) + 1;
      }
    });
  });
  
// #39：X が 4枚全体公開 → 自動配布（ホストのみ・一度だけ）
if ((v.mission?.id|0) === 39) {
  const X = v?.meta?.m39_x|0;
  const done = v?.meta?.m39_dealt === true;
  if (X && !done && (openCountByNum[X]||0) === 4 && state.isHost) {
    performM39Deal();
  }
}

// #23：表示中の“数値カード（m23_number）”と同じ数字が4枚全体公開
// → 山札に残っているアイテムカードをアイテム欄に並べる（ホストのみ・一回）
if ((v.mission?.id|0) === 23) {
  const X = v?.meta?.m23_number|0;
  const done = v?.meta?.m23_spread === true;
  if (X && !done && (openCountByNum[X]||0) === 4 && state.isHost) {
    performM23Spread();
  }
}

  
  /* ★ テーブル1の真上にチェック表（1..12）を設置 */
  if((v.tables||[]).length>0){
    const cl = document.createElement('div'); cl.className='checklist';
    for(let n=1; n<=12; n++){
      const cell = document.createElement('div'); cell.className='check-item';
      cell.textContent = String(n);
      if((openCountByNum[n]||0) === 4){ // 同じ数字が4本全体公開
        const mk = document.createElement('div'); mk.className='check-mark';
        cell.appendChild(mk);
      }
      /* ここから追加：#43のときだけクリック可能（全員） */
          {
        const mid = (v?.mission?.id|0);
        if (mid === 43 || mid === 53) {
          cell.style.cursor = 'pointer';
          cell.onclick = async ()=>{
            const prev = (mid===43 ? (v?.meta?.m43_pos|0) : (v?.meta?.m53_pos|0));
            const next = n|0;
            if (!state.roomCode) return;
            if (mid === 43){
              await update(ref(db, `rooms/${state.roomCode}/meta`), {
                m43_prevPos: prev||0, m43_pos: next, m43_updatedAt: Date.now()
              });
            }else{
              await update(ref(db, `rooms/${state.roomCode}/meta`), {
                m53_prevPos: prev||0, m53_pos: next, m53_updatedAt: Date.now()
              });
            }
          };
        }
      }
      
      cl.appendChild(cell);
    }
    tablesEl.appendChild(cl); // ← 直後にテーブル1が来るので「真上」になる
  }

  const W = cssNum('--card-w'), G = cssNum('--card-gap'), CW = cssNum('--char-w');
  const seatedAny = (v.tables||[]).some(T => !!T.playerId);
  // ★ 変更：上限の対応
  //   ＝ の上限はアイテム12の使用回数
  //   ≠ の上限はアイテム1の使用回数
  const uses = v.meta?.itemUses || {i1:0,i2:0,i12:0,i14:0};
  const caps = { 
    equal: uses.i12>=2 ? 4 : (uses.i12>=1 ? 2 : 0),
    noteq: uses.i1>=2  ? 4 : (uses.i1>=1  ? 2 : 0),
    x1:    uses.i14>=2 ? 2 : (uses.i14>=1 ? 1 : 0)
  };
  const counts = v.meta?.tokenCounts || {equal:0,noteq:0,x1:0};
  const i2All=v.meta?.i2Flow;
  const i18All=v.meta?.i18Flow;

  (v.tables||[]).forEach((t, idx)=>{
    const box=document.createElement('div'); box.className='table';
    box.addEventListener('mouseenter', ()=> box.classList.add('elevated'));
    box.addEventListener('mouseleave', ()=> {
      const hasTokenLater = (t.hand||[]).some(c=> (c.tokens||[]).length>0);
      if(!hasTokenLater) box.classList.remove('elevated');
    });

    const n = (t.hand||[]).length;
    const handInner = n>0 ? (n*W + (n-1)*G) : 0;
    const totalW = CW + 8 + handInner + 16;
    box.style.width = Math.max(totalW, CW + 16) + 'px';

const header=document.createElement('div'); header.className='t-header';
const title=document.createElement('div');  title.className='title';
title.textContent = t.playerName ? t.playerName : String(t.titleNumber ?? (idx+1));

    
    
    /* ▼▼ ここから追加：#29 所持数表示 ▼▼ */
if ((v.mission?.id|0) === 29) {
  const cnt = Array.isArray(t.m29Hand) ? t.m29Hand.length : 0;
  // ← 「（n）」の“n”部分をアンカー化
  const span = document.createElement('span');
  span.id = `m29cnt-${idx}`;  // ★ここが anchor
  span.textContent = `（${cnt}）`;
 title.appendChild(span);
}
    
    header.appendChild(title);
    /* ★ 追加：ホストだけ—テーブル名クリックで「キック」 */
    if (state.isHost){
      title.style.cursor = 'pointer';
     title.title = 'クリックして操作';
      title.onclick = (ev)=>{
        if(!t.playerId) return; // 空席はメニュー無し
        openMenu(ev.clientX, ev.clientY, [
          { label:'キック', action: async ()=>{ await kickSeatAt(idx); } }
        ]);
     };
    }
    
// #13：初期情報トークン（数値）—— 表示はキャラ下、ここでは値と auto-hide だけ扱う
let m13HeaderNum = null;
if (v.mission?.flags?.m13_headerRandomInfoToken && Array.isArray(v.meta?.m13_header)) {
  const headerNums = v.meta.m13_header;
  const n0 = headerNums[idx];
  if (n0 != null) {
    m13HeaderNum = n0;

// 同テーブル内で同じ数字の情報トークン（type:'num'）が使われたら自動で消す
// ※ レンダー中にDB更新しない：対象indexだけキューへ積む
if (v.mission?.flags?.m13_autoHideHeaderToken) {
  let used = false;
  (t.hand || []).forEach(c => {
    (c.tokens || []).forEach(tk => {
      if (tk?.type === 'num') {
        const n = parseInt(tk.value, 10);
        if (Number.isInteger(n) && n === n0) used = true;
      }
    });
  });
  if (used) {
    const current = (state.watching?.meta?.m13_header || [])[idx];
    if (current === n0) {
      if (!m13HeaderClearIndices) m13HeaderClearIndices = new Set();
      m13HeaderClearIndices.add(idx);
    }
  }
}

  }
}
box.appendChild(header);


    const content=document.createElement('div'); content.className='t-content';

// ★ キャラ＋下部トークン（#13）用ラッパー
const charCol = document.createElement('div'); 
charCol.className = 'char-col';

const char=document.createElement('div'); 
char.className='char-card';
// 自分が未着席  または  この席が空席 → ブランク固定
const amSeated = seatedNow;           // 先頭で算出済み
const seatEmpty = !t.playerId;        // 空席判定
if (!amSeated || seatEmpty) {
  char.classList.add('blank');
  char.removeAttribute('style');
  char.onclick = null;
} else {
  const face = t.character?.flipped ? './battery.jpg' : `./${t.character?.face || 'member (1).jpg'}`;
  char.style.backgroundImage = `url("${face}")`;
  char.onclick = async ()=> {
    await update(ref(db, `rooms/${state.roomCode}/tables/${idx}/character`), { flipped: !t.character?.flipped });
  };
}
    if ((state.watching?.mission?.id|0) === 34 && t.playerId !== state.userId){
  // #34：自分以外はブランク表示・操作不可
  char.removeAttribute('style');
  char.onclick = null;
  char.classList.add('blank');
}
charCol.appendChild(char);

// ★ #13：初期情報トークンはキャラの「下」に小さく表示（meta.m13_header をそのまま使う）
if (m13HeaderNum != null) {
  const tok = document.createElement('div');
  tok.className = 'token black';
  tok.textContent = String(m13HeaderNum);
  charCol.appendChild(tok);
}
if (Array.isArray(t.m22Tokens) && t.m22Tokens.length > 0) {
  const row = document.createElement('div');
  row.className = 'm22-under';
  t.m22Tokens.slice(0,3).forEach(nn=>{

    const d = document.createElement('div');
    d.className = 'token black';
    d.textContent = String(nn);
     d.style.cursor = 'default'; // 誤誘導を防ぐ（手カーソルにしない）
    row.appendChild(d);
  });
  charCol.appendChild(row);
}
  // ★ #50：情報トークンはアルファベット直下ではなく「キャラカードの下」に集約表示（4列で折返し）
  if ((v.mission?.id|0) === 50) {
    const nums = [];
    (t.hand||[]).forEach(c=>{
      (c.tokens||[]).forEach(tk=>{
        if (tk?.type === 'num') nums.push( (parseInt(tk.value,10) || tk.value) );
      });
    });
    if (nums.length > 0) {
      const row = document.createElement('div');
      row.className = 'm50-under';
      nums.forEach(nn=>{
        const d = document.createElement('div');
        d.className = 'token black';
        d.textContent = String(nn);
        d.style.cursor = 'default';
        row.appendChild(d);
      });
      charCol.appendChild(row);

      // 高さ調整：4列折返しに合わせて必要分だけテーブルを拡張
      const BASE=96, PERROW=3;
      const rows = Math.ceil(nums.length / PERROW);
      const extra = rows>0 ? (4 + rows*20 + Math.max(0, rows-1)*2) : 0; // 20px(トークン) + 行間
      applyTableHeight(box, Math.max(BASE, BASE + extra));  // ← 既存ユーティリティ
    }
  }

    
content.appendChild(charCol);


    const hand=document.createElement('div'); hand.className='hand';
    (t.hand||[]).forEach((c,ci)=>{
            /* 無効カードは描画しない（"undefined"表示の根絶） */
      if (!c || (c.num == null && c?.kind!=='red' && c?.kind!=='yellow')) {
        console.warn('[hand] invalid card skipped', { table: idx, ci, card: c });
        return; // 以降の描画処理に入らない
      }
      const wrap=document.createElement('div'); wrap.className='card-wrap';
      const card=document.createElement('div'); card.className='card';
wrap.dataset.table = String(idx);
wrap.dataset.cardId = String(c.id||'');
      
      if (c.gone === true){
  wrap.classList.add('m42-gone');     // ★ 数字・トークンなど別レイヤもまとめて不可視
}
     // 既に消滅済なら見えない空枠として保持（幅は保つ）
      if (c.gone === true){
        card.style.visibility = 'hidden';
        card.style.pointerEvents = 'none';
      }

      // ☝ON中かつ全体公開カードは青枠＋自由ドラッグ可
      if ((state.watching?.meta?.m42_on) && c.open===true){
        card.classList.add('i2-selectable'); // 既存青点線

        card.addEventListener('pointerdown', (ev)=>{
          // ゴースト生成（実カードは固定のまま）
          const r = card.getBoundingClientRect();
          const ghost = card.cloneNode(true);
          ghost.style.position='fixed';
          ghost.style.left = r.left+'px'; ghost.style.top = r.top+'px';
          ghost.style.width=r.width+'px'; ghost.style.height=r.height+'px';
          ghost.style.opacity='0.9'; ghost.style.cursor='grabbing';
          ghost.style.zIndex='2147483647';
          document.body.appendChild(ghost);

          const offX = ev.clientX - r.left, offY = ev.clientY - r.top;
          const move = (e)=>{ ghost.style.left=(e.clientX-offX)+'px'; ghost.style.top=(e.clientY-offY)+'px'; };
          const up = async (e)=>{
            window.removeEventListener('pointermove', move, true);
            window.removeEventListener('pointerup', up, true);
            const bx = document.getElementById('m42Box');
            ghost.remove();
            // 箱ヒット判定（数ピクセルの猶予）
            const hit = (()=>{
              if(!bx) return false;
              const br=bx.getBoundingClientRect(), x=e.clientX, y=e.clientY, pad=4;
              return (x>=br.left-pad && x<=br.right+pad && y>=br.top-pad && y<=br.bottom+pad);
            })();
            if(hit){
              // 消滅：このカードに gone:true を立てる（見えない空枠となる）
              await update(ref(db, `rooms/${state.roomCode}/tables/${idx}/hand/${ci}`), { gone:true });
            }
          };
          window.addEventListener('pointermove', move, true);
          window.addEventListener('pointerup', up, true);
        }, {capture:true});
      }
      
 const isMine = ((c.ownerId ?? t.playerId) === state.userId);

   const seated = (v?.tables||[]).some(T => T.playerId === state.userId);
      if (!seated) {
        if (!c.open) card.classList.add('back'); // 数字は .back CSS で隠れる
      } else {
        /* ▼▼ 着席後のみ #38/#56 特別表示を適用 ▼▼ */
        const mid = (state.watching?.mission?.id|0);
        const isM38 = (mid === 38);
        const isM56 = (mid === 56);
        const isM64 = (mid === 64);
        const isCaptainTable = (idx === (state.watching?.captainTable|0));
        const isRightmost = (ci === (t.hand||[]).length - 1);
        const hasX = Array.isArray(c.tokens) && c.tokens.some(tk => String(tk.type) === 'xmark');
        const m38Special = isM38 && isCaptainTable && isRightmost && hasX;
        const m56Special = isM56 && isRightmost && hasX; // 全テーブル対象
        const m64Special = isM64 && hasX;                // ★ 位置不問：xmark付きは「自分だけ裏」
const ownerBlindSpecial = (m38Special || m56Special || m64Special);

        if (!c.open) {
          if (ownerBlindSpecial) {
            if (t.playerId === state.userId) {
              // 隊長本人：裏（黒背景）
              card.classList.add('back');
            } else {
              // 他プレイヤー：灰＋数字（＝自分の非公開手札の見え方）
              const numEl = document.createElement('div');
              numEl.className = 'num';
              numEl.textContent = String(c.num ?? '');
              card.appendChild(numEl);
              // 背景は .card の #bbb をそのまま利用（back は付けない）
            }
          } else if (!isMine) {
            // 通常の他人カードは裏
            card.classList.add('back');
          }
        }
      }

      if (c.open) card.classList.add('open');

      if (i2All?.selA && i2All.selA.cardId===c.id && i2All.selA.table===idx){ const m = document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
      if (i2All?.selB && i2All.selB.cardId===c.id && i2All.selB.table===idx){ const m = document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
   const m42s = state.watching?.meta?.m42Swap;
const showM42Swap = !!(m42s && m42s.usingBy === state.userId);
if (showM42Swap && m42s.selA && m42s.selA.cardId===c.id && m42s.selA.table===idx){ const m=document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
if (showM42Swap && m42s.selB && m42s.selB.cardId===c.id && m42s.selB.table===idx){ const m=document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }

const m42m2 = state.watching?.meta?.m42M2;
const showM42M2 = !!(m42m2 && m42m2.usingBy === state.userId);
if (showM42M2 && m42m2.selA && m42m2.selA.cardId===c.id && m42m2.selA.table===idx){ const m=document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
if (showM42M2 && m42m2.selB && m42m2.selB.cardId===c.id && m42m2.selB.table===idx){ const m=document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
      if (i18All?.sel && i18All.sel.cardId===c.id && i18All.sel.table===idx){ const m=document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }
      if(c.markUntil && now()<c.markUntil){ const m=document.createElement('div'); m.className='marker'; m.textContent='▼'; wrap.appendChild(m); }

      const isI2Actor = i2All && i2All.usingBy===state.userId;
      const canPickSelf  = isI2Actor && i2All?.phase==='pickSelf'  && t.playerId===state.userId;
      const canPickOther = isI2Actor && i2All?.phase==='pickOther' && t.playerId!==state.userId;

      const isI18Actor = i18All && i18All.usingBy===state.userId;
      const canI18Pick = isI18Actor && i18All?.phase==='pickOther' && t.playerId!==state.userId;

      if(isI2Actor && (canPickSelf || canPickOther)){
        card.classList.add('i2-selectable');
        card.onclick = async (ev)=>{
          ev.stopPropagation();
          if(canPickSelf){
            await update(ref(db, `rooms/${state.roomCode}/meta/i2Flow`), { selA:{table:idx, cardId:c.id}, phase:'pickOther' });
          }else if(canPickOther){
            await update(ref(db, `rooms/${state.roomCode}/meta/i2Flow`), { selB:{table:idx, cardId:c.id} });
            openBottomMenu([
              {label:'交換する', action: async ()=>{
                const i2 = (await get(ref(db, `rooms/${state.roomCode}/meta/i2Flow`))).val();
                if(i2?.selA && i2?.selB) await doItem2Swap(i2.selA, i2.selB);
              }},
              {label:'やり直す', action: async ()=>{
                await update(ref(db, `rooms/${state.roomCode}/meta`), { i2Flow:{usingBy:state.userId, phase:'pickSelf', selA:null, selB:null} });
              }}
            ]);
          }
        };
      }else if(canI18Pick){
        card.classList.add('i2-selectable');
        card.onclick = async (ev)=>{
          ev.stopPropagation();
          await update(ref(db, `rooms/${state.roomCode}/meta/i18Flow`), { sel:{table:idx, cardId:c.id} });
          openBottomMenu([
            {label:'とる', action: async ()=>{ const i18=(await get(ref(db, `rooms/${state.roomCode}/meta/i18Flow`))).val(); if(i18?.sel) await doItem18Take(i18.sel); }},
            {label:'やり直す', action: async ()=>{ await update(ref(db, `rooms/${state.roomCode}/meta/i18Flow`), { sel:null, phase:'pickOther' }); }}
          ]);
        };
      }else{
         card.onclick = async ()=>{
   if (state.watching?.meta?.m42_on || state.watching?.meta?.m42Swap?.on || state.watching?.meta?.m42M2?.on) return;
          if(isMine){
            const blockingI2 = i2All && i2All.usingBy===state.userId && (i2All.phase==='pickSelf' || i2All.phase==='pickOther');
            const blockingI18= i18All && i18All.usingBy===state.userId && (i18All.phase==='pickOther');
            if(blockingI2 || blockingI18) return;
            await update(ref(db, `rooms/${state.roomCode}/tables/${idx}/hand/${ci}`), {open: !c.open});
          }
        };
      }

      const num=document.createElement('div'); num.className='num';
            /*未定義を文字列 "undefined" で出さない */
      const hasNum = (c.num != null && !Number.isNaN(Number(c.num)));
      if (hasNum) {
        num.textContent = String(c.num);
        num.style.visibility = (c.open || isMine) ? 'visible' : 'hidden';
      } else {
        num.textContent = '';
        num.style.visibility = 'hidden';
        console.warn('[hand] card without visible num', { table: idx, ci, card: c });
      }
      card.appendChild(num);

      const bot=document.createElement('div'); bot.className='img-bottom';
      let img='codenumber.jpg'; if(c.kind==='red') img='redcode.png'; if(c.kind==='yellow') img='yellowcode.png';
      bot.style.backgroundImage=`url("./${img}")`; if(card.classList.contains('back')) bot.style.display='none';
      card.appendChild(bot);

      const badge=document.createElement('div'); badge.className='badge-fixed';
      const a=document.createElement('div'); a.className='alpha'; a.textContent=c.alpha||'';

      const col=document.createElement('div'); col.className='tok-col';
      const isM50 = ((state.watching?.mission?.id|0) === 50);
      if (!isM50) {
        (c.tokens||[]).forEach(tk=>{
          const el = document.createElement('div');
          el.className = 'token ' + (tk.style || '');
          col.appendChild(el);

          const tokenText = (t)=>{
    switch(t.type){
      case 'equal':  return '＝';   // = トークン
      case 'noteq':  return '≠';   // ≠ トークン
      case 'x1':     return 'x1';  // x1
      case 'x2':     return 'x2';  // x2（ミッション専用）
      case 'x3':     return 'x3';  // x3（ミッション専用）
      case 'yellow': return '▧';   // 黄コードトークン（▧）
      case 'even':   return '2/4'; // 偶数
      case 'odd':    return '1/3'; // 奇数
      case 'xmark':  return '✕';   // ミッション#20の黄色✕用
      case 'num':    return String(t.value); // 数字
      default:       return String(t.value ?? '');
    }
          };
          el.textContent = tokenText(tk);
        });
      }


      if(!(i2All && i2All.usingBy===state.userId) && !(i18All && i18All.usingBy===state.userId) && isMine){
        a.onclick=(ev)=>{
          ev.stopPropagation();
          const cardPath  = `rooms/${state.roomCode}/tables/${idx}/hand/${ci}`;
          const tokens = c.tokens || [];
          const has = (type)=> tokens.some(tk=>tk.type===type);
 const INCOMP_GROUP = new Set(['odd','even','x1','x2','x3','yellow']);
  const hasGroup = tokens.some(tk => INCOMP_GROUP.has(tk.type));
          const canEqual = !has('equal') && (counts.equal < caps.equal);
          const canNoteq = !has('noteq') && (counts.noteq < caps.noteq);
          const canNum   = !has('num');
          const canX1    = !has('x1') && (counts.x1 < caps.x1);

         const entries = [];

// ▼ ミッション専用：フラグ取得
const flags = state.watching?.mission?.flags || {};
const myHand = (t.hand||[]).filter(cc => cc.ownerId===state.userId);
const countSame = myHand.filter(cc => cc.num===c.num).length;
 // ここから追加：#40 番手別の使用許可（x系 or 偶奇）
 // 番手＝隊長テーブルを1番手として時計回りに 1,2,3,…
 const _m40 = ((state.watching?.mission?.id|0) === 40);
 const cap   = state.watching?.captainTable ?? 0;
 const total = (state.watching?.tables?.length||0);
 const order = ((idx - cap + total) % total) + 1; // 1始まり
 // x系許可：1,3,5番手／ 偶奇許可：2,4番手／ それ以外（6番手など）はどちらも不可
 const USE_X      = (!!flags.useXTokens)   || (_m40 && [1,3,5].includes(order));
 const USE_PARITY = (!!flags.useParityToken)|| (_m40 && [2,4].includes(order));
const isColorCode = (c.kind === 'red' || c.kind === 'yellow');

 // 黄コードトークン（▧）
if(!hasGroup && (flags.useYellowToken || c.kind === 'yellow')){
   entries.push({label:'▧', action: async ()=>{
    // 既にグループが付いていたら何もしない（多重防止の最終ガード）
    if (hasGroup || has('yellow')) return;
    const updated = [...tokens, {type:'yellow', value:'▧', style:'yellow'}];
     await update(ref(db, cardPath), { tokens: updated });
     box.classList.add('elevated');
   }});
 }

 // x1/x2/x3（数字ポップを出さないミッション用）
if (!hasGroup && USE_X && !isColorCode){
   if(countSame===1) entries.push({label:'x1', action: async ()=>{
    if (hasGroup || has('x1')) return;
    const updated=[...tokens, {type:'x1', value:'x1', style:'x1'}];
     await update(ref(db, cardPath), { tokens: updated });
     box.classList.add('elevated');
   }});
   if(countSame===2) entries.push({label:'x2', action: async ()=>{
    if (hasGroup || has('x2')) return;
    const updated=[...tokens, {type:'x2', value:'x2', style:'x2'}];
     await update(ref(db, cardPath), { tokens: updated });
     box.classList.add('elevated');
   }});
   if(countSame===3) entries.push({label:'x3', action: async ()=>{
    if (hasGroup || has('x3')) return;
    const updated=[...tokens, {type:'x3', value:'x3', style:'x3'}];
     await update(ref(db, cardPath), { tokens: updated });
     box.classList.add('elevated');
   }});
 }

 // 偶数/奇数（数字ポップを出さないミッション用）
if (!hasGroup && USE_PARITY && !isColorCode){
   const isEven = (c.num % 2)===0;
   if(isEven){
     entries.push({label:'2/4', action: async ()=>{
     if (hasGroup || has('even')) return;
      const updated=[...tokens, {type:'even', value:'2/4', style:'even'}];
       await update(ref(db, cardPath), { tokens: updated });
       box.classList.add('elevated');
     }});
   }else{
     entries.push({label:'1/3', action: async ()=>{
      if (hasGroup || has('odd')) return;
      const updated=[...tokens, {type:'odd', value:'1/3', style:'odd'}];
       await update(ref(db, cardPath), { tokens: updated });
       box.classList.add('elevated');
     }});
   }
 }


/* ここから追加：#52 数字トークンポップ（通常=自数だけ除外／赤=全て可） */
const _m52 = ((state.watching?.mission?.id|0) === 52);
if (_m52 && canNum && (c.kind==='normal' || c.kind==='red')) {
  for (let nn = 1; nn <= 12; nn++) {
    if (c.kind === 'normal' && nn === (c.num|0)) continue; // 通常は上の数だけ除外
    entries.push({
      label: String(nn),
      action: async ()=>{
        const updated = [ ...(tokens), { type:'num', value: nn, style:'black' } ];
        await update(ref(db, cardPath), { tokens: updated });
        box.classList.add('elevated');
      }
    });
  }
}
          
const suppressNumberPop = (c.kind !== 'normal') || !!flags.useYellowToken || !!flags.useXTokens || !!flags.useParityToken;
 const m40 = ((state.watching?.mission?.id|0) === 40);
 const suppressNumberPop_m40 = suppressNumberPop || m40;
// ▼ 数字ポップの出し方（通常 or #17 隊長用）
const isCaptain = (state.watching?.captainTable|0) === idx;
if(!_m52 && !suppressNumberPop_m40 && canNum){  if(v.mission?.flags?.m17_captainInverseNumberPop && isCaptain){
    // 隊長は「自分のカード数値 以外」の 1..12 を候補にする
    for(let nn=1; nn<=12; nn++){
      if(nn===c.num) continue;
      entries.push({label:String(nn), action: async ()=>{
        const updated=[...(tokens), {type:'num', value:nn, style:'black'}];
        await update(ref(db, cardPath), { tokens: updated });
        box.classList.add('elevated');
      }});
    }
  }else{
    // 通常：そのカードの数字
    entries.push({label:String(c.num), action: async ()=>{
      const updated=[...(tokens), {type:'num', value:c.num, style:'black'}];
      await update(ref(db, cardPath), { tokens: updated });
      await consumeM22IfMatches(idx, c.num);   // ← 追加
      box.classList.add('elevated');
    }});
  }
}

          // ＝（アイテム12管理）
          if (has('equal')) {
            entries.push({
              label:'＝',
              action: async ()=>{
                openMenu(ev.clientX, ev.clientY, [
                  { label:'消す', action: async ()=>{
                      const next = tokens.filter(tk=>tk.type!=='equal');
                      await update(ref(db, cardPath), { tokens: next });
                      await incToken('equal', -1);
                      const afterHas = (t.hand||[]).some(cc => (cc.tokens||[]).length>0);
                      box.classList.toggle('elevated', afterHas);
                    }},
                  { label:String(c.num), action: async ()=>{
                      if(!has('num')){
                        const next=[...(tokens), {type:'num', value:c.num, style:'black'}];
                        await update(ref(db, cardPath), { tokens: next });
                        box.classList.add('elevated');
                      }
                    }}
                ]);
              }
            });
          } else if (canEqual){
            entries.push({label:'＝', action: async ()=>{
              const updated=[...(tokens), {type:'equal', value:c.num, style:'equal'}];
              await update(ref(db, cardPath), { tokens: updated });
              await incToken('equal', +1);
              box.classList.add('elevated');
            }});
          }

          // ≠（アイテム1管理）
          if (has('noteq')) {
            entries.push({
              label:'≠',
              action: async ()=>{
                openMenu(ev.clientX, ev.clientY, [
                  { label:'消す', action: async ()=>{
                      const next = tokens.filter(tk=> tk.type!=='noteq');
                      await update(ref(db, cardPath), { tokens: next });
                      await incToken('noteq', -1);
                      const afterHas = (t.hand||[]).some(cc => (cc.tokens||[]).length>0);
                      box.classList.toggle('elevated', afterHas);
                    }},
                  { label:String(c.num), action: async ()=>{
                      if(!has('num')){
                        const next=[...(tokens), {type:'num', value:c.num, style:'black'}];
                        await update(ref(db, cardPath), { tokens: next });
                        box.classList.add('elevated');
                      }
                    }}
                ]);
              }
            });
          } else if (canNoteq){
            entries.push({
              label:'≠',
              action: async ()=>{
                const updated=[...(tokens), {type:'noteq', value:c.num, style:'noteq'}];
                await update(ref(db, cardPath), { tokens: updated });
                await incToken('noteq', +1);
                box.classList.add('elevated');
              }
            });
          }

if (canX1 && c.kind === 'normal'){
            entries.push({label:'x1', action: async ()=>{
              const updated=[...(tokens), {type:'x1', value:c.num, style:'x1'}];
              await update(ref(db, cardPath), { tokens: updated });
              await incToken('x1', +1);
              box.classList.add('elevated');
            }});
          }
          // x1 を既に持っている場合：
          // 1) x1ポップは表示しない
          // 2) 数字（num）を消すのみ表示（num がある時だけ）

          if(tokens.length>0){
tokens.forEach((tk,ti)=>{
  const tokenText =
    tk.type === 'equal'  ? '＝' :
    tk.type === 'noteq'  ? '≠' :
    tk.type === 'x1'     ? 'x1' :
    (tk.value != null)   ? String(tk.value) :
    (c?.num != null)     ? String(c.num) : '';

  const label = `${tokenText} を消す`;
            
              entries.push({label, action: async ()=>{
                const next = tokens.slice(); const removed = next.splice(ti,1)[0];
                await update(ref(db, cardPath), { tokens: next });
                if(removed?.type==='equal') await incToken('equal', -1);
                if(removed?.type==='noteq') await incToken('noteq', -1);
                if(removed?.type==='x1')    await incToken('x1', -1);
                const afterHas = (t.hand||[]).some(cc => (cc.tokens||[]).length>0);
                box.classList.toggle('elevated', afterHas);
              }});
            });
          }

          openMenu(ev.clientX, ev.clientY, entries);
        };
      }

      badge.appendChild(a);
      badge.appendChild(col);

      wrap.appendChild(card);
      wrap.appendChild(badge);
      hand.appendChild(wrap);
    });
    content.appendChild(hand);
    box.appendChild(content);

    const hasToken = (t.hand||[]).some(c=> (c.tokens||[]).length>0);
    box.classList.toggle('elevated', hasToken);

    tablesEl.appendChild(box);
      growForCardTokens(box);

  });

  /* ★ #22：黄カードが「公開」された枚数が2枚以上になった瞬間に表を出す（種類ではなく枚数） */
  if (v.mission?.flags?.m22_showTableAfter2Yellows) {
    let openYellowCount = 0;
    (v.tables||[]).forEach(T=>{
      (T.hand||[]).forEach(c=>{
        if(c?.kind==='yellow' && c.open===true){
          openYellowCount += 1;
        }
      });
    });

    const alreadyShown = !!v.meta?.m22_infoShown;
    if (openYellowCount >= 2 && !alreadyShown) {
      // フラッシュ防止：描画は次の onValue レンダーに任せる
      update(ref(db, `rooms/${state.roomCode}/meta`), { m22_infoShown: true });
        showInfo22Panel(state.watching || v); // ← 一度だけ明示的に出す
    }
  }
  renderM22PickPanel(v);

    // ★ #27：黄コードが2本公開されたら、アイテム列の直下に提示用トークンを出す
  if (v.mission?.flags?.m27_poolAfter2Yellows) {
    // 黄公開枚数を再利用して判定
    let yOpen = 0;
    (v.tables||[]).forEach(T=>{
      (T.hand||[]).forEach(c=>{
        if (c?.kind==='yellow' && c.open===true) yOpen += 1;
      });
    });
    // 初回だけプールを作ってDBへ保存
    const shown = !!v.meta?.m27_shown;
    if (yOpen >= 2 && !shown) {
      ensureM27Candidates(v).then(()=> renderM27Row(state.watching || v));
    } else {
      // 既に用意済みなら毎描画で同期
      renderM27Row(v);
    }
  }

  // ▼ #13 ヘッダートークンの遅延一括更新（次tickで実行...）
// ▼ #13 ヘッダートークンの遅延一括更新（次tickで実行）
if (!m13HeaderUpdateScheduled && m13HeaderClearIndices && m13HeaderClearIndices.size > 0) {
  m13HeaderUpdateScheduled = true;
  setTimeout(async () => {
    try {
      const indices = Array.from(m13HeaderClearIndices);
      m13HeaderClearIndices = null;
      m13HeaderUpdateScheduled = false;

      // 現在のヘッダー配列を取得して、対象 index を null にする
      const snap = await get(ref(db, `rooms/${state.roomCode}/meta/m13_header`));
      const currentHeader = (snap.val() || []).slice();
      indices.forEach(i => {
        if (i >= 0 && i < currentHeader.length) currentHeader[i] = null;
      });

      await update(ref(db, `rooms/${state.roomCode}/meta`), { m13_header: currentHeader });
    } catch (e) {
      console.error('m13 header clear failed', e);
    }
  }, 0);
}

async function incToken(kind, delta){
  try {
    const path = `rooms/${state.roomCode}/meta/tokenCounts`;
    const snap = await get(ref(db, path));
    const prev = snap.val() || { equal:0, noteq:0, x1:0 };
    const next = { ...prev, [kind]: Math.max(0, (prev[kind] || 0) + delta) };
    await set(ref(db, path), next);
  } catch (e) {
    console.error('incToken failed', e);
  }
}

}
function renderM22PickPanel(v){
  // ミッション22以外は消す
  if (!v?.mission?.id || v.mission.id !== 22) {
    if (m22PickPanel) m22PickPanel.classList.add('hidden');
    return;
  }
  // 自分が未着席なら消す
  const myIdx = (v.tables||[]).findIndex(T => T.playerId === state.userId);
  if (myIdx < 0) { if (m22PickPanel) m22PickPanel.classList.add('hidden'); return; }

  const myTable = v.tables[myIdx] || {};
  // すでに完了しているなら表示しない
  if (myTable.m22Done) { m22PickPanel.classList.add('hidden'); return; }

  // 手札にある整数の集合
  const myHandInts = new Set((myTable.hand||[])
    .filter(c => Number.isInteger(c.num))
    .map(c => c.num|0));

  // 候補 = 1..12 から手札に無い数字
  const candidates = [];
  for (let n=1; n<=12; n++) if (!myHandInts.has(n)) candidates.push(n);

  // 既に自分が選んだトークン
  const picked = Array.isArray(myTable.m22Tokens) ? myTable.m22Tokens.slice(0,2) : [];
  const pickedSet = new Set(picked);

  // 上限：候補が1つなら1、2つ以上なら2
  const maxPick = Math.min(2, candidates.length);

  // もう必要数選び終わってたら閉じる（他端末で同期していてもOK）
  if (picked.length >= maxPick) {
    // DBにも完了フラグを残す（再表示防止）
    update(ref(db, `rooms/${state.roomCode}/tables/${myIdx}`), { m22Done: true });
    m22PickPanel.classList.add('hidden');
    return;
  }

  // 描画
  m22PickPanel.innerHTML = '<span class="cap">未所持の数字から最大2つ選択：</span>';
  candidates.forEach(nn=>{
    const d = document.createElement('div');
    d.className = 'token black' + (pickedSet.has(nn) ? ' disabled' : '');
    d.textContent = String(nn);
    d.onclick = async ()=>{
      if (pickedSet.has(nn)) return;           // 既に選択済み
      if (picked.length >= maxPick) return;    // 上限

      const next = picked.concat(nn);

      // 選び切ったら：m22Tokens + m22Done を同時に保存 → パネルを即非表示
      if (next.length >= maxPick) {
        await update(ref(db, `rooms/${state.roomCode}/tables/${myIdx}`), {
          m22Tokens: next,
          m22Done: true
        });
        m22PickPanel.classList.add('hidden');
      } else {
        // まだ上限に達していない：選択だけ保存して続行
        await update(ref(db, `rooms/${state.roomCode}/tables/${myIdx}`), { m22Tokens: next });
      }
    };
    m22PickPanel.appendChild(d);
  });

  m22PickPanel.classList.remove('hidden');
}


  
/* ：#29 描画・操作ロジック ▼▼ */
function renderM29(v){
  const isM29 = (v?.mission?.id|0) === 29;
  // 既存行の掃除
  const oldHand = document.getElementById('m29HandRow');
  const oldCenter = document.getElementById('m29CenterRow');
  if (!isM29) { if (oldHand) oldHand.remove(); if (oldCenter) oldCenter.remove(); return; }


  
  // 自分の席
  const myIdx = (v.tables||[]).findIndex(T => T.playerId === state.userId);
  const myHand = (myIdx>=0) ? (v.tables[myIdx]?.m29Hand||[]) : [];

  // ---- 自分の手札（画面下部：ミッション詳細の上） ----
  const footer = document.getElementById('missionFooter');
  if (footer) {
    // いったん既存を消す
    const ex = document.getElementById('m29HandRow'); if (ex) ex.remove();
    if (myIdx>=0 && myHand.length>0) {
      const row = document.createElement('div');
      row.id = 'm29HandRow';
      row.className = 'numlane';
      row.style.marginTop = '4px';
      // 各カード
      myHand.forEach(n=>{
        const c = document.createElement('div');
        c.className = 'numcard';
         /* ここから追加：数値カードの表面は画像を使用 */
       c.style.backgroundImage = `url('${imgNumber(n)}')`;
       c.style.backgroundSize = 'cover';
       c.style.backgroundPosition = 'center';
        c.title = '場に出す';
        c.onclick = async (ev)=>{
          try{
            // DBから再取得して安全に更新
            const tRef = ref(db, `rooms/${state.roomCode}/tables/${myIdx}`);
            const mRef = ref(db, `rooms/${state.roomCode}`);
            const [tSnap, rSnap] = await Promise.all([get(tRef), get(mRef)]);
            const T = tSnap.val()||{};
           const R = rSnap.val()||{};
            const hand0 = Array.isArray(T.m29Hand) ? T.m29Hand.slice() : [];
            const pos   = hand0.indexOf(n);
            if (pos<0) return;
            // 1) 出す：手札から抜いてセンターへ
            hand0.splice(pos,1);
            const center = Array.isArray(R.m29_center) ? R.m29_center.slice() : [];
            center.push({ n, by: myIdx, faceUp:false });

            // 2) 自動ドロー：手札が1枚以下なら残り山から1枚
            let drew = false;
            let nextHand = hand0.slice();
            if (nextHand.length <= 1) {
              // 既存のデッキがあれば使う。無ければ“残り”（1..12 から使用済みを除外）を生成
              let deck = Array.isArray(R.m29_deck) ? R.m29_deck.slice() : null;
              if (!Array.isArray(deck)) {
                const used = new Set();
                (R.tables||[]).forEach(TT => (TT?.m29Hand||[]).forEach(x => used.add(x)));
                (Array.isArray(R.m29_center)?R.m29_center:[]).forEach(o => used.add(o?.n|0));
                deck = MATERIALS.numbers.filter(x => !used.has(x));
                shuffle(deck);
              }
              if (deck.length > 0) {
                const d = deck.shift();
                nextHand.push(d);
                drew = true;
                // m29_deck を書き戻す
                await update(ref(db, `rooms/${state.roomCode}`), { m29_deck: deck });
              }
            }
            // 3) DB 更新（手札・センター）
            await Promise.all([
              update(tRef, { m29Hand: nextHand }),
              update(ref(db, `rooms/${state.roomCode}`), { m29_center: center })
            ]);
            // 4) UI：名前右の枚数表示の右に「+1」を3秒出す
            if (drew) {
              const id = `m29cnt-${myIdx}`;
              const anchor = document.getElementById(id);
              if (anchor && anchor.parentNode) {
                const badge = document.createElement('span');
                badge.textContent = '+1';
                // 目立ちすぎない緑＆少し余白、3秒後フェードアウト
                badge.style.marginLeft = '2px';
                badge.style.color = '#22c55e';
                badge.style.transition = 'opacity .3s linear';
                anchor.after(badge);
                setTimeout(()=>{ badge.style.opacity='0'; setTimeout(()=>badge.remove(), 300); }, 2700);
              }
            }
          }catch(e){ console.error(e); }
        };
        row.appendChild(c);
      });
      // ミッション詳細タイトルの直前に差し込む
      const title = document.getElementById('missionDetailTitle');
      if (title && title.parentNode === footer) {
        footer.insertBefore(row, title);
      } else {
        footer.appendChild(row);
      }
    }
  }

  // ---- センター（アイテム下・中央寄せ） ----
  const bar = document.getElementById('itemsBar');
  if (!bar) return;
  { const ex = document.getElementById('m29CenterRow'); if (ex) ex.remove(); }

  const center = Array.isArray(v.m29_center) ? v.m29_center : [];
  // ★追加：公開中“コード”の数字別公開枚数を集計（kind:'normal' かつ open:true）
  const openCountByNum = {};
  (v.tables||[]).forEach(T=>{
    (T.hand||[]).forEach(c=>{
      if (c?.kind === 'normal' && c.open === true){
        const num = c.num|0;
        openCountByNum[num] = (openCountByNum[num]||0) + 1;
      }
    });
  });
  if (center.length>0){
    const row = document.createElement('div');
    row.id = 'm29CenterRow';
    row.className = 'numlane';
    row.style.justifyContent = 'center';
    // 各センター札
    center.forEach((obj, idx)=>{
      const cell = document.createElement('div');
      cell.className = 'numcard';
      cell.style.display = 'grid'; cell.style.placeItems = 'center'; cell.style.fontWeight = 'bold';
         /* ここから追加：数値カードは表＝数字画像／裏＝背面画像 */
     if (obj.faceUp) {
       cell.style.backgroundImage = `url('${imgNumber(obj.n)}')`;
       cell.style.backgroundSize = 'cover';
       cell.style.backgroundPosition = 'center';
     } else {
       cell.style.backgroundImage = "url('./numbercardback.jpg')";
       cell.style.backgroundSize = 'cover';
       cell.style.backgroundPosition = 'center';
     }


      
      // ★変更：公開4枚成立時は「捨てる」表示
      const willDiscardOnly = obj.faceUp && ((openCountByNum[obj.n|0]||0) === 4);
      cell.title = obj.faceUp ? (willDiscardOnly ? '捨てる' : '出したプレイヤーの次のテーブルへ移す') : 'めくる';
      cell.onclick = async (ev)=>{        try{
          const rRef = ref(db, `rooms/${state.roomCode}`);
          const rSnap = await get(rRef);
          const R = rSnap.val()||{};
          const cur = Array.isArray(R.m29_center) ? R.m29_center.slice() : [];
          // インデックス安全化
          if (idx<0 || idx>=cur.length) return;
          const curObj = cur[idx];
          if (!curObj) return;

          if (!curObj.faceUp){
            // 表にする
            cur[idx] = { ...curObj, faceUp:true };
            await update(rRef, { m29_center: cur });
        } else {
            // ★変更：公開4枚成立時は送らず「捨てる」ポップ
            const opened4 = (()=>{
              const map = {};
              (R.tables||[]).forEach(T=>{
                (T.hand||[]).forEach(c=>{
                  if (c?.kind==='normal' && c.open===true){
                    const num = c.num|0;
                    map[num] = (map[num]||0) + 1;
                  }
                });
              });
             return (map[(curObj.n|0)]||0) === 4;
            })();
           if (opened4){
              openOneMini(ev.clientX, ev.clientY, '捨てる', async ()=>{
                const nowSnap = await get(rRef);
                const RR = nowSnap.val()||{};
                const arr = Array.isArray(RR.m29_center) ? RR.m29_center.slice() : [];
               if (idx<0 || idx>=arr.length) return;
                arr.splice(idx,1);
               await update(rRef, { m29_center: arr });
              });
           } else {
              // 通常：出したプレイヤーの“次のテーブル”へ移す
              const toIdx = ((curObj.by|0) + 1) % (v.tableCount|0);
              const tRef = ref(db, `rooms/${state.roomCode}/tables/${toIdx}`);
              const tSnap = await get(tRef);
              const T2 = tSnap.val()||{};
              const hand = Array.isArray(T2.m29Hand) ? T2.m29Hand.slice() : [];
              hand.push(curObj.n);
              cur.splice(idx,1);
              await Promise.all([
                update(tRef, { m29Hand: hand }),
                update(rRef,  { m29_center: cur })
             ]);
            }      
          }
        }catch(e){ console.error(e); }
      };
      row.appendChild(cell);
    });

    bar.insertAdjacentElement('afterend', row);
  }
}

function renderM26(v){
  const mid = (v?.mission?.id|0);
  const isTarget = (mid === 26 || mid === 47);   // ← ここだけ追加・変更
  const old   = document.getElementById('m26Grid');

  // 26/47 以外なら消すだけ
  if (!isTarget){ if (old) old.remove(); return; }

  // アイテム帯がまだ描画されていない瞬間はスキップ（次の onValue で描画）
  const bar = document.getElementById('itemsBar');
  if (!bar) return;

  // まだ未設置なら設置
  if (!old) {
    mountM26GridUnderItems();     // ← 関数名も id もそのまま流用でOK
    return; // 次の onValue で _sync が走る
  }

  // 既にある場合は最新 state に合わせて再同期
  old._sync && old._sync();
}

/* ===== #55：チャレンジ10枚から人数分を確定。c8が含まれたら左右の数値2枚も確定 ===== */
async function ensureM55MetaInit(vNow){
  const v = vNow || state.watching; if(!v) return;
  const mid = (v?.mission?.id|0);
  if (!(mid === 55 || mid === 60)) return;
  const M = v.meta || {};

  // まだ確定していなければ、ホストが山札と公開札を確定
  if (!Array.isArray(M.m55_shown)) {
    if (!state.isHost) return;
    // 画像ファイル名（拡張子混在のまま扱う）
    const deck = [
      'c1.png','c2.png','c3.png','c4.png','c5.png',
      'c6.png','c7.png','c8.png','c9.png','c10.png'
    ].slice();
    shuffle(deck);
    const n = v.tableCount|0;
    const shown = deck.slice(0, Math.max(1,n)); // 人数分

    // c8が含まれているなら左右の数値を1枚ずつランダムに決める（1..12）
    let c8Sides = null;
    if (shown.some(s => /c8\.(png|jpg)$/i.test(s))) {
  const [L, R] = pickK(MATERIALS.numbers, 2); // ← ユニーク抽選
  c8Sides = [L, R];
    }
    await update(ref(db, `rooms/${state.roomCode}/meta`), {
      m55_deck: deck,
      m55_shown: shown,
      m55_c8Sides: c8Sides
    });
  }
}


// タップ拡大（conZoomOverlayを流用）
function openChallengeZoom(id){
  try{
    const old = document.getElementById('conZoomOverlay');
    if (old) old.remove();
    const ov = document.createElement('div');
    ov.id = 'conZoomOverlay';
    ov.addEventListener('click', (e)=>{ if(e.target===ov) closeConstraintZoom(); });
    const wrap = document.createElement('div'); wrap.className = 'conzoom-wrap';
    const big  = document.createElement('div'); big.className  = 'conzoom-card';
    big.style.backgroundImage = `url('${imgChallenge(id)}')`;
    wrap.appendChild(big);
    ov.appendChild(wrap);
    document.body.appendChild(ov);
  }catch(e){ console.error(e); }
}


  
/* ===== #55：チャレンジ札（人数分）。c8 のときだけ左右に数値1枚ずつ表示 ===== */
function renderM55(v){
  const isM55 = ((v?.mission?.id|0) === 55 || (v?.mission?.id|0) === 60);
  const rowId = 'm55Row';
  const old   = document.getElementById(rowId);
  if (!isM55){ if (old) old.remove(); return; }

  // 初回はメタを用意させる
  if (!Array.isArray(v?.meta?.m55_shown)) { ensureM55MetaInit(v); if (old) old.remove(); return; }

  if (old) old.remove();
  const lane = document.createElement('div');
  lane.id = rowId;
  lane.className = 'conlane'; // concard と並べる既存レーン

  const shown = v.meta.m55_shown || [];
  const sides = v.meta.m55_c8Sides || null;

  // 画像URLユーティリティ
  const imgChallenge = (fname)=> `./${fname}`;

  shown.forEach(fname=>{
    const isC8 = /c8\.(png|jpg)$/i.test(fname);

    // c8 のときは LEFT数値 → concard → RIGHT数値 の順で横並び
    if (isC8 && Array.isArray(sides) && sides.length===2){
      const leftNum  = document.createElement('div');
      leftNum.className = 'numcard';
      leftNum.style.backgroundImage = `url('${imgNumber(sides[0])}')`;
      lane.appendChild(leftNum);
    }

    const cc = document.createElement('div');
    cc.className = 'concard';
    cc.style.backgroundImage = `url('${imgChallenge(fname)}')`;
cc.onclick = (ev)=>{
  ev.stopPropagation();
openChallengeZoom(fname.replace(/\.(png|jpg)$/,''));
};
    lane.appendChild(cc);

    if (isC8 && Array.isArray(sides) && sides.length===2){
      const rightNum = document.createElement('div');
      rightNum.className = 'numcard';
      rightNum.style.backgroundImage = `url('${imgNumber(sides[1])}')`;
      lane.appendChild(rightNum);
    }
  });

  // 既存の「アイテム列の直下に挿入」ヘルパを使用（#15等と同じ）
  mountLaneUnderItemsBar(lane);  // #15 の末尾と同じ呼び方でOK :contentReference[oaicite:0]{index=0}
}


  
/* ここから追加：#31 描画・操作ロジック */
function renderM31(v){
  const isM31 = ((v?.mission?.id|0) === 31) || ((v?.mission?.id|0) === 34);

  // 既存除去
  const oldH = document.getElementById('m31HandRow'); if (oldH) oldH.remove();
  const oldC = document.getElementById('m31CenterRow'); if (oldC) oldC.remove();
  if (!isM31) return;

  const myIdx = (v.tables||[]).findIndex(T => T.playerId === state.userId);
  const myLetter = (myIdx>=0) ? v.tables[myIdx]?.m31Con : null;
  const center = Array.isArray(v.m31_center) ? v.m31_center : [];

  // ── 自分の下部（場に出してないときだけ表示）
  const myOut = center.some(o => o?.by === myIdx);
  const footer = document.getElementById('missionFooter');
  if (footer && myIdx>=0 && myLetter && !myOut) {
    const row = document.createElement('div');
    row.id = 'm31HandRow';
    row.className = 'conlane';
    const c = document.createElement('div');
    c.className = 'concard';
    c.style.backgroundImage = `url('${imgConstraint(myLetter)}')`;
    /* ここから変更 */
    c.title = '拡大';
    c.onclick = (ev)=>{ ev.stopPropagation(); openConstraintZoom(myLetter, myIdx); };
    /* ここまで変更 */
    row.appendChild(c);

    // タイトルの直前に差し込む（#29と同様）
    const title = document.getElementById('missionDetailTitle');
    if (title && title.parentNode === footer) footer.insertBefore(row, title);
    else footer.appendChild(row);
  }

  // ── センター（アイテム列の直下）
  const bar = document.getElementById('itemsBar');
  if (bar && center.length>0){
    const row = document.createElement('div');
    row.id = 'm31CenterRow';
    row.className = 'conlane';
    center.forEach((obj, idx)=>{
      const cell = document.createElement('div');
      cell.className = 'concard';
      cell.style.backgroundImage = `url('${imgConstraint(obj.ch)}')`;
      cell.title = '戻す';
      cell.onclick = async ()=>{
        try{
          const rRef = ref(db, `rooms/${state.roomCode}`);
          const rSnap = await get(rRef);
          const R = rSnap.val()||{};
          const cur = Array.isArray(R.m31_center) ? R.m31_center.slice() : [];
          if (idx>=0 && idx<cur.length){
            cur.splice(idx,1);
            await update(rRef, { m31_center: cur });
          }
        }catch(e){ console.error(e); }
      };
      row.appendChild(cell);
    });
    bar.insertAdjacentElement('afterend', row);
  }
}

/* ここから追加：#32/#37 制約カードの山札（同期表示） */
// 共有：meta 初期化（ミッションIDごと）
async function ensureConDeckMetaInit(vNow, mid){
  const v = vNow || state.watching; if (!v) return;
  if ((v?.mission?.id|0) !== mid) return;
  const keyDeck = `m${mid}_deck`;
  const keyDisc = `m${mid}_discards`;
  if (Array.isArray(v?.meta?.[keyDeck])) return;   // 既に初期化済み
  if (!state.isHost) return;                        // 初期化はホストのみ

  // 制約カード A〜L をシャッフルして山札に
  const deck = 'ABCDEFGHIJKL'.split(''); shuffle(deck);
  await update(ref(db, `rooms/${state.roomCode}/meta`), {
    [keyDeck]: deck,
    [keyDisc]: []
  });
}

// 共有：描画（mid=32/37 を切替）
function renderConDeckSync(v, mid){
  const isTarget = ((v?.mission?.id|0) === mid);
  const rowId = `m${mid}ConRow`;
  const old = document.getElementById(rowId);
  if (!isTarget){ if (old) old.remove(); return; }

  const keyDeck = `m${mid}_deck`;
  const keyDisc = `m${mid}_discards`;

  // 初回：ホストが meta を用意（未用意なら一旦抜けて次の onValue で描画）
  if (!Array.isArray(v?.meta?.[keyDeck])){ ensureConDeckMetaInit(v, mid); if (old) old.remove(); return; }

  if (old) old.remove();
  const lane = document.createElement('div');
  lane.id = rowId;
  lane.className = 'conlane';  // 制約カード帯（既存CSS）

  // 山札ボタン（制約カード裏面）＋残表示
  const deckBtn = document.createElement('div');
  deckBtn.className = 'numdeck';                        // 使い回し
  deckBtn.title = 'めくる';
  deckBtn.style.background = "#fff url('./conback.jpg') center/70% no-repeat";

  const restLbl = document.createElement('span');
  restLbl.className = 'numrest';

  // 右側：公開札（積み重ね）
  const pile = document.createElement('div');
  pile.className = 'numcard-holder';
  pile.style.position = 'relative';

  lane.appendChild(deckBtn);
  lane.appendChild(restLbl);
  lane.appendChild(pile);

  // 再描画
  const refresh = ()=>{
    const d = (v?.meta?.[keyDeck]||[]);
    const x = (v?.meta?.[keyDisc]||[]);
    const remain = d.filter(ch => !x.includes(ch)).length;
    restLbl.textContent = `残:${remain}`;
    pile.innerHTML = '';

    // discards を積み重ね表示（2px オフセット）
    x.forEach((ch, i)=>{
      const node = document.createElement('div');
      node.className = 'concard';
      node.style.backgroundImage = `url('${imgConstraint(ch)}')`;
      node.title = '拡大';
      node.onclick = (ev)=>{ ev.stopPropagation(); openConstraintZoom(ch); };
      if (i>0){
        const off = i*2;
        node.style.position = 'absolute';
        node.style.left = off + 'px';
        node.style.top  = off + 'px';
      }
      pile.appendChild(node);
      const extra = i*2;
      // 制約カードのサイズは CSS 変数に追従（既存CSS：--con-h / --item-h）
      const baseH = cssNum('--con-h') || cssNum('--item-h') || 75;
      pile.style.height = (baseH + extra) + 'px';
      lane.style.marginBottom = extra + 'px';
    });
  };
  refresh();

  // 1枚めくる：山札順で未使用の1枚を discards に積む（全員へ同期）
  deckBtn.onclick = async ()=>{
    try{
      const mRef = ref(db, `rooms/${state.roomCode}/meta`);
      const mSnap = await get(mRef);
      const meta = mSnap.val() || {};
      const D  = Array.isArray(meta[keyDeck]) ? meta[keyDeck].slice() : [];
      const Xs = Array.isArray(meta[keyDisc]) ? meta[keyDisc].slice() : [];
      const next = D.find(ch => !Xs.includes(ch));
      if (next == null){
        // すべて使い切ったら再生成メニュー（#30 などと同様の運用にするならここで再構築しても可）
        return;
      }
      Xs.push(next);
      await update(mRef, { [keyDisc]: Xs });
    }catch(e){ console.error(e); }
  };

  // DOM：アイテム列の直下
  mountLaneUnderItemsBar(lane);
}

// エイリアス（ミッションごと）
function renderM32(v){ renderConDeckSync(v, 32); }
function renderM37(v){ renderConDeckSync(v, 37); }
/* ここまで追加 */

  
  
/* ここから追加：#42 描画・操作ロジック（⇅入れ替えモードをひとかたまりで実装） */
function renderM42(v){
  const isM42 = ((v?.mission?.id|0) === 42);

  // 1) 一度だけ仕込む補助CSS
  if (!document.getElementById('m42ExtraStyle')) {
    const st = document.createElement('style');
    st.id = 'm42ExtraStyle';
    st.textContent = `
      /* 消滅済み枠（既存維持） */
      .m42-gone, .m42-gone * { visibility: hidden !important; pointer-events: none !important; }
      /* ⇅ / -2 モード時：全体公開カードを青枠表示（既存の i2-selectable 風） */
      body[data-m42swap="on"] .card.open,
      body[data-m42m2="on"]   .card.open { outline:2px dashed #38bdf8; outline-offset:-3px; }
        /* exright/exleft の表示は常に画面中央に固定（保険） */
        #m42Ex{ position:fixed!important; left:50%!important; top:50%!important; transform:translate(-50%,-50%)!important; }

      
    `;
    document.head.appendChild(st);
  }

  // 既存UIの掃除（バー/箱）。☝（m42_on）は前コード互換として残す
  const oldBar = document.getElementById('m42HostBar'); if (oldBar) oldBar.remove();
  const oldBox = document.getElementById('m42Box');     if (oldBox && !v?.meta?.m42_on) oldBox.remove();

  if (!isM42){
    // ミッション外：⇅ / -2 のハンドラと表示フラグを落とす
    document.body.removeAttribute('data-m42swap');
    document.body.removeAttribute('data-m42m2');
    if (state._m42swapClick){ document.removeEventListener('click', state._m42swapClick, true); state._m42swapClick=null; }
    if (state._m42m2Click)  { document.removeEventListener('click', state._m42m2Click,   true); state._m42m2Click=null; }
    return;
  }

  // 2) ホスト下部バー
  if (state.isHost){
    const bar = document.createElement('div');
    bar.id = 'm42HostBar';
    Object.assign(bar.style, {
      position:'fixed', left:'50%', bottom:'10px', transform:'translateX(-50%)',
      display:'flex', gap:'6px', zIndex:2147483600, background:'#fff',
      border:'1px solid #eee', borderRadius:'12px', padding:'6px 8px',
      boxShadow:'0 10px 24px rgba(0,0,0,.08)'
    });
    const btn = (txt, on)=>{ const b=document.createElement('button'); b.className='btn small'; b.textContent=txt; b.onclick=on; return b; };

    // ☝トグル（既存維持）
    const toggleBox = async ()=>{
      const on = !!v?.meta?.m42_on;
      await update(ref(db, `rooms/${state.roomCode}/meta`), { m42_on: !on });
    };

    // ⇅トグル：入れ替えモード on/off と選択状態のリセット
    const toggleSwap = async ()=>{
      const on = !!v?.meta?.m42Swap?.on;
      await update(ref(db, `rooms/${state.roomCode}/meta`), { m42Swap: on ? null : { on:true, usingBy:null, selA:null, selB:null } });
    };
    // -2トグル：2枚同数を選んで「裏に戻す」
    const toggleMinus2 = async ()=>{
      const on = !!v?.meta?.m42M2?.on;
      await update(ref(db, `rooms/${state.roomCode}/meta`), { m42M2: on ? null : { on:true, usingBy:null, selA:null, selB:null } });
    };

    bar.appendChild(btn('-2', toggleMinus2));     // 追加：-2トグル
    bar.appendChild(btn('⇅', toggleSwap));        // ← 今回の本体
    bar.appendChild(btn('☝', toggleBox));        // 互換
  /* ここから追加：#42 ↻（左/右タブ → 画像 → 循環席移動） */
    const flashEx = (img) => {
      let ex = document.getElementById('m42Ex');
      if (ex) ex.remove();
      ex = document.createElement('div');
     ex.id = 'm42Ex';
      Object.assign(ex.style, {
       position:'fixed', left:'50%', bottom:'10px', transform:'translateX(-50%)',
        width:'140px', height:'90px',
        background:`url('./${img}') center/contain no-repeat`,
        zIndex:2147483647, pointerEvents:'none'
      });
      popLayer.appendChild(ex); // 画面最前のオーバーレイ層へ
      return ex;
    };
    const clearEx = ()=>{ const ex=document.getElementById('m42Ex'); if(ex) ex.remove(); };

    const findMySeat = (vv)=>{
  if (state.seatedTable != null) return Number(state.seatedTable);
      const i = (vv?.tables||[]).findIndex(t=> t?.playerId===state.userId);
      return (i>=0? i : null);
    };

    const seatTo = async (newIdx)=>{
      // 現席を離席 → 新しい席に着席＆手札の ownerId を自分に
      await leaveSeatNow();
      await update(ref(db, `rooms/${state.roomCode}/tables/${newIdx}`), {
        playerId: state.userId, playerName: state.userName
      });
      const hRef = ref(db, `rooms/${state.roomCode}/tables/${newIdx}/hand`);
      const hSnap = await get(hRef);
      const hand = hSnap.val() || [];
      await Promise.all(hand.map((_,idx)=>
        update(ref(db, `rooms/${state.roomCode}/tables/${newIdx}/hand/${idx}`), { ownerId: state.userId })
      ));
      state.seatedTable = newIdx;
      updateMenuButtons();
    };

    const moveSeatCyclic = async (dir)=>{
      const vv = state.watching || v;
      const n  = (vv?.tableCount|0) || (vv?.tables?.length|0);
      if (!n) return;
      const cur = findMySeat(vv);
      if (cur==null){ alert('席に座っていません'); return; }
      const next = ( (cur + (dir>0? +1 : -1)) % n + n ) % n; // 循環
      await seatTo(next);
    };

   // ★ 全員の座席を循環移動：dir=+1（左/次テーブル）, -1（右/前テーブル）
     const rotateAllSeats = async (dir)=>{
       const vv = state.watching || v;
       const snap = await get(ref(db, `rooms/${state.roomCode}/tables`));
       const tbls = snap.val() || [];
       const n = tbls.length|0; if(!n) return;
       const nextPlayers = Array.from({length:n}, ()=>({id:null, name:null}));
       for(let i=0;i<n;i++){
         const pid  = tbls[i]?.playerId || null;
         const name = tbls[i]?.playerName || null;
         if(pid){
           const j = ((i + (dir>0? +1 : -1)) % n + n) % n;
           nextPlayers[j] = {id:pid, name};
         }
       }
       const out = tbls.map((T,i)=>{
         const np = nextPlayers[i];
         const hand = Array.isArray(T?.hand) ? T.hand.map(c => ({...c, ownerId: np.id||null})) : [];
         return {...T, playerId: np.id||null, playerName: np.name||null, hand};
       });
       await set(ref(db, `rooms/${state.roomCode}/tables`), out);
       // ローカルの自席インデックスも更新（UIズレ防止）
      const cur = (vv?.tables||[]).findIndex(t=> t?.playerId===state.userId);
       if (cur>=0){
         const next = ((cur + (dir>0? +1 : -1)) % n + n) % n;
         state.seatedTable = next; updateMenuButtons();
       }
     };

    
    const onRotate = (ev)=>{
       openBottomMenu([
  { label:'左', action: async ()=>{
            // 画像表示を全員に同期：metaへ発火（3秒）
            await update(ref(db, `rooms/${state.roomCode}/meta`), { m42_ex:{ img:'exleft.jpg', at: Date.now() } });
            await rotateAllSeats(+1);    // 全員を次テーブルへ（既存維持）
            setTimeout(async ()=>{
              // ホスト側でmetaをクリア（ローカル保険は③で実装）
              await update(ref(db, `rooms/${state.roomCode}/meta`), { m42_ex: null });
            }, 3000);
        }},
        { label:'右', action: async ()=>{
            await update(ref(db, `rooms/${state.roomCode}/meta`), { m42_ex:{ img:'exright.jpg', at: Date.now() } });
            await rotateAllSeats(-1);    // 全員を前テーブルへ（既存維持）
            setTimeout(async ()=>{
              await update(ref(db, `rooms/${state.roomCode}/meta`), { m42_ex: null });
            }, 3000);
        }},
      ]);
    };
    bar.appendChild(btn('↻', onRotate));
    document.body.appendChild(bar);
  }

  /* ▼ 追加：全員向けのex画像（m42_ex）表示ロジック：metaを見て中央に3秒表示 */
  {
   const ex = v?.meta?.m42_ex;
    const exist = document.getElementById('m42Ex');
    if (ex && !exist){
      const div = document.createElement('div');
      div.id = 'm42Ex';
      Object.assign(div.style, {
        position:'fixed', left:'50%', top:'50%', transform:'translate(-50%, -50%)',
        width:'140px', height:'90px',
        background:`url('./${ex.img}') center/contain no-repeat`,
        zIndex:2147483647, pointerEvents:'none'
     });
      popLayer.appendChild(div);
      // ローカル保険：3秒で自動消去（ホストは②でmetaもnullにします）
      setTimeout(()=>{ if(div.isConnected) div.remove(); }, 3000);
    }
    if (!ex && exist){ exist.remove(); }
  }

  
  // 3) ☝ONなら箱を出す（既存互換）
  if (v?.meta?.m42_on){
    const bar = document.getElementById('itemsBar');
    if (bar && !document.getElementById('m42Box')){
      const box = document.createElement('div');
      box.id = 'm42Box';
      Object.assign(box.style, {
        width:'140px', height:'90px', marginTop:'6px', marginLeft:'4px',
        background:`url('./box.jpg') center/cover no-repeat`,
        border:'2px dashed #38bdf8', borderRadius:'10px'
      });
      bar.insertAdjacentElement('afterend', box);
    }
  }

  // 4) ⇅入れ替えモード：青枠＋クリック選択（▼表示は renderTables 側の2行で描画）
  const swapOn = !!v?.meta?.m42Swap?.on;
  if (swapOn){
    document.body.setAttribute('data-m42swap','on');
    // 既存カードの裏表トグルonclickより前に捕捉して止める＆選択処理へ
    if (!state._m42swapClick){
      state._m42swapClick = async (ev)=>{
        // クリック捕捉（気泡化前）。カード以外は無視
        const wrap = ev.target.closest?.('.card-wrap');
        if (!wrap) return;
        // 非公開は対象外：.open が付いているか見る
        const cardEl = wrap.querySelector('.card');
        if (!cardEl || !cardEl.classList.contains('open')) return;

        // ここで既存のカードflip onclickを止める
        ev.stopPropagation();

        // DOMに付けたdata属性から table / cardId を取得（下の最小追記で付与）
        const table = parseInt(wrap.dataset.table,10);
        const cardId = wrap.dataset.cardId;
        if (!Number.isInteger(table) || !cardId) return;

        const me = state.userId;
        const mRef = ref(db, `rooms/${state.roomCode}/meta`);
        const mSnap = await get(mRef);
        const meta  = mSnap.val() || {};
        const flow  = meta.m42Swap && meta.m42Swap.on ? meta.m42Swap : {on:true, usingBy:null, selA:null, selB:null};

        // 他人が選びかけていても、自分が触れば乗っ取り（Aさん→Bさんでキャンセル要求を満たす）
        if (flow.usingBy && flow.usingBy !== me){
          await update(mRef, { m42Swap:{on:true, usingBy:me, selA:{table, cardId}, selB:null} });
          return;
        }

        // 自分のフローとして進行
        if (!flow.selA){
          await update(mRef, { m42Swap:{on:true, usingBy:me, selA:{table, cardId}, selB:null} });
          return;
        }
        if (flow.selA && !flow.selB){
          // 2枚目選択
          const selA = flow.selA, selB = {table, cardId};

          // 2枚が同じ数字ならキャンセル
          const tSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
          const tables = tSnap.val() || [];
          const findNum = ({table, cardId})=>{
            const hand = (tables[table]?.hand)||[];
            const c = hand.find(x=> x?.id===cardId);
            return c ? (c.num|0) : null;
          };
          const na = findNum(selA), nb = findNum(selB);
          if (na!=null && nb!=null && na===nb){
            alert('同じ数字です'); // シンプルポップ
            await update(mRef, { m42Swap:{on:true, usingBy:me, selA:null, selB:null} });
            return;
          }

          // 2枚揃った：下ポップで「交換する／やり直す」
          await update(mRef, { m42Swap:{on:true, usingBy:me, selA, selB} });
          openBottomMenu([
            {label:'交換する', action: async ()=>{
              // 昇順に並べ替えず、その場で入れ替える
              const ts = (await get(ref(db, `rooms/${state.roomCode}/tables`))).val() || [];
              const pick = (ti, id)=>{ const hand=(ts[ti]?.hand)||[]; const idx=hand.findIndex(c=> c?.id===id); return {hand, idx, card: idx>=0?hand[idx]:null}; };
              const A = pick(selA.table, selA.cardId);
              const B = pick(selB.table, selB.cardId);
              if (!A.card || !B.card) { await update(mRef, { m42Swap:{on:true, usingBy:me, selA:null, selB:null} }); return; }

              const toA = {...B.card, ownerId: (ts[selA.table]?.playerId)||null, markUntil: (now()+6000)};
              const toB = {...A.card, ownerId: (ts[selB.table]?.playerId)||null, markUntil: (now()+6000)};
              A.hand[A.idx] = toA;
              B.hand[B.idx] = toB;

              // アルファの振り直し（既存慣例）
              const realpha = (hand)=>{ const alpha='abcdefghijklmnopqrstuvwxyz'; hand.forEach((c,i)=> c.alpha = alpha[i%alpha.length]); };
              realpha(A.hand); realpha(B.hand);

              await Promise.all([
                set(ref(db, `rooms/${state.roomCode}/tables/${selA.table}/hand`), A.hand),
                set(ref(db, `rooms/${state.roomCode}/tables/${selB.table}/hand`), B.hand),
               update(mRef, { m42Swap: null })
              ]);
            }},
            {label:'やり直す', action: async ()=>{
              await update(mRef, { m42Swap:{on:true, usingBy:me, selA:null, selB:null} });
            }}
          ]);
        }
      };
      document.addEventListener('click', state._m42swapClick, true);
    }
  }else{
    // ⇅オフ：フラグ/ハンドラ解除
    document.body.removeAttribute('data-m42swap');
    if (state._m42swapClick) { document.removeEventListener('click', state._m42swapClick, true); state._m42swapClick=null; }
  }
  // 5) -2モード：青枠＋クリック選択→同数なら「元に戻す（裏に）」/「やり直す」
  const m2On = !!v?.meta?.m42M2?.on;
  if (m2On){
    document.body.setAttribute('data-m42m2','on');
   if (!state._m42m2Click){
      state._m42m2Click = async (ev)=>{
        const wrap = ev.target.closest?.('.card-wrap'); if (!wrap) return;
        const cardEl = wrap.querySelector('.card');      if (!cardEl || !cardEl.classList.contains('open')) return; // 公開のみ
        ev.stopPropagation(); // 既存flip阻止
        const table = parseInt(wrap.dataset.table,10);
        const cardId = wrap.dataset.cardId;
        if (!Number.isInteger(table) || !cardId) return;

       const me = state.userId;
        const mRef = ref(db, `rooms/${state.roomCode}/meta`);
        const mSnap = await get(mRef);
        const meta  = mSnap.val() || {};
        const flow  = meta.m42M2 && meta.m42M2.on ? meta.m42M2 : {on:true, usingBy:null, selA:null, selB:null};

        // 乗っ取り（A→BでAの選択をキャンセル）
        if (flow.usingBy && flow.usingBy !== me){
          await update(mRef, { m42M2:{on:true, usingBy:me, selA:{table, cardId}, selB:null} });
          return;
        }
        // 自分のフロー
        if (!flow.selA){
          await update(mRef, { m42M2:{on:true, usingBy:me, selA:{table, cardId}, selB:null} });
          return;
      }
        if (flow.selA && !flow.selB){
          const selA = flow.selA, selB = {table, cardId};
          // 数字チェック（同数のみ許可）
          const ts = (await get(ref(db, `rooms/${state.roomCode}/tables`))).val() || [];
          const pickNum = ({table, cardId})=>{
            const hand=(ts[table]?.hand)||[]; const c=hand.find(x=> x?.id===cardId);
           return (c && typeof c.num==='number') ? (c.num|0) : null;
          };
          const na = pickNum(selA), nb = pickNum(selB);
          if (na==null || nb==null || na!==nb){
            alert('違う数字です');
            await update(mRef, { m42M2:{on:true, usingBy:me, selA:null, selB:null} });
           return;
          }
          // 2枚揃い：下ポップ
          await update(mRef, { m42M2:{on:true, usingBy:me, selA, selB} });
          openBottomMenu([
           {label:'元に戻す', action: async ()=>{
              // 2枚とも「裏」にする（open:false）
              const ts2 = (await get(ref(db, `rooms/${state.roomCode}/tables`))).val() || [];
              const locate = ({table, cardId})=>{
                const hand=(ts2[table]?.hand)||[]; const idx=hand.findIndex(c=> c?.id===cardId);
                return {hand, idx};
              };
              const A = locate(selA), B = locate(selB);
              if (A.idx<0 || B.idx<0){ await update(mRef, { m42M2:{on:true, usingBy:me, selA:null, selB:null} }); return; }
              if (A.hand[A.idx]) A.hand[A.idx] = {...A.hand[A.idx], open:false};
              if (B.hand[B.idx]) B.hand[B.idx] = {...B.hand[B.idx], open:false};
await Promise.all([
  set(ref(db, `rooms/${state.roomCode}/tables/${selA.table}/hand`), A.hand),
  set(ref(db, `rooms/${state.roomCode}/tables/${selB.table}/hand`), B.hand),
  update(mRef, { m42M2: null })
]);
            }},
            {label:'やり直す', action: async ()=>{
              await update(mRef, { m42M2:{on:true, usingBy:me, selA:null, selB:null} });
           }}
          ]);
        }
      };
      document.addEventListener('click', state._m42m2Click, true); // キャプチャでflip阻止
    }
  }else{
    // -2オフ
   document.body.removeAttribute('data-m42m2');
    if (state._m42m2Click){ document.removeEventListener('click', state._m42m2Click, true); state._m42m2Click=null; }
  }
}
/* ここまで追加：#42 */

/* ここから追加：ミッション43 */
function renderM43(v){
  const isM43 = ((v?.mission?.id|0) === 43);
  const old = document.getElementById('m43Nano');

  // ミッション43以外 → 後片付け
  if (!isM43){
    if (old) old.remove();
    document.getElementById('nanoRow')?.remove(); // 旧・新UIの掃除
    return;
  }

  // 初期化：ホストが m43_nano を用意
  if ((v?.meta?.m43_nano|0) === 0){
    if (state.isHost){
      const P = (v?.tableCount|0) || (v?.tables?.length|0) || 0;
      const initNano = (P>=5) ? 3 : 4;
      update(ref(db, `rooms/${state.roomCode}/meta`), { m43_nano: initNano, m43_pos: 0, m43_prevPos: 0 });
    }
    if (old) old.remove();
    document.getElementById('nanoRow')?.remove();
    return;
  }

  const pos     = v?.meta?.m43_pos|0;
  const prevPos = v?.meta?.m43_prevPos|0;
  const nanoLv  = clamp(v?.meta?.m43_nano|0, 0, 4);

  if (!pos){
    if (old) old.remove();
    document.getElementById('nanoRow')?.remove();
    return;
  }

  const goingLeft = (prevPos>0 && pos < prevPos);
  const img = goingLeft ? `./nano${nanoLv}left.png` : `./nano${nanoLv}.png`;

  // 行コンテナ（itemsBar の直下）を用意
  const itemsBar = document.getElementById('itemsBar');
  if (!itemsBar) return;
  let row = document.getElementById('nanoRow');
  if (!row){
    row = document.createElement('div');
    row.id = 'nanoRow';
    row.className = 'nano-row';
    itemsBar.insertAdjacentElement('afterend', row);
  }

  const node = old || document.createElement('div');
  node.id = 'm43Nano';
  node.className = 'm43-nano';
  node.style.backgroundImage = `url("${img}")`;

  node.onclick = (ev)=>{
    openMenu(ev.clientX, ev.clientY, [
      { label:'回収', action: async ()=>{
      /* ここから追加：#43 回収タップ → A群から1枚を自分の手札へ */
      const code = state.roomCode;
      const myTable = state.seatedTable;
      if (myTable == null) { alert('席に座っているプレイヤーのみ操作できます'); return; }

      // メタとテーブルを取得
      const mRef = ref(db, `rooms/${code}/meta`);
      const tRef = ref(db, `rooms/${code}/tables`);
      const [mSnap, tSnap] = await Promise.all([ get(mRef), get(tRef) ]);
      const meta = mSnap.val() || {};
      const tbls = tSnap.val() || [];
      const A = Array.isArray(meta.m43_A) ? meta.m43_A.slice() : [];

      // A群から1枚取り出し（先頭＝一番上）
      if (A.length > 0 && tbls[myTable]) {
        const n = A.shift(); // number
        const T = tbls[myTable];
        const hand = Array.isArray(T.hand) ? T.hand : [];
        hand.push({
          id: crypto.randomUUID(),
          num: n,
          kind: 'normal',
          open: false,
          ownerId: T.playerId || null,
          tokens: [],
          markUntil: Date.now() + 5000   // ← 5秒間「▼」表示
        });
        hand.sort((a,b)=> a.num - b.num);
        const alpha = 'abcdefghijklmnopqrstuvwxyz';
        hand.forEach((c,i)=> c.alpha = alpha[i % alpha.length]);
        T.hand = hand;

        // DB へ反映（テーブル更新＋A群を更新）
        await Promise.all([
          set(ref(db, `rooms/${code}/tables`), tbls),
          update(mRef, { m43_A: A })
        ]);
      }

      // 既存の「段階を下げる」もそのまま実行
      const cur = (state.watching?.meta?.m43_nano|0);
      const next = Math.max(0, cur - 1);
      await update(mRef, { m43_nano: next, m43_updatedAt: Date.now() });
      }
      }
    ]);
  };

  // 位置は checklist のセル中央に合わせて「nanoRow」内で left を決める
  const cells = tablesEl.querySelectorAll('.checklist .check-item');
  const target = cells[pos-1];
  if (!target){ if (node.isConnected) node.remove(); row.remove(); return; }
  const rb = target.getBoundingClientRect();
  const rrow = row.getBoundingClientRect();
  const x = rb.left - rrow.left + (rb.width/2) - 28; // 56px の半分
  node.style.left = `${Math.max(0, x)}px`;
  node.style.top  = `0px`;
  if (!node.isConnected) row.appendChild(node);
}

/* ==== ミッション59：各 checklistbox の直上に12数値カード（固定ランダム）
   ＋ nano（カード上半分に重ねる：セル内相対配置版） ==== */
async function renderM59(v){
  const isM59 = ((v?.mission?.id|0) === 59);
  if (!isM59){
    document.querySelectorAll('.m59-row').forEach(n => n.remove());
    document.getElementById('m59Nano')?.remove();
    return;
  }

  // 対象行（checklistbox が無ければ .checklist をフォールバック）
  const boxes   = Array.from(tablesEl.querySelectorAll('.checklistbox'));
  const targets = boxes.length ? boxes : Array.from(tablesEl.querySelectorAll('.checklist'));
  if (!targets.length) return;

  // ゲームごと固定の12枚（初回はホストが保存）
  let nums = v?.meta?.m59Nums;
  if (!Array.isArray(nums) || nums.length !== 12){
    nums = MATERIALS.numbers.slice();
    shuffle(nums);
    if (state.isHost){
      await update(ref(db, `rooms/${state.roomCode}/meta`), { m59Nums: nums });
    }
  }

  // 既存レーンを掃除
  document.querySelectorAll('.m59-row').forEach(n => n.remove());

  // 各 checklistbox の直前に12枚レーンを新設
  targets.forEach((boxEl, rowIdx) => {
    const lane = document.createElement('div');
    lane.className = 'm59-row';
    lane.style.display = 'grid';
    lane.style.gridTemplateColumns = 'repeat(12, 1fr)';
    lane.style.columnGap = '2px';
    lane.style.width = '100%';
    // チェックリストの左マージンに合わせてずらす（横幅見た目一致）
    lane.style.margin = '0 0 6px 10px';
    lane.style.overflow = 'visible';

    nums.forEach((n, idx) => {
      const cell = document.createElement('div');
      cell.className = 'm59-cell';
      cell.style.position = 'relative';
      cell.style.display  = 'grid';
      cell.style.placeItems = 'center';

      const card = document.createElement('div');
      card.className = 'numcard m59num';
      card.style.width  = '30px'; // #59 は少し小さく
      card.style.height = '46px';
      card.style.backgroundImage = `url('${imgNumber(n)}')`;
      card.title = String(n);

      card.onclick = async () => {
        await update(ref(db, `rooms/${state.roomCode}/meta`), {
          m59_row: rowIdx,        // 0-based
          m59_pos: (idx + 1),     // 1..12
          m59_updatedAt: Date.now()
        });
      };

      cell.appendChild(card);
      lane.appendChild(cell);
    });

    boxEl.parentNode.insertBefore(lane, boxEl); // 真上に差し込む
  });

  // === nano を描画（セル内相対配置） ===
  const rowIndex = (v?.meta?.m59_row ?? 0) | 0;
  const posIndex = (v?.meta?.m59_pos | 0);  // 1..12
  const goLeft   = !!(v?.meta?.m59_left);

  const lanes = Array.from(tablesEl.querySelectorAll('.m59-row'));
  if (!posIndex || !lanes[rowIndex]){ document.getElementById('m59Nano')?.remove(); return; }

  const targetCell = lanes[rowIndex].children[posIndex - 1];
  if (!targetCell){ document.getElementById('m59Nano')?.remove(); return; }

  // 既存を確実に一掃（常に1つだけ）
  document.getElementById('m59Nano')?.remove();

  const node = document.createElement('div');
  node.id = 'm59Nano';
  node.className = 'm43-nano'; // 56x56 既存CSSを流用
  node.style.backgroundImage = `url("${goLeft ? './nano0left.png' : './nano0.png'}")`;

  // ★ここが「上半分重ね」：セル内基準で上辺に中心を合わせる
  node.style.left   = '50%';
  node.style.top    = '-10px';
  node.style.transform = 'translate(-50%, -50%)';
  node.style.pointerEvents = 'auto';

  // クリックで向きトグル
  node.onclick = (ev)=>{
    openMenu(ev.clientX, ev.clientY, [
      { label: (goLeft ? '右向きにする' : '左向きにする'),
        action: async ()=>{
          await update(ref(db, `rooms/${state.roomCode}/meta`), {
            m59_left: !goLeft,
            m59_updatedAt: Date.now()
          });
        }
      }
    ]);
  };

  targetCell.appendChild(node);
}

  
// ミッション57：二重描画/二重保存対策込みで全面書き直し
async function renderM57(v){
  const isM57 = ((v?.mission?.id|0) === 57);
  
  if (!isM57){
    // #57から離れた瞬間に確実に片付ける（ホットリロード/一時的な未呼出対策）
    document.getElementById('m57Grid')?.remove();
    document.getElementById('m57Sel')?.remove();
    document.getElementById('conZoomOverlay')?.remove();
    return;
  }
  // 再入防止（同フレーム二重実行を遮断）
  if (state._m57Rendering) return;
  state._m57Rendering = true;

  try {
    // 既存ノードを必ず1個化
    document.getElementById('m57Grid')?.remove();
    document.querySelectorAll('.m57-grid').forEach(n=>n.remove()); // 互換用

    const itemsBar = document.getElementById('itemsBar');
    if (!itemsBar) return;

    // letters は初回のみホストが保存して全員で再利用
    let letters = v?.meta?.m57Letters;
    if (!letters) {
      letters = shuffle("abcdefghijkl".split(''));
      if (state.isHost) {
        await update(ref(db, `rooms/${state.roomCode}/meta`), { m57Letters: letters });
      }
    }
 // ▼ 全体公開中の通常コードを数字別に集計し、4枚そろった数字を抽出
 const openCountByNum = {};
 (v.tables || []).forEach(T => {
   (T.hand || []).forEach(c => {
     if (c?.kind === 'normal' && c.open === true) {
       const n = c.num | 0; // 1..12
       openCountByNum[n] = (openCountByNum[n] || 0) + 1;
     }
   });
 });
 const hideNums = new Set(
   Object.entries(openCountByNum)
     .filter(([, cnt]) => (cnt | 0) >= 4)
     .map(([n]) => Number(n))
 );
    // グリッド生成
    const grid = document.createElement('div');
    grid.id = 'm57Grid';
    grid.className = 'm57-grid';
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = 'repeat(4, auto)';
    grid.style.gap = '6px';
    grid.style.marginTop = '6px';

    for (let i = 1; i <= 12; i++) {
        if (hideNums.has(i)) continue;
      const wrap = document.createElement('div');
      wrap.style.position = 'relative';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.marginRight = '-6px'; // 少し重ねる

      // 数値カード
      const num = document.createElement('div');
      num.className = 'numcard';
      num.style.backgroundImage = `url('${imgNumber(i)}')`;

      // 制約カード
      const con = document.createElement('div');
      con.className = 'concard';
      con.style.marginLeft = '-6px'; // 重なり
      con.style.backgroundImage = `url('${imgConstraint(letters[i-1])}')`;

      // 拡大（選ぶ付き）
      con.onclick = () => {
        // 既存の拡大を消してから出す（多重ポップ防止）
        document.getElementById('conZoomOverlay')?.remove();

        const overlay = document.createElement('div');
        overlay.id = 'conZoomOverlay';
        overlay.innerHTML = `
          <div class="conzoom-wrap">
            <div class="conzoom-card" style="background-image:url('${imgConstraint(letters[i-1])}')"></div>
            <div class="conzoom-menu"><button id="m57ChooseBtn">選ぶ</button></div>
          </div>`;
        overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
        document.body.appendChild(overlay);

        document.getElementById('m57ChooseBtn').onclick = async () => {
          await update(ref(db, `rooms/${state.roomCode}/meta`), { m57Chosen: letters[i-1] });
          overlay.remove();
        };
      };

      wrap.appendChild(num);
      wrap.appendChild(con);
      grid.appendChild(wrap);
    }

    itemsBar.insertAdjacentElement('afterend', grid);

    // di 左側に選択中カードを同期表示（クリックで拡大のみ・ポップなし）
    const di = document.getElementById('di');
    if (di) {
      document.getElementById('m57Sel')?.remove();
      const sel = v?.meta?.m57Chosen;
      if (sel) {
        const img = document.createElement('div');
        img.id = 'm57Sel';
        img.className = 'concard';
        img.style.backgroundImage = `url('${imgConstraint(sel)}')`;
        img.style.marginRight = '6px';
        img.onclick = () => {
          document.getElementById('conZoomOverlay')?.remove();
          const overlay = document.createElement('div');
          overlay.id = 'conZoomOverlay';
          overlay.innerHTML = `
            <div class="conzoom-wrap">
              <div class="conzoom-card" style="background-image:url('${imgConstraint(sel)}')"></div>
            </div>`;
          overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
          document.body.appendChild(overlay);
        };
        di.insertAdjacentElement('beforebegin', img);
      }
    }
  } finally {
    state._m57Rendering = false;
  }
}

/* ここから追加：ミッション61（制約A~E配布＆交換/B=F~G、隊長の↑↓回し） */
async function ensureM61MetaInit(vNow){
  const v = vNow || state.watching; if(!v) return;
  if ((v?.mission?.id|0) !== 61) return;
  const n = (v?.tables?.length|0); if (n<=0) return;
  // 既に配り済みなら何もしない
  if (Array.isArray(v?.meta?.m61_byTable) && v.meta.m61_byTable.length === n) return;
  if (!state.isHost) return;
  // デッキA = A..E をシャッフルして人数分に配る（人数が5超なら循環）
  const A = ['A','B','C','D','E']; shuffle(A);
  const by = Array.from({length:n}, (_,i)=> A[i % A.length]);
  await update(ref(db, `rooms/${state.roomCode}/meta`), { m61_byTable: by, m61_rotAt: Date.now() });
}

/* ここから追加：ミッション63（隊長のみ初期配布／リザーブはアイテム下／譲渡＆回収） */

// 初期メタの用意（ホストのみ）
async function ensureM63MetaInit(vNow){
  const v = vNow || state.watching; if (!v) return;
  if ((v?.mission?.id|0) !== 63) return;
  const n = (v?.tables?.length|0); if (n <= 0) return;
  if (v?.meta?.m63_init === true) return;
  if (!state.isHost) return;

  // 人数 → 初期配布数（隊長のみ）
  const per = (m)=>{
    if (m===2) return 14;
    if (m===3) return 18;
    if (m===4) return 24;
    return 30; // 5 or 6
  };

  const cap = Math.max(0, v?.captainTable|0);
  const by = {};
  for (let i=0;i<n;i++) by[i] = (i===cap ? per(n) : 0);

  await update(ref(db, `rooms/${state.roomCode}/meta`), {
    oxItem: 0,
    oxByTable: by,
    m63_init: true
  });
}

// 描画・操作
function renderM63(v){
  const isM63 = ((v?.mission?.id|0) === 63);
  // 片付け
  if (!isM63){
    document.getElementById('m63Reserve')?.remove();
    document.querySelectorAll('.table').forEach(tb=> tb.style.removeProperty('--table-h'));
    return;
  }

  // 初回メタ
  if (v?.meta?.m63_init !== true){ ensureM63MetaInit(v); return; }

  // ===== リザーブ（アイテム列の直下） =====
  const itemsBar = document.getElementById('itemsBar');
  if (!itemsBar) return;

  let poolRow = document.getElementById('m63Reserve');
  if (!poolRow){
    poolRow = document.createElement('div');
    poolRow.id = 'm63Reserve';
    poolRow.className = 'ox-row';               // ox-pool は付けない（ox2画像は使わない）
    // 中身（折返し10列）
    const wrap = document.createElement('div');
    wrap.className = 'ox-wrap';
    poolRow.appendChild(wrap);
    itemsBar.insertAdjacentElement('afterend', poolRow);
  }

  const wrap = poolRow.querySelector('.ox-wrap');
  wrap.innerHTML = '';
  const poolCnt = Math.max(0, v?.meta?.oxItem|0);
  for (let i=0;i<poolCnt;i++){
    const t = document.createElement('div');
    t.className = 'token ox';
    wrap.appendChild(t);
  }

  // 小さな "+N" フラッシュ（2秒）
  const flashPlus = (n)=>{
    if (!poolRow) return;
    const old = document.getElementById('m63Plus');
    if (old) old.remove();
    const plus = document.createElement('div');
    plus.id = 'm63Plus';
    plus.textContent = `+${n}`;
    plus.style.marginLeft = '6px';
    plus.style.fontWeight = '700';
    plus.style.opacity = '0.85';
    poolRow.appendChild(plus);
    setTimeout(()=> plus.remove(), 2000);
  };

  // リザーブ：隊長のみ「回収」ポップ
  const myIdx = (v?.tables||[]).findIndex(T => T.playerId === state.userId);
  const capIdx = (v?.captainTable|0);
  if (myIdx === capIdx && poolCnt > 0){
    poolRow.onclick = (ev)=>{
      openOneMini(ev.clientX, ev.clientY, '回収', async ()=>{
        const mRef = ref(db, `rooms/${state.roomCode}/meta`);
        const snap = await get(mRef);
        const meta = snap.val()||{};
        const pool = Math.max(0, meta?.oxItem|0);
        if (pool <= 0) return;
        const curCap = Math.max(0, meta?.oxByTable?.[capIdx]||0);
        const upd = {};
        upd['oxItem'] = 0;
        upd[`oxByTable/${capIdx}`] = curCap + pool;
        await update(mRef, upd);
      });
    };
  }else{
    poolRow.onclick = null;
  }

  // ===== 各テーブルに所持酸素を表示（#44と同じ位置に出す） =====
  const tableNodes = document.querySelectorAll('.table'); // renderTables と同順
  const n = (v?.tables?.length|0);

  (v.tables||[]).forEach((T, ti)=>{
    const box = tableNodes[ti]; if (!box) return;

    // 既存の行を再利用 or 生成（#44流用）
    let row = box.querySelector('.ox-row[data-owner="1"][data-m63="1"]');
    if (!row){
      row = document.createElement('div');
      row.className = 'ox-row';
      row.dataset.owner = '1';
      row.dataset.m63 = '1';
      // #44 と同じアンカー（アルファベット直下） :contentReference[oaicite:4]{index=4}
      const anchor = box.querySelector('.badge-fixed');
      if (anchor){
        anchor.insertAdjacentElement('afterend', row);
        const ah = anchor.querySelector('.alpha')?.getBoundingClientRect().height || 18;
        row.style.marginTop = `${Math.round(ah * 5)}px`;
      }else{
        (box.querySelector('.hand') || box).appendChild(row);
      }
    }

 // 再描画（必ず .ox-wrap を挟む）
 row.innerHTML = '';
 let w = document.createElement('div');
 w.className = 'ox-wrap';
 row.appendChild(w);
 const cnt = Math.max(0, v?.meta?.oxByTable?.[ti]||0);
 for (let i=0;i<cnt;i++){
   const t = document.createElement('div');
   t.className = 'token ox';
   w.appendChild(t);                // ← .ox-wrap 内に追加
 }

    // テーブル高さを所持数に応じて拡張（15個ごとに1行追加）
    const baseH = 96;       // 標準の高さ
    const perRow = 15;      // 1行あたりのトークン数
    const rowH = 24;        // 1行の高さ（20px + gap余白を考慮）
    const rows = Math.ceil(cnt / perRow);
    const extra = rows > 0 ? (4 + rowH * rows) : 0;
    box.style.setProperty('--table-h', `${baseH + extra}px`);
    // 自分の所持酸素クリック → 1..12 をリザーブへ返却（+Nフラッシュ）
    if (Number.isInteger(myIdx) && myIdx === ti){
      row.onclick = (ev)=>{
        const mine = Math.max(0, v?.meta?.oxByTable?.[ti]||0);
        if (mine <= 0) return;
        const maxK = Math.min(12, mine);
        const entries = Array.from({length:maxK}, (_,i)=> i+1).map(k=>({
          label:String(k),
          action: async ()=>{
            const mRef = ref(db, `rooms/${state.roomCode}/meta`);
            const snap = await get(mRef);
            const meta = snap.val()||{};
            const curMine = Math.max(0, meta?.oxByTable?.[ti]||0);
            const curPool = Math.max(0, meta?.oxItem|0);
            if (k > curMine) return;
            const upd = {};
            upd[`oxByTable/${ti}`] = curMine - k;
            upd['oxItem'] = curPool + k;
            await update(mRef, upd);
            flashPlus(k);
          }
        }));
　　    entries.push({ label: `/ ${mine}` });
        openMenu(ev.clientX, ev.clientY, entries);
      };
    }else{
      row.onclick = null;
    }

    // 他プレイヤーの「テーブル全体」に渡す判定を付与（ターゲット側のboxで出す）
    if (Number.isInteger(myIdx) && myIdx !== ti && !box.dataset.m63Bind){
      box.dataset.m63Bind = '1';
      box.addEventListener('click', (ev)=>{
        const mineNow = Math.max(0, v?.meta?.oxByTable?.[myIdx]||0);
        if (mineNow <= 0) return;
        openOneMini(ev.clientX, ev.clientY, '渡す', async ()=>{
          const mRef = ref(db, `rooms/${state.roomCode}/meta`);
          const snap = await get(mRef);
          const meta = snap.val()||{};
          const curMine   = Math.max(0, meta?.oxByTable?.[myIdx]||0);
          if (curMine <= 0) return;
          const curTarget = Math.max(0, meta?.oxByTable?.[ti]||0);
          const upd = {};
          upd[`oxByTable/${myIdx}`] = 0;
          upd[`oxByTable/${ti}`]    = curTarget + curMine;
          await update(mRef, upd);
        });
      });
    }
  });
}
/* ここまで追加：ミッション63 */

  
/* ここから追加：#62 人数分の数値カード（同期） */
async function ensureM62MetaInit(vNow){
  const v = vNow || state.watching; if (!v) return;
  if ((v?.mission?.id|0) !== 62) return;
  const need = (v?.tables?.length|0); if (need <= 0) return;

  // 既に人数分そろっていれば何もしない（不足/過多なら作り直し）
  const cur = Array.isArray(v?.meta?.m62_nums) ? v.meta.m62_nums : null;
  if (Array.isArray(cur) && cur.length === need) return;
  if (!state.isHost) return;

  // 場に未使用の数字から人数分を抽選（重複回避ユーティリティ）
  const picks = (typeof pickUnusedNumbers === 'function')
    ? pickUnusedNumbers(need)
    : MATERIALS.numbers.slice().sort(()=>Math.random()-0.5).slice(0, need);

  await update(ref(db, `rooms/${state.roomCode}/meta`), { m62_nums: picks });
}

function renderM62(v){
  const isM62 = ((v?.mission?.id|0) === 62);
  const rowId = 'm62Row';
  const old   = document.getElementById(rowId);
  if (!isM62){ if (old) old.remove(); return; }

  const need = (v?.tables?.length|0);
  const nums = Array.isArray(v?.meta?.m62_nums) ? v.meta.m62_nums : null;
  if (!nums || nums.length !== need){ ensureM62MetaInit(v); if (old) old.remove(); return; }

  if (old) old.remove();
  const lane = document.createElement('div');
  lane.id = rowId;
  lane.className = 'numlane';

  // placeNumberCard は既存の同じ数字の表示を一ヵ所に集約（重複防止＆移動）してくれます
  nums.forEach(n => {
    if (typeof placeNumberCard === 'function'){
      placeNumberCard(n, lane);
    }else{
      const nc = document.createElement('div');
      nc.className = 'numcard';
      nc.style.backgroundImage = `url('${imgNumber(n)}')`;
      lane.appendChild(nc);
    }
  });

  // アイテム列の直下に設置（既存ユーティリティ）
  mountLaneUnderItemsBar(lane);
}


  /* ===== ここから追加：#66 ステージ＆制約（十字） ===== */

/** 初回メタ生成（ホストのみ） */
async function ensureM66MetaInit(vNow){
  const v = vNow || state.watching; if (!v) return;
  if ((v?.mission?.id|0) !== 66) return;
  if (Array.isArray(v?.meta?.m66_slots)) return;   // 既に用意済み
  if (!state.isHost) return;

  // A~E をシャッフル → 固定5スロットに配置
  const deck = ['A','B','C','D','E'];
  shuffle(deck);
  const slots = [deck[0], deck[1], deck[2], deck[3], deck[4]]; // [byDi, top(x), bottom, left, right]

  await update(ref(db, `rooms/${state.roomCode}/meta`), {
    m66_slots: slots,
    m66_face : 1,     // 1階（1stage.jpg）
    m66_rabit: null   // まだ表示なし
  });
}

/** 描画・操作 */
function renderM66(v){
  const isM66 = ((v?.mission?.id|0) === 66);
  const oldLayer = document.getElementById('m66Layer');
  const oldByDi  = document.getElementById('m66ConByDi');

  if (!isM66){
    if (oldLayer) oldLayer.remove();
    if (oldByDi)  oldByDi.remove();
    if (document.getElementById('conZoomOverlay')) closeConstraintZoom();
    return;
  }

  // 初期メタ未用意ならホストが用意（次tickで描画）
  if (!Array.isArray(v?.meta?.m66_slots)){ ensureM66MetaInit(v); if (oldLayer) oldLayer.remove(); if (oldByDi) oldByDi.remove(); return; }

  const slots = v.meta.m66_slots.slice(); // [byDi, top, bottom, left, right]

  // ── di画像の左：制約1枚（byDi）
  const di = document.getElementById('di');
  if (di){
    let byDi = document.getElementById('m66ConByDi');
    if (!byDi){
      byDi = document.createElement('div');
      byDi.id = 'm66ConByDi';
      byDi.className = 'concard';
      // diの左に差し込み（itemsBar内）
      di.insertAdjacentElement('beforebegin', byDi);
      // ドラッグ＆ドロップ入替
      bindM66Drag(byDi, 'bydi');
      byDi.title = '拡大';
      byDi.addEventListener('click', (ev)=>{ 
        ev.stopPropagation();
        const cur = Array.isArray(state?.watching?.meta?.m66_slots) ? state.watching.meta.m66_slots : slots;
        openConstraintZoomView(cur[0]);
      });
    }
    // 表示は今回の描画スナップショットでOK
    byDi.style.backgroundImage = `url('${imgConstraint(slots[0])}')`;
  }


  // ── アイテム列の直下：十字レイアウト（top / left stage right / bottom）
  let layer = document.getElementById('m66Layer');
  if (!layer){
    layer = document.createElement('div');
    layer.id = 'm66Layer';
    layer.className = 'm66-layer';

    // 上（x）
    const lineTop = document.createElement('div'); lineTop.className = 'm66-line';
    lineTop.appendChild(mkSlot('top'));
    layer.appendChild(lineTop);

    // 中（左・ステージ・右）
    const lineMid = document.createElement('div'); lineMid.className = 'm66-line';
    lineMid.appendChild(mkSlot('left'));
    lineMid.appendChild(mkStageBox());
    lineMid.appendChild(mkSlot('right'));
    layer.appendChild(lineMid);

    // 下
    const lineBot = document.createElement('div'); lineBot.className = 'm66-line';
    lineBot.appendChild(mkSlot('bottom'));
    layer.appendChild(lineBot);

    // 既存ヘルパで itemsBar の直下に設置
    mountLaneUnderItemsBar(layer);
  }

  // 再描画
  refreshM66(layer, slots, v);

  /* ===== 内部ヘルパ ===== */

  function mkSlot(name){
    const slot = document.createElement('div'); slot.className = 'm66-slot';
    const cc = document.createElement('div'); cc.className = 'concard'; cc.draggable = true;

    // 拡大（常に最新metaから参照）
    cc.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      const map = { bydi:0, top:1, bottom:2, left:3, right:4 };
      const idx = map[name];
      const cur = Array.isArray(state?.watching?.meta?.m66_slots) ? state.watching.meta.m66_slots : slots;
      const letter = cur?.[idx];
      if (letter) openConstraintZoomView(letter);
    });

    bindM66Drag(cc, name);
    slot.appendChild(cc);
    return slot;
  }

  // （getLetterBy は不要になったら削除OK）


  function mkStageBox(){
    const box = document.createElement('div');
    box.className = 'm66-stagebox';
    const stage = document.createElement('div');
    stage.className = 'm66-stage';
    box.appendChild(stage);

    // 右上ホットスポット（階切替）
    const hot = document.createElement('div');
    hot.className = 'm66-hot';
    hot.title = '階を切替';
    hot.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      const cur = (v?.meta?.m66_face|0)===2 ? 2 : 1;
      const to2 = (cur===1);
      openOneMini(ev.clientX, ev.clientY, to2 ? '2階へ' : '1階へ', async ()=>{
        await update(ref(db, `rooms/${state.roomCode}/meta`), { m66_face: to2 ? 2 : 1 });
      });
    });
    box.appendChild(hot);

    // ステージクリック：ラビットをその座標に移動（1匹だけ）
    box.addEventListener('click', async (ev)=>{
      const r = box.getBoundingClientRect();
      const nx = (ev.clientX - r.left) / r.width;
      const ny = (ev.clientY - r.top) / r.height;
      await update(ref(db, `rooms/${state.roomCode}/meta`), { m66_rabit: { x:nx, y:ny } });
    });

    return box;
  }



 function refreshM66(layer, slots, v){
    const ccTop = layer.querySelector('.m66-line:nth-child(1) .concard');
    const mid   = layer.querySelector('.m66-line:nth-child(2)');
    const ccLeft  = mid?.querySelector('.m66-slot:nth-child(1) .concard');
    const ccRight = mid?.querySelector('.m66-slot:nth-child(3) .concard');
    const ccBot = layer.querySelector('.m66-line:nth-child(3) .concard');

    if (ccTop){   ccTop.style.backgroundImage   = `url('${imgConstraint(slots[1])}')`; ccTop.dataset.letter = slots[1]; }
    if (ccLeft){  ccLeft.style.backgroundImage  = `url('${imgConstraint(slots[3])}')`; ccLeft.dataset.letter = slots[3]; }
    if (ccRight){ ccRight.style.backgroundImage = `url('${imgConstraint(slots[4])}')`; ccRight.dataset.letter = slots[4]; }
    if (ccBot){   ccBot.style.backgroundImage   = `url('${imgConstraint(slots[2])}')`; ccBot.dataset.letter = slots[2]; }
    // ステージ面（1=表 2=裏）
    const stage = layer.querySelector('.m66-stage');
    const face  = (v?.meta?.m66_face|0)===2 ? './2stage.jpg' : './1stage.jpg';
    if (stage) stage.style.backgroundImage = `url('${face}')`;

    // ラビットの座標反映
    const box = layer.querySelector('.m66-stagebox');
    if (box){
      let rab = box.querySelector('.m66-rabit');
      const pos = v?.meta?.m66_rabit;
      if (pos && Number.isFinite(pos.x) && Number.isFinite(pos.y)){
        if (!rab){ rab = document.createElement('div'); rab.className='m66-rabit'; box.appendChild(rab); }
        rab.style.left = (pos.x * 100) + '%';
        rab.style.top  = (pos.y * 100) + '%';
      }else{
        if (rab) rab.remove();
      }
    }
  }

  // D&D 交換（同一固定スロット間で中身を入替）
  function bindM66Drag(node, name){
    const map = { bydi:0, top:1, bottom:2, left:3, right:4 };
    node.setAttribute('draggable','true');

    node.addEventListener('dragstart',(e)=>{
      e.dataTransfer.setData('text/plain', name);
    });
    node.addEventListener('dragover',(e)=>{ e.preventDefault(); });
    node.addEventListener('drop', async (e)=>{
      e.preventDefault();
      const src = e.dataTransfer.getData('text/plain');
      const dst = name;
      if (!src || !dst || src===dst) return;
      try{
        const mRef = ref(db, `rooms/${state.roomCode}/meta`);
        const snap = await get(mRef);
        const meta = snap.val()||{};
        const cur  = Array.isArray(meta?.m66_slots) ? meta.m66_slots.slice() : slots.slice();
        const si = map[src], di = map[dst];
        if (si==null || di==null) return;
        const tmp = cur[si]; cur[si]=cur[di]; cur[di]=tmp;
        await update(mRef, { m66_slots: cur });
      }catch(err){ console.error(err); }
    });
  }
}
/* ===== ここまで追加：#66 ===== */

  
  
/* ここまで追加：#62 */
// ===== M65 初期配布：隊長テーブルから全テーブルへラウンドロビン配布 =====
async function ensureM65MetaInit(vNow){
  const v = vNow || state.watching; if (!v) return;
  if ((v?.mission?.id|0) !== 65) return;
  const N = (v?.tables?.length|0); if (N <= 0) return;
  if (Array.isArray(v?.meta?.m65_byTable)) return;   // 既に初期化済み
  if (!state.isHost) return;                         // 初期化はホストのみ

  const cap = Math.max(0, v?.captainTable|0);

  // 配布順：隊長テーブル → 右回りで「全テーブル」（未着席も含む）
  const order = [];
  for (let off=0; off<N; off++){
    order.push((cap + off) % N);
  }

  // 1..12 をシャッフルして、order にラウンドロビン配布
  const deck = MATERIALS.numbers.slice(); // 想定: [1..12]
  shuffle(deck);

  const by = Array.from({length:N}, ()=> []);
  for (let k=0; k<deck.length; k++){
    const owner = order[k % order.length];
    by[owner].push(deck[k]);
  }

  await update(ref(db, `rooms/${state.roomCode}/meta`), { m65_byTable: by });
}
// ===== /M65 =====

function renderM65(v){
  const isM65 = ((v?.mission?.id|0) === 65);
  const rowId = 'm65Row';
  const old   = document.getElementById(rowId);
  if (!isM65){ if (old) old.remove(); return; }

  // 初期配布（未生成ならホストが一度だけ）
  if (!Array.isArray(v?.meta?.m65_byTable)){ ensureM65MetaInit(v); if (old) old.remove(); return; }

  // 自分が未着席なら表示しない
  const tables = v.tables || [];
  const myIdx  = tables.findIndex(T => T?.playerId === state.userId);
  if (myIdx < 0){ if (old) old.remove(); return; }

  // 自分の持ち札（数値カード）を取得・昇順表示
  const mine = Array.isArray(v.meta.m65_byTable?.[myIdx]) ? v.meta.m65_byTable[myIdx].slice() : [];
  mine.sort((a,b)=>a-b);

  // 全体公開の通常コード枚数を集計（各テーブル hand の open==true, kind:'normal'）→ 4枚以上で裏面
  const openCountByNum = {};
  (tables||[]).forEach(T=>{
    (T.hand||[]).forEach(c=>{
      if (c?.kind==='normal' && c.open===true){
        const n = c.num|0;
        openCountByNum[n] = (openCountByNum[n]||0) + 1;
      }
    });
  });

  const footer = document.getElementById('missionFooter');
  if (!footer){ if (old) old.remove(); return; }
  let row = old;
  if (!row){
    row = document.createElement('div');
    row.id = rowId;
    row.className = 'numlane';
    footer.appendChild(row);
  }
  row.innerHTML = '';

  // 次の着席者を求める
  const findNextSeated = (fromIdx)=>{
    if (tables.length===0) return -1;
    for (let off=1; off<=tables.length; off++){
      const i = (fromIdx + off) % tables.length;
      if (tables[i]?.playerId) return i;
    }
    const any = tables.findIndex(T => T?.playerId);
    return any >= 0 ? any : 0;
  };
  const nextIdx = findNextSeated(myIdx);
  const nextName = tables[nextIdx]?.playerName || `#${(nextIdx|0)+1}`;

  // カードDOM生成（裏面条件: その数が4枚以上 全体公開）
  mine.forEach(n=>{
    const holder = document.createElement('div');
    holder.className = 'numcard-holder';
    const nc = document.createElement('div');
    nc.className = 'numcard';
    const needBack = (openCountByNum[n]|0) >= 4;
    if (needBack){
      nc.classList.add('back'); // 裏面表示（クリック可）
      nc.style.backgroundImage = `url('${imgBack}')`; // ★ 数値カード専用の裏面
    }else{
      nc.style.backgroundImage = `url('${imgNumber(n)}')`;
    }
    nc.title = `#${n}`;

    nc.onclick = async (ev)=>{
      openMenu(ev.clientX, ev.clientY, [
        { label:`${nextName} に ${n} を渡す`, action: async ()=>{
          try{
            // 最新メタを取得して自分→次席へ1枚移動
            const mRef = ref(db, `rooms/${state.roomCode}/meta`);
            const snap = await get(mRef);
            const meta = snap.val() || {};
            const by   = Array.isArray(meta.m65_byTable) ? meta.m65_byTable.slice() : [];
            const myArr   = Array.isArray(by[myIdx]) ? by[myIdx].slice() : [];
            const nextArr = Array.isArray(by[nextIdx]) ? by[nextIdx].slice() : [];
            const pos = myArr.indexOf(n);
            if (pos >= 0){
              myArr.splice(pos,1);
              nextArr.push(n);
              by[myIdx]  = myArr;
              by[nextIdx]= nextArr;
              await update(mRef, { m65_byTable: by });
            }
          }catch(e){ console.error(e); }
        }}]);
    };
    holder.appendChild(nc);
    row.appendChild(holder);
  });
}
/* ===== /#65 ===== */

  
function renderM61(v){
  const isM61 = ((v?.mission?.id|0) === 61);
  // 片付け（#61以外になったら痕跡を消す）
  if (!isM61){
    document.querySelectorAll('.m61-con, .m61-stack').forEach(n=>n.remove());
    if (document.getElementById('conZoomOverlay')) closeConstraintZoom();
    return;
  }
  // 初期配布
  if (!Array.isArray(v?.meta?.m61_byTable)) { ensureM61MetaInit(v); return; }

  const by = v.meta.m61_byTable.slice();
  const myIdx = (v.tables||[]).findIndex(T => T.playerId === state.userId);

  // 各テーブルのキャラカード「左」に、キャラカードと同サイズで表示
  const tableEls = Array.from(document.querySelectorAll('#tables .table'));
  tableEls.forEach((tbEl, ti)=>{
    // 既存ノードを掃除して1個化
    tbEl.querySelectorAll('.m61-con, .m61-stack').forEach(n=>n.remove());
    const content = tbEl.querySelector('.t-content');
    const charCol = tbEl.querySelector('.char-col');
    if (!content || !charCol) return;
    const ch = by[ti];
    if (!ch) return;

    // ▼ M61 専用スタック（制約の下に極小キャラ）
    const stack = document.createElement('div');
    stack.className = 'm61-stack';
    // 制約カード
    const con = document.createElement('div');
    con.className = 'concard m61-con';
    con.style.width  = 'var(--char-w)';
   con.style.height = 'var(--char-h)';
    con.style.backgroundImage = `url('${imgConstraint(ch)}')`;
    // ミニキャラ
    const mini = document.createElement('div');
   mini.className = 'm61-mini';
    const t = (v.tables||[])[ti] || {};
    const seatEmpty = !t.playerId;
    const amSeatedHere = (t.playerId && t.playerId === state.userId);
    if (seatEmpty){
      mini.classList.add('blank');
      mini.onclick = null;
    }else{
      const face = t.character?.flipped ? './battery.jpg' : `./${t.character?.face || 'member (1).jpg'}`;
      mini.style.backgroundImage = `url("${face}")`;
     // 既存の大キャラ同様、本人のみ裏表トグル
      mini.onclick = amSeatedHere ? (async ()=> {
        await update(ref(db, `rooms/${state.roomCode}/tables/${ti}/character`), { flipped: !t.character?.flipped });
      }) : null;
      if (!amSeatedHere) mini.style.cursor = 'default';
   }
    stack.appendChild(con);
    stack.appendChild(mini);
    // 旧 .char-col を物理削除して詰める
    content.insertBefore(stack, charCol);
    charCol.remove();
    // 自分のテーブルだけ「拡大→交換」可能
    if (ti === myIdx){
      con.style.cursor = 'pointer';
      con.onclick = ()=> openConstraintZoom61(ch, ti);
   }else{
      // 自分以外：拡大のみ（交換などのポップなし）
      con.style.cursor = 'pointer';
      con.onclick = ()=> openConstraintZoomView(ch);
    }
  });

  // ▼ 隊長の画面下に ↑/↓ ポップ（自分が隊長＝face: member (5).jpg かつ自席）
   // ▼ 隊長の画面下に ↑/↓ ポップ（自分が隊長＝face: member (5).jpg かつ自席）
  const capIdx = (v.tables||[]).findIndex(T => (T?.character?.face||'').includes('member (5).jpg'));
  const zoneId = 'm61TapZone';
  document.getElementById(zoneId)?.remove();
  if (capIdx >= 0 && capIdx === myIdx){
    const zone = document.createElement('div');
    zone.id = zoneId;
    Object.assign(zone.style, {
      position:'fixed', left:'0', right:'0', bottom:'0', height:'56px',
      zIndex:'2147483602', background:'transparent', pointerEvents:'auto'
    });
    const mRef = ref(db, `rooms/${state.roomCode}/meta`);
    const rotate = async (dir)=>{
      try{
        const snap = await get(mRef);
        const meta = snap.val()||{};
        const arr = Array.isArray(meta.m61_byTable) ? meta.m61_byTable.slice() : [];
        if (arr.length===0) return;
        const n = arr.length;
        const next = Array.from({length:n}, (_,i)=> arr[(i - dir + n)%n]);
        await update(mRef, { m61_byTable: next, m61_rotAt: Date.now() });
      }catch(e){ console.error('[M61 rotate]', e); }
    };
    zone.onclick = (ev)=>{
      ev.stopPropagation();
      openBottomMenu([
        { label:'制約カードを↑', action: ()=> rotate(-1) },
        { label:'制約カードを↓', action: ()=> rotate(1) }
      ]);
    };
    document.body.appendChild(zone);
  }

}


  
/* ここから追加：ミッション54（酸素リザーブ＋赤デッキ） */
async function renderM54(v){
  const isM54 = ((v?.mission?.id|0) === 54);
  // 画面要素の片付け
  if (!isM54){
    const x = document.getElementById('m54OxPool'); if (x) x.remove();
    const y = document.getElementById('m54RedBox'); if (y) y.remove();
    return;
  }

  // --- 0) 初期化（ホストのみ・1回） ---
  // ②配布：人数別 {2:9,3:6,4:3,5:2,6:2} を各テーブルに配布
  // ③リザーブ： 30 - (人数×配布数)
  // ⑥赤デッキ：1..11 をシャッフルして m54_redDeck に、使用済みは m54_redUsed
  if (state.isHost && v?.meta?.m54_init !== true){
    const n = (v?.tables?.length|0);
    const per = (n<=2)?9 : (n===3)?6 : (n===4)?3 : 2;
    const by  = {}; for (let i=0;i<n;i++) by[i]=per;
    const pool = Math.max(0, 30 - n*per);

const deck = Array.from({length:11}, (_,i)=> (i+1) + 0.5);
    shuffle(deck);

update(ref(db, `rooms/${state.roomCode}/meta`), {
  m54_init: true,
  m54_byTable: by,
  m54_pool: pool,
  m54_redDeck: deck,
  m54_redUsed: []
}).catch(console.error);

    return; // 次の onValue で描画
  }

  // --- 1) アイテム列の直下に「リザーブ」を出す（左に ox2 画像） ---
  const itemsBar = document.getElementById('itemsBar');
  if (!itemsBar) return;

  let poolRow = document.getElementById('m54OxPool');
  if (!poolRow){
    poolRow = document.createElement('div');
    poolRow.id = 'm54OxPool';
    poolRow.className = 'ox-row ox-pool';   // #44 と同じクラス
    itemsBar.insertAdjacentElement('afterend', poolRow);
  }
  // 左側の ox2 と右側のラップ
  let wrap = poolRow.querySelector('.ox-wrap');
  if (!wrap){
    poolRow.innerHTML = '';
    const side = document.createElement('div');
    side.className = 'ox-side';             // 背景は ox2.jpg（#44 と同じ）
    poolRow.appendChild(side);
    wrap = document.createElement('div');
    wrap.className = 'ox-wrap';
    poolRow.appendChild(wrap);
  }else{
    wrap.innerHTML = '';
  }
  const poolCnt = Math.max(0, v?.meta?.m54_pool|0);
  for (let i=0;i<poolCnt;i++){
    const t = document.createElement('div');
    t.className = 'token ox';
    wrap.appendChild(t);
  }

  // ④ リザーブクリック → 「補給」ポップ（1枚獲得）
  poolRow.onclick = (ev)=>{
    if ((v?.meta?.m54_pool|0) <= 0) return;
    openOneMini(ev.clientX, ev.clientY, '補給', async ()=>{
      const idx = (state?.seatedTable==null)? null : Number(state.seatedTable);
      if (idx==null) return;
      const mine = (v?.meta?.m54_byTable?.[idx]|0) + 1;
      const left = (v?.meta?.m54_pool|0) - 1;
      await update(ref(db, `rooms/${state.roomCode}/meta`), {
        m54_pool: left,
        [`m54_byTable/${idx}`]: mine
      });
    });
  };

  // --- 2) 各テーブル下に自分の酸素トークン表示（#44と同じ場所） ---
  const tableNodes = document.querySelectorAll('.table'); // renderTables と同順
  const n = (v?.tables?.length|0);
  (v.tables||[]).forEach((T, ti)=>{
    const box = tableNodes[ti]; if (!box) return;

    let row = box.querySelector('.ox-row[data-owner="1"][data-m54="1"]');
    if (!row){
      row = document.createElement('div');
      row.className = 'ox-row';
      row.dataset.owner = '1';
      row.dataset.m54 = '1';
      const anchor = box.querySelector('.badge-fixed');
      if (anchor){
        anchor.insertAdjacentElement('afterend', row);
        const ah = anchor.querySelector('.alpha')?.getBoundingClientRect().height || 18;
        row.style.marginTop = `${Math.round(ah * 5)}px`;
    }else{
     (box.querySelector('.hand') || box).appendChild(row);
     }
   }
     // 再描画（.ox-wrap を介し 15 個/行で折返し：M49/M63と一致）
   row.innerHTML = '';
   const cnt = Math.max(0, v?.meta?.m54_byTable?.[ti]||0);
    const wrap = document.createElement('div');
    wrap.className = 'ox-wrap';
     row.appendChild(wrap);
     for (let i=0; i<cnt; i++){
      const t = document.createElement('div');
      t.className = 'token ox';
     wrap.appendChild(t);
    }
    // テーブル高さ：所持酸素の行数に合わせて拡張
     const baseH = 96, perRow = 15, rowH = 24;
    const rows  = (cnt>0) ? Math.ceil(cnt / perRow) : 0;
    const extra = rows>0 ? (4 + rowH * rows) : 0;
  const needH = Math.max(baseH, baseH + extra);
   box.style.setProperty('--table-h', `${needH}px`);
    box.style.height = `${needH}px`;  // ← 実高さも直指定
    // ⑤ 自分の行クリック → 1/2/3 を返却（リザーブに戻す）
    //    （#44の返却 UI と同様の挙動）
    const myIdx = (()=>{
      const sNum = (state?.seatedTable==null)? null : Number(state.seatedTable);
      if (Number.isInteger(sNum) && sNum>=0 && sNum<n) return sNum;
      const alt = (v.tables||[]).findIndex(t=> t?.playerId===state.userId);
      return (alt>=0? alt : null);
    })();

    if (myIdx !== null && myIdx === ti){
      row.onclick = (ev)=>{
        const maxCan = Math.max(0, v?.meta?.m54_byTable?.[ti]||0);
        const choices = [1,2,3].filter(k=> k<=maxCan).map(k=>({
          label:String(k),
          action: async ()=>{
            const mine = (v?.meta?.m54_byTable?.[ti]||0) - k;
            const pool = (v?.meta?.m54_pool||0) + k;
            if (mine<0) return;
            await update(ref(db, `rooms/${state.roomCode}/meta`), {
              m54_pool: pool,
              [`m54_byTable/${ti}`]: mine
            });
          }
        }));
        if (choices.length>0) openMenu(ev.clientX, ev.clientY, choices);
      };
    }else{
      row.onclick = null;
    }
  });

  // --- 3) 赤デッキ（diの左側に redcode.png ＋ 残枚数） ---
  const di = document.getElementById('di');
  if (di && !document.getElementById('m54RedBox')){
    const box = document.createElement('div');
    box.id = 'm54RedBox';
    box.style.display = 'flex';
    box.style.flexDirection = 'column';
    box.style.alignItems = 'center';
    // デッキ画像（numdeck見た目を流用しつつ背景だけ差し替え）
    const deckBtn = document.createElement('div');
    deckBtn.className = 'numdeck';
    deckBtn.style.backgroundImage = "url('./redcode.png')";
    deckBtn.title = '赤コード（追加）';
    // 残枚数
    const restLbl = document.createElement('span');
    restLbl.className = 'numrest';
    restLbl.style.marginTop = '2px';

    box.appendChild(deckBtn);
    box.appendChild(restLbl);
    di.insertAdjacentElement('beforebegin', box);

    // 残表示の更新
    const refreshRed = ()=>{
      const D = Array.isArray(v?.meta?.m54_redDeck)? v.meta.m54_redDeck : [];
      const U = Array.isArray(v?.meta?.m54_redUsed)? v.meta.m54_redUsed : [];
      const remain = D.filter(x=> !U.includes(x)).length;
      restLbl.textContent = `残:${remain}`;
    };
    refreshRed();

    // ⑥ クリック → 「追加」タブ → 山札の上から1枚を自分の手札に昇順挿入
    deckBtn.onclick = (ev)=>{
      openOneMini(ev.clientX, ev.clientY, '追加', async ()=>{
        try{
          const mRef = ref(db, `rooms/${state.roomCode}/meta`);
          const rRef = ref(db, `rooms/${state.roomCode}`);
          const [mSnap, rSnap] = await Promise.all([get(mRef), get(rRef)]);
          const meta = mSnap.val()||{};
          const room = rSnap.val()||{};
          const D = Array.isArray(meta.m54_redDeck)? meta.m54_redDeck.slice() : [];
          const U = Array.isArray(meta.m54_redUsed)? meta.m54_redUsed.slice() : [];

          // 次の1枚
          const top = D.find(n=> !U.includes(n));
          if (top==null) return;

          // 自分のテーブル番号
          const myTable = (()=>{
            const sNum = (state?.seatedTable==null)? null : Number(state.seatedTable);
            if (Number.isInteger(sNum)) return sNum;
            const idx = (room.tables||[]).findIndex(t=> t?.playerId===state.userId);
            return idx>=0? idx : null;
          })();
          if (myTable==null || !Array.isArray(room.tables)) return;

          // 手札へ（昇順・alpha再付番） — #43 の追加処理と同じ流儀
          const tbls = room.tables.slice();
          const T = tbls[myTable];
          const hand = Array.isArray(T.hand)? T.hand.slice() : [];
          hand.push({
            id: crypto.randomUUID(),
            num: top,
            kind: 'red',     // ← 種別は red としておく（必要なら 'normal' に変更）
            open: false,
            ownerId: T.playerId || null,
            tokens: [],
            markUntil: Date.now() + 5000
          });
          hand.sort((a,b)=> a.num - b.num);
          const alpha = 'abcdefghijklmnopqrstuvwxyz';
          hand.forEach((c,i)=> c.alpha = alpha[i % alpha.length]);
          T.hand = hand;

          // 使用済みへ記録
          U.push(top);

          await Promise.all([
            set(ref(db, `rooms/${state.roomCode}/tables`), tbls),
            update(mRef, { m54_redUsed: U })
          ]);
        }catch(e){ console.error(e); }
      });
    };
  }else{
    // 既にあれば残表示だけ更新
    const restLbl = document.querySelector('#m54RedBox .numrest');
    if (restLbl){
      const D = Array.isArray(v?.meta?.m54_redDeck)? v.meta.m54_redDeck : [];
      const U = Array.isArray(v?.meta?.m54_redUsed)? v.meta.m54_redUsed : [];
      restLbl.textContent = `残:${D.filter(x=>!U.includes(x)).length}`;
    }
  }
}
/* ここまで追加：ミッション54 */

  
/* ここから追加：ミッション53（nano0 固定） */
function renderM53(v){
  const isM53 = ((v?.mission?.id|0) === 53);
  const old = document.getElementById('m53Nano');

  // #53 以外なら後片付け
  if (!isM53){
    if (old) old.remove();
    tablesEl.classList.remove('m43-shift'); // #43 と同じレイアウト調整を流用
    return;
  }

  const pos = v?.meta?.m53_pos|0;
  if (!pos){
    if (old) old.remove();
    tablesEl.classList.remove('m43-shift');
    return;
  }

  // 画像は常に nano0.png（レベルや向きは不使用）
  const node = old || document.createElement('div');
  node.id = 'm53Nano';
  node.className = 'm43-nano'; // CSSは#43のnanoを共用
  node.style.backgroundImage = `url("./nano0.png")`;

  // 位置は #43 と同じ：チェックリストのセル中央上
  const itemsBar = document.getElementById('itemsBar');
  if (!itemsBar) return;
  let row = document.getElementById('nanoRow');
  if (!row){
    row = document.createElement('div');
    row.id = 'nanoRow';
    row.className = 'nano-row';
    itemsBar.insertAdjacentElement('afterend', row);
  }
  const cells = tablesEl.querySelectorAll('.checklist .check-item');
  const target = cells[pos-1];
  if (!target){ if (node.isConnected) node.remove(); row.remove(); return; }
  const rb = target.getBoundingClientRect();
  const rrow = row.getBoundingClientRect();
  const x = rb.left - rrow.left + (rb.width/2) - 28;
  node.style.left = `${Math.max(0, x)}px`;
  node.style.top  = `0px`;
  if (!node.isConnected) row.appendChild(node);
}
/* ここまで追加：ミッション53 */

  
/* ▼▼ ：ミッション44（酸素トークン） ▼▼ */
function renderM44(v){
 if ((v?.mission?.id|0) !== 44) { const x=document.getElementById('m44OxPool'); if(x) x.remove(); return; }

  // ▼ 着席インデックスを安全に一度だけ取得（state.seatedTable が欠落していても拾う）
  const idx = (()=>{
    const n = (v?.tables?.length|0);
    const s = (state?.seatedTable==null) ? null : Number(state.seatedTable);
    if (Number.isInteger(s) && s>=0 && s<n) return s;
    const alt = (v.tables||[]).findIndex(t => t?.playerId === state.userId);
    return (alt>=0 ? alt : null);
  })();

  
  // --- 1) 初期セット（ホストのみ）：人数×2 を全体プールに用意 ---
  if (state.isHost && (!v.meta || typeof v.meta.oxItem !== 'number')) {
    const init = (v.tables?.length || 0) * 2;
    update(ref(db, `rooms/${state.roomCode}/meta`), { oxItem:init, oxByTable:{} });
    return; // 次回 onValue で描画
  }

  // --- 2) アイテム列の下に全体プールを表示（クリックで 1/2/3 の取得） ---
  const itemsBar = document.getElementById('itemsBar');
  if (!itemsBar) return;

  let poolRow = document.getElementById('m44OxPool');
  if (!poolRow){
    poolRow = document.createElement('div');
    poolRow.id = 'm44OxPool';
    poolRow.className = 'ox-row ox-pool';   // 左画像を置くプール行
    // アイテム列の“直下”に置く（ミッション12の num-under と同様の位置感）
    itemsBar.insertAdjacentElement('afterend', poolRow);
  }
  let wrap = poolRow.querySelector('.ox-wrap');
  if (!wrap){
    poolRow.innerHTML = '';
    const side = document.createElement('div');
    side.className = 'ox-side';       // ← 左側の ox2.jpg（アイテムカードと同サイズ）
    poolRow.appendChild(side);
    wrap = document.createElement('div');
    wrap.className = 'ox-wrap';       // ← トークンを詰める枠（10個で改行）
    poolRow.appendChild(wrap);
  }else{
    wrap.innerHTML = '';
  }  const poolCnt = Math.max(0, v.meta?.oxItem|0);
  for (let i=0; i<poolCnt; i++){
    const t = document.createElement('div');
    t.className = 'token ox';
    wrap.appendChild(t);  // ← トークンは .ox-wrap の中へ
  }

  // クリックで 1/2/3 取得（隊長は「集める」も表示）
  poolRow.onclick = (ev)=>{
    const poolCnt = Math.max(0, v.meta?.oxItem|0);  // ← プール残量
    const entries = [1,2,3]
      .filter(k => poolCnt >= k)                    // ← 足りる数だけ表示
     .map(k => ({
        label: String(k),
        action: async ()=>{
         const left = (v.meta?.oxItem|0) - k;
         if (idx==null){ alert('席に座ってから取得してください'); return; }
         const mine = (v.meta?.oxByTable?.[idx]||0) + k;         
          if (left < 0) return;
          await update(ref(db, `rooms/${state.roomCode}/meta`), {
            oxItem: left,
            [`oxByTable/${idx}`]: mine
          });
        }
      }));

    // ★隊長だけ：全員の酸素トークンを集めてリザーブ（oxItem）へ戻す
    if ((v.captainTable|0) === (state.seatedTable|0)) {
      entries.push({
        label:'集める',
        action: async ()=>{
          const by = v.meta?.oxByTable || {};
          // 全テーブル所持酸素の合計
          const total = Object.values(by).reduce((a,b)=> a + ((b|0) || 0), 0);

          // 変更が無ければ何もしない
          if (total <= 0) return;

          // meta 直下を update でまとめて更新（oxByTable[*] を 0 に、oxItem を合算加算）
          const upd = {
            oxItem: (v.meta?.oxItem || 0) + total
          };
          // いま持っているキーだけ 0 にする（存在しないキーは触らない）
          Object.keys(by).forEach(k=>{
            upd[`oxByTable/${k}`] = 0;
          });

          await update(ref(db, `rooms/${state.roomCode}/meta`), upd);
        }
      });
    }
    if (entries.length === 0) return; openMenu(ev.clientX, ev.clientY, entries);  };

  // --- 3) 各プレイヤーテーブルの“下部”（情報トークン群より下）に所持酸素を表示 ---
  const tableNodes = document.querySelectorAll('.table'); // renderTables の並びと同順
  (v.tables||[]).forEach((T, ti)=>{
    const box = tableNodes[ti];
    if (!box) return;

    // 既存の行を再利用 or 生成
    let ownRow = box.querySelector('.ox-row[data-owner="1"]');
    if (!ownRow){
      ownRow = document.createElement('div');
      ownRow.className = 'ox-row';
      ownRow.dataset.owner = '1';
      // ★変更：情報トークン有無に依らず、常に「アルファベット直下」に置く
     const anchor = box.querySelector('.badge-fixed'); // ← 1枚目の .alpha を含む
     if (anchor && anchor.parentElement) {
       (anchor.parentElement).appendChild(ownRow);
      // 「アルファベット二個分」だけ下げる（文字高を動的取得）
      const ah = anchor.parentElement.querySelector('.alpha')?.getBoundingClientRect().height || 18;
    ownRow.style.marginTop = `${Math.round(ah * 5)}px`;
      } else {
        // フォールバック：手札の直後に置く
        const hand = box.querySelector('.hand');
        (hand || box).appendChild(ownRow);
      }
    }
    // 再描画（10個で改行するため常に .ox-wrap を挿入）
    ownRow.innerHTML = '';
    const cnt = Math.max(0, v.meta?.oxByTable?.[ti]||0);
    const wrapSelf = document.createElement('div');
    wrapSelf.className = 'ox-wrap';      // ← プールと同じ折返しルール（10で改行）
    ownRow.appendChild(wrapSelf);
    for (let i=0; i<cnt; i++){
      const t = document.createElement('div');
     t.className = 'token ox';
      wrapSelf.appendChild(t);           // ← トークンは wrap 内に入れる
    }

  // ▼▼ テーブル高さを所持酸素の【行数】に合わせてスライド（M49/M63と同一）
    const BASE   = 96;     // 基準高さ（座席のみ）
     const PERROW = 15;     // 1行あたりのトークン数（.ox-wrap と一致）
    const ROWH   = 24;     // 1行の実質高さ（20px+余白）
    const rows   = (cnt>0) ? Math.ceil(cnt / PERROW) : 0;
    const extra  = rows>0 ? (4 + ROWH * rows) : 0;
   const needH  = Math.max(BASE, BASE + extra);
    box.style.setProperty('--table-h', `${needH}px`);
    box.style.height = `${needH}px`;      // ← 実高さも直指定で確実に反映
  

    // 自分の所持酸素をクリック → 1/2/3 を返却（プールへ）
if (Number.isInteger(idx) && idx === ti){
      ownRow.onclick = (ev)=>{
        openMenu(ev.clientX, ev.clientY, [1,2,3].map(k=>({
          label:String(k),
          action: async ()=>{
            const mine = (v.meta?.oxByTable?.[ti]||0) - k;
            const pool = (v.meta?.oxItem||0) + k;
            if (mine < 0) return;
            await update(ref(db, `rooms/${state.roomCode}/meta`), {
              oxItem: pool,
              [`oxByTable/${ti}`]: mine
            });
          }
        })));
      };
    }else{
      ownRow.onclick = null;
    }
  });
}
/* ▲▲ ここまで追加：ミッション44（酸素トークン） ▲▲ */


  
/* ▼▼ ここから追加：ミッション49（配布＆譲渡：プールなし） ▼▼ */
 async function renderM49(v){
  try{
      const isM49 = ((v?.mission?.id|0) === 49);
      // ミッション49でなければ、前回の高さ上書きを元に戻して終了
      if (!isM49) {
        document.querySelectorAll('.table').forEach(tb=>{
          tb.style.removeProperty('--table-h');
       });
        return;
      }

    // --- 0) 安全ガード：tables が無い/空なら何もしない ---
    const n = (v?.tables?.length|0);
    if (!Array.isArray(v?.tables) || n <= 0) return;

    // --- 1) 初期配布（ホストのみ・一度だけ） ---
    // 人数→初期枚数：2人=7, 3人=6, 4人=5, 5人=4, 6人=4
    if (state.isHost && v?.meta?.m49_init !== true){
      const map = (m)=>{
        if (m<=2) return 7;
        if (m===3) return 6;
        if (m===4) return 5;
        return 4; // 5 or 6
      };
      const per = map(n);
      const by  = {};
      for (let i=0;i<n;i++) by[i] = per;

      // ミッション44で使っていた oxItem（プール）は使わないので 0 に
  update(ref(db, `rooms/${state.roomCode}/meta`), {
        oxByTable: by,
        oxItem: 0,
        m49_init: true
  }).catch(console.error);
      return; // 次回 onValue で描画
    }

    // --- 2) 各テーブルに所持酸素を表示（位置は #44 と同じアンカー直下） ---
    // #44 と同じクラス/見た目を再利用（.token.ox / .ox-row）
    const tableNodes = document.querySelectorAll('.table'); // renderTables と同順
    (v.tables||[]).forEach((T, ti)=>{
      const box = tableNodes[ti];
      if (!box) return;

      // 既存行を再利用 or 生成
      let row = box.querySelector('.ox-row[data-owner="1"]');
      if (!row){
        row = document.createElement('div');
        row.className = 'ox-row';
        row.dataset.owner = '1';

        // #44 同様、「アルファベット直下」に固定配置
        const anchor = box.querySelector('.badge-fixed');
        if (anchor && anchor.parentElement){
          const ah = anchor.parentElement.querySelector('.alpha')?.getBoundingClientRect().height || 18;
          (anchor.parentElement).appendChild(row);
          row.style.marginTop = `${Math.round(ah * 5)}px`;
        }else{
          // フォールバック：手札の直後
          const hand = box.querySelector('.hand');
          (hand || box).appendChild(row);
        }
      }

  // 再描画（M63と同じく .ox-wrap を介して 15 個で改行）
  row.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.className = 'ox-wrap';     // CSS で 1 行あたり 15 個に折返し
  row.appendChild(wrap);
  const cnt = Math.max(0, v?.meta?.oxByTable?.[ti]||0);
  for (let i=0; i<cnt; i++){
    const t = document.createElement('div');
    t.className = 'token ox';
    wrap.appendChild(t);
  }
     // ▼▼ テーブル高さ：所持酸素の行数に合わせて自動調整（#63相当の計算）
  {
    const baseH = 96;           // CSS :root の --table-h 既定
    const perRow = 15;          // 1 行あたりのトークン数（.ox-wrap と一致）
    const rows = Math.ceil(cnt / perRow);
    // 4px（前縁） + 20px（トークン高）×行数 + 2px（行間）×(行数-1)
    const extra = rows > 0 ? (4 + rows * 20 + Math.max(0, rows - 1) * 2) : 0;
    const needH = Math.max(baseH, baseH + extra);
    box.style.setProperty('--table-h', `${needH}px`);
　  box.style.height = `${needH}px`;          // ← 実高さも直指定して確実に広げる

  }
      // --- 3) 譲渡メニュー：自分“以外”の行だけクリック可 ---
      // 自分のテーブル番号を安全に特定する
      const myIdx = (() => {
  const sNum = (state?.seatedTable == null) ? null : Number(state.seatedTable);
  if (Number.isInteger(sNum) && sNum >= 0 && sNum < n) return sNum;

  // フォールバック：playerId と自分の userId を照合
  const alt = (v.tables || []).findIndex(t => t?.playerId === state.userId);
  return (alt >= 0 ? alt : null);      })();

  if (myIdx !== null && myIdx !== ti){

  // 共通ハンドラ：row/box から呼ぶ。二重発火防止のため stopPropagation
  const openGiveMenu = async (ev)=>{
    ev.stopPropagation();
    const mine = Math.max(0, v?.meta?.oxByTable?.[myIdx]||0);
    if (mine <= 0) return;

    const entries = Array.from({length: mine}, (_,i)=> i+1).map(k=>({
      label: String(k),
      action: async ()=>{
        const snap = await get(ref(db, `rooms/${state.roomCode}/meta`));
        const meta = snap.val()||{};
        const curMine   = Math.max(0, meta?.oxByTable?.[myIdx]||0);
        const curTarget = Math.max(0, meta?.oxByTable?.[ti]||0);
        if (k > curMine) return;
        const upd = {};
        upd[`oxByTable/${myIdx}`] = curMine - k;
        upd[`oxByTable/${ti}`]    = curTarget + k;
        await update(ref(db, `rooms/${state.roomCode}/meta`), upd);
      }
    }));
    if (entries.length > 0) openMenu(ev.clientX, ev.clientY, entries);
  };

  // 従来どおり酸素行（細帯）もクリック可
  row.onclick = openGiveMenu;

  // ★追加：テーブル枠（box）全体にも同じクリック判定を付与（1回だけ）
  if (!box.dataset.m49Bind) {
    box.dataset.m49Bind = '1';
    box.addEventListener('click', openGiveMenu);
  }

}else{
  // 自分の行はクリック不可（row / box とも付けない）
  row.onclick = null;
}

    });
  }catch(err){
    // 入室不能事故を防ぐため、例外は握り潰してログだけ
    console.error('[M49]', err);
  }
}
/* ▲▲ ここまで追加：ミッション49 ▲▲ */


  
  // #31：制約カード拡大ポップ（オーバーレイ表示）
function openConstraintZoom(letter, myIdx){
  try{
    const old = document.getElementById('conZoomOverlay');
    if (old) old.remove();

    const ov = document.createElement('div');
    ov.id = 'conZoomOverlay';
    ov.addEventListener('click', (e)=>{ if(e.target===ov) closeConstraintZoom(); });

    const wrap = document.createElement('div');
    wrap.className = 'conzoom-wrap';

    const big = document.createElement('div');
    big.className = 'conzoom-card';
    big.style.backgroundImage = `url('${imgConstraint(letter)}')`;
    big.addEventListener('click', (e)=>{
      e.stopPropagation();
      // メニューが無ければ生成／あればトグル
       if (typeof myIdx !== 'number') return;
      let m = wrap.querySelector('.conzoom-menu');
      if (m){ m.remove(); return; }
      m = document.createElement('div');
      m.className = 'conzoom-menu';

      const btnOut = document.createElement('button');
      btnOut.textContent = '場に出す';
      btnOut.onclick = async (ev)=>{
        ev.stopPropagation();
        try{
          const rRef = ref(db, `rooms/${state.roomCode}`);
          const rSnap = await get(rRef);
          const R = rSnap.val()||{};
          const cur = Array.isArray(R.m31_center) ? R.m31_center.slice() : [];
          if (!cur.some(o => o?.by === myIdx)){
            cur.push({ ch: letter, by: myIdx });
            await update(rRef, { m31_center: cur });
          }
        }catch(err){ console.error(err); }
        closeConstraintZoom();
      };

   
      m.appendChild(btnOut);
      wrap.appendChild(m);
    });

    wrap.appendChild(big);
    ov.appendChild(wrap);
    document.body.appendChild(ov);
  }catch(e){ console.error(e); }
}
function closeConstraintZoom(){
  const ov = document.getElementById('conZoomOverlay');
  if (ov) ov.remove();
}

// #61：閲覧専用の拡大（ボタン・ポップなし）
function openConstraintZoomView(letter){
  try{
    const old = document.getElementById('conZoomOverlay');
    if (old) old.remove();
   const ov = document.createElement('div');
    ov.id = 'conZoomOverlay';
    ov.addEventListener('click', (e)=>{ if(e.target===ov) closeConstraintZoom(); });
   const wrap = document.createElement('div');
    wrap.className = 'conzoom-wrap';
    const big = document.createElement('div');
    big.className = 'conzoom-card';
    big.style.backgroundImage = `url('${imgConstraint(letter)}')`;
    wrap.appendChild(big);
    ov.appendChild(wrap);
    document.body.appendChild(ov);
  }catch(e){ console.error(e); }
}
  
// ★ #61専用：拡大→「交換」→「本当に？」→B(F/G)から差し替え
function openConstraintZoom61(letter, myIdx){
  try{
    const old = document.getElementById('conZoomOverlay');
    if (old) old.remove();
    const ov = document.createElement('div');
    ov.id = 'conZoomOverlay';
    ov.addEventListener('click', (e)=>{ if(e.target===ov) closeConstraintZoom(); });
    const wrap = document.createElement('div');
    wrap.className = 'conzoom-wrap';
    const big = document.createElement('div');
    big.className = 'conzoom-card';
    big.style.backgroundImage = `url('${imgConstraint(letter)}')`;
    wrap.appendChild(big);
    ov.appendChild(wrap);
    document.body.appendChild(ov);
    // 最初は「交換」ボタンだけ
    const menu = document.createElement('div');
    menu.className = 'conzoom-menu';
    const btnSwap = document.createElement('button');
   btnSwap.textContent = '交換';
    btnSwap.onclick = (ev)=>{
      ev.stopPropagation();
      // 確認段階へ置き換え
      menu.innerHTML = '';
      const btnOk = document.createElement('button');
      btnOk.textContent = '本当に？';
      btnOk.onclick = async (ev2)=>{
        ev2.stopPropagation();
        try{
          const mRef = ref(db, `rooms/${state.roomCode}/meta`);
          const snap = await get(mRef);
          const meta = snap.val()||{};
          const arr  = Array.isArray(meta.m61_byTable) ? meta.m61_byTable.slice() : [];
          if (myIdx<0 || myIdx>=arr.length) { closeConstraintZoom(); return; }
          // デッキB = F or G をランダム
const deckB = ['F','G','H','I','J','K','L'];
const B = deckB[Math.floor(Math.random() * deckB.length)];
          arr[myIdx] = B;
          await update(mRef, { m61_byTable: arr, m61_swapAt: Date.now() });
        }catch(e){ console.error('[M61 swap]', e); }
        closeConstraintZoom();
      };
      const btnCancel = document.createElement('button');
      btnCancel.textContent = 'やめる';
      btnCancel.onclick = (e3)=>{ e3.stopPropagation(); closeConstraintZoom(); };
      menu.appendChild(btnOk);
      menu.appendChild(btnCancel);
    };
    menu.appendChild(btnSwap);
   wrap.appendChild(menu);
  }catch(e){ console.error(e); }
}

  
/* ：アイテム拡大ポップ */
function openItemZoom(itemNo, itemIdx, opt={}){
  try{
    const old = document.getElementById('conZoomOverlay');
    if (old) old.remove();

    const ov = document.createElement('div');
    ov.id = 'conZoomOverlay';
    ov.addEventListener('click', (e)=>{ if(e.target===ov) closeConstraintZoom(); });

    const wrap = document.createElement('div');
    wrap.className = 'conzoom-wrap';

    const big = document.createElement('div');
    big.className = 'conzoom-card';
    big.style.backgroundImage = `url('./item${itemNo}.jpg')`;

    big.addEventListener('click', async (e)=>{
      e.stopPropagation();
      let m = wrap.querySelector('.conzoom-menu');
      if (m){ m.remove(); return; }
      m = document.createElement('div');
      m.className = 'conzoom-menu';

      // ①（任意）裏なら「表にする」
      if (opt?.canFaceUp) {
        const btnFace = document.createElement('button');
        btnFace.textContent = '表にする';
        btnFace.onclick = async (ev)=>{
          ev.stopPropagation();
          await update(ref(db, `rooms/${state.roomCode}/items/${itemIdx}`), { faceUp:true });
          closeConstraintZoom();
        };
        m.appendChild(btnFace);
      }

      // ②「使う」：従来の '使用する' と同等の処理
      const btnUse = document.createElement('button');
      btnUse.textContent = '使う';
      btnUse.onclick = async (ev)=>{
        ev.stopPropagation();
        await update(ref(db, `rooms/${state.roomCode}/items/${itemIdx}`), { used:true });
        const path=`rooms/${state.roomCode}/meta/itemUses`;
        const uses = state.watching?.meta?.itemUses || {i1:0,i2:0,i12:0,i14:0};
        if(itemNo===1)  await update(ref(db, path), {i1:(uses.i1||0)+1});
        if(itemNo===2)  await update(ref(db, path), {i2:(uses.i2||0)+1});
        if(itemNo===12) await update(ref(db, path), {i12:(uses.i12||0)+1});
        if(itemNo===14) await update(ref(db, path), {i14:(uses.i14||0)+1});

        if(itemNo===2){
          await update(ref(db, `rooms/${state.roomCode}/meta`), { i2Flow:{usingBy:state.userId, phase:'pickSelf', selA:null, selB:null} });
        }
        if(itemNo===13){ await addTwoItemsFromDeck(); }
        if(itemNo===16){ await handleItem16(itemIdx); }
        if(itemNo===18){ await update(ref(db, `rooms/${state.roomCode}/meta`), { i18Flow:{usingBy:state.userId, phase:'pickOther', sel:null} }); }

        closeConstraintZoom();
      };
      m.appendChild(btnUse);

      wrap.appendChild(m);
    });

    wrap.appendChild(big);
    ov.appendChild(wrap);
    document.body.appendChild(ov);
  }catch(e){ console.error(e); }
}


  
/* === #22 用：数字トークンの使用数を集計 === */
function countNumTokenUsage(n, v){
  const vv = v || state.watching;
  let used = 0;
  (vv?.tables || []).forEach(T=>{
    // カードに置かれた「数字」トークン
    (T.hand || []).forEach(c=>{
      (c.tokens || []).forEach(tk=>{
        if (tk?.type === 'num' && parseInt(tk.value, 10) === n) used += 1;
      });
    });
   // キャラクターカード下の保持トークン（m22Tokens）
    (T.m22Tokens || []).forEach(nn=>{
      if (parseInt(nn, 10) === n) used += 1;
    });
  });
  return used;
}

 // ★ #27：候補プールを生成して DB(meta) に保存（初回のみ）
 async function ensureM27Candidates(vNow){
   const v = vNow || state.watching;
   if (!v) return;
   // 既に用意済みなら何もしない
   if (Array.isArray(v?.meta?.m27_row) && v.meta.m27_row.length > 0) {
     await update(ref(db, `rooms/${state.roomCode}/meta`), { m27_shown: true });
     return;
   }
   // Z = 1..12 各2個、使用分（上限2まで）を差し引き
   const pool = [];
   for (let n=1; n<=12; n++){
     const left = 2 - Math.min(2, countNumTokenUsage(n, v));
     for (let i=0; i<left; i++) pool.push(n);
   }
   // 人数ぶんランダム提示（重複は許可：仕様は「各2個」なので重複OK）
   shuffle(pool);
   const need = Math.max(0, v.tableCount|0);
   const picks = pool.slice(0, need);
   await update(ref(db, `rooms/${state.roomCode}/meta`), {
     m27_row: picks,
     m27_shown: true
   });
 }

 // ★ #27：アイテム列の直下に提示トークン行を描画
 function renderM27Row(vNow){
   const v = vNow || state.watching;
   const bar = document.getElementById('itemsBar');
   if (!bar || !v?.mission || v.mission.id !== 27) {
     const old = document.getElementById('m27Row');
     if (old) old.remove();
     return;
   }
   const list = Array.isArray(v?.meta?.m27_row) ? v.meta.m27_row.slice() : [];
   // 行が不要なら消す
   if (list.length === 0){
     const old = document.getElementById('m27Row');
     if (old) old.remove();
     return;
   }

   // 既存行を再利用 or 新規作成
   let row = document.getElementById('m27Row');
   if (!row){
     row = document.createElement('div');
     row.id = 'm27Row';
     row.className = 'm27-row';
     // 「提示トークン」ラベル
     const cap = document.createElement('span');
     cap.className = 'cap';
     cap.textContent = '提示トークン：';
     row.appendChild(cap);
     bar.insertAdjacentElement('afterend', row);
   }
   // ラベル以外を消して再描画
   [...row.children].forEach((ch,i)=>{ if(i>0) ch.remove(); });

   list.forEach((n, idx)=>{
     const tok = document.createElement('div');
     tok.className = 'token black';
     tok.textContent = String(n);
     tok.title = 'クリックしたプレイヤーのキャラ下に置く';
     tok.onclick = async (ev)=>{
       try{
         // 自分の席へ
         const myIdx = (v.tables||[]).findIndex(T => T.playerId === state.userId);
         if (myIdx < 0){ alert('席に座ってから選んでください'); return; }

        const metaSnap0 = await get(ref(db, `rooms/${state.roomCode}/meta`));
        const meta0 = metaSnap0.val() || {};
        const takenMap = meta0.m27_taken || {};
        if (takenMap[state.userId]) {
          // 既に1個取得済み
          return;
        }
         
         // m22Tokens を汎用の“保持トークン置き場”として流用（#22 と同じ自動消費ルーチンが使える）
         const tRef = ref(db, `rooms/${state.roomCode}/tables/${myIdx}`);
         const snap = await get(tRef);
         const cur  = snap.val() || {};
         const arr  = Array.isArray(cur.m22Tokens) ? cur.m22Tokens.slice() : [];
         arr.push(n);

         // 行側からも1つ取り除く
         const metaSnap = await get(ref(db, `rooms/${state.roomCode}/meta`));
         const meta  = metaSnap.val() || {};
         const rowNow = Array.isArray(meta.m27_row) ? meta.m27_row.slice() : [];
         // idx の位置の 1 個を削除（同値が複数あるため index 指定）
         if (rowNow[idx] === n) rowNow.splice(idx,1);
         else {
           const pos = rowNow.indexOf(n);
           if (pos >= 0) rowNow.splice(pos,1);
         }

         await Promise.all([
          update(tRef, { m22Tokens: arr }),
          update(ref(db, `rooms/${state.roomCode}/meta`), { 
            m27_row: rowNow,
            m27_taken: { ...(meta.m27_taken||{}), [state.userId]: true }
          })         ]);

         // 取り終えたら即時再描画（次の onValue を待たずに軽く）
         renderM27Row(state.watching || v);
       }catch(e){
         console.error(e);
       }
     };
     row.appendChild(tok);
   });
 }
  
  /* ▼ #22：自分のキャラ下の保持トークンを1つ消費する */
async function consumeM22IfMatches(tableIdx, n){
  try{
    const tRef = ref(db, `rooms/${state.roomCode}/tables/${tableIdx}`);
    const snap = await get(tRef);
    const cur  = snap.val() || {};
    const arr  = Array.isArray(cur.m22Tokens) ? cur.m22Tokens.slice() : [];
    const i    = arr.indexOf(n);
    if(i >= 0){
      arr.splice(i,1);
      await update(tRef, { m22Tokens: arr });
    }
  }catch(e){ console.error('consumeM22IfMatches', e); }
}


/* === #22 用：情報トークン表（3×4）：黒トークン + x0/x1/x2 を横並び表示 === */
function showInfo22Panel(vNow){
  if (window.m22_alreadyShown) return;  // ★ここから追加：一度だけ表示
  window.m22_alreadyShown = true;   

  const v = vNow || state.watching;
  if (!v) return;

  // ★ 黄2種公開（＝サーバ側で m22_infoShown を立てた）までは表を生成しない
  if (v?.meta?.m22_infoShown !== true) return;
 　const givenMap = v.meta?.m22_given || {};
　 const iGave    = !!givenMap[state.userId];
  const div = document.createElement('div');
  div.id = 'info22';
  div.className = 'info22';

  for (let n=1; n<=12; n++){
    // 使用数（2以上は 2 で打ち止め）
    const used = countNumTokenUsage(n, v);
const shown = 2 - Math.min(2, used);

      const cell = document.createElement('div');
    cell.className = 'cell';

    // 黒トークン本体（既存の .token.black を再利用）
    const tok = document.createElement('div');
    tok.className = 'token black';
    tok.textContent = String(n);

// ★ shown が 0 の場合は無効スタイルを付与
if (shown === 0) cell.classList.add('disabled');
    
    // 右側の xラベル
    const xl = document.createElement('span');
    xl.className = 'xlabel';
    xl.textContent = `x${shown}`;

    cell.appendChild(tok);
    cell.appendChild(xl);

    // ▼ セル全域／トークンどちらを押しても同じ挙動：自分は1回だけ「渡す」可能。以降は「隠す」のみ
    const handleGiveOrHide = async (ev)=>{
      ev.stopPropagation();

  // ★ x0 はポップを出さない（何もしない）
  if (shown === 0) return;
      
      const latest = state.watching || v;
      const givenMap = latest?.meta?.m22_given || {};
      const iGaveNow = !!givenMap[state.userId];

      if (state.m22GaveOnce || iGaveNow) {
        openMenu(ev.clientX, ev.clientY, [
          { label:'隠す', action: ()=>{ const x=document.getElementById('info22'); if(x) x.remove(); } }
        ]);
        return;
      }

      // 次手番：自分の次の着席者
      const tables = (latest.tables||[]);
      const myIdx  = tables.findIndex(T => T.playerId === state.userId);
      let nextIdx  = -1;
      if (myIdx >= 0 && tables.length > 0){
        for (let off=1; off<=tables.length; off++){
          const i = (myIdx + off) % tables.length;
          if (tables[i]?.playerId){ nextIdx = i; break; }
        }
      }
      if (nextIdx < 0){
        nextIdx = (tables.findIndex(T => T.playerId) + tables.length) % Math.max(1, tables.length);
      }
      const nextName = tables[nextIdx]?.playerName || `#${(nextIdx|0)+1}`;

      openMenu(ev.clientX, ev.clientY, [
        { label: `${nextName} に ${n} を渡す`, action: async ()=>{
            try{
              state.m22GaveOnce = true;

              const gPath = `rooms/${state.roomCode}/meta/m22_given`;
              const gSnap = await get(ref(db, gPath));
              const gMap  = gSnap.val() || {};
              if (gMap[state.userId]) return;

              // 受け取り先に push
              const tRef = ref(db, `rooms/${state.roomCode}/tables/${nextIdx}`);
              const snap = await get(tRef);
              const cur  = snap.val() || {};
              const arr  = Array.isArray(cur.m22Tokens) ? cur.m22Tokens.slice() : [];
              arr.push(n);
              await update(tRef, { m22Tokens: arr });

              // 自分は渡し済みにする（DB保持）
              await update(ref(db, gPath), { [state.userId]: true });
    // ★ 渡したら表を自動で隠す
    const panel = document.getElementById('info22');
    if (panel) panel.remove();
  }catch(e){
    state.m22GaveOnce = false;
    console.error(e);
            }
          } }
      ]);
    };

    cell.onclick = handleGiveOrHide;
    tok.onclick  = handleGiveOrHide;

    div.appendChild(cell);
  }
  
  document.body.appendChild(div);
}

function refreshInfo22(vNow){
  const panel = document.getElementById('info22');
  if (!panel) return;
  const v = vNow || state.watching;
  // フラグが下がっていたら閉じる
  if (v?.meta?.m22_infoShown !== true) { panel.remove(); return; }

  // 1..12 の各セルの x表示と disabled を更新
  const cells = panel.querySelectorAll('.cell');
  for (let n=1; n<=12; n++){
    const cell = cells[n-1];
    if (!cell) continue;
    const used  = countNumTokenUsage(n, v);          // 既存関数を再利用
    const shown = 2 - Math.min(2, used);             // 0/1/2
    const xl = cell.querySelector('.xlabel');
    if (xl) xl.textContent = `x${shown}`;
    cell.classList.toggle('disabled', shown===0);    // x0 はクリック無効
  }
}




/* ===== Item 2 swap ===== */
async function doItem2Swap(A, B){
  if(!A || !B) return;
  const snap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = snap.val() || [];

  const pickCard = (tableIdx, cardId)=>{
    const hand = (tables[tableIdx]?.hand)||[];
    const i = hand.findIndex(c=> c.id===cardId);
    return {hand, index:i, card: i>=0 ? hand[i] : null};
  };

  const a = pickCard(A.table, A.cardId);
  const b = pickCard(B.table, B.cardId);
  if(!a.card || !b.card){ await update(ref(db, `rooms/${state.roomCode}/meta`), { i2Flow:null }); return; }

  a.hand.splice(a.index,1); b.hand.splice(b.index,1);

  const insertSortedLeft = (hand, card)=>{ const n = card.num; let pos = 0; while(pos<hand.length && hand[pos].num < n) pos++; while(pos>0 && hand[pos-1].num===n) pos--; hand.splice(pos,0,card); };

  const mark = now()+10000; // 10秒
  const toB = {...a.card, ownerId: tables[B.table].playerId || null, markUntil: mark};
  const toA = {...b.card, ownerId: tables[A.table].playerId || null, markUntil: mark};

  insertSortedLeft(b.hand, toB);
  insertSortedLeft(a.hand, toA);

  const realpha = (hand)=>{ const alpha='abcdefghijklmnopqrstuvwxyz'; hand.forEach((c,i)=> c.alpha = alpha[i%alpha.length]); };
  realpha(a.hand); realpha(b.hand);

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/tables/${A.table}/hand`), a.hand),
    set(ref(db, `rooms/${state.roomCode}/tables/${B.table}/hand`), b.hand),
    update(ref(db, `rooms/${state.roomCode}/meta`), { i2Flow:null })
  ]);
}

/* ===== Item 18 take ===== */
async function doItem18Take(sel){
  const myTable = state.watching?.tables?.findIndex(t=> t.playerId===state.userId);
  if(myTable==null || myTable<0){ alert('席に座ってから使用してください'); await update(ref(db, `rooms/${state.roomCode}/meta/i18Flow`), {sel:null, phase:'pickOther'}); return; }
  const snap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = snap.val() || [];

  const srcHand = (tables[sel.table]?.hand)||[];
  const si = srcHand.findIndex(c=> c.id===sel.cardId);
  if(si<0){ await update(ref(db, `rooms/${state.roomCode}/meta/i18Flow`), {sel:null, phase:'pickOther'}); return; }
  const card = srcHand.splice(si,1)[0];

  const dstHand = (tables[myTable]?.hand)||[];
  const n = card.num;
  let pos = 0; while(pos<dstHand.length && dstHand[pos].num < n) pos++; while(pos>0 && dstHand[pos-1].num===n) pos--; 
  const mark = now()+10000;
  dstHand.splice(pos,0,{...card, ownerId: state.userId, markUntil: mark});

  const realpha = (hand)=>{ const alpha='abcdefghijklmnopqrstuvwxyz'; hand.forEach((c,i)=> c.alpha = alpha[i%alpha.length]); };
  realpha(dstHand); realpha(srcHand);

  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/tables/${sel.table}/hand`), srcHand),
    set(ref(db, `rooms/${state.roomCode}/tables/${myTable}/hand`), dstHand),
    update(ref(db, `rooms/${state.roomCode}/meta`), { i18Flow:null })
  ]);
}

/* ==== アイテムデッキ制御（ミッション別） ==== */

/* このミッションで黄コードを使うか？ */
function missionUsesYellow(missionId){
  const plan = buildMixPlan(missionId) || [];
  // yellowPick / yellowChoose を含むか、#2（黄コード）なら true
  return missionId===2 || plan.some(p => p.type==='yellowPick' || p.type==='yellowChoose');
}

/* ミッションごとのアイテム除外リスト（必要に応じて追記） */
const ITEM_EXCLUSIONS = {
  // 例）12: [3, 7],   // ミッション12ではアイテム3と7を除外
};


    
/* ===== Item helpers ===== */
/* missionId と “黄コードを使うか”で山札を決定し、除外も適用 */
function itemDeckNumbers(missionId){
  // 43以降は 1..18 を使用
  if(missionId >= 43){
    return Array.from({length:18}, (_,i)=> i+1);
  }

  // 〜42は 1..13（黄コードあり） / 1..12（黄コードなし）
  const useYellow = missionUsesYellow(missionId);
  const maxNo = useYellow ? 13 : 12;
  let pool = Array.from({length:maxNo}, (_,i)=> i+1);

  // 除外適用
  const ex = ITEM_EXCLUSIONS[missionId] || [];
  if(ex.length){
    const exSet = new Set(ex);
    pool = pool.filter(n => !exSet.has(n));
  }
  return pool;
}


/* item13: 追加で2枚 */
async function addTwoItemsFromDeck(){
  const v = state.watching; if(!v) return;
  const missionId = v?.mission?.id || 0;

  // ミッション規則に従ったプール
  const pool = itemDeckNumbers(missionId);

  // 既存と重複しないものから追加
  const existingNos = new Set((v.items||[]).map(i=>i.no));
  const candidates = pool.filter(n=> !existingNos.has(n));
  shuffle(candidates);

  const pick = candidates.slice(0,2).map(no=>({id:crypto.randomUUID(), no, used:false}));
  if(pick.length===0) return;

  const next = (v.items||[]).concat(pick);
  await set(ref(db, `rooms/${state.roomCode}/items`), next);
}


/* item16: 数字(1..12)の使用数を集計し、<2の数字から1つ選びメタに保存（表示はアイテム16右側で行う） */
async function handleItem16(itemIdx){
  const v = state.watching; if(!v) return;

  const counts = Array.from({length:13}, ()=>0); // 1..12
  (v.tables||[]).forEach(T=>{
    (T.hand||[]).forEach(c=>{
      (c.tokens||[]).forEach(tk=>{
        if(tk?.type==='num'){
          const n = parseInt(tk.value, 10);
          if(n>=1 && n<=12) counts[n] += 1;
        }
      });
    });
  });

  const candidates = [];
  for(let n=1; n<=12; n++){
    if((counts[n]||0) < 2) candidates.push(n);
  }

  if(candidates.length===0){
    await update(ref(db, `rooms/${state.roomCode}/meta`), { i16Badge: null });
    return;
  }

  const pick = candidates[Math.floor(Math.random()*candidates.length)];
  await update(ref(db, `rooms/${state.roomCode}/meta`), { i16Badge: { num: pick, at: Date.now() } });
}

/* gear etc */
function updateMenuButtons(){
  const seated = state.seatedTable!=null;
  H(btnSit, seated);
  H(btnLeave, !seated);
  H(btnPickMission, !state.isHost);

  // ★ #22：黄コード2種公開までは「表」をメニューに出さない
  const v = state.watching;
  const id  = 'btnShowInfo22';
  const old = document.getElementById(id);

  // 条件 = ミッション22でメニュー許可フラグが立っていて、かつ v.meta.m22_infoShown === true（黄2種公開済み）
  const canReferInfoTable = !!(v?.mission?.flags?.m22_allowInfoTableFromMenu && v?.meta?.m22_infoShown === true);

  if (!canReferInfoTable && old){ old.remove(); }
  if (canReferInfoTable && !old){
    const b = document.createElement('button');
    b.className = 'btn'; b.id = id; b.textContent = '情報トークン（#22）';
b.onclick = ()=>{ window.m22_alreadyShown = false; showInfo22Panel(state.watching); };
    menuPop.insertBefore(b, menuPop.firstChild || null);
  }
}


const outsideClose=(e,t)=>{ if(!t.contains(e.target)) H(t,true); };
function closeAllMini(e){ document.querySelectorAll('.mini-pop').forEach(pop=>{ if(!pop.contains(e.target)) pop.remove(); }); }
 document.addEventListener('click',(e)=>{ closeAllMini(e); outsideClose(e, menuPop); }, true);
gear.onclick=()=> { menuPop.classList.toggle('hidden'); if(!menuPop.classList.contains('hidden')) updateMenuButtons(); };

/* ★ 共通の離席処理 */
async function leaveSeatNow(){
  if(state.seatedTable==null || !state.watching?.tables) return;
  const idx=state.seatedTable; const hand=(state.watching.tables[idx].hand||[]);
  await update(ref(db, `rooms/${state.roomCode}/tables/${idx}`), {playerId:null, playerName:null});
  await Promise.all(hand.map((_,i)=> update(ref(db, `rooms/${state.roomCode}/tables/${idx}/hand/${i}`), {ownerId:null})));
  state.seatedTable=null; updateMenuButtons();
}

  /* ★ 追加：ホスト用—任意テーブルをキック（離席化） */
  async function kickSeatAt(tableIdx){
    const v = state.watching;
    if(!state.isHost || !v?.tables || tableIdx==null) return;
    const T = v.tables[tableIdx] || {};
    if(!T.playerId) return; // 空席は何もしない
    const hand = Array.isArray(T.hand) ? T.hand : [];
    await update(ref(db, `rooms/${state.roomCode}/tables/${tableIdx}`), { playerId:null, playerName:null });
    await Promise.all(hand.map((_,i)=>
      update(ref(db, `rooms/${state.roomCode}/tables/${tableIdx}/hand/${i}`), { ownerId:null })
    ));
  }

  
 // ▼ 席選択タブの描画を関数化：開いている間も再描画で同期
function renderSeatTabs(v){
  if(!v?.started) return;
  seatTabs.innerHTML='';
  (v.tables||[]).forEach((t,i)=>{
    const tab=document.createElement('div'); 
    tab.className='tab';
    tab.textContent = t.playerName ? `${i+1}（使用中）` : `${i+1}`;
    if(t.playerId) tab.classList.add('disabled');
    tab.onclick=async ()=>{
      if(tab.classList.contains('disabled')) return;
      await update(ref(db, `rooms/${state.roomCode}/tables/${i}`), {
        playerId:state.userId, playerName:state.userName
      });
      const hRef = ref(db, `rooms/${state.roomCode}/tables/${i}/hand`);
      const hSnap = await get(hRef);
      const hand = hSnap.val() || [];
      await Promise.all(hand.map((_,idx)=> 
        update(ref(db, `rooms/${state.roomCode}/tables/${i}/hand/${idx}`), { ownerId: state.userId })
      ));
      state.seatedTable=i; H(seatPop,true); updateMenuButtons();
    };
    seatTabs.appendChild(tab);
  });
}

btnSit.onclick = ()=>{
  if(state.mode!=='player'){ alert('観戦入室では席に座れません。参加で入り直してください。'); return; }
  const v=state.watching; if(!v?.started){ return; }
  renderSeatTabs(v);
  H(seatPop,false);
 };
btnSeatCancel.onclick=()=> H(seatPop,true);

btnLeave.onclick = async ()=>{ await leaveSeatNow();btnSit.onclick(); };

/* start / mission-pick */
btnPickMission.onclick = ()=>{
  if(!state.isHost){ alert('ホストのみ操作可'); return; }
  openMissionPicker();   // ▼ 新しいピッカー表示
};

// 既存のrestartPopは使わない
btnRestartOk.onclick = ()=>{};
btnRestartCancel.onclick = ()=>{ H(restartPop,true); };

// ▼ 変更：爆弾を解除！ で下部ピッカーを開く

btnStartCancel.onclick = ()=> H(startPop,true);
btnStartOk.onclick = async ()=>{ const count=clamp(parseInt(selCount.value,10),1,6); const missionId=parseInt(selMission.value,10); H(startPop,true); await startGame(count, missionId); };


/* ▼▼ ミッションピッカー実装 ▼▼ */
let mpSelectedCount = 4;

function openMissionPicker(){
  // 初期人数は現在のテーブル数 or 4
  const v = state.watching;
  mpSelectedCount = clamp(parseInt(v?.tableCount||4,10), 1, 6);

  // 人数タブ生成
  mpCounts.innerHTML = '';
  [2,3,4,5,6].forEach(n=>{
    const tab = document.createElement('div');
    tab.className = 'tab' + (n===mpSelectedCount?' active':'');
    tab.textContent = String(n);
    tab.onclick = ()=>{
      mpSelectedCount = n;
      [...mpCounts.children].forEach(c=>c.classList.remove('active'));
      tab.classList.add('active');
    };
    mpCounts.appendChild(tab);
  });

// ミッション一覧生成（#付き数字）
mpMissions.innerHTML = '';
// 1〜66 全部
const missionIds = Array.from({length:66}, (_,i) => i+1);
missionIds.forEach(id=>{
  const b = document.createElement('button');
  b.className = 'btn small';
  b.textContent = `#${id}`; // ★ #付き
  b.onclick = async ()=>{
    await leaveSeatNow();
    closeMissionPicker();
    await startGame(mpSelectedCount, id);
  };
  mpMissions.appendChild(b);
});



  btnMpBack.onclick = ()=> closeMissionPicker();
  H(mp, false);
  // 他のポップは閉じる
  H(menuPop, true);
}

function closeMissionPicker(){ H(mp, true); }
/* ▲▲ ミッションピッカー実装 ▲▲ */

async function startGame(playerCount, missionId){
  if(!state.isHost) return;

  // ★ 前のゲーム由来のDOM＆レジスタを完全クリア
  clearMissionOverlays();
  // 念のため、画面下部バッジも消す
  if(globalReveal){ globalReveal.innerHTML=''; H(globalReveal,true); }
 // ★ #22：渡し済みガードのリセット
  state.m22GaveOnce = false;
  // ★ #22：サーバ側メタも初期化（可視フラグ／渡し済み表）
  try{
    await update(ref(db, `rooms/${state.roomCode}/meta`), {
      m22_infoShown:false, m22_given:null,
      m27_row: [], m27_shown:false, m27_taken:null,
      // ★ M44 の初期化（ミッション切替時に必ずリセット）
      oxItem: 0,
      oxByTable: {}
    });
   }catch(_){}
  const code = state.roomCode;


  const captainIndex = Math.floor(Math.random()*playerCount);
  const faces=[1,2,3,4]; shuffle(faces);
  const tables=[]; for(let i=0;i<playerCount;i++){ const face=(i===captainIndex)?'member (5).jpg':`member (${faces[i%4]}).jpg`; tables.push({ titleNumber:i+1, playerId:null, playerName:null, character:{face, flipped:false}, hand:[] }); }

  // ===== デッキ構築 =====
  let deck=[]; let missionMeta;
  // ベースデッキ 1..12 x4 = 48（通常コード）
  const base=[]; for(let n=1;n<=12;n++){ for(let k=0;k<4;k++) base.push({id:crypto.randomUUID(), num:n, kind:'normal', open:false, ownerId:null}); }
  shuffle(base);

  // ▼ ミッション別：赤/黄の混入プランを取得＆実行
  const planList = buildMixPlan(missionId);
  const { toAdd, mixLines, chooseLines } = executeMixPlan(planList);

  // #1/#2の旧実装は planList で包含できるが、互換のためフォールバック
  if(missionId===1 && planList.length===0){
    const x = (Math.random()*11|0) + 1;
    toAdd.push({num:x+0.5, kind:'red'});
    mixLines.push(`赤[${x+0.5}]`);
  }
  if(missionId===2 && planList.length===0){
    const x = (Math.random()*11|0) + 1;
    toAdd.push({num:x+0.1, kind:'yellow'});
    mixLines.push(`黄[${x+0.1}]`);
  }

  // デッキ合成
  deck = base.concat(
    toAdd.map(s => ({ id:crypto.randomUUID(), num:s.num, kind:s.kind, open:false, ownerId:null }))
  );
  shuffle(deck);

  // ミッション表示メタ生成（赤/黄の結果行を先頭に差し込む）
  missionMeta = missionInfo(missionId, { mixLines, chooseLines });
  /* ▼▼ ここから追加：#29 数値カードの配布とセンター初期化 ▼▼ */
  if (missionId === 29) {
    const nums = MATERIALS.numbers.slice(); shuffle(nums); // 1..12 をシャッフル
    // 全員に2枚、隊長の前（cap-1）のテーブルに +1
    const cap = captainIndex|0;
    const x   = (cap - 1 + playerCount) % playerCount;
    let pi = 0;
    tables.forEach((T, i) => {
      const take = (i===x) ? 3 : 2;
      T.m29Hand = [];
      for (let k=0; k<take && pi<nums.length; k++) T.m29Hand.push(nums[pi++]);
    });
    // センター（場に出した数値カード置き場）
    // 形式: { n: number, by: tableIndex, faceUp: boolean }
    missionMeta.flags = { ...(missionMeta.flags||{}), m29:true };
  }
  /* ▲▲ ここまで追加：#29 ▼▼ */

  let m43A = [];
  if (missionId === 43) {
    // 5,6人→3枚 / 3,4人→4枚（2人は想定外だが 4 に寄せる）
    const need = (playerCount >= 5) ? 3 : 4;
    // 「このミッションで配布する予定のカード」＝現在の deck から通常数値カードだけを候補に
    const normalIdx = deck.map((c,i)=> c?.kind==='normal' ? i : -1).filter(i=> i>=0);
    shuffle(normalIdx);
    // ランダムに必要枚数ぶんを選び、デッキから“抜き取り”→ A群（数値の配列）に
    const takeIdx = normalIdx.slice(0, need).sort((a,b)=> b-a); // 後ろから splice するため降順
    takeIdx.forEach(i=>{
      const c = deck[i];
      if (c && typeof c.num === 'number') {
        m43A.push(c.num|0);
        deck.splice(i,1); // デッキから除外
      }
    });
  }

  
  // ===== 配布 → 手札昇順 → α付与 =====
  const alpha="abcdefghijklmnopqrstuvwxyz";
  let p=0; while(p<deck.length){ for(let t=0; t<playerCount && p<deck.length; t++){ const c=deck[p++]; tables[t].hand.push({...c, alpha:'', tokens:[], markUntil:null}); } }
  tables.forEach(T=>{ T.hand.sort((a,b)=> a.num - b.num); T.hand.forEach((c,i)=>{ c.alpha = alpha[i % alpha.length]; }); });

// アイテム（人数ぶん） — ミッション規則に合わせて山札を作る
let pool = itemDeckNumbers(missionId);

// ★ ミッションのフラグを先に確認して limitItemsTo があれば pool を絞る
const flagsForItems = missionMeta?.flags || {};
if (Array.isArray(flagsForItems.limitItemsTo) && flagsForItems.limitItemsTo.length > 0) {
  pool = flagsForItems.limitItemsTo.slice(); // ミッション18は [8] になる
}

shuffle(pool);

// #15: 最初は裏向き（faceUp:false）。それ以外は通常どおり表（faceUp:true）
const faceUpStart = !(missionMeta?.flags?.itemsFaceDownStart);

 // #23 は開始時は配らない（広げ条件を満たすまで非表示）
 const items = (missionMeta?.id === 23)
   ? []
   : pool
       .slice(0, Math.min(playerCount, pool.length))
       .map(no => ({ id: crypto.randomUUID(), no, used: false, faceUp: faceUpStart }));

  // ★ 開始エッジを作るために一瞬だけ false を書く（ミッションは未選択状態へ）
  await update(ref(db, `rooms/${code}`), { started:false, mission:null });

  await set(ref(db, `rooms/${code}`), {
    ...(state.watching||baseRoom(state.userId)),
    hostId: state.watching?.hostId || state.userId,
    started:true, tableCount:playerCount, tables, items,
  di:{ value: ((missionId===51 || missionId===55 || missionId===60 || missionId===62 || missionId===41) ? 1 : playerCount), max:6 },
  captainTable: captainIndex, mission: missionMeta,     /* ▼▼ ここから追加：#29 センター初期化 ▼▼ */
    m29_center: (missionMeta?.id===29 ? [] : null),
    /* ▲▲ ここまで追加 ▼▼ */
    meta:{ itemUses:{i1:0,i2:0,i12:0,i14:0}, tokenCounts:{equal:0,noteq:0,x1:0}, i2Flow:null, i18Flow:null, i16Badge:null }
  });
  /* ここから追加：#43 A群と nano 初期値を meta に保存 */
  if (missionId === 43) {
    const initNano = (playerCount >= 5) ? 3 : 4; // スタート時の表示（仕様どおり）
    try{
      await update(ref(db, `rooms/${code}/meta`), {
        m43_A: Array.isArray(m43A) ? m43A : [],
        m43_nano: initNano,
        m43_pos: 0,
        m43_prevPos: 0
      });
    }catch(_e){}
  }
  await setupMissionOnStart(code);   // ★追加

  H(gear,false);
}

/* ==== ミッション開始時セットアップ ==== */
async function setupMissionOnStart(code){
  const snap = await get(ref(db, `rooms/${code}`));
  const v = snap.val(); if(!v?.mission) return;
  const flags = v.mission.flags || {};
  /* #9：右2 + 異なる数値2枚を決定して meta に保存（ホストのみ実行） */
  if ((v.mission?.id|0) === 9) {
   const pool = MATERIALS.numbers.slice(); shuffle(pool);
    const picks = pool.slice(0,2);            // 異なる2枚
   await update(ref(db, `rooms/${code}/meta`), {
      m9_numbers: picks,
     m9_rule: 'right2'
    });
  }

    /* ★ #12：各アイテムの“真下”に置く数字を決定→metaへ保存（ホストのみ・一度だけ） */
    if ((v.mission?.id|0) === 12) {
    if (!Array.isArray(v?.meta?.m12_under)) {
        const itemCount = Array.isArray(v.items) ? v.items.length : 0;
       const pool = MATERIALS.numbers.slice(); shuffle(pool);
        const picks = pool.slice(0, itemCount);   // 1アイテムにつき1枚、重複なし
        await update(ref(db, `rooms/${code}/meta`), { m12_under: picks });
      }
    }

  
  /* ここから追加：#41 黄コード4枚配布（4人＝全員 / 5人＝隊長以外） */
  if ((v.mission?.id|0) === 41) {
    const tcount = v.tableCount|0;
    const cap    = v.captainTable|0;

    // 受け取り先：4人→全員 / 5人→隊長以外 / その他→先頭から最大4人
    const recipients =
      (tcount === 5)
        ? Array.from({length:tcount}, (_,i)=>i).filter(i => i !== cap)
        : (tcount === 4)
            ? [0,1,2,3]
            : Array.from({length: Math.min(4, tcount)}, (_,i)=>i);

    // 黄コード4枚を抽選（受け取り人数ぶんだけ使用）
    const yList = MATERIALS.yellowCodes.slice(); shuffle(yList);
    const pick  = yList.slice(0, recipients.length);

    // ▼ ミッション詳細に表示（先頭タイトルの直後に ▧行を差し込む）
    try{
      const dispSnap = await get(ref(db, `rooms/${code}/mission/display`));
      const disp = dispSnap.val() || [];
      const yellowLine = '<span style="color:gold;">▧</span>' + pick.map(n => `[${n}]`).join('');
      await update(ref(db, `rooms/${code}/mission`), { display: [disp[0] || '#41', yellowLine, ...disp.slice(1)] });
    }catch(_){}

    
    // テーブルに直接配布（手札へ追加→昇順→α再採番）
    const tablesSnap = await get(ref(db, `rooms/${code}/tables`));
    const tbls = tablesSnap.val() || [];
    const realpha = (hand)=>{ const alpha='abcdefghijklmnopqrstuvwxyz'; hand.forEach((c,i)=> c.alpha = alpha[i%alpha.length]); };

    recipients.forEach((ti, idx)=>{
      const hand = tbls[ti]?.hand || [];
      hand.push({
        id: crypto.randomUUID(),
        num: pick[idx],
        kind: 'yellow',
        open: false,
        ownerId: tbls[ti]?.playerId || null,
        tokens: []
      });
      hand.sort((a,b)=> a.num - b.num);
      realpha(hand);
      tbls[ti].hand = hand;
    });
    // ▼▼ 追加：#41 開始時に「各キャラ下へ 情報トークン(黒) を1枚ずつ」配布（クリック不可・使用で自動消滅）
    //    表示は既存の m22Tokens 描画（char 下の黒トークン列）を流用します。
    //    仕様：各席ランダム 1..12（重複OK）。使用時は consumeM22IfMatches で自動的に取り除かれます。
    try{
      const pool = MATERIALS.numbers.slice();  // [1..12]
      shuffle(pool);
      for (let ti = 0; ti < tbls.length; ti++){
        if (!tbls[ti]) continue;
        const n = pool[ti % pool.length];      // 人数>12 の場合も循環配布（重複可）
        tbls[ti].m22Tokens = [ n ];            // 1枚だけ持たせる
      }
    }catch(_){}



    
    await set(ref(db, `rooms/${code}/tables`), tbls);
  }

/* ここから追加：#48 黄コード3枚を「隊長→次→次」へ直接配布 */
if ((v.mission?.id|0) === 48) {
  const tcount = v.tableCount|0;
  const cap    = v.captainTable|0;
  if (tcount >= 1 && cap >= 0) {                       // ← 安全ガード（入室不能バグ対策）
    const targets = [cap, (cap+1)%tcount, (cap+2)%tcount];

    // ランダムに黄コード 3 つ
    const yList = MATERIALS.yellowCodes.slice(); shuffle(yList);
    const pick  = yList.slice(0, 3);

    // ミッション詳細の先頭に表示（▧[n] を1行差し込み）
    try{
      const dispSnap = await get(ref(db, `rooms/${code}/mission/display`));
      const disp = dispSnap.val() || [];
      const yellowLine = '<span style="color:gold;">▧</span>' + pick.map(n => `[${n}]`).join('');
      await update(ref(db, `rooms/${code}/mission`), { display: [disp[0] || '#48', yellowLine, ...disp.slice(1)] });
    }catch(_){}

    // 直接配布（手札へ追加 → 昇順 → α再採番）
    const tablesSnap = await get(ref(db, `rooms/${code}/tables`));
    const tbls = tablesSnap.val() || [];
    const realpha = (hand)=>{
      const alpha='abcdefghijklmnopqrstuvwxyz';
      hand.forEach((c,i)=> c.alpha = alpha[i%alpha.length]);
    };

    targets.forEach((ti, idx)=>{
      const hand = (tbls[ti]?.hand || []).slice();
      hand.push({
        id: crypto.randomUUID(),
        num: pick[idx],
        kind: 'yellow',
        open: false,
        ownerId: tbls[ti]?.playerId || null,
        tokens: []
      });
      hand.sort((a,b)=> a.num - b.num);
      realpha(hand);
      if (tbls[ti]) tbls[ti].hand = hand;
    });

    await set(ref(db, `rooms/${code}/tables`), tbls);
  }
}
/* ここまで追加：#48 */

  
 // ===== #13：赤コード3枚を「隊長→次→次」へ直接配布＋名前右トークン設定 =====
  if(v.mission?.flags?.m13_distributeRedToCaptain3){
    const tcount = v.tableCount|0;
    const cap = v.captainTable|0;
    const targets = [cap, (cap+1)%tcount, (cap+2)%tcount];
    
    // ランダムに赤コード 3 つ
    const redList = MATERIALS.redCodes.slice(); shuffle(redList);
    const pick = redList.slice(0,3);
// ▼ 追加：選ばれた赤コードをミッション表示に反映（先頭に1行差し込み）
try{
  const dispSnap = await get(ref(db, `rooms/${code}/mission/display`));
  const disp = dispSnap.val() || [];
  const redLine = '<span style="color:red;">●</span>' + pick.map(n => `[${n}]`).join('');
  await update(ref(db, `rooms/${code}/mission`), { display: [disp[0] || '#13', redLine, ...disp.slice(1)] });
}catch(_){}
    const tablesSnap = await get(ref(db, `rooms/${code}/tables`));
    const tbls = tablesSnap.val() || [];
    const realpha = (hand)=>{ const alpha='abcdefghijklmnopqrstuvwxyz'; hand.forEach((c,i)=> c.alpha=alpha[i%alpha.length]); };

    targets.forEach((ti, idx)=>{
      const hand = tbls[ti]?.hand || [];
      hand.push({ id:crypto.randomUUID(), num:pick[idx], kind:'red', open:false, ownerId: tbls[ti]?.playerId||null, tokens:[] });
      hand.sort((a,b)=> a.num - b.num);
      realpha(hand);
      tbls[ti].hand = hand;
    });

    // 名前の右のランダム数字（各テーブル）
    const header = Array.from({length:tcount}, ()=> MATERIALS.numbers[(Math.random()*12)|0]);

    await Promise.all([
      set(ref(db, `rooms/${code}/tables`), tbls),
      update(ref(db, `rooms/${code}/meta`), { m13_header: header })
    ]);
  }



  // ===== #18：アイテムを 8 のみ、かつ P1 山札 =====
  if(Array.isArray(v.mission?.flags?.limitItemsTo)){
    const allow = new Set(v.mission.flags.limitItemsTo);
    const nextItems = (v.items||[]).filter(it => allow.has(it.no));
    await set(ref(db, `rooms/${code}/items`), nextItems);
  }

  // ===== #20：各テーブルで 1 枚を右端へ移動し、黄色✕トークンを付与 =====
  if(v.mission?.flags?.m20_rightmostX){
    const tablesSnap = await get(ref(db, `rooms/${code}/tables`));
    const tbls = tablesSnap.val() || [];
    const alphaStr='abcdefghijklmnopqrstuvwxyz';
    tbls.forEach(T=>{
      const hand = (T.hand||[]).slice().sort((a,b)=> a.num - b.num); // 昇順ベース
      if(hand.length===0) return;
      const ri = (Math.random()*hand.length)|0;
      const chosen = hand.splice(ri,1)[0];
      hand.push(chosen); // 右端へ
      // ✕トークン（黄色）をそのカードに付与
      chosen.tokens = [...(chosen.tokens||[]), {type:'xmark', value:'✕', style:'yellowX'}];
      // α再付与
      hand.forEach((c,i)=> c.alpha = alphaStr[i%alphaStr.length]);
      T.hand = hand;
    });
    await set(ref(db, `rooms/${code}/tables`), tbls);
  }


 /* ここから追加：#38 隊長テーブルのみ 右端✕ */
  if (v.mission?.flags?.m38_captainRightmostX) {
    const captainIdx = (v.captainTable|0);
    if (captainIdx >= 0) {
      const tablesSnap = await get(ref(db, `rooms/${code}/tables`));
      const tbls = tablesSnap.val() || [];
      const T = tbls[captainIdx];
    if (T && Array.isArray(T.hand) && T.hand.length > 0) {
       const alphaStr='abcdefghijklmnopqrstuvwxyz';
        const hand = T.hand.slice().sort((a,b)=> a.num - b.num); // 昇順ベース
        const ri = (Math.random()*hand.length)|0;
        const chosen = hand.splice(ri,1)[0];
        hand.push(chosen); // 右端へ
        chosen.tokens = [ ...(chosen.tokens||[]), {type:'xmark', value:'✕', style:'yellowX'} ];
        hand.forEach((c,i)=> c.alpha = alphaStr[i%alphaStr.length]); // α再付与
      T.hand = hand;
     await set(ref(db, `rooms/${code}/tables`), tbls);
      }
    }
 }

  /* === #64：各手札からランダム2枚→小さい方を左端／大きい方を右端（自分だけ裏） === */
  if ((v.mission?.id|0) === 64) {
    // 二重実行防止
    if (v?.meta?.m64_init === true) { /* 既に完了 */ }
    else if (state.isHost) {
      try{
        const tSnap = await get(ref(db, `rooms/${code}/tables`));
        const tbls = tSnap.val() || [];
        const realpha = (hand)=>{ const alpha='abcdefghijklmnopqrstuvwxyz'; hand.forEach((c,i)=> c.alpha = alpha[i%alpha.length]); };

        for (let ti = 0; ti < tbls.length; ti++){
          const T = tbls[ti] || {};
          const hand = Array.isArray(T.hand) ? T.hand.slice() : [];
          if (hand.length < 2) continue;

          // ランダムに2枚抽出（重複なし）
          const idxs = Array.from({length: hand.length}, (_,i)=>i);
          shuffle(idxs);
          const aIdx = idxs[0], bIdx = idxs[1];
          const A = hand[aIdx], B = hand[bIdx];
          if (!A || !B) continue;

          // 小さい方→左端 / 大きい方→右端（同数なら抽出順）
          const leftCard  = (A.num|0) < (B.num|0) ? A : (A.num|0) > (B.num|0) ? B : A;
          const rightCard = (leftCard === A) ? B : A;

          // 2枚を元の配列から除去
          const leftId = leftCard.id, rightId = rightCard.id;
          const rest = hand.filter(c => c && c.id !== leftId && c.id !== rightId);

          // xmark 付与（重複防止）
          const putX = (c)=>{
            const tokens = Array.isArray(c.tokens) ? c.tokens.slice() : [];
            if (!tokens.some(tk => tk?.type === 'xmark')) tokens.push({type:'xmark'});
            return { ...c, tokens };
          };

          const newHand = [ putX(leftCard), ...rest, putX(rightCard) ];
          realpha(newHand);
          tbls[ti].hand = newHand;
        }

        await Promise.all([
          set(ref(db, `rooms/${code}/tables`), tbls),
          update(ref(db, `rooms/${code}/meta`), { m64_init: true })
        ]);
      }catch(e){ console.error('[M64 init]', e); }
    }
  }

  
  /* ここまで追加 */
  // #39：初期化（task1〜3）
if ((v.mission?.id|0) === 39) {
  // 1) 各テーブル：手札にない数字からランダム1つを m22Tokens に付与
  const tblRef = ref(db, `rooms/${code}/tables`);
  const tblSnap = await get(tblRef);
  const tbls    = tblSnap.val() || [];
  const allNums = MATERIALS.numbers.slice();

  tbls.forEach(T=>{
    const tok = allNums[(Math.random()*allNums.length)|0]; // ← 手札は見ない
    const row = Array.isArray(T.m22Tokens) ? T.m22Tokens.slice() : [];
    if (!row.includes(tok)) row.push(tok);                 // 既存は保持しつつ1つ追加
    T.m22Tokens = row;
  });

  // 2) X を決定、3) X を除く 11 枚から 8 枚の山札
  const X    = allNums[(Math.random()*allNums.length)|0];
  const rest = allNums.filter(n=> n!==X); shuffle(rest);
  const deck8 = rest.slice(0,8);

  await Promise.all([
    set(tblRef, tbls),
    update(ref(db, `rooms/${code}/meta`), {
      m39_x: X,
      m39_deck: deck8,
      m39_discards: [],
      m39_dealt: false
    })
  ]);
}

  // #26：1〜12を3×4で配置（裏表トグル）
  if (flags.m26_grid12) {
    mountM26GridUnderItems();
  }
  
// #31：A〜E を各テーブルに1枚ずつ（人数>5のときは循環）
if ((v.mission?.id|0) === 31 || (v.mission?.id|0) === 34) {
  const codeSnap = await get(ref(db, `rooms/${code}`));
  const vv = codeSnap.val() || {};
  const tables = (vv.tables||[]).map(T => ({...T}));
  const letters = ['A','B','C','D','E']; shuffle(letters);
  for (let i=0; i<tables.length; i++){
    if (!tables[i].m31Con) tables[i].m31Con = letters[i % letters.length];
  }
  await update(ref(db, `rooms/${code}`), {
    tables,
   m31_center: []
  });
}
  function randNum(){ return MATERIALS.numbers[(Math.random()*12)|0]; }
}

/* ==== 数値カード表示ユーティリティ ==== */
function buildNumLaneDOM(cells){
  const lane = document.createElement('div'); lane.className='numlane';
  cells.forEach(c=>{
    const div = document.createElement('div');
    if(c.kind==='rule'){ div.className='rulecard'; div.style.backgroundImage=`url('${c.img}')`; }
    if(c.kind==='num'){  div.className='numcard';  div.style.backgroundImage=`url('${c.img}')`; }
    lane.appendChild(div);
  });
  return lane;
}
function mountLaneUnderItemsBar(lane){
  const bar = document.getElementById('itemsBar');
  bar.insertAdjacentElement('afterend', lane);
}

/* パターン1：山札→めくる */
function buildDeckLaneP1(){
  const lane = document.createElement('div'); 
  lane.className='numlane';

  // 1..12 のみ・重複なしの山札
  const deck = MATERIALS.numbers.slice(); 
  shuffle(deck);
  let rest = deck.length;

  // 山札ボタンと残表示
  const deckBtn = document.createElement('div');
  deckBtn.className='numdeck';
  deckBtn.title='めくる';

  const restLbl = document.createElement('span');
  restLbl.className='numrest';
  restLbl.textContent=`残:${rest}`;

  // ★ 右側に公開札積み重ね用ホルダー
  const pile = document.createElement('div');
  pile.className = 'numcard-holder';
  pile.style.position = 'relative';

  lane.appendChild(deckBtn);
  lane.appendChild(restLbl);
  lane.appendChild(pile);

  // 積み重ね追加
  function addToPile(n){
    const already = pile.querySelectorAll('.numcard').length;
    const node = document.createElement('div');
    node.className = 'numcard';
    node.style.backgroundImage = `url('${imgNumber(n)}')`;

    if(already>0){
      const off = already * 2; // 2px刻み
      node.style.position = 'absolute';
      node.style.left = off + 'px';
      node.style.top  = off + 'px';
    }
    pile.appendChild(node);

    // ★ 高さ調整（見切れ防止）
    const extraH = already * 2; // 下方向へのズレ分
    pile.style.height = (48 + extraH) + 'px'; // 48pxはカード高さ
    lane.style.marginBottom = extraH + 'px'; // テーブルを少し下げる
  }

  deckBtn.onclick = (ev)=>{
    if(rest<=0){
      openOneMini(ev.clientX, ev.clientY, '山札を作る', async ()=>{
        deck.splice(0, deck.length, ...MATERIALS.numbers.slice()); 
        shuffle(deck);
        rest = deck.length;
        restLbl.textContent = `残:${rest}`;
        deckBtn.style.backgroundImage = `url('./numberdeck.png')`;
        deckBtn.style.background = '';
        deckBtn.title = 'めくる';
        pile.innerHTML = '';
        pile.style.height = '48px';
        lane.style.marginBottom = '0px';
        NUMCARD_REG.clear();
      });
      return;
    }

    const n = deck.pop();
    rest--;
    restLbl.textContent = `残:${rest}`;
    addToPile(n);


   
    if(rest===0){
      deckBtn.style.background = `#fff url('${imgBack}') center/60% no-repeat`;
      deckBtn.title='山札を作る';
    }
  };

  return lane;
}
/* 制約カード版：P1（山札→めくる）*/
function buildConDeckLaneP1(){
  // ミッション31と同じ見た目サイズにするため、帯は conlane、カードは concard を使う
  const lane = document.createElement('div');
  lane.className = 'conlane';
  lane.id = 'm32ConRow'; // 念のため一意ID

  // 制約カード12枚（A〜L）
  const deck = 'ABCDEFGHIJKL'.split('');
  shuffle(deck);
  let rest = deck.length;

  // 山札ボタンと残表示（数値P1と同じUI部品を流用）
  const deckBtn = document.createElement('div');
  deckBtn.className = 'numdeck';   // 見た目は共通のデッキボタンでOK
  deckBtn.title = 'めくる';
 deckBtn.style.background = "#fff url('./conback.jpg') center/70% no-repeat"; 
  const restLbl = document.createElement('span');
  restLbl.className = 'numrest';
  restLbl.textContent = `残:${rest}`;

  // 右側に公開札の積み重ね置き場（制約カードは concard で積む）
  const pile = document.createElement('div');
  pile.className = 'numcard-holder';
  pile.style.position = 'relative';

  lane.appendChild(deckBtn);
  lane.appendChild(restLbl);
  lane.appendChild(pile);

    // 1枚めくって公開札（右側）に積む：挙動は数値P1と同じ
    const addToPile = (ch)=>{
      const node = document.createElement('div');
      node.className = 'concard';
      node.style.backgroundImage = `url('${imgConstraint(ch)}')`;

      const already = pile.querySelectorAll('.concard').length;
      const off = already * 2;

      if (already > 0){
        node.style.position = 'absolute';
        node.style.left = off + 'px';
        node.style.top  = off + 'px';
      }
   node.title = '拡大';
　　node.onclick = (ev)=>{ ev.stopPropagation(); openConstraintZoom(ch); };
      pile.appendChild(node);

      // ★ ここから変更：1枚目でも必ず高さ/余白を更新する
      const baseH = cssNum('--con-h') || cssNum('--item-h') || 75;
      pile.style.height = (baseH + off) + 'px';
      lane.style.marginBottom = off + 'px';
      // ★ ここまで変更
    };

  deckBtn.onclick = ()=>{
    if (rest <= 0) return;
    const ch = deck.pop(); // 末尾から1枚
    rest -= 1;
    restLbl.textContent = `残:${rest}`;
    addToPile(ch);
  };

  return lane;
}
  
/* パターン2：デッキからn枚→並べる（アイテム下） */
function buildDeckLaneP2(n=2){
  const lane = document.createElement('div'); lane.className='numlane';
  const deck = MATERIALS.numbers.slice(); shuffle(deck);
  const picks = deck.slice(0, n);
  picks.forEach(x=>{
    const nc = document.createElement('div'); nc.className='numcard'; nc.style.backgroundImage=`url('${imgNumber(x)}')`;
    lane.appendChild(nc);
  });
  return lane;
}

/* パターン3：指定カードを固定並べ（必要時） */
function buildFixedLane(list){
  return buildNumLaneDOM(list.map(n=>({kind:'num',img:imgNumber(n)})));
}

  /* ===== #9：右2 + 異なる数値2枚（同期表示） ===== */
  function renderM9(v){
    const isM9 = ((v?.mission?.id|0) === 9);
   const old = document.getElementById('m9Row');
    if (!isM9){ if(old) old.remove(); return; }
    // メタ（ホストが開始時に保存）
    const nums = Array.isArray(v?.meta?.m9_numbers) ? v.meta.m9_numbers : null;
    const rule = v?.meta?.m9_rule || 'right2';
    if (!nums || nums.length < 2) return; // 未準備なら何もしない（次のonValueで描画）
   if (old) old.remove();
    // [右2][数][数] をアイテム列の直下に表示
    const lane = buildNumLaneDOM([
      {kind:'rule', img: imgRule(rule)},
      {kind:'num',  img: imgNumber(nums[0])},
      {kind:'num',  img: imgNumber(nums[1])},
    ]);
    lane.id = 'm9Row';
    mountLaneUnderItemsBar(lane);
  }
/* ここから追加：#11 数値カード1枚（同期表示） */
async function ensureM11MetaInit(vNow){
  const v = vNow || state.watching; if (!v) return;
  // 既に用意済みなら何もしない／初期化はホストのみ
  if ((v?.meta?.m11_number|0) > 0) return;
  if (!state.isHost) return;

  // まだ場に使われていない数字から1枚選ぶ（重複防止ユーティリティを活用）
  const pick = (typeof pickUnusedNumbers === 'function')
    ? pickUnusedNumbers(1)[0]
    : MATERIALS.numbers[Math.random()*MATERIALS.numbers.length|0];

  await update(ref(db, `rooms/${state.roomCode}/meta`), { m11_number: pick });
}

function renderM11(v){
  const isM11 = ((v?.mission?.id|0) === 11);
  const rowId = 'm11Row';
  const old   = document.getElementById(rowId);
  if (!isM11){ if (old) old.remove(); return; }

  // 初回：ホストが m11_number を用意（未用意なら用意して次のonValueで描画）
  if ((v?.meta?.m11_number|0) === 0){ ensureM11MetaInit(v); if (old) old.remove(); return; }

  if (old) old.remove();
  const lane = document.createElement('div');
  lane.id = rowId;
  lane.className = 'numlane';

  // 数値カード1枚を配置（重複禁止の登録つき）
  const N = v?.meta?.m11_number|0;
  if (typeof placeNumberCard === 'function'){
    placeNumberCard(N, lane);     // 既存UI登録ユーティリティ
  }else{
    // フォールバック（ユーティリティが無い場合）
    const holder = document.createElement('div');
    holder.className = 'numcard-holder';
    const nc = document.createElement('div');
    nc.className = 'numcard';
    nc.style.backgroundImage = `url('${imgNumber(N)}')`;
    holder.appendChild(nc);
    lane.appendChild(holder);
  }

  // DOM設置：アイテム列の直下（#39等と同じ）
  mountLaneUnderItemsBar(lane);
}

function renderM12(v){
  const isM12 = ((v?.mission?.id|0) === 12);
  const old = document.getElementById('m12UnderRow');
  if (!isM12){ if (old) old.remove(); return; }

  const itemsBar = document.getElementById('itemsBar');
  const items    = document.querySelectorAll('#items .item');
  const arr      = Array.isArray(v?.meta?.m12_under) ? v.meta.m12_under.slice(0, items.length) : null;

  // アイテムがまだ描画されていない／meta 未準備の瞬間はスキップ（次の onValue で描画）
  if (!itemsBar || items.length === 0 || !arr || arr.length < items.length) return;

  if (old) old.remove();

  const under = document.createElement('div');
  under.id = 'm12UnderRow';
  under.className = 'num-under';          // 既存CSS。アイテム外側の真下に横並びで配置 :contentReference[oaicite:4]{index=4}

  arr.forEach(n=>{
    const slot   = document.createElement('div');
    slot.className = 'slot';

    const holder = document.createElement('div');  // 既存のカード枠（重ね表現と整合）
    holder.className = 'numcard-holder';           // :contentReference[oaicite:5]{index=5}

    const card   = document.createElement('div');
    card.className = 'numcard';
    card.style.backgroundImage = `url('${imgNumber(n)}')`;

    holder.appendChild(card);
    slot.appendChild(holder);
    under.appendChild(slot);

    // 他のレーンと同じユニーク管理に合わせる（同数の多重表示を避ける仕様）
    NUMCARD_REG.set(n, holder);                    // :contentReference[oaicite:6]{index=6}
  });

  itemsBar.insertAdjacentElement('afterend', under); // 既存ユーティリティ相当の挿入位置 :contentReference[oaicite:7]{index=7}
}

/* ===== #23：数値1枚 固定表示 + 右側にアイテム山札（同期） ===== */
async function ensureM23NumberInit(vNow){
  const v = vNow || state.watching; if(!v) return;
  if (v?.mission?.id !== 23) return;
  const has = (v.meta && (v.meta.m23_number|0) > 0);
  if (has) return;
  if (!state.isHost) return; // 初期化はホストのみ
  const n = MATERIALS.numbers[(Math.random()*MATERIALS.numbers.length)|0] | 0; // 1..12
  await update(ref(db, `rooms/${state.roomCode}/meta`), { m23_number: n });
}

function renderM23(v){
  const isM23 = ((v?.mission?.id|0) === 23);
  const rowId = 'm23Row';
  const old = document.getElementById(rowId);
  if (!isM23){ if (old) old.remove(); return; }

  // 数値＆アイテム山のメタが未準備ならホストが準備して次tickへ
  if (!((v?.meta?.m23_number|0) > 0)) { ensureM23NumberInit(v); if (old) old.remove(); return; }
  if (!Array.isArray(v?.meta?.m23_deck)) { ensureM23MetaInit().then(()=>{}); if (old) old.remove(); return; }

  if (old) old.remove();
  const lane = document.createElement('div');
  lane.id = rowId;
  lane.className = 'numlane';

  // 左：数値1枚を固定表示（全員に同期）
  const N = v?.meta?.m23_number|0;
  if (N){
    const nc = document.createElement('div');
   nc.className = 'numcard';
    nc.style.backgroundImage = `url('${imgNumber(N)}')`;
    lane.appendChild(nc);
  }

  // 右：アイテム山札UI（※広げ済みは表示しない）
  if (!(v?.meta?.m23_spread)) {
    attachM23DeckUI(lane);
  }
  // アイテム列の直下に設置（#39等と同じユーティリティ）
 mountLaneUnderItemsBar(lane);
}  
 
/* ===== ★ #23：アイテム山（7枚）を数値山レーンの右側に表示 ===== */
async function ensureM23MetaInit(){
  const v = state.watching; if(!v) return;
  if (Array.isArray(v?.meta?.m23_deck)) return; // 既に初期化済み
  const pool = itemDeckNumbers(v?.mission?.id || 23).slice(); // 1..13 or 1..12
  shuffle(pool);
  const seven = pool.slice(0,7);
  await update(ref(db, `rooms/${state.roomCode}/meta`), {
    m23_deck: seven,        // 山札（番号配列）
   m23_discards: [],       // 捨て札
    m23_spread: false,      // 広げたか？
    m23_drawnNumbers: []    // 数値山で表になった数値
  });
}

  /* ===== #18：数値カード山札（同期表示） ===== */
  async function ensureM18MetaInit(vNow){
    const v = vNow || state.watching; if (!v) return;
   if (Array.isArray(v?.meta?.m18_deck)) return;        // 既に初期化済み
    if (!state.isHost) return;                            // 初期化はホストのみ
    const deck = MATERIALS.numbers.slice(); shuffle(deck); // 1..12 をシャッフル
    await update(ref(db, `rooms/${state.roomCode}/meta`), {
      m18_deck: deck,
      m18_discards: []
   });
  }

 function renderM18(v){
   const isM18 = ((v?.mission?.id|0) === 18);
    const rowId = 'm18Row';
   const old = document.getElementById(rowId);
    if (!isM18){ if (old) old.remove(); return; }
    // 初回のみホストがメタを準備（未用意なら用意して次のonValueで描画）
    if (!Array.isArray(v?.meta?.m18_deck)) { ensureM18MetaInit(v); if (old) old.remove(); return; }

    if (old) old.remove();
    const lane = document.createElement('div');
    lane.id = rowId;
    lane.className = 'numlane';

    // 山札（数値）ボタンと残枚数
   const deckBtn = document.createElement('div');
   deckBtn.className = 'numdeck';
  deckBtn.title = 'めくる';

    const restLbl = document.createElement('span');
   restLbl.className = 'numrest';
   // 公開札の積み重ね
    const pile = document.createElement('div');
    pile.className = 'numcard-holder';
   pile.style.position = 'relative';
   lane.appendChild(deckBtn);
    lane.appendChild(restLbl);
    lane.appendChild(pile);

    const refresh = ()=>{
      const d = (v?.meta?.m18_deck||[]);
      const x = (v?.meta?.m18_discards||[]);
      const remain = d.filter(n=>!x.includes(n)).length;
      restLbl.textContent = `残:${remain}`;
      pile.innerHTML = '';
      x.forEach((n, i)=>{
       const node = document.createElement('div');
        node.className = 'numcard';
        node.style.backgroundImage = `url('${imgNumber(n)}')`;
        if (i>0){
         const off = i*2;
         node.style.position='absolute';
          node.style.left = off+'px';
          node.style.top  = off+'px';
        }
        pile.appendChild(node);
        const extra = i*2;
        pile.style.height = (48+extra)+'px';
      lane.style.marginBottom = extra+'px';
     });
    };
    refresh();

    // 1枚めくって公開札へ → DB(meta.m18_discards) を更新（全員に即同期）
deckBtn.onclick = async (ev)=>{
  try{
    const mRef = ref(db, `rooms/${state.roomCode}/meta`);
    const mSnap = await get(mRef);
    const meta  = mSnap.val()||{};
    const D = Array.isArray(meta.m18_deck) ? meta.m18_deck.slice() : [];
    const Xs = Array.isArray(meta.m18_discards) ? meta.m18_discards.slice() : [];

    const next = D.find(n=> !Xs.includes(n)); // 山札順で次
    if (next==null){
      openOneMini(ev.clientX, ev.clientY, '山札を作り直す', async ()=>{
        const newDeck = MATERIALS.numbers.slice(); shuffle(newDeck);
        await update(mRef, { m18_deck: newDeck, m18_discards: [] });
      });
      return;
    }
    Xs.push(next);
    await update(mRef, { m18_discards: Xs });
  }catch(e){ console.error(e); }
};


    // アイテム列の直下に設置（既存ユーティリティ使用）
    mountLaneUnderItemsBar(lane);
  }

   function renderM19(v){
     const isM19 = ((v?.mission?.id|0) === 19);
     const barId = 'm19AudioBar';
     const audioId = 'm19Audio';
     const oldBar = document.getElementById(barId);
     if (!isM19){ if (oldBar) oldBar.remove(); return; }

     let audio = document.getElementById(audioId);
     if (!audio){
       audio = document.createElement('audio');
       audio.id = audioId;
       audio.preload = 'auto';
       audio.src = './mi19.mp3';
       audio.crossOrigin = 'anonymous';
       audio.style.display = 'none';
       document.body.appendChild(audio);
     }

     if (state.isHost){
       if (oldBar) oldBar.remove();
       const bar = document.createElement('div');
       bar.id = barId;
       bar.className = 'line';
       bar.innerHTML = `
         <button class="btn small" id="m19Back10">⏪ 10秒</button>
         <button class="btn small" id="m19Play">▶</button>
         <button class="btn small" id="m19Pause">⏸</button>
         <input id="m19Seek" type="range" min="0" max="0" value="0" step="0.1" style="vertical-align:middle; width:240px; margin:0 8px;">
         <span id="m19Time">0:00</span>
       `;
       const footer = document.getElementById('missionFooter');
       if (footer && !footer.classList.contains('hidden')) {
         footer.appendChild(bar);
       }

       const btnBack = document.getElementById('m19Back10');
       const btnPlay = document.getElementById('m19Play');
       const btnPause= document.getElementById('m19Pause');
       const seek    = document.getElementById('m19Seek');
       const timeLbl = document.getElementById('m19Time');

       const fmt = (t)=> {
         const s = Math.max(0, Math.floor(t|0));
         const m = (s/60)|0; const r = s%60;
         return `${m}:${String(r).padStart(2,'0')}`;
       };
       const writeMeta = async (playing)=>{
         const payload = {
           m19_audio: {
             playing: !!playing,
             t: audio.currentTime||0,
             at: Date.now()
           }
         };
         await update(ref(db, `rooms/${state.roomCode}/meta`), payload);
       };
       const refreshDur = ()=>{
         const dur = isFinite(audio.duration) ? Math.max(0, audio.duration) : 0;
         seek.max = String(dur || 0);
       };
       if (isNaN(audio.duration) || !isFinite(audio.duration)){
         audio.addEventListener('loadedmetadata', refreshDur, { once:true });
       } else {
         refreshDur();
       }
       const refreshLocal = ()=>{
         timeLbl.textContent = fmt(audio.currentTime||0);
         if (!document.activeElement || document.activeElement !== seek){
           seek.value = String(audio.currentTime||0);
         }
       };
       refreshLocal();
       audio.addEventListener('timeupdate', refreshLocal);

       btnPlay.onclick = async ()=>{
         try{ await audio.play(); }catch(_e){}
         await writeMeta(true);
       };
       btnPause.onclick = async ()=>{
         try{ audio.pause(); }catch(_e){}
         await writeMeta(false);
       };
       btnBack.onclick = async ()=>{
         audio.currentTime = Math.max(0, (audio.currentTime||0) - 10);
         await writeMeta(!audio.paused);
       };
       seek.oninput = ()=>{ timeLbl.textContent = fmt(Number(seek.value||'0')); };
       seek.onchange = async ()=>{
         audio.currentTime = Number(seek.value||'0');
         await writeMeta(!audio.paused);
       };
     } else {
       if (oldBar) oldBar.remove();
     }

     
     const data = v?.meta?.m19_audio || null;
     if (data){
       const elapsed = Math.max(0, (Date.now() - (data.at||0)) / 1000);
       const target = Math.max(0, (data.t||0) + (data.playing ? elapsed : 0));
       if (Math.abs((audio.currentTime||0) - target) > 0.5){
         audio.currentTime = target;
       }
       if (data.playing && audio.paused){
         audio.play().catch(()=>{
           if (!document.getElementById('m19Unlock')){
             const div = document.createElement('div');
             div.id = 'm19Unlock';
             div.className = 'mini-pop bottom-pop';
             div.innerHTML = `<button class="btn small">音声を有効化（ワンタップ）</button>`;
             div.onclick = async ()=>{
               try{ await audio.play(); }catch(_e){}
               div.remove();
             };
             document.getElementById('popLayer')?.appendChild(div);
           }
         });
       }
       if (!data.playing && !audio.paused){
         audio.pause();
       }
     }
   }
  
/* ===== #15：数値カード山札（同期表示｜#39/#18に準拠） ===== */
async function ensureM15MetaInit(vNow){
  const v = vNow || state.watching; if (!v) return;
  if (Array.isArray(v?.meta?.m15_deck)) return;   // 既に初期化済み
  if (!state.isHost) return;                       // 初期化はホストのみ
  const deck = MATERIALS.numbers.slice(); shuffle(deck); // 1..12 をシャッフル
  await update(ref(db, `rooms/${state.roomCode}/meta`), {
    m15_deck: deck,
    m15_discards: []
  });
}

function renderM15(v){
 const mid   = (v?.mission?.id|0);
  const isM15 = (mid === 15 || mid === 45 || mid === 51); // ← #45でも動かす
  const rowId = 'm15Row';
  const old   = document.getElementById(rowId);
  if (!isM15){ if (old) old.remove(); return; }
  // 初回のみホストがメタを準備（未用意なら用意して次のonValueで描画）
  if (!Array.isArray(v?.meta?.m15_deck)) { ensureM15MetaInit(v); if (old) old.remove(); return; }

  if (old) old.remove();
  const lane = document.createElement('div');
  lane.id = rowId;
  lane.className = 'numlane';

  // 山札（数値）ボタンと残枚数
  const deckBtn = document.createElement('div');
  deckBtn.className = 'numdeck';
  deckBtn.title = 'めくる';

  const restLbl = document.createElement('span');
  restLbl.className = 'numrest';

  // 公開札の積み重ね
  const pile = document.createElement('div');
  pile.className = 'numcard-holder';
  pile.style.position = 'relative';

  lane.appendChild(deckBtn);
  lane.appendChild(restLbl);
  lane.appendChild(pile);

  const refresh = ()=>{
    const d = (v?.meta?.m15_deck||[]);
    const x = (v?.meta?.m15_discards||[]);
    const remain = d.filter(n=>!x.includes(n)).length;
    restLbl.textContent = `残:${remain}`;

    pile.innerHTML = '';
    x.forEach((n, i)=>{
      const node = document.createElement('div');
      node.className = 'numcard';
      node.style.backgroundImage = `url('${imgNumber(n)}')`;
      if (i>0){
        const off = i*2;
        node.style.position='absolute';
        node.style.left = off+'px';
        node.style.top  = off+'px';
      }
      pile.appendChild(node);
      const extra = i*2;
      pile.style.height = (48+extra)+'px';
      lane.style.marginBottom = extra+'px';
    });
  };
  refresh();

  // 1枚めくって公開札へ → DB(meta.m15_discards) を更新（全員に即同期）
// 1枚めくる。空なら「山札を作り直す」タブを出す（全員同期）
deckBtn.onclick = async (ev)=>{
  try{
    const mRef = ref(db, `rooms/${state.roomCode}/meta`);
    const mSnap = await get(mRef);
    const meta  = mSnap.val()||{};
    const D = Array.isArray(meta.m15_deck) ? meta.m15_deck.slice() : [];
    const Xs = Array.isArray(meta.m15_discards) ? meta.m15_discards.slice() : [];

    const next = D.find(n=> !Xs.includes(n)); // 山札順で次
    if (next==null){
      // 山札切れ → 作り直しメニュー
      openOneMini(ev.clientX, ev.clientY, '山札を作り直す', async ()=>{
        const newDeck = MATERIALS.numbers.slice(); shuffle(newDeck);
        await update(mRef, { m15_deck: newDeck, m15_discards: [] });
      });
      return;
    }
    Xs.push(next);
    await update(mRef, { m15_discards: Xs });
  }catch(e){ console.error(e); }
};


  // DOM設置：アイテム列の直下
  mountLaneUnderItemsBar(lane);
}


/* ===== #30：数値カード山札（同期）─ 1/2/3枚ポップ対応 ===== */
async function ensureM30MetaInit(vNow){
  const v = vNow || state.watching; if (!v) return;
  if (((v?.mission?.id|0) !== 30)) return;
  if (Array.isArray(v?.meta?.m30_deck)) return;  // 既に初期化済み
  if (!state.isHost) return;                      // 初期化はホストのみ
  const deck = MATERIALS.numbers.slice(); shuffle(deck); // 1..12 をシャッフル
  await update(ref(db, `rooms/${state.roomCode}/meta`), {
    m30_deck: deck,       // 山札順
    m30_used: [],         // 山札から使用済み（1/2/3いずれもここに積む）
    m30_pile: [],         // 1枚ドロー分（右の公開札に積み重ね表示）
    m30_row:  []          // 2枚 or 3枚ドローの“横並び表示”の現行セット
  });
}

function renderM30(v){
  const isM30 = ((v?.mission?.id|0) === 30);
  const rowId = 'm30Row';
  const old   = document.getElementById(rowId);
  if (!isM30){ if (old) old.remove(); return; }

  // 初回：ホストが meta を用意（未用意なら用意して次の onValue で描画）
  if (!Array.isArray(v?.meta?.m30_deck)){ ensureM30MetaInit(v); if (old) old.remove(); return; }

  if (old) old.remove();
  const lane = document.createElement('div');
  lane.id = rowId;
  lane.className = 'numlane';

  // 山札ボタン + 残表示
  const deckBtn = document.createElement('div');
  deckBtn.className = 'numdeck';
  deckBtn.title = 'めくる';

  const restLbl = document.createElement('span');
  restLbl.className = 'numrest';

  // 右：1枚ドローの公開札（積み重ね）
  const pile = document.createElement('div');
  pile.className = 'numcard-holder';
  pile.style.position = 'relative';

  // 下：2/3枚ドローの横並び
  const row = document.createElement('div');
  row.style.display = 'flex';
  row.style.gap = '6px';

  lane.appendChild(deckBtn);
  lane.appendChild(restLbl);
  lane.appendChild(pile);
  lane.appendChild(row);

  // 描画リフレッシュ（#15/#39と同じ積み重ねロジック） 
  const refresh = ()=>{
    const d = (v?.meta?.m30_deck||[]);
    const used = (v?.meta?.m30_used||[]);
    const remain = d.filter(n => !used.includes(n)).length;
    restLbl.textContent = `残:${remain}`;

    // 右側：1枚公開札の積み重ね（2pxオフセット）
    pile.innerHTML = '';
    const xs = (v?.meta?.m30_pile||[]);
    xs.forEach((n,i)=>{
      const node = document.createElement('div');
      node.className = 'numcard';
      node.style.backgroundImage = `url('${imgNumber(n)}')`;
      if (i>0){
        const off = i*2;
        node.style.position='absolute';
        node.style.left = off+'px';
        node.style.top  = off+'px';
      }
      pile.appendChild(node);
      const extra = i*2;
      pile.style.height = (48+extra)+'px';
      lane.style.marginBottom = extra+'px';
    });

    // 下段：2/3ドローの横並び
    row.innerHTML = '';
    (v?.meta?.m30_row||[]).forEach(n=>{
      const nc = document.createElement('div');
      nc.className = 'numcard';
      nc.style.backgroundImage = `url('${imgNumber(n)}')`;
      row.appendChild(nc);
    });
  };
  refresh();

  // クリックで 1/2/3 を選ぶ（メニューは既存の openMenu を使用）
  deckBtn.onclick = (ev)=>{
    const d = (v?.meta?.m30_deck||[]);
    const used = (v?.meta?.m30_used||[]);
    const remain = d.filter(n => !used.includes(n)).length;

    const make = (k)=> async ()=>{
      try{
        const mRef = ref(db, `rooms/${state.roomCode}/meta`);
        const mSnap = await get(mRef);
        const meta  = mSnap.val()||{};
        const D = Array.isArray(meta.m30_deck) ? meta.m30_deck.slice() : [];
        const U = Array.isArray(meta.m30_used) ? meta.m30_used.slice() : [];
        const P = Array.isArray(meta.m30_pile) ? meta.m30_pile.slice() : [];
        // 山札順から未使用を k 枚取得
        const pick = [];
        for (const n of D){
          if (!U.includes(n)){ pick.push(n); if (pick.length===k) break; }
        }
        if (pick.length < k) return; // 足りなければ何もしない

          // ★ 以前の挙動に合わせる：常に「1枚目→右に積む」「残り→下段」
        const first = pick[0];
        const rest  = pick.slice(1);
            // ★ 常に“最新のみ可視化”：前回表示は消し、今回分だけを保存
        const patch = {
          m30_used: U.concat(pick),  // 使用履歴は蓄積
          m30_pile: [first],         // 右の公開札は常に1枚だけ（上書き）
          m30_row : rest             // 下段は今回の残りだけ（置き換え）
        };
        await update(mRef, patch);
      }catch(e){ console.error(e); }
    };

    const rebuild = async ()=>{
      try{
        const deck = MATERIALS.numbers.slice(); shuffle(deck);
        await update(ref(db, `rooms/${state.roomCode}/meta`), {
          m30_deck: deck, m30_used: [], m30_pile: [], m30_row: []
        });
      }catch(e){ console.error(e); }
    };

    const menu = [];
    if (remain >= 1) menu.push({label:'1', action: make(1)});
    if (remain >= 2) menu.push({label:'2', action: make(2)});
    if (remain >= 3) menu.push({label:'3', action: make(3)});
    if (remain === 0) menu.push({label:'山札を作り直す', action: rebuild});
    openMenu(ev.clientX, ev.clientY, menu);
  };

  // DOM設置：アイテム列の直下（他ミッションと同じ）
  mountLaneUnderItemsBar(lane);
}

/* ここから追加：#36 数値5枚＋左2/右2（同期表示） */
async function ensureM36MetaInit(vNow){
  const v = vNow || state.watching; if (!v) return;
  if (((v?.mission?.id|0) !== 36)) return;

  // 数値5枚が未確定ならホストが一度だけ確定
  if (!Array.isArray(v?.meta?.m36_numbers) || v.meta.m36_numbers.length !== 5){
    if (!state.isHost) return;
    const picks = (typeof pickUnusedNumbers === 'function')
      ? pickUnusedNumbers(5)
      : MATERIALS.numbers.slice().sort(()=>Math.random()-0.5).slice(0,5);

    await update(ref(db, `rooms/${state.roomCode}/meta`), {
      m36_numbers: picks,
      m36_side: null    // ← 左右どちらもブランクで開始
    });
     await update(ref(db, `rooms/${state.roomCode}/meta`), {
       m36_numbers: picks,
       m36_side: null,   // ← 左右どちらもブランクで開始
       m36_faceDown: []  // ← 追加：裏向きにしている数値のリスト（同期）
     });
    return;
  }

  // 数値は確定済みだが m36_side が未定義なら補完（ホストのみ）
  if (typeof v?.meta?.m36_side === 'undefined' && state.isHost){
    await update(ref(db, `rooms/${state.roomCode}/meta`), { m36_side: null });
  }
}

function renderM36(v){
  const isM36 = ((v?.mission?.id|0) === 36);
  const rowId = 'm36Row';
  const old   = document.getElementById(rowId);
  if (!isM36){ if (old) old.remove(); return; }

  const nums = Array.isArray(v?.meta?.m36_numbers) ? v.meta.m36_numbers : null;
  if (!nums || nums.length < 5){ ensureM36MetaInit(v); if (old) old.remove(); return; }

  if (old) old.remove();

  // レーン（土台）
  const lane = document.createElement('div');
  lane.id = rowId;
  lane.className = 'numlane';

  // ユーティリティ：カードDOM（背景未指定＝ブランク）
  const mkCard = (imgUrl)=>{
    const d = document.createElement('div');
    d.className = 'numcard';
    if (imgUrl) d.style.backgroundImage = `url('${imgUrl}')`;
    return d;
  };

  // 左ブランク（クリックで左に right2）
  const leftSlot = mkCard(null);
  leftSlot.classList.add('m36-slot','m36-left');
  leftSlot.title = 'クリックで右2を表示';
  leftSlot.classList.remove('numcard');
  leftSlot.classList.add('rulecard');
  leftSlot.onclick = async (ev)=>{
    ev.stopPropagation();
    await update(ref(db, `rooms/${state.roomCode}/meta`), { m36_side: 'L' });
  };

  // 数値5枚（中央）
  const n0 = mkCard(imgNumber(nums[0]));
  const n1 = mkCard(imgNumber(nums[1]));
  const n2 = mkCard(imgNumber(nums[2]));
  const n3 = mkCard(imgNumber(nums[3]));
  const n4 = mkCard(imgNumber(nums[4]));
  // ★ 追加：裏向きトグル（同期）
  const downs = new Set(Array.isArray(v?.meta?.m36_faceDown) ? v.meta.m36_faceDown : []);
  const nodes = [n0, n1, n2, n3, n4];
  nodes.forEach((node, i)=>{
    const num = nums[i];
    // 初期反映：裏向きなら裏面を表示
    if (downs.has(num)) {
      node.style.backgroundImage = `url('${imgBack}')`;
    }
    // クリックで表⇄裏トグル（全員同期）
    node.onclick = async (ev)=>{
      ev.stopPropagation();
      const cur = state.watching?.meta?.m36_faceDown;
      const arr = Array.isArray(cur) ? cur.slice() : [];
      const idx = arr.indexOf(num);
      if (idx >= 0) arr.splice(idx, 1); else arr.push(num);
      await update(ref(db, `rooms/${state.roomCode}/meta`), { m36_faceDown: arr });
    };
  });
  // 右ブランク（クリックで右側に left2）
  const rightSlot = mkCard(null);
  rightSlot.classList.add('m36-slot','m36-right');
  rightSlot.title = 'クリックで左2を表示';
 rightSlot.classList.remove('numcard');
 rightSlot.classList.add('rulecard');
  rightSlot.onclick = async (ev)=>{
    ev.stopPropagation();
    await update(ref(db, `rooms/${state.roomCode}/meta`), { m36_side: 'R' });
  };

  // 現在のサイド状態を反映：'L' → 左=right2/右=ブランク、'R' → 右=left2/左=ブランク、null → 両方ブランク
  const side = v?.meta?.m36_side ?? null;
  if (side === 'L'){
    leftSlot.style.backgroundImage  = `url('${imgRule('right2')}')`;
    rightSlot.style.backgroundImage = ''; // ブランク
  }else if (side === 'R'){
    leftSlot.style.backgroundImage  = ''; // ブランク
    rightSlot.style.backgroundImage = `url('${imgRule('left2')}')`;
  } // null のときは両方ブランクのまま

  // 並べる：左ブランク → 数値5 → 右ブランク
  lane.appendChild(leftSlot);
  lane.appendChild(n0); lane.appendChild(n1); lane.appendChild(n2); lane.appendChild(n3); lane.appendChild(n4);
  lane.appendChild(rightSlot);

  // 既存の設置ユーティリティで配置
  mountLaneUnderItemsBar(lane);
}
/* ここまで追加 */



  
  
/* ===== #39：左に X、右に数値P1山＋公開札、下に自分の受け取り数値 ===== */
function renderM39(v){
  const isM39 = ((v?.mission?.id|0) === 39);
  const old = document.getElementById('m39Row');
  if (!isM39){
    if (old) old.remove();                 // 上部の公開札レーンを掃除
    const hand = document.getElementById('m39HandRow');
    if (hand) hand.remove();               // 画面下部の手札帯も掃除 ← 追加
    return;
  }
  if (old) old.remove();
  const lane = document.createElement('div');
  lane.id = 'm39Row';
  lane.className = 'numlane';

  // 左：X（固定表示）
  const X = v?.meta?.m39_x|0;
  if (X){
    const xNode = document.createElement('div');
    xNode.className = 'numcard';
    xNode.style.backgroundImage = `url('${imgNumber(X)}')`;
    lane.appendChild(xNode);
  }

  // 中央：P1風の山札（残表示）
  const deckBtn = document.createElement('div');
  deckBtn.className = 'numdeck';
  deckBtn.title = 'めくる';

  const restLbl = document.createElement('span');
  restLbl.className = 'numrest';

  // 右：公開札積み重ね
  const pile = document.createElement('div');
  pile.className = 'numcard-holder';
  pile.style.position = 'relative';

  lane.appendChild(deckBtn);
  lane.appendChild(restLbl);
  lane.appendChild(pile);

  if (v?.meta?.m39_dealt) {
    deckBtn.remove();     // 山札ボタンを消す
    restLbl.remove();     // 残数ラベルも消す（山札とペアなので）
  }
  
  // 既存公開札の再描画 & 残表示
  const refresh = ()=>{
    const d = (v?.meta?.m39_deck||[]);
    const x = (v?.meta?.m39_discards||[]);
    const remain = d.filter(n=>!x.includes(n)).length;
    restLbl.textContent = `残:${remain}`;

    pile.innerHTML = '';
    x.forEach((n, i)=>{
      const node = document.createElement('div');
      node.className = 'numcard';
      node.style.backgroundImage = `url('${imgNumber(n)}')`;
      if (i>0){
        const off = i*2;
        node.style.position='absolute';
        node.style.left = off+'px';
        node.style.top  = off+'px';
      }
      pile.appendChild(node);
      const extra = i*2;
      pile.style.height = (48+extra)+'px';
      lane.style.marginBottom = extra+'px';
    });
  };
  refresh();

  deckBtn.onclick = async ()=>{
    try{
      const mRef = ref(db, `rooms/${state.roomCode}/meta`);
      const mSnap = await get(mRef);
      const meta  = mSnap.val()||{};
      if (meta.m39_dealt) return; // 配布後は止める
      const D = Array.isArray(meta.m39_deck) ? meta.m39_deck.slice() : [];
      const Xs = Array.isArray(meta.m39_discards) ? meta.m39_discards.slice() : [];
      const next = D.find(n=> !Xs.includes(n)); // 山札順で次
      if (next==null) return;
      Xs.push(next);
      await update(mRef, { m39_discards: Xs });
    }catch(e){ console.error(e); }
  };

  mountLaneUnderItemsBar(lane);

  // 自分の受け取り数値（m39Hand）をミッション詳細の直上に表示
  const rowId = 'm39HandRow';
  const oldRow = document.getElementById(rowId);
  if (oldRow) oldRow.remove();

  const myIdx = (v?.tables||[]).findIndex(T => T.playerId === state.userId);
  const myT   = myIdx>=0 ? v.tables[myIdx] : null;
  const row = document.createElement('div');
  row.id = rowId;
  row.style.display = 'flex';
  row.style.gap = '6px';
  row.style.margin = '6px 0';
  (myT?.m39Hand||[]).forEach(n=>{
    const nc = document.createElement('div');
    nc.className = 'numcard';
    nc.style.backgroundImage = `url('${imgNumber(n)}')`;
    row.appendChild(nc);
  });
  missionFooter.insertAdjacentElement('beforebegin', row);
}

  
/* ===== #16：数値3 + 右4（全員同期） ===== */
function renderM16(v){
  const isM16 = ((v?.mission?.id|0) === 16);
  const old = document.getElementById('m16Row');
  if (!isM16){ if (old) old.remove(); return; }

  // ★ ホストが一度だけ3枚を確定（DBに保存）—無ければ作って即return（次のonValueで描画）
  if (state.isHost){
    const ok = Array.isArray(v?.meta?.m16_nums) && v.meta.m16_nums.length === 3;
    if (!ok){
      const pool = MATERIALS.numbers.slice(); shuffle(pool);
      const three = pool.slice(0,3); // 重複なし
      update(ref(db, `rooms/${state.roomCode}/meta`), { m16_nums: three });
      return;
    }
  }

  const nums = Array.isArray(v?.meta?.m16_nums) ? v.meta.m16_nums.slice(0,3) : [];
  if (old) old.remove();
 const lane = document.createElement('div');
  lane.id = 'm16Row';
  lane.className = 'numlane';

  // 左端：右4カード（横向き）
 const rule = document.createElement('div');
  rule.className = 'rulecard';
 rule.style.backgroundImage = `url('${imgRule('right4')}')`;
  lane.appendChild(rule);

  // 右側：数値カード3枚（静的表示・操作なし）
  nums.forEach(n=>{
   const node = document.createElement('div');
    node.className = 'numcard';
    node.style.backgroundImage = `url('${imgNumber(n)}')`;
    lane.appendChild(node);
  });

  // アイテム列の直下に敷く（#39と同じ置き方）
 mountLaneUnderItemsBar(lane);
}

  
  async function performM39Deal(){
  try{
    const rRef = ref(db, `rooms/${state.roomCode}`);
    const [rSnap, tSnap] = await Promise.all([
      get(rRef),
      get(ref(db, `rooms/${state.roomCode}/tables`))
    ]);
    const R = rSnap.val()||{};
    const meta = R.meta||{};
    if (meta.m39_dealt) return;

    const deck = Array.isArray(meta.m39_deck) ? meta.m39_deck.slice() : [];
    const disc = Array.isArray(meta.m39_discards) ? meta.m39_discards.slice() : [];
    const rest = deck.filter(n => !disc.includes(n)); // ←“捨て札にならなかった”カード

    const tables = Array.isArray(tSnap.val()) ? tSnap.val().map(T=>({...T})) : [];
    const tCount = R.tableCount|0;
    const start  = R.captainTable|0;

    // ラウンドロビン配布
    rest.forEach((n, i)=>{
      const to = (start + i) % tCount;
      const T  = tables[to] || (tables[to]={});
      const arr = Array.isArray(T.m39Hand) ? T.m39Hand.slice() : [];
      arr.push(n);
      T.m39Hand = arr;
    });

    // 条件付き：情報トークンをキャラ下行に1つ配布
    tables.forEach(T=>{
      const got = Array.isArray(T.m39Hand) ? T.m39Hand : [];
      const hand = Array.isArray(T.hand) ? T.hand : [];
      const row  = Array.isArray(T.m22Tokens) ? T.m22Tokens.slice() : [];
      got.forEach(n=>{
        const hasSameNum = hand.some(c => c?.kind==='normal' && (c.num|0)===(n|0));
        const someNoNumToken = hand.some(c =>
          c?.kind==='normal' && (c.num|0)===(n|0) &&
          !(Array.isArray(c.tokens) && c.tokens.some(tk => String(tk.type)==='num' && (tk.value|0)===(n|0)))
        );
        if (hasSameNum && someNoNumToken && !row.includes(n)){
          row.push(n);
        }
      });
      T.m22Tokens = row;
    });

    await update(ref(db, `rooms/${state.roomCode}/meta`), { m39_dealt: true });
    await set(ref(db, `rooms/${state.roomCode}/tables`), tables);
  }catch(e){ console.error('performM39Deal', e); }
}

// #23：残りのアイテム山札を“アイテム欄”に並べる（メタへ確定保存）
async function performM23Spread(){
  try{
    const rRef   = ref(db, `rooms/${state.roomCode}`);
    const rSnap  = await get(rRef);
    const R      = rSnap.val() || {};
    const meta   = R.meta || {};

    // すでに実行済みなら何もしない
    if (meta.m23_spread === true) return;

    // 残っているアイテム（＝山札 - 捨て札）
    const deck = Array.isArray(meta.m23_deck)     ? meta.m23_deck.slice()     : [];
    const disc = Array.isArray(meta.m23_discards) ? meta.m23_discards.slice() : [];
    const rest = deck.filter(n => !disc.includes(n));
     // ★ items と meta を同時に更新（チラつき防止）
     const list = rest.map(no => ({ id: crypto.randomUUID(), no, used: false, faceUp: true }));
    await update(ref(db, `rooms/${state.roomCode}`), {
      'items': list,
      'meta/m23_spread': true,
      'meta/m23_spreadRest': []
     });
   
  }catch(e){
    console.error('performM23Spread', e);
  }
}
  
function attachM23DeckUI(lane){
  const deckBtn = document.createElement('div');
 deckBtn.className = 'numdeck';
  deckBtn.style.backgroundImage = `url("./itemback.jpg")`;
  const restLbl = document.createElement('span');
  restLbl.className = 'numrest';
  const refreshRest = ()=>{
    const v=state.watching, meta=v?.meta||{};
    const d=(meta.m23_deck||[]), x=(meta.m23_discards||[]);
    const remain = d.filter(n=>!x.includes(n)).length;
    restLbl.textContent = `残:${remain}`;
  };
  refreshRest();
  lane.appendChild(deckBtn);
  lane.appendChild(restLbl);

  // ★ 追加：表向き捨て札の積み重ね表示（アイテム）
  const pile = document.createElement('div');
  pile.className = 'numcard-holder';
  pile.style.position = 'relative';
  pile.style.width = cssNum('--item-w') + 'px';
  pile.style.height = cssNum('--item-h') + 'px';
  lane.appendChild(pile);

  const addToItemPile = (no)=>{
    const already = pile.querySelectorAll('.item').length;
    const node = document.createElement('div');
    node.className = 'item';
    node.style.backgroundImage = `url("./item${no}.jpg")`;
    if(already>0){
      const off = already * 2; // 数値山札と同じ2px刻み
      node.style.position = 'absolute';
      node.style.left = off + 'px';
      node.style.top  = off + 'px';
      // 見切れ防止：高さと下マージンを増やす
      const baseH = cssNum('--item-h');
      pile.style.height = (baseH + off) + 'px';
      lane.style.marginBottom = off + 'px';
    }
    pile.appendChild(node);
  };

  // ★ 既存の捨て札を描画（リロード/再入室対策）
  (state.watching?.meta?.m23_discards || []).forEach(addToItemPile);

  deckBtn.onclick = async (ev)=>{
    const v=state.watching, meta=v?.meta||{};
    const d=(meta.m23_deck||[]), x=(meta.m23_discards||[]);
    const remain = d.filter(n=>!x.includes(n));

    // 「広げる」条件は従来通りポップで提示（指示は“めくる”のみポップ廃止）
    const drawn = new Set(meta.m23_drawnNumbers||[]);
    const openCountByNum = {};
    (v.tables||[]).forEach(T=> (T.hand||[]).forEach(c=>{
      if(c?.kind==='normal' && c.open===true){
        const nn=c.num|0; openCountByNum[nn]=(openCountByNum[nn]||0)+1;
      }
    }));
    const ready = Array.from(drawn).some(nn => (openCountByNum[nn]||0)===4);

    if (!meta.m23_spread && ready){
      openOneMini(ev.clientX, ev.clientY, '広げる', async ()=>{
        const list = remain.map(no=>({id:crypto.randomUUID(), no, used:false, faceUp:true}));
 await Promise.all([
  set(ref(db, `rooms/${state.roomCode}/items`), list),
   update(ref(db, `rooms/${state.roomCode}/meta`), { 
     m23_spread: true,
     m23_spreadRest: remain
   })
 ]);
        // 展開後は右側積みはクリア
        pile.innerHTML = '';
        pile.style.height = cssNum('--item-h') + 'px';
        lane.style.marginBottom = '0px';
        refreshRest();
          // ★★★ ここから追加：アイテム山札UIを消滅させる ★★★
        try{
          deckBtn.onclick = null;              // 念のため無効化
          if (restLbl?.parentNode) restLbl.remove();
          if (pile?.parentNode)    pile.remove();
          if (deckBtn?.parentNode) deckBtn.remove();
        }catch(_){}
    });
      return;
    }

    // ★ 「めくる」は即時実行（ポップなし）
    if (remain.length<=0) return;
    const pick = remain[(Math.random()*remain.length)|0];
    await update(ref(db, `rooms/${state.roomCode}/meta`), { m23_discards: (x||[]).concat(pick) });
    addToItemPile(pick);  // 右側に表で重ねる
    refreshRest();
  };

}

/* ===== ★ #26：1〜12 を 3×4 で並べ、裏表をトグル ===== */
function mountM26GridUnderItems(){
  const bar = document.getElementById('itemsBar');
  // 二重生成防止（既にあれば一旦消す）
  const existed = document.getElementById('m26Grid');
  if (existed) existed.remove();

  // 2行 × 6列（合計12枚）
  const wrap = document.createElement('div');
  wrap.id = 'm26Grid';                      // ★ 後でremoveできるようにID付与
  wrap.style.flexDirection = 'column';
 wrap.style.alignItems = 'flex-start';
  wrap.style.gap = '6px';
  const rows = [ [1,2,3,4,5,6], [7,8,9,10,11,12] ];
  rows.forEach(arr=>{
    const row = document.createElement('div');
    row.className = 'numlane';
    arr.forEach(n=>{
     const c = document.createElement('div');
      c.className = 'numcard';
      c.dataset.num = String(n);
      row.appendChild(c);
    });
   wrap.appendChild(row);
  });
  bar.insertAdjacentElement('afterend', wrap);

  const sync = ()=>{
    const v = state.watching||{}; const hidden = new Set((v.meta?.m26_hidden)||[]);
    wrap.querySelectorAll('.numcard').forEach(el=>{
      const n = parseInt(el.dataset.num,10);
      el.style.backgroundImage = hidden.has(n) ? `url('${imgBack}')` : `url('${imgNumber(n)}')`;
    });
  };
  sync();
  wrap._sync = sync;

  wrap.querySelectorAll('.numcard').forEach(el=>{
   el.onclick = (ev)=>{
      const n = parseInt(el.dataset.num,10);
      const v = state.watching||{}; const hidden = new Set((v.meta?.m26_hidden)||[]);
      const allHidden = hidden.size===12;
      // ★ 全部が裏のときだけポップで「全て表にする」
      if (allHidden){
        openOneMini(ev.clientX, ev.clientY, '全て表にする', async ()=>{
          await update(ref(db, `rooms/${state.roomCode}/meta`), { m26_hidden: [] });
          sync();
        });
        return;
      }
      // ★ それ以外は即時トグル（ポップを出さない）
      (hidden.has(n) ? hidden.delete(n) : hidden.add(n));
      update(ref(db, `rooms/${state.roomCode}/meta`), { m26_hidden: Array.from(hidden) }).then(sync);
    };
  });
}
  
function missionInfo(id, opts={}){
  const mixLines = opts.mixLines || [];     // 例: ['赤[1.5]', '黄[2.1][5.1]']
  const chooseLines = opts.chooseLines || [];// 例: ['赤コード[1.5] [3.5] のうち1つ']
  const linesForMix = [...mixLines, ...chooseLines]; // 表示の先頭に差し込む

  switch(id){
    case 1:{ // 赤コード1
      return {
        id:1, name:'#1', desc:'', 
        display: ['#1', ...linesForMix],
      };
    }
    case 2:{ // 黄コード1
      return {
        id:2, name:'#2', desc:'',
        display: ['#2', ...linesForMix],
      };
    }
    case 3:{
      const list=[1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5]; shuffle(list);
      const pick=list.slice(0,3);
      return {
        id:3, name:'#3', desc:'',
        display:[ '#3', `${pick[0]} – ${pick[1]} - ${pick[2]} のうち1つ`, ...linesForMix ],
      };
    }

    /* === #9〜#12（指定の引用文と赤/黄表示を合成）=== */
    case 9: {
      return {
        id:9, name:'#9', desc:'',
        display: [
          '#9',
          ...linesForMix, // ← 赤1・黄2の結果（赤[1.5] / 黄[2.1][…] など）
          '最初に左にあるカードを切断しなければ、右にあるカードを切断できない。',
          '手番に切断できるコードがなければ起爆ダイヤルを1進める。'
        ],
        flags: { needsRuleRow:true, rule: { type:'R2with2', rightCount:2 } }
      };
    }
    case 10: {
      return {
        id:10, name:'#10', desc:'',
        display: [
          '#10',
          ...linesForMix,
          '15分以内に解除しなければならない！',
          '時計回りではなく、手番を行いたいプレイヤーが「チョキン！」と言ってから、切断を実行する。',
          '2人になった場合を除いて、連続で手番をプレイできない。'
        ],
        flags: { timed:true, freeTurnCall:true }
      };
    }
    case 11: {
      return {
        id:11, name:'#11', desc:'',
        display: [
          '#11',
          ...linesForMix,
          '数値カードの数字のコードは全て赤コードと見なされる。',
          '手札がこのコードだけになった場合、公開して手番を終えられる。'
        ],
        flags: { numberAsRed:true, needsNumberLane:true, pattern:'P1' }
      };
    }
    case 12: {
      return {
        id:12, name:'#12', desc:'',
        display: [
          '#12',
          ...linesForMix,
          'それぞれの装備カードの下に数値カードを置く。',
          'その装備を使うにはその数値カードの数字と、装備カードの数字を2本ずつ解除しなければならない。'
        ],
        flags: { needsNumberLane:true, pattern:'P2-eachItem' }
      };
    }
    case 13: {
      return {
        id:13, name:'#13', desc:'',
        display:[
          '#13',
          ...linesForMix,
          '情報トークンはランダムに1枚引いてコードの前に置く。（同じ数字のコードがなければ手元に残す。）',
          '赤コードを3つ、隊長から順番通りに配布する。',
          '誰でも赤コードの場所を3つ同時に指摘して解除できるが、間違えると爆発する。',
          '赤コードの切断に「フツーノ探知機」や装備カードは使えない。'
        ],
        flags:{ m13_distributeRedToCaptain3:true, m13_headerRandomInfoToken:true, m13_autoHideHeaderToken:true }
      };
    }

    case 14: {
      return {
        id:14, name:'#14', desc:'',
        display:[
          '#14', ...linesForMix,
          '隊長カードの持ち主は「新人」となる。',
          '新人が切断に失敗すると爆発する。',
          '新人は「万能氷」が使えない。'
        ],
        flags:{ m14_rookieIsCaptain:true }
      };
    }

    case 15: {
      return {
        id:15, name:'#15', desc:'',
        display:[
          '#15', ...linesForMix,
          '数値カードの数字と同じ数字のコードを4本切断した時、即座に1枚目の装備カードが使えるようになる。',
          '次にめくる数値が全て切断済みなら引き直す。'
        ],
        flags:{ itemsFaceDownStart:true, needsNumberLane:true, pattern:'P1' }
      };
    }

    case 16: {
      return {
        id:16, name:'#16', desc:'',
        display:[
          '#16', ...linesForMix,
          '左側の数値カードと同じ数字のコード4本を切断しなければ右の数値のコードを切断できない」',
          '手番に切断できるコードがなければ爆発する'
        ],
        flags:{ m16_ruleRight4With3:true }
      };
    }

    case 17: {
      return {
        id:17, name:'#17', desc:'',
        display:[
          '#17', ...linesForMix,
          '隊長カードの持ち主は「セルジオ・エル・ミトー」となる。',
          '「セルジオ」は最初に誤った情報トークンを2枚置く。',　　
          '「セルジオ」は「フツーノ探知機」や他の装備が使えない。'
        ],
        flags:{ m17_captainInverseNumberPop:true }
      };
    }

    case 18: {
      return {
        id:18, name:'#18', desc:'',
        display:[
          '#18', ...linesForMix,
          'スタート時に情報トークンを置かない',
          '①手番開始時に数値カードの山札から1枚めくる。',
          '②手番プレイヤーはその数字で「なんでもレーダー」を使用した後、切断役を決める。',
        ],
  flags:{ limitItemsTo:[8] }   
      };
    }

    case 19: {
      return {
        id:19, name:'#19', desc:'',
        display:[ '#19', ...linesForMix, '音声を聞こう。' ],
        flags:{}
      };
    }

    case 20: {
      return {
        id:20, name:'#20', desc:'',
        display:[
          '#20', ...linesForMix,
          'ランダムのコードを右側に配置する。',
          '✕トークンが置かれたカードにはアイテムを使用できない。'
        ],
        flags:{ m20_rightmostX:true }
      };
    }

    case 21: {
      return {
        id:21, name:'#21', desc:'',
        display:[
          '#21', ...linesForMix,
          '情報トークンは偶数トークン（2/4）か奇数トークン（1/3）を使う。'
        ],
        flags:{ useParityToken:true }
      };
    }

    case 22: {
      return {
        id:22, name:'#22', desc:'',
        display:[
          '#22', ...linesForMix,
          '手元にない数字の情報トークンを2枚選び、手元に置いておく。',
          '最初の2本の黄コードが解除されたら、全員が未使用の情報トークンから1枚選び、次手番の人に渡す。',
          '渡されたプレイヤーはその数字のコードがあれば、その情報トークンを使用できる。',
        ],
        flags:{
          m22_pick3:true,
          m22_showTableAfter2Yellows:true,
          m22_allowInfoTableFromMenu:true
        }
      };
    }

    case 23: {
      return {
        id:23, name:'#23', desc:'',
        display:[
          '#23', ...linesForMix,
          '数値カード1枚を表にして置く。装備カード7枚の山札を作る。',
         'いずれの装備も使わずに、数値カードと同じ数字のコードを4本同時に解除しなければいけない。',
          'これを解除するまでは、隊長の手番になるたびに装備カードの山から1枚ずつ捨て札にする。',
          'これを解除したら、捨て札になっていない装備が即座に全て使えるようになる。'
        ],
 flags:{ m23_hideItemsUntilSpread:true }
      };
    }

   case 24: {
      return {
        id:24, name:'#24', desc:'',
        display:[
          '#24', ...linesForMix,
          '情報トークンはx1/x2/x3トークンのみ使用する。',
          '赤コードの前には情報トークンを置けない。'
        ],
        flags:{ useXTokens:true }
      };
    }

    case 25: {
      return {
        id:25, name:'#25', desc:'',
        display:[ '#25', ...linesForMix,
          '声を出せば、起爆ダイヤルが１進む。'
                  ],
        flags:{}
      };
    }

    case 26: {
      return {
        id:26, name:'#26', desc:'',
        display:[
         '#26', ...linesForMix,
          '表の数値カードを1枚選んで、そのコードを切断する。',
          'その後、その数値カードを裏にする。',
          '全ての数値カードが裏になったら、表に戻す。',
          '切断できるコードの数値カードがない場合のみ手番を飛ばす。'
        ],
        flags:{ m26_grid12:true }
      };
    }

    case 27: {
      return {
        id:27, name:'#27', desc:'',
        display:[
          '#27', ...linesForMix,

          '全員「フツーノ探知機」を持っていない。',
          '最初の2本の黄コードが切断された時、プレイ人数に等しい情報トークンをランダムで取り、隊長から順番に選んで使う。'
        ],
        flags:{ m27_poolAfter2Yellows:true }
      };
    }

    case 28: {
      return {
        id:28, name:'#28', desc:'',
        display:[ '#28', ...linesForMix, 
                 ' 隊長カードの持ち主は「ラジネス隊長」となる。', 
                 'ラジネス隊長は「フツーノ探知機」を持っておらず、装備カードも使うことができない。', 
                 'ラジネス隊長が切断に失敗した場合、爆発する。' 
                ],
        flags:{}
      };
    }
 
  case 29: {
      return {
        id:29, name:'#29', desc:'',
        display:[
          '#29', ...linesForMix,
          '数値カードをシャッフルして、全員に2枚ずつ配る。',
          '隊長の前の数字のプレイヤーには3枚配る。',
          '①手番プレイヤーの前のプレイヤーは数値カードを選んで裏向きで出す。',
          '手番プレイヤーが切断を行った後、場の数値カードを公開して、同じ数字だった場合、起爆ダイヤルが1進む。',
          '手番の後、手番プレイヤーはそのカードを取る。'
        ],
        // ※UIは段階導入。初回は説明のみ（今後のPRでアクション実装予定）
        flags:{}
      };
    }

    case 30: {
      return {
        id:30, name:'#30', desc:'',
        display:[
          '#30', ...linesForMix,
          '音声を聞こう。'
        ],
        flags:{ needsNumberLane:true, pattern:'P1-pop123' }
      };
    }

    case 31: {
      return {
        id:31, name:'#31', desc:'',
        display:[
          '#31',...linesForMix,
          '各プレイヤーに制約カードを1枚ずつ配る',
          '各プレイヤーはこれを守らなければならない。',
          '自分のコードを見て、制約を守れなくなった時は制約カードを公開して通常通りプレイする。'
        ],
        // ※表示・配布UIは今後追加予定（今回の差分は説明表示のみ）
        flags:{}
      };
    }

    case 32: {
      return {
        id:32, name:'#32', desc:'',
        display:[
          '#32',...linesForMix,
          '制約カードの山札から1枚引いて、表にする。',
          'プレイヤー全員はこの制約を守らなければならない。',
          '隊長の手番になると、制約カードを引き直すことができる。',
          '制約を守れないプレイヤーは手番を飛ばす。'
        ],
        // ※今回：説明表示のみ。山札UIは次の差分で追加予定
        flags:{}
      };
    }

    case 33: {
      return {
        id:33, name:'#33', desc:'',
        display:[
          '#33',...linesForMix,
          '情報トークンは偶数/奇数トークンのみ使用する。'
        ],
        // 既存の #21 と同様のフラグで偶奇トークンだけを許可
        flags:{ useParityToken:true }
      };
    }

    case 34: {
      return {
        id:34, name:'#34', desc:'',
        display:[
          '#34',...linesForMix,
          '自分だけ役職カードを見る。',
          '隊長カードの持ち主は「ウィーケスト・リンク」となる。',
          '「ウィーケスト・リンク」だけが制約を守らなければならない。',
          '誰かが「ウィーケスト・リンク」であるプレイヤーと制約の両方を指摘できたら、「ウィーケスト・リンク」は制約カードを公開して解放される。',
          'ただし、間違えると起爆ダイヤルが1進む。'
        ],
        // ※今回：表示のみ。秘匿/推理UIは後続PRで
        flags:{}
      };
    }

    case 35: {
      return {
        id:35, name:'#35', desc:'',
        display:[
          '#35',...linesForMix,
          'ランダムで一枚選び、自分のスタンドの一番右に置く。',
          'このコードは黄コードを全て切断しないと、切断できない。',
          'このコードを切断するのにアイテムは使用できない。'
        ],
        // #20 と同じ右端✕処理を流用
        flags:{ m20_rightmostX:true }
      };
    }

    case 36: {
      return {
        id:36, name:'#36', desc:'',
        display:[
          '#36',...linesForMix,
          '数値カードを5枚並べる。',
          '最初に隊長はどちらの方向から切断できるか決める。',
          '数値カード上のコードはこの順で2本切断しなければならない。',
          'カード上の2本を切断するたびに、相談せずに、切断したプレイヤーがどちらの方向から切断できるか決め直してよい。',
          'それ以外の数値は自由に切断できる。'
        ],
        flags:{ m36_directionRow:true }
      };
    }

    case 37: {
      return {
        id:37, name:'#37', desc:'',
        display:[
          '#37',...linesForMix,
          '制約カード12枚の山札から1枚目を表向きにする。',
          'ある数字のコードが4本切断されるたびに制約カードを引き直す。',
          '制約を守れないプレイヤーは手番を飛ばす。',
          '一周するまでに全員が制約を守れなかった場合、起爆ダイヤルを1進めて、制約カードを引き直す。',
          '制約カードがなくなれば、新しく引かない。'
        ],
        flags:{ }
      };
    }

    case 38: {
     return {
        id:38, name:'#38', desc:'',
        display:[
          '#38',...linesForMix,
          '隊長の手札から1枚ランダムで選び、スタンドの右に置く。',
          'このカードが隊長は見ることができない。',
          '隊長は「フツーノ探知機」やアイテムカードを使わずにこのカードを切断しなければならない。',
          '隊長の手札から1枚ランダムで選び、スタンドの右に置く。',
          
       ],
        flags:{ m38_captainRightmostX:true }
      };
    }
      
    case 39: {
     return {
        id:39, name:'#39', desc:'',
        display:[
          '#39',...linesForMix,
          '情報トークンをランダムに得て、その数字のコードを持っていなければ手元に置いておく。',
          '数値カードを1枚表向きで置いて、残りの数値カードから8枚取って山札にして置く。',
          '数値カードの数字と同じ数字のコードが4本切断されるまで、隊長の手番になるたびに数値カードの山札から1枚捨て札にする。',
          '数値カードの数字と同じ数字のコードが4本切断されたら、山札に残っている数値カードを全員に配る。',
          '配られた数値カードと同じ数字のコードが手元にあれば、情報トークンをつけることができる。',
          'つまり、このコードを早く切断すればするほど、情報が得られるということだ。'
                 ],
        flags:{  }
      };
    }
       case 40: {
     return {
        id:40, name:'#40', desc:'',
        display:[
          '#40',...linesForMix,
          '隊長と3,5番手のプレイヤーはx1,x2,x3トークンのみ使用する。',
          '2,4番手のプレイヤーは奇数、偶数トークンのみ使用する。'
       ],
        flags:{  }
      };
    }
       case 41: {
     return {
        id:41, name:'#41', desc:'',
        display:[
          '#41',...linesForMix,
          '最初に起爆ダイヤルを残り1まで進める。',
          '全員に黄コードを1枚ずつ配る。ただし、5人プレイ時は隊長には黄コードを配らない。',
          '情報トークンはランダムに得て、置けない場合は手元に置いておく。',
          'このミッションでは共同で黄コードの切断を行わず、チームメイトの黄コードの場所を1つ選んで、切断できる。',
          '黄コードの切断に成功すると起爆ダイヤルが1戻るが、失敗すると起爆ダイヤルが1進む。'
       ],
        flags:{  }
      };
    }
           case 42: {
     return {
        id:42, name:'#42', desc:'',
        display:[
          '#42',...linesForMix,
          '音声を聞こう。',
       ],
        flags:{  }
      };
    }  
           case 43: {
     return {
        id:43, name:'#43', desc:'',
        display:[
          '#43',...linesForMix,
          'ロボットのナノをボード上のスペース1に置く。',
          'コードを配る時、ナノに指定の数のコードを置く。',
          'プレイヤーの手番終了時にナノは1マス進み、12で方向転換する。',
          'ナノがいるスペースの数値に対応するコードを切断した時に、ナノのコードを1枚回収できる。',
          '爆弾を解除するには全てのコードを回収して切断しなければならない。',
          '※いつでもコーヒーを使っても、ナノは1マス進む。',
       ],
        flags:{  }
      };
    }  
           case 44: {
     return {
        id:44, name:'#44', desc:'',
        display:[
          '#44',...linesForMix,
          '手番プレイヤーは切断する直前に、切断するコードの数値に対応する枚数の酸素をリザーブから取らなければならない。',
          '隊長の手番開始時に全ての酸素トークンをリザーブエリアに戻す。',
          '切断できない場合、起爆ダイヤルを1進める。',
       ],
        flags:{  }
      };
    }  
           case 45: {
     return {
        id:45, name:'#45', desc:'',
        display:[
          '#45',...linesForMix,
          '切断するたびに、数値カードを1枚めくり、その数値のコードを切断しなければならない。',
          '時計回り順ではプレイせず、最初に「チョキン！」と言ったプレイヤーが切断する。',
          'チョキン！と言ったのに切断できなかったり、手掛かりを与える発言（「その数値のコードは切断したくない」など）があった場合は起爆ダイヤルが1進む。',
          '誰もチョキン！と言わない場合は隊長が一人選ぶ。',
          'そのプレイヤーがいかなる理由でも切断できなければ起爆ダイヤルが1進む。',
          '赤コードしか持っていないプレイヤーはいつでもチョキン！と言って赤コードを公開できる。',
       ],
        flags:{  }
      };
    }  
                 case 46: {
     return {
        id:46, name:'#46', desc:'',
        display:[
          '#46',...linesForMix,
          '7のコードは最後に切断しなければならない。',
          '手札に7しかない場合、4本の7を同時に切断しなければならず、失敗すれば爆発する。',
          'それより前の段階で7が見つかった場合、起爆ダイアルが1進む。',
       ],
        flags:{  }
      };
    }  
               case 47: {
     return {
        id:47, name:'#47', desc:'',
        display:[
          '#47',...linesForMix,
          'コードを切断するために、プレイヤーは2枚選んだその和か差の数字のコードを切断できる。',
          'その後、選んだカードを裏向きにする。',
          '全て裏向きなら、表にする。',
          '切断ができない場合、任意の2枚を裏にして、起爆ダイヤルを1進める。',
       ],
        flags:{  }
      };
    }  
                   case 48: {
     return {
        id:48, name:'#48', desc:'',
        display:[
          '#48',...linesForMix,
          'このミッションでは3本の黄コードを同時に切断しなければならない。',
          '黄コードを持っていないプレイヤーもこれを実行できる。',
          '',
       ],
        flags:{  }
      };
    }  
                case 49: {
     return {
        id:49, name:'#49', desc:'',
        display:[
          '#49',...linesForMix,
          'コードを切断するために、切断したい数字の枚数分の酸素トークンを他プレイヤー1人に渡さなければならない。',
          '酸素トークンを渡すのは切断を行う相手じゃなくてよい。',
          '切断が行えない場合、起爆ダイヤルを1進める。',
          '水中にいるため意思疎通は難しい。',
       ],
        flags:{  }
      };
    }  
                case 50: {
     return {
        id:50, name:'#50', desc:'',
        display:[
          '#50',...linesForMix,
          '切断に失敗した時、指し示されたコードにではなく、コードの外側に情報トークンを置く。',
          '',
          '',
       ],
        flags:{  }
      };
    }  
case 51: {
  return {
    id:51, name:'#51', desc:'',
    display:[
      '#51',
      ...linesForMix,
      '起爆ダイヤルを1まで進める。',
      '手番プレイヤーは「サー」となる。',
      '「サー」は数値カードをめくって、その数字で切断を行うプレイヤ－を決める。（自分でも可）',
      '指名された人は「サー・イエス・サー！」と言い、切断アクションを行う。',
      '切断を行えない場合は起爆ダイヤルを1進める。',
      '「サー」の次の人が次の手番を行う。',
    ],
    flags:{}
  };
}
case 52: {
  return {
    id:52, name:'#52', desc:'',
    display:[
      '#52',
      ...linesForMix,
      '最初に必ず偽の情報トークンを2枚置く。（数字コードでも赤コードでもよい。）',
      'このミッションで使う情報トークンは全て偽の情報トークンを使う。',
      '間違えて指し示された場合は宣言された数字の情報トークンを置く。',
    ],
    flags:{}
  };
}
case 53: {
  return {
    id:53, name:'#53', desc:'',
    display:[
      '#53',
      ...linesForMix,
      '',
      'コードの切断に成功した：+1',
      'ナノがいるスペースの数字のコードの切断に成功した：-1',
      'コードの切断に失敗した：-2',
      'ナノがスペース12に到達した場合、ドカーン！',
    ],
    flags:{}
  };
}
case 54: {
  return {
    id:54, name:'#54', desc:'',
    display:[
      '#54',
      ...linesForMix,
      '最初に指定の数の酸素トークンを配り、残りの酸素トークンをリザーブに置く。',
      'コードを切断する時は指定の数の酸素トークンをリザーブへ支払わなければならない。',
      '切断できない場合は起爆トークンが1進む。',
      '確定トークンを置くたびに各プレイヤーは酸素トークンを1つ得る。',
    ],
    flags:{}
  };
}
case 55: {
  return {
    id:55, name:'#55', desc:'',
    display:[
      '#55',
      ...linesForMix,
      '起爆ダイヤルを1まで進める。',
      '人数分のチャレンジカードをテーブルに置く。',
      'チャレンジカードを達成するたびに起爆ダイヤルを1つ後退させる。',
    ],
    flags:{}
  };
}
case 56: {
  return {
    id:56, name:'#56', desc:'',
    display:[
      '#56',
      ...linesForMix,
      '手札からランダムで1枚とり、コードの右側に裏向きで設置する。',
      'このコードはアイテムを使わずに自分で切断しなければならない。',
      'チームメイトの右側のコードを切断してしまった場合、起爆ダイヤルが1つ進む。',
    ],
    flags:{ m20_rightmostX:true }
  };
}
case 57: {
  return {
    id:57, name:'#57', desc:'',
    display:[
      '#57',
      ...linesForMix,
      '確定トークンが置かれるたびに、その数値に割り当てられている制約カードをボード上に置く。',
      'プレイヤーはこの制約を守らなければならない。',
      '既に制約カードがある場合はその上に重ねて置き、新たな1枚だけが発動する。',
    ],
    flags:{}
  };
}
case 58: {
  return {
    id:58, name:'#58', desc:'',
    display:[
      '#58',
      ...linesForMix,
      'このミッションでは情報トークンを使わない。',
      '切断に失敗した場合何も情報は得られない。',
      'プレイヤーは手番ごとにフツーノ探知機が使用できる。',
    ],
    flags:{}
  };
}
case 59: {
  return {
    id:59, name:'#59', desc:'',
    display:[
      '#59',
      ...linesForMix,
      '数値カード12枚をランダムに並べて、7の位置に12の方向を向くようにナノを配置する。',
      '❶ナノが今いるカードか、ナノの前方にあるカードのうち、手札にある数字の方を選び、ナノをそのままにしておくか移動させる。',
      '❷その数字のコードを切断する。',
      '❸ナノを任意の方向に向ける（そのままにしてもよい）。',
      '選択できる数値がない場合は、ナノを反転させてから起爆ダイヤルを1進めて、切断を行う。',
      '「いつでもコーヒー」は手番全体を飛ばす。',
    ],
    flags:{}
  };
}
case 60: {
  return {
    id:60, name:'#60', desc:'',
    display:[
      '#60',
      ...linesForMix,
      '起爆ダイヤルを1まで進める。',
      '人数分のチャレンジカードをテーブルに置く。',
      'チャレンジカードを達成するたびに起爆ダイヤルを1つ後退させる。',
    ],
    flags:{}
  };
}
case 61: {
  return {
    id:61, name:'#61', desc:'',
    display:[
      '#61',
      ...linesForMix,
      '各プレイヤーは自分の制約を守らなければならない。',
      '制約を守れない場合は手番を飛ばす。',
      '全員が制約を守れずに1ラウンド終了した場合、爆弾は爆発する。',
      '隊長の手番の最初に相談して全員一斉に制約カードを右か左に渡せる。',
      'プレイヤーはいつでも制約カードを山札の制約カードと交換できる。',
      'その際に起爆ダイヤルを1つ進める。',
    ],
    flags:{}
  };
}
case 62: {
  return {
    id:62, name:'#62', desc:'',
    display:[
      '#62',
      ...linesForMix,
      '数値カードを人数分テーブルに並べる。',
      '見えている数値カードのうち1枚のコードを4本切断するたびに、起爆ダイヤルを1つ後退させる。',
    ],
    flags:{}
  };
}
case 63: {
  return {
    id:63, name:'#63', desc:'',
    display:[
      '#63',
      ...linesForMix,
      '隊長は特定の枚数の酸素トークンを手元に置く。',
      '切断を実行するには切断したいコードの数値の分だけリザーブに支払わなければならない。',
      '手番終了後、持っている全ての酸素トークンを次の手番の人に渡す。',
      '隊長の手番の最初にリザーブから全ての酸素トークンを回収する。',
      '切断ができない場合は起爆ダイヤルを1進める。',
      '水中にいるため意思疎通は難しいはずだ。',
    ],
    flags:{}
  };
}
case 64: {
  return {
    id:64, name:'#64', desc:'',
    display:[
      '#64',
      ...linesForMix,
      '各プレイヤーの手札からランダムで2枚を抜き、数字の小さい方を左側に置き、大きい方を右側に置く。',
      'このカードはアイテムを使わずに自分で切断しなければならない。',
      '他のプレイヤーのこれらのコードを切断した場合、起爆ダイヤルを1つ進める。',
    ],
    flags:{}
  };
}
case 65: {
  return {
    id:65, name:'#65', desc:'',
    display:[
      '#65',
      ...linesForMix,
      '数値カードを各プレイヤーに配布する。',
      '各プレイヤーは自分の数値カードにある数字のコードを切断しなければならない。',
      '手番終了後、1枚選んで次の手番のプレイヤーに渡す。',
      '4本切断されている数値カードは裏向きにする。',
      '裏向きのカードを次のプレイヤーに渡してもよい。',
      '切断できない場合は起爆ダイヤルを1進める。',
    ],
    flags:{}
  };
}
case 66: {
  return {
    id:66, name:'#66', desc:'',
    display:[
      '#66',
      ...linesForMix,
      '',
      '',
    ],
    flags:{}
  };
}
        
      
    default:  { return {id, name:`#${id}`, desc:'', display:[`#${id}`, ...linesForMix]}; }
  }
}


// 画面タップで各種ポップは外側タップで消える
 document.addEventListener('click',(e)=>{ if(!miniPop.contains(e.target)) H(miniPop,true); }, true);
</script>
</body>
</html>