<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>テンプレ（右に六角＋6部屋 / 中央にデッキ5枚）</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:1200; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .attack-roll-result-debug{font-weight:700;min-width:52px;text-align:left;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn.danger{background:#ef4444;color:#fff;border-color:#ef4444;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:hidden;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('back.jpg'); }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;
    z-index:700;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}

  /* 公開確認ポップ */
  .confirm-pop{
    position:fixed;
    left:0; top:0;
    transform:translate(-50%,-10px);
    background:#fff;
    border:1px solid rgba(0,0,0,.18);
    border-radius:12px;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    padding:10px 10px 10px;
    z-index:10050;
    min-width:210px;
  }
  .confirm-pop.hidden{display:none;}
  .confirm-pop .msg{font-size:13px;line-height:1.45;margin:0 0 10px;}
  .confirm-pop .msg .ability-pill{display:inline-block;padding:1px 6px;border-radius:999px;background:#111;color:#fff;font-weight:700;}
  .confirm-pop .actions{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}
  .confirm-pop .caret{
    position:absolute;
    left:50%; top:-7px;
    width:12px; height:12px;
    background:#fff;
    border-left:1px solid rgba(0,0,0,.18);
    border-top:1px solid rgba(0,0,0,.18);
    transform:translateX(-50%) rotate(45deg);
  }
  .confirm-pop.bottom-fixed{
    left:50%;
    top:auto;
    bottom:16px;
    transform:translateX(-50%);
    min-width:280px;
    max-width:min(92vw, 420px);
  }
  .confirm-pop.bottom-fixed .caret{display:none;}
  .btn.pop-dark{background:#111;color:#fff;border-color:#111;}
  .btn.pop-disabled{background:#bcbcbc;color:#fff;border-color:#bcbcbc;cursor:not-allowed;}
  .btn.pop-purple{background:#6d28d9;color:#fff;border-color:#6d28d9;}
  .btn.pop-white{background:#fff;color:#111;border-color:#d1d5db;}

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:1000;cursor:pointer;
    z-index:2000;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:2010;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(560px, calc(100% - 0px));
    max-height:min(74vh, 700px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:1000;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(74vh - 48px);}

  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;border-bottom:1px solid rgba(0,0,0,.06);
  }
  .role-row:last-child{border-bottom:none;}
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:1000;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}
  .role-desc .meta{font-size:12px;opacity:.8;margin-top:6px;white-space:pre-wrap;}

  .seat-pop-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:900;
    padding:16px;
  }
  .seat-pop-backdrop.hidden{display:none;}

  .seat-board{
    width:min(420px, calc(100% - 32px));
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.22);
    padding:12px 12px 14px;
    position:relative;
    margin:0;
  }
  .seat-board-title{
    font-weight:1000;
    font-size:13px;
    opacity:.9;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin:0 0 10px;
  }
  .seat-count-badge{
    font-size:12px;
    font-weight:900;
    background:#111;
    color:#fff;
    padding:4px 8px;
    border-radius:999px;
    white-space:nowrap;
  }
  .tile-grid{
    display:grid;
    grid-template-columns:repeat(4, 54px);
    grid-auto-rows:54px;
    gap:10px;
    justify-content:flex-start;
    padding:4px 0 2px;
  }
  .seat-tile{
    width:54px;height:54px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.12);
    box-shadow:0 6px 16px rgba(0,0,0,.16);
    cursor:pointer;
    position:relative;
    overflow:hidden;
    outline:none;
  }
  .seat-tile:focus{box-shadow:0 0 0 3px rgba(37,99,235,.25), 0 6px 16px rgba(0,0,0,.16);}
  .seat-tile.me::after{ display:none; }
  .seat-initial{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    font-weight:1000;
    font-size:16px;
    line-height:1;
    color:#111;
    pointer-events:none;
    user-select:none;
  }
  .seat-tile.empty{opacity:.95;}
  .seat-tile.taken{opacity:1;}
  .seat-tile .seat-num{
    position:absolute;right:6px;bottom:6px;
    font-size:11px;font-weight:1000;
    color:rgba(0,0,0,.55);
    background:rgba(255,255,255,.7);
    border:1px solid rgba(0,0,0,.08);
    padding:2px 6px;border-radius:999px;
    pointer-events:none;
  }

  .warn{
    font-size:12px;
    opacity:.75;
    text-align:center;
    margin-top:10px;
  }

  .seat-board-actions{
    display:flex;
    justify-content:flex-end;
    margin-top:10px;
    gap:8px;
    flex-wrap:wrap;
  }

  :root{
    --outer:#0b3b2e;
    --gold:#d6b35a;
    --brown:#5a4032;
    --team:#c21d1d;
    --black:#111;
    --paper:#f7f4ee;
    --effect:#ffd9a3;
    --inner-gap:-0.5px;
    --inner-w:1px;
    --inner-r:9px;
    --ini-stroke:0.3px;
    --ini-stroke-shadow:0.3px;
    --ini-y:-0.4px;

    /* =========================================================
       ★HPボード：各ルーム（damage 15→0）の高さを個別調整
       ========================================================= */
    --hp-r15: 25px;
    --hp-r14: 29px;
    --hp-r13: 23px;
    --hp-r12: 21px;
    --hp-r11: 24px;
    --hp-r10: 23px;
    --hp-r9:  23px;
    --hp-r8:  21px;
    --hp-r7:  22px;
    --hp-r6:  22px;
    --hp-r5:  22px;
    --hp-r4:  23px;
    --hp-r3:  22px;
    --hp-r2:  22px;
    --hp-r1:  20px;
    --hp-r0:  28px;

    /* HPセルの左右余白（高さを変えたくない場合は縦paddingを0推奨） */
    --hp-cell-pad-x: 6px;
    --hp-cell-pad-y: 0px;
  }

  .my-role-dock{
    position:fixed;
    right:16px;
    bottom:16px;
    z-index:260;
    display:none;
  }
  .my-role-dock.visible{ display:block; }

  /* =========================
     装備枠（★カードパネル直下まで上に伸ばす）
     ========================= */
  .equip-dock{
    position:fixed;
    left:16px;
    right:calc(2px + 72px + 12px);
    top:var(--equip-top, auto);
    bottom:16px;
    z-index:259;
    display:none;
    min-height:120px;
  }
  .equip-dock.visible{ display:block; }
  .equip-dock.david-select-front{ z-index:10030; }

  .equip-board{
    background-color:#ffffff;
    background-image:url('gear.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    border:1px solid rgba(0,0,0,.10);
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.18);
    padding:10px;
    height:100%;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    overflow:visible;
  }

  .equip-body{
    flex:1 1 auto;
    display:flex;
    flex-wrap:wrap;
    align-content:flex-start;
    align-items:flex-start;
    gap:6px;
    min-height:0;
    overflow-y:auto;
    overflow-x:visible;
    padding:8px 4px 8px 0;
    margin:-8px -4px -8px 0;
    -ms-overflow-style:none;
    scrollbar-width:none;
  }
  .equip-body::-webkit-scrollbar{
    width:0;
    height:0;
    display:none;
  }

  .equip-row{
    display:inline-flex;
    align-items:flex-start;
    gap:5px;
    padding:2px 0;
    overflow:visible;
  }

  .equip-tag{
    width:18px;height:18px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.35);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:12px;
    line-height:1;
    user-select:none;
    flex:0 0 auto;
  }
  .equip-cards{
    display:flex;
    flex-wrap:wrap;
    gap:5px;
    align-items:flex-start;
    justify-content:flex-start;
    overflow:visible;
    padding-bottom:2px;
    flex:0 1 auto;
  }

  .id72{
    width:72px;height:108px;
    background-color: var(--paper);
    background-image: none;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border:1.4px solid var(--outer);
    border-radius:10px;
    box-sizing:border-box;
    position:relative;
    overflow:hidden;
    cursor:pointer;
  }
  .id72::before{
    content:"";
    position:absolute;
    left:var(--inner-gap);right:var(--inner-gap);
    top:var(--inner-gap);bottom:var(--inner-gap);
    border:var(--inner-w) solid var(--gold);
    border-radius:var(--inner-r);
    pointer-events:none;
    z-index:1;
    opacity:1;
  }
  .id72 .initial{
    position:absolute;top:1px;left:1px;
    width:16px;height:16px;
    border:1px solid var(--black);
    border-radius:999px;
    display:grid;place-items:center;
    font-weight:900;font-size:13px;
    background:var(--team);
    line-height:1;z-index:5;
  }
  .id72 .initial span{
    display:inline-block;line-height:1;
    color:var(--black);
    transform: translateY(var(--ini-y));
    -webkit-text-stroke: var(--ini-stroke) var(--gold);
    text-stroke: var(--ini-stroke) var(--gold);
    text-shadow:
      0 0 0 var(--gold),
      0 var(--ini-stroke-shadow) 0 var(--gold),
      0 calc(var(--ini-stroke-shadow) * -1) 0 var(--gold),
      var(--ini-stroke-shadow) 0 0 var(--gold),
      calc(var(--ini-stroke-shadow) * -1) 0 0 var(--gold);
  }
  .id72 .team-arc{
    position:absolute;left:2px;top:18px;
    width:16px;height:10px;
    z-index:6;pointer-events:none;overflow:visible;
  }
  .id72 .team-arc text{
    font-weight:600;font-size:6px;letter-spacing:.40px;
    fill:var(--team);
  }
  .id72 .eng-sub{
    position:absolute;top:3px;left:15px;
    padding:1px 3px 1px 3px;
    background:var(--black);color:var(--gold);
    border:1px solid var(--gold);
    border-radius:0 6px 6px 0;
    font-weight:900;letter-spacing:.2px;
    font-size:10px;line-height:1;
    box-sizing:border-box;z-index:4;
  }
  .id72 .name{
    position:absolute;top:48px;left:2px;right:4px;
    text-align:left;padding:0px 4px;
    background:var(--black);color:var(--gold);
    border:1px solid var(--gold);
    border-radius:6px;
    font-weight:900;font-size:9px;
    letter-spacing:.3px;
    box-sizing:border-box;z-index:2;
  }
  .id72 .hp-badge{
    position:absolute;top:46px;right:1px;
    width:18px;height:18px;border-radius:999px;
    background:var(--brown);
    border:1px solid var(--gold);
    box-sizing:border-box;z-index:3;
    display:flex;flex-direction:column;
    align-items:center;justify-content:center;
    gap:0;padding-top:1px;
  }
  .id72 .hp-badge .label{
    font-size:5px;font-weight:900;line-height:0.5;
    color:var(--gold);letter-spacing:.2px;opacity:.98;
  }
  .id72 .hp-badge .val{
    font-size:12px;font-weight:1000;line-height:1;
    color:var(--gold);
    transform:translateY(-1px);
  }
  .id72 .effect{
    position:absolute;left:3px;right:3px;bottom:2px;top:64px;
    background:var(--effect);
    border-radius:4px;
    padding:1px 1px;
    box-sizing:border-box;
    font-size:5.5px;line-height:1.25;
    color:var(--black);
    overflow:hidden;z-index:2;
  }
  .id72 .tag{
    display:inline-block;
    background:var(--black);
    color:#fff;
    font-weight:900;
    padding:1px 2px;
    border-radius:3px;
    margin-right:1px;
    font-size:5.5px;
    letter-spacing:.2px;
    line-height:1;
    vertical-align:baseline;
  }
  .id72 .row{ margin:0 0 1px 0; }
  .id72 .row:last-child{ margin-bottom:0; }
  .role-card-wrap{ flex:0 0 auto; }

  .host-settings-btn{
    position:fixed;
    left:16px;
    bottom:66px;
    width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;
    z-index:2000;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;
    left:16px;
    bottom:120px;
    background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:1600;min-width:280px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:900;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}
  .start-badge{
    display:inline-flex;align-items:center;gap:6px;
    font-size:12px;font-weight:900;
    padding:4px 10px;border-radius:999px;
    border:1px solid rgba(0,0,0,.12);
    background:#f8f8f8;
  }

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    min-height:calc(100vh - 60px);
    padding-top:12px;
    gap:12px;
  }

  .game-area{
    width:min(980px, calc(100% - 24px));
    display:flex;
    flex-direction:column;
    gap:1px;
    align-items:center;
    justify-content:flex-start;
    padding-bottom:18px;
  }
  .top-row{
    width:100%;
    display:flex;
    gap:14px;
    align-items:flex-start;
    justify-content:center;
    margin-top:-10px;
  }

  /* パネル共通 */
  .panel{
    background:rgba(255,255,255,.78);
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    box-shadow:0 12px 28px rgba(0,0,0,.10);
    padding:12px;
    box-sizing:border-box;
  }

  .left-panel{
    width:170px;
    padding:0px;
    display:flex;
    align-items:stretch;
    justify-content:stretch;
    background:transparent !important;
    border:none !important;
    box-shadow:none !important;

    aspect-ratio: 2 / 4.5;
    height:auto;
    min-height:0;
  }

  /* =========================================================
     ★①左図形：枠/セル線/背景を透明（画像だけ表示）
     ========================================================= */
  .hp-board{
    width:100%;
    height:100%;
    min-height:0;

    border:none;                 /* 枠なし */
    border-radius:12px;

    overflow:hidden;
    position:relative;
    display:grid;

    grid-template-rows:
      var(--hp-r15) var(--hp-r14) var(--hp-r13) var(--hp-r12)
      var(--hp-r11) var(--hp-r10) var(--hp-r9)  var(--hp-r8)
      var(--hp-r7)  var(--hp-r6)  var(--hp-r5)  var(--hp-r4)
      var(--hp-r3)  var(--hp-r2)  var(--hp-r1)  var(--hp-r0);

    background-image:url('hp.png'); /* 画像だけ */
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    transform:none;
  }
  .hp-cell{
    position:relative;
    min-height:0;
    overflow:hidden;

    display:flex;
    align-items:center;
    justify-content:flex-start;
    flex-wrap:nowrap;
    gap:6px;

    padding:var(--hp-cell-pad-y) var(--hp-cell-pad-x);
    box-sizing:border-box;

    background:transparent; /* セル背景も透明 */
  }
  .hp-cell::after{ display:none; } /* セル線を消す */

.chip16{
    width:16px;height:16px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.35);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:11px;
    line-height:1;
    user-select:none;
    box-shadow:0 4px 10px rgba(0,0,0,.12);
    flex:0 0 auto;
  }

  .right-panel{
    width:min(520px, 52vw);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
  }
/* 自分のマーカーだけ、丸い点線リング */
  .mark-me-ring{
  fill: transparent;
  stroke: rgba(17,17,17,.95);
  stroke-width: 2;
  stroke-dasharray: 3.5 3.5;
  stroke-linecap: round;
  vector-effect: non-scaling-stroke;
  cursor:pointer;
  pointer-events:all;
}

#markerLayer.swap-animating{
  opacity:0;
}

.chip16.turn-pulse{
  animation:markerPulse 1.2s ease-in-out infinite;
}


.dice-roll-overlay{
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:11000;
}
.dice-flyer{
  position:absolute;
  left:0;
  top:0;
  transform:translate(-9999px,-9999px);
  will-change:transform;
}
.dice-flyer.rolling{
  transition:transform .95s cubic-bezier(.08,.62,.18,1);
}

.dice-flyer,
.dice-flyer *{
  box-sizing:border-box;
}

.dice-flyer{
  --die: 48px;
  --pip: 8px;
  --pad: 6px;
  --d4-2-gap: 13%;
}

.attack-result-pin{
  position:absolute;
  left:0;
  top:0;
  pointer-events:none;
}

.die{
  width:var(--die); height:var(--die);
  background:#e53935;
  border:1px solid #b71c1c;
  border-radius:5px;
  position:relative;
}
.pip{
  width:var(--pip); height:var(--pip);
  background:#fff; border-radius:50%;
  position:absolute;
}
.tl{left:var(--pad); top:var(--pad);}
.tr{right:var(--pad); top:var(--pad);}
.ml{left:var(--pad); top:50%; transform:translateY(-50%);}
.mc{left:50%; top:50%; transform:translate(-50%,-50%);}
.mr{right:var(--pad); top:50%; transform:translateY(-50%);}
.bl{left:var(--pad); bottom:var(--pad);}
.br{right:var(--pad); bottom:var(--pad);}

.d4{
  width:var(--die);
  height:calc(var(--die) * 0.8660254038);
  position:relative;
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
  background:#1e88e5;
  border:none;
  --vTopX: 50%;  --vTopY: 0%;
  --vLftX: 0%;   --vLftY: 100%;
  --vRgtX: 100%; --vRgtY: 100%;
  --cx: 50%;
  --cy: calc(100% * 2 / 3);
  --k: 0.45;
}
.tpip{
  width:var(--pip); height:var(--pip);
  background:#fff; border-radius:50%;
  position:absolute;
  transform:translate(-50%,-50%);
}
.t_center{left:var(--cx); top: var(--cy);}
.t_midL{left: calc(var(--cx) - var(--d4-2-gap)); top:  var(--cy);}
.t_midR{left: calc(var(--cx) + var(--d4-2-gap)); top:  var(--cy);}
.t_top{
  left: calc(var(--cx) + (var(--vTopX) - var(--cx)) * var(--k));
  top:  calc(var(--cy) + (var(--vTopY) - var(--cy)) * var(--k));
}
.t_botL{
  left: calc(var(--cx) + (var(--vLftX) - var(--cx)) * var(--k));
  top:  calc(var(--cy) + (var(--vLftY) - var(--cy)) * var(--k));
}
.t_botR{
  left: calc(var(--cx) + (var(--vRgtX) - var(--cx)) * var(--k));
  top:  calc(var(--cy) + (var(--vRgtY) - var(--cy)) * var(--k));
}

  /* =========================================================
     ★②右図形：図形外の背景を透明（パネルの白背景/枠/影を消す）
     ========================================================= */
  .map-panel{
    width:110%;
    height:min(62vh, 340px);
    display:flex;
    justify-content:center;
    align-items:center;
    padding:0;
    overflow:hidden;

    background:transparent !important;
    border:none !important;
    box-shadow:none !important;
  }

  .position-line{
    min-height:16px;
    display:flex;
    flex-wrap:wrap;
    align-items:flex-start;
    justify-content:center;
    gap:4px;
  }
  .position-item{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
    position:relative;
  }
  .position-chip-wrap{
    position:relative;
    display:flex;
    justify-content:center;
    align-items:center;
  }
  .position-bubble{
    position:absolute;
    bottom:calc(100% + 10px);
    left:50%;
    transform:translateX(-50%);
    max-width:120px;
    padding:4px 8px;
    border-radius:8px;
    background:#111;
    border:1px solid #fff;
    color:#fff;
    font-size:10px;
    font-weight:900;
    white-space:nowrap;
    overflow:visible;
    text-overflow:clip;
    line-height:1.2;
    pointer-events:none;
    z-index:2;
  }
  .position-bubble::after{
    content:"";
    position:absolute;
    left:50%;
    top:100%;
    transform:translateX(-50%);
    border:7px solid transparent;
    border-top-color:#111;
  }
  .position-bubble::before{
    content:"";
    position:absolute;
    left:50%;
    top:100%;
    transform:translateX(-50%);
    border:8px solid transparent;
    border-top-color:#fff;
    z-index:-1;
  }
  .starter-mark{
    min-height:10px;
    font-size:10px;
    font-weight:900;
    line-height:1;
    color:#111;
  }
  .position-line.hidden{ display:none; }
  .turn-end-wrap{
    position:fixed;
    right:16px;
    bottom:230px;
    z-index:261;
    display:flex;
    justify-content:center;
  }
  .turn-end-wrap.hidden{display:none;}
  #btnEndTurn{
    width:88px;
    height:88px;
    border-radius:50%;
    padding:0 10px;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    line-height:1.2;
    font-size:13px;
  }

  .endturn-confirm{
    position:fixed;
    left:50%;
    bottom:16px;
    transform:translateX(-50%);
    background:#fff;
    border:1px solid rgba(0,0,0,.18);
    border-radius:12px;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    padding:10px;
    z-index:10060;
    min-width:240px;
  }
  .endturn-confirm.hidden{display:none;}
  .endturn-confirm .msg{font-size:13px;line-height:1.45;margin:0 0 10px;}
  .endturn-confirm .actions{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}
  .position-arrow{
    font-size:12px;
    font-weight:900;
    line-height:1;
    color:#111;
    user-select:none;
    margin-top:2px;
  }

  :root{
    --card-w:72px;
    --card-h:108px;
    --card-gap:6px;

    --wb-black:#111;
    --wb-gold:#caa44a;
    --wb-gold2:#f3dc8a;
    --wb-gray:#e5e5e5;

    --green-dark:#0b3b2e;
    --green-soft:#e9fff4;
  }

  /* =========================================================
     ★③カードテーブル：背景をgear.jpgに
     ========================================================= */
  .cards-panel{
    width:calc(100% + 40px);
    max-width:min(1060px, calc(100vw - 16px));
    display:flex;
    justify-content:center;
    align-items:flex-start;
    padding:6px 12px;
    overflow-x:auto;
    overflow-y:hidden;
    -webkit-overflow-scrolling:touch;

    background-color:#ffffff;
    background-image:url('gear.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    border:1px solid rgba(0,0,0,.08);
    box-shadow:0 12px 28px rgba(0,0,0,.10);
    border-radius:16px;
  }

  .empty-cards-row{
    display:flex;
    gap:var(--card-gap);
    justify-content:flex-start;
    align-items:flex-start;
    flex-wrap:nowrap;
    width:max-content;
    padding:0;
  }

  .room-svg{width:100%;height:100%;display:block;}
  .shape{fill:#f7f7f7;stroke:#111;stroke-width:2;vector-effect:non-scaling-stroke;}
  .roomhit{fill:transparent;cursor:pointer;}
  .roomhit:hover{fill:rgba(0,0,0,.06);}
  .room-choice-pulse{
    transform-box:fill-box;
    transform-origin:center;
    animation:roomChoicePulse 1.2s ease-in-out infinite;
  }
  .room-choice-once{
    transform-box:fill-box;
    transform-origin:center;
    animation:roomChoicePulse 1.2s ease-in-out infinite;
  }
  @keyframes roomChoicePulse{
    0%,100%{ transform:scale(1); }
    50%{ transform:scale(1.05); }
  }

.mark-rect{stroke:#111;stroke-width:1;vector-effect:non-scaling-stroke;}
.mark-rect.guardian-shield{stroke:#d4af37;stroke-width:2;}
.mark-text{font-weight:1000;font-size:10px;dominant-baseline:middle;text-anchor:middle;user-select:none;pointer-events:none;}
.mark-pulse-target{
  transform-box:fill-box;
  transform-origin:center;
  animation:markerPulse 1.2s ease-in-out infinite;
}
.equip-steal-pulse{
  animation:equipStealPulse 1.1s ease-in-out infinite;
  cursor:pointer;
}
.equip-defeat-pulse{
  animation:equipDefeatPulse .9s ease-in-out infinite;
  cursor:pointer;
}
@keyframes equipStealPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.06); }
}
@keyframes equipDefeatPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.14); }
}
@keyframes markerPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.2); }
}
.turn-hint-pop{
  position:fixed;
  top:55px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:nowrap;
  background:#111;
  color:#fff;
  border-radius:10px;
  padding:8px 12px;
  font-size:14px;
  font-weight:800;
  white-space:nowrap;
  z-index:10070;
  box-shadow:0 8px 18px rgba(0,0,0,.28);
}
.turn-hint-pop.hidden{ display:none; }
.turn-hint-action{
  display:inline-block;
  margin:0;
  width:max-content;
  white-space:nowrap;
  font-size:13px;
  color:#fff !important;
  border-color:rgba(255,255,255,.78) !important;
  background:rgba(255,255,255,.08);
}
#roomActionPop.lower-mode{
  left:50% !important;
  top:auto !important;
  bottom:160px;
  transform:translateX(-50%);
}
#roomActionPop.lower-mode .caret{ display:none; }
#roomActionPop.room3-mode .actions{
  flex-wrap:nowrap;
  justify-content:center;
}
#roomActionPop.room3-mode .actions .btn{
  white-space:nowrap;
}

  .card72{
    width:var(--card-w);
    height:var(--card-h);
    border-radius:10px;
    box-sizing:border-box;
    background:rgba(255,255,255,.92);
    border:1.4px solid rgba(17,17,17,.55);
    position:relative;
    overflow:hidden;
    flex:0 0 auto;
    user-select:none;
  }
  .card72.deck{
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    cursor:pointer;
  }

  /* 既存の「薄くする」ロック */
  .card72.locked{
    opacity:.35;
    filter:grayscale(.55);
    cursor:default !important;
    pointer-events:none;
  }

  /* ★追加：薄くしないがクリック不可（白表 / 黒オモテ用） */
  .card72.blocked{
    opacity:1;
    filter:none;
    cursor:default !important;
    pointer-events:none;
  }

  .count-tag{
    position:absolute;
    top:4px;
    right:4px;
    background:rgba(235,235,235,.95);
    color:#111;
    font-weight:1000;
    font-size:12px;
    line-height:1;
    padding:4px 7px;
    border-radius:999px;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 6px 16px rgba(0,0,0,.12);
    z-index:5;
    pointer-events:none;
  }

  .card72.wb-front{
    border:1px solid var(--wb-black);
    border-radius:10px;
    background:#fff;
    cursor:pointer;
  }
  .card72.wb-front.wb-white{ background:#fff; }
  .card72.wb-front.wb-black{ background:#000; }
  .card72.wb-front.wb-green{ background:#74745a; border-color:#0b3b2e; }

  .card72.wb-front .wb-name{
    position:absolute;
    left:2px; right:2px; top:2px;
    height:18px;
    border:2px solid var(--wb-gold);
    border-radius:8px;
    background:#000;
    display:flex;align-items:center;justify-content:center;
    box-sizing:border-box;
    padding:0 4px;
    z-index:3;
  }
  .card72.wb-front.wb-green .wb-name{
    background:var(--green-dark);
    border-color:#d6b35a;
  }
  .card72.wb-front .wb-name span{
    font-size:8px;
    line-height:1;
    font-weight:900;
    letter-spacing:.04em;
    color:var(--wb-gold);
    text-shadow:0 1px 0 rgba(255,255,255,.08);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    width:100%;
    text-align:center;
  }
  .card72.wb-front .wb-circle{
    position:absolute;
    top:14px;
    left:50%;
    transform:translateX(-50%);
    width:60px;height:60px;
    border-radius:50%;
    border:transparent;
    background: radial-gradient(circle at 30% 30%, rgba(243,220,138,.45), rgba(0,0,0,0) 55%);
    box-sizing:border-box;
    overflow:hidden;
    z-index:1;
  }
  .card72.wb-front.wb-green .wb-circle{
    background: radial-gradient(circle at 30% 30%, rgba(34,197,94,.25), rgba(0,0,0,0) 60%);
  }
  .card72.wb-front .wb-circle img{
    width:100%;
    height:100%;
    display:block;
    object-fit:cover;
  }
  .card72.wb-front .wb-effect{
    position:absolute;
    left:2px; right:2px; bottom:2px;
    top:69px;
    background:var(--wb-gray);
    border-radius:6px;
    padding:2px;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    gap:4px;
    overflow:hidden;
    z-index:2;
  }
  .card72.wb-front.wb-green .wb-effect{
    background:rgba(238,223,200,.92);
    border:1px solid rgba(11,59,46,.28);
  }
  .card72.wb-front .wb-desc{
    position:relative;
    z-index:6;
    font-size:6px;
    line-height:1.25;
    font-weight:700;
    color:#111;
    overflow:hidden;
    white-space:pre-wrap;
  }
  .card72.wb-front.wb-black .wb-desc{ color:#111; }
  .card72.wb-front .wb-desc .inline-tag{
    display:inline-block;
    background:#000;
    color:#fff;
    font-weight:900;
    font-size:6px;
    line-height:1;
    padding:2px 4px;
    border-radius:4px;
    margin-right:2px;
    vertical-align:baseline;
  }

  /* ★追加：0枚（空）のときは枠なし */
  .card72.noframe{
    background:transparent;
    border:none !important;
  }

  /* ★④ 正体カード（右下）：裏面表示用 */
  .role-back{
    width:72px;height:108px;
    border-radius:10px;
    border:1.4px solid rgba(17,17,17,.55);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    cursor:pointer;
    box-shadow:0 10px 26px rgba(0,0,0,.18);
  }

  .zoom-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.55);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:9999;
    padding:18px;
  }
  .zoom-backdrop.hidden{ display:none; }
  .zoom-backdrop.passthrough{
    pointer-events:none;
    background:transparent;
  }
  .zoom-backdrop.passthrough .zoom-stage{
    pointer-events:none;
  }
  .zoom-stage{
    position:relative;
    width:72px;
    height:108px;
    transform:scale(var(--zoom, 4));
    transform-origin:center;
    will-change:transform;
    transition:transform .35s ease;
  }
  .zoom-backdrop.green-reveal-active .zoom-stage{
    transform:translateX(-90px) scale(var(--zoom, 4));
  }
  .zoom-backdrop.david-select-active .zoom-stage{
    transform:translateX(-90px) scale(var(--zoom, 4));
  }
  .zoom-stage .card72,
  .zoom-stage .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
  }
  .zoom-stage .equip-steal-pulse{
    animation:none;
  }
  .zoom-stage .equip-defeat-pulse{
    animation:none;
  }
  .zoom-identity-owner{
    position:absolute;
    left:50%;
    top:-22px;
    transform:translateX(-50%);
    display:flex;
    align-items:center;
    gap:6px;
    background:#fff;
    border:1px solid rgba(0,0,0,.15);
    border-radius:999px;
    padding:4px 8px;
    font-size:12px;
    font-weight:700;
    color:#111;
    white-space:nowrap;
    line-height:1;
  }
  .zoom-identity-owner .equip-tag{
    width:8px;
    height:8px;
    min-width:8px;
    min-height:8px;
    font-size:8px;
    border-width:1px;
  }
  .eliminated-dim{
    opacity:.7;
  }
  .marker-eliminated{
    opacity:.45;
  }
  .chip16.eliminated-clickable{
    opacity:.45;
    cursor:pointer;
  }
  .zoom-close{
    position:fixed;
    right:14px;
    top:14px;
    z-index:10000;
    width:40px;
    height:40px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.55);
    background:rgba(17,17,17,.7);
    color:#fff;
    font-size:20px;
    font-weight:900;
    cursor:pointer;
  }
  .zoom-close.hidden{ display:none; }

  .green-share-dock{
    position:fixed;
    left:50%;
    top:500px;
    transform:translateX(-50%);
    z-index:10001;
    width:min(380px, calc(100vw - 40px));
    background:rgba(255,255,255,.96);
    border:1px solid rgba(0,0,0,.12);
    border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.26);
    padding:10px;
  }
  .green-share-dock.hidden{ display:none; }
  .green-share-title{
    font-size:13px;
    font-weight:900;
    margin:0 0 8px;
  }
  .green-share-subtitle{
    font-size:12px;
    margin:0 0 8px;
    color:#333;
    line-height:1.4;
  }
  .green-share-list{
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:8px;
  }
  .green-share-actions{
    display:flex;
    justify-content:flex-end;
    margin-top:-30px;
  }
  .green-share-actions.hidden{ display:none; }
  .green-share-btn{
    border:1px solid rgba(0,0,0,.15);
    border-radius:999px;
    background:#fff;
    width:100%;
    padding:4px 8px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    font-weight:700;
  }
  .green-share-btn.answer{
    justify-content:center;
    border-radius:8px;
    border-color:#111;
    background:#111;
    color:#fff;
  }
  .green-share-btn.answer:disabled{
    opacity:1;
    background:#b8b8b8;
    border-color:#b8b8b8;
    color:#fff;
  }
  .green-share-btn:disabled{
    opacity:.45;
    cursor:default;
  }
  .green-share-btn.waiting-selected{
    opacity:1;
  }

  .green-reveal-panel{
    position:fixed;
    left:50%;
    top:50%;
    width:72px;
    height:108px;
    transform:translate(-50%,-50%) translateX(60px);
    z-index:10002;
    pointer-events:none;
    opacity:0;
    transition:transform .35s ease, opacity .35s ease;
  }
  .zoom-backdrop.green-reveal-active .green-reveal-panel{
    transform:translate(-50%,-50%) translateX(95px);
    opacity:1;
  }
  .green-reveal-panel.hidden{ display:none; }
  .green-reveal-panel.reveal-slide-in .green-reveal-card-wrap .id72{
    animation:greenRevealSlideIn .42s cubic-bezier(.16,.84,.28,1);
  }
  @keyframes greenRevealSlideIn{
    from{ transform:translateX(220px) scale(2); opacity:0; }
    to{ transform:translateX(0) scale(2); opacity:1; }
  }
  .green-reveal-label{
    position:absolute;
    left:50%;
    top:calc(100% + 8px);
    transform:translateX(-50%);
    font-size:12px;
    font-weight:900;
    color:#fff;
    text-shadow:0 2px 8px rgba(0,0,0,.55);
    white-space:nowrap;
  }
  .green-reveal-card-wrap{
    position:absolute;
    inset:0;
  }
  .green-reveal-card-wrap .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    transform:scale(2);
    transform-origin:center;
  }

  .david-select-preview{
    position:fixed;
    left:50%;
    top:50%;
    width:72px;
    height:108px;
    transform:translate(-50%,-50%) translateX(95px);
    z-index:10003;
    pointer-events:none;
    opacity:0;
    transition:transform .2s ease, opacity .2s ease;
  }
  .zoom-backdrop.david-select-active .david-select-preview{
    opacity:1;
  }
  .david-select-preview.hidden{ display:none; }
  .david-select-preview .card72,
  .david-select-preview .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    transform:scale(2);
    transform-origin:center;
  }
</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <div class="small attack-roll-result-debug" id="attackRollResult" aria-live="polite"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="gameArea" class="game-area hidden" aria-label="ゲーム面">
      <div class="top-row">
        <div class="panel left-panel">
          <div id="hpBoard" class="hp-board" aria-label="HPボード"></div>
        </div>

        <div class="right-panel">
          <div class="panel map-panel">
            <svg id="roomSvg" class="room-svg" viewBox="-170 -170 340 340" preserveAspectRatio="xMidYMid meet" aria-label="部屋マップ">
              <g id="roomG"></g>
            </svg>
          </div>
          <div id="positionLine" class="position-line hidden" aria-label="位置列"></div>
          <div id="turnEndWrap" class="turn-end-wrap hidden">
            <button id="btnEndTurn" class="btn primary">手番を終わる</button>
          </div>
        </div>
      </div>

      <div class="panel cards-panel" id="cardsPanel" aria-label="デッキ">
        <div class="empty-cards-row">
          <div id="slot1" class="card72"></div>
          <div id="slot2" class="card72"></div>
          <div id="slot3" class="card72"></div>
          <div id="slot4" class="card72"></div>
          <div id="slot5" class="card72"></div>
        </div>
      </div>
    </div>
  </div>
</main>

<!-- 拡大表示 -->
<div id="zoomBackdrop" class="zoom-backdrop hidden" aria-label="拡大表示">
  <button id="zoomCloseBtn" class="zoom-close hidden" aria-label="閉じる">×</button>
  <div id="zoomStage" class="zoom-stage" style="--zoom:2"></div>
  <div id="greenRevealPanel" class="green-reveal-panel hidden" aria-live="polite">
    <div id="greenRevealLabel" class="green-reveal-label"></div>
    <div id="greenRevealCardWrap" class="green-reveal-card-wrap"></div>
  </div>
  <div id="davidSelectPreview" class="david-select-preview hidden" aria-hidden="true"></div>
  <div id="greenShareDock" class="green-share-dock hidden" aria-label="緑カード共有">
    <p class="green-share-title">誰に渡しますか。</p>
    <p id="greenShareSubtitle" class="green-share-subtitle hidden"></p>
    <div id="greenShareList" class="green-share-list"></div>
    <div id="greenShareActions" class="green-share-actions hidden">
      <button id="greenShareCloseBtn" class="btn ghost" type="button">閉じる</button>
    </div>
  </div>
</div>

<!-- 公開確認ポップ -->
<div id="revealPop" class="confirm-pop hidden" role="dialog" aria-label="公開確認">
  <p class="msg" id="revealMsg">公開しますか？</p>
  <div class="actions">
    <button class="btn primary" id="btnRevealYes">はい</button>
    <button class="btn ghost" id="btnRevealNo">いいえ</button>
  </div>
</div>

<div id="attackPop" class="confirm-pop hidden" role="dialog" aria-label="攻撃確認">
  <div class="caret" aria-hidden="true"></div>
  <p class="msg" id="attackMsg">攻撃しますか。</p>
  <div class="actions">
    <button class="btn primary" id="btnAttackYes">はい</button>
    <button class="btn ghost" id="btnAttackNo">いいえ</button>
  </div>
</div>

<div id="identityPromptPop" class="confirm-pop bottom-fixed hidden" role="dialog" aria-label="陣営公開確認">
  <p class="msg" id="identityPromptMsg"></p>
  <div class="actions">
    <button class="btn" id="btnIdentityPromptYes">はい</button>
    <button class="btn" id="btnIdentityPromptNo">いいえ</button>
  </div>
</div>

<div id="roomActionPop" class="confirm-pop hidden" role="dialog" aria-label="部屋効果確認">
  <div class="caret" aria-hidden="true"></div>
  <p class="msg" id="roomActionMsg"></p>
  <div class="actions">
    <button class="btn primary" id="btnRoomActionYes">はい</button>
    <button class="btn ghost" id="btnRoomActionNo">いいえ</button>
  </div>
</div>

<div id="turnHintPop" class="turn-hint-pop hidden" aria-live="polite"></div>

<div id="endTurnConfirm" class="endturn-confirm hidden" role="dialog" aria-label="手番終了確認">
  <p class="msg" id="endTurnConfirmMsg">本当に終了しますか。</p>
  <div class="actions">
    <button class="btn primary" id="btnEndTurnYes">はい</button>
    <button class="btn ghost" id="btnEndTurnNo">いいえ</button>
  </div>
</div>


<div id="seatPopBackdrop" class="seat-pop-backdrop hidden" aria-label="座席カラータイル">
  <div class="seat-board" id="seatBoard">
    <div class="seat-board-title">
      <span>プレイヤーカラーを選択してください。</span>
      <span class="seat-count-badge" id="seatCountBadge">0 / 12</span>
    </div>
    <div id="tileGrid" class="tile-grid"></div>
    <div class="warn" id="startWarn">※ホストが「スタート」を押すと配布されます</div>

    <div class="seat-board-actions">
      <button id="btnSpectate" class="btn ghost">観戦</button>
    </div>
  </div>
</div>

<!-- 装備枠 -->
<div id="equipDock" class="equip-dock" aria-label="装備枠">
  <div class="equip-board">
    <div class="equip-body" id="equipBody"></div>
  </div>
</div>

<div id="myRoleDock" class="my-role-dock" aria-label="自分の正体カード">
  <div id="myRoleCard"></div>
</div>

<div id="diceRollOverlay" class="dice-roll-overlay" aria-hidden="true"></div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn danger" id="btnKickYes">はい</button>
      <button class="btn ghost" id="btnKickNo">キャンセル</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード（一覧）</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    <span class="start-badge" id="startBadge">参加人数：0</span><br>
    「スタート」で参加人数に応じた構成で、全員に正体カードを1枚配布。<br>
    「リセット」で席・正体をリセットします。<br>
    <span class="small">開始後は座席変更できません。</span>
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, set, get, update, onValue, remove, runTransaction } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
    authDomain: "timebomb-3b0c7.firebaseapp.com",
    databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
    projectId: "timebomb-3b0c7",
    storageBucket: "timebomb-3b0c7.firebasestorage.app",
    messagingSenderId: "532935786630",
    appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
    measurementId: "G-K8NRR8K64Y"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);
  const USER_NAME_CACHE_KEY = "bbCachedUserName";

  const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
  sessionStorage.setItem('bbUserId', savedUserId);

  function setHpRowHeights(map){
    const root = document.documentElement;
    for (let i=0;i<=15;i++){
      const key = `--hp-r${i}`;
      if (map && Object.prototype.hasOwnProperty.call(map, i)) {
        root.style.setProperty(key, String(map[i]));
      }
    }
  }

  const equipDock = document.getElementById("equipDock");
  const cardsPanel = document.getElementById("cardsPanel");

  function updateEquipDockTop(){
    if (!equipDock || !cardsPanel) return;
    const rect = cardsPanel.getBoundingClientRect();
    if (!Number.isFinite(rect.bottom) || rect.bottom <= 0) return;
    const gap = 6;
    const top = Math.round(rect.bottom + gap);
    const minTop = 80;
    equipDock.style.setProperty('--equip-top', `${Math.max(minTop, top)}px`);
  }
  window.addEventListener('resize', () => { updateEquipDockTop(); });

  const GREEN_DECK = [
    { text:"推理カード：正体カードを見せよ。" },
    { text:"推理カード：あなたは D / F / G / V / W ?（HP12以上）だったら2ダメージ受けよ。" },
    { text:"推理カード：あなたは A / B / C / E / U ?（HP11以下）だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら2ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か レイダー？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か レイダー？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
  ];

  const WHITE_DECK = [
    { name:"銀のロザリオ", effect:"装備、ダイスの攻撃によって倒したPLの全ての装備を奪う。" },
    { name:"銀のロザリオ", effect:"装備、ダイスの攻撃によって倒したPLの全ての装備を奪う。" },
    { name:"虹色のパラソル", effect:"装備、攻撃する代わりに攻撃レンジのPLに推理カードを渡す。" },
    { name:"エクスカリバー", effect:"装備、あなたがレイダーなら、攻撃ダメージが 2 上がる。" },
    { name:"神秘のコンパス", effect:"装備、移動の時にダイスを二回振って、選ぶことができる。" },
    { name:"幸運のブローチ", effect:"装備、市庁舎(8)の効果ダメージを受けない。" },
    { name:"賢者のローブ", effect:"装備、与える攻撃ダメージ、受ける攻撃ダメージが 1 減少する。" },
    { name:"いにしえの聖杯", effect:"装備、三つ目の黒犬,吸血コウモリ,呪いの人形の効果を受けない。" },
    { name:"光臨", effect:"あなたがレイダーなら、全ダメージを回復する。" },
    { name:"守護天使", effect:"次の自分の手番の始めまで、攻撃ダメージを受けない。" },
    { name:"封印の知恵", effect:"この手番の終了後、もう1手番を行う。" },
    { name:"応急手当", effect:"任意のPL（自分も可）を選び、そのPLのダメージを7にする。" },
    { name:"人魚の涙", effect:"最もダメージが多い人を 3 回復する。" },
    { name:"幸せのクッキー", effect:"あなたが A または U なら、HPを全回復する。" },
    { name:"闇を祓う鏡", effect:"あなたがシャドウ陣営でウルリッヒでないなら、必ず正体カードを公開する。" },
    { name:"いやしの聖水", effect:"自分のダメージを 2 回復する。" },
    { name:"いやしの聖水", effect:"自分のダメージを 2 回復する。" },
    { name:"いやしの聖水", effect:"自分のダメージを 2 回復する。" },
    { name:"裁きの閃光", effect:"自分以外のPL全員に 2 ダメージ与える。" },
    { name:"恩恵", effect:"自分以外のPLを選び、6面ダイスを振る。目の数回復する。" },
  ];

  const BLACK_DECK = [
    { name:"サーベル", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"拳銃R", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"拳銃L", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"クロスボウガン", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"妖刀マサムネ", effect:"装備、攻撃レンジにPLがいれば必ず攻撃を行う。4面ダイスだけを使う。" },
    { name:"ガトリング", effect:"装備、攻撃レンジのPL全員に攻撃する。" },
    { name:"死神スコープ", effect:"装備、攻撃レンジが 1 増加する。" },
    { name:"死神スコープ", effect:"装備、攻撃レンジが 1 増加する。" },
    { name:"オリバーの子分", effect:"任意のPLを選んで、装備を1つ奪う。" },
    { name:"オリバーの子分", effect:"任意のPLを選んで、装備を1つ奪う。" },
    { name:"オリバーの子分", effect:"任意のPLを選んで、装備を1つ奪う。" },
    { name:"吸血コウモリ", effect:"自分以外のPL1人に2ダメージ与え,自分は1回復する。" },
    { name:"吸血コウモリ", effect:"自分以外のPL1人に2ダメージ与え,自分は1回復する。" },
    { name:"吸血コウモリ", effect:"自分以外のPL1人に2ダメージ与え,自分は1回復する。" },
    { name:"三つ目の黒犬", effect:"自分と選んだPL1人に2ダメージ与える。" },
    { name:"三つ目の黒犬", effect:"自分と選んだPL1人に2ダメージ与える。" },
    { name:"暴動", effect:"ダイスを2つ振り、目のエリアにいるPL全員に3ダメージ与える。" },
    { name:"バナナの皮", effect:"装備を1つ誰かに渡す。なければ 1 ダメージ受ける。" },
    { name:"呪いの人形", effect:"PLを1人選び6面ダイスを振る。1-4なら選んだPLに、5-6なら自分に3ダメージ与える。" },
    { name:"戦慄の闇儀式", effect:"あなたがシャドウで正体を公開したら、全回復する。" },
  ];

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  function safeText(s){ return String(s ?? ""); }
  function escapeHtml(s){
    return safeText(s)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }
  function escHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function cardImageFileFromName(cardName){
    const safe = encodeURI(String(cardName || "").trim());
    return safe ? `${safe}.jpg` : "";
  }
  function rgbFromHex(hex){
    const h = String(hex||"").trim();
    if(!h.startsWith("#") || (h.length!==7 && h.length!==4)) return {r:0,g:0,b:0};
    if(h.length===4){
      const r = parseInt(h[1]+h[1],16);
      const g = parseInt(h[2]+h[2],16);
      const b = parseInt(h[3]+h[3],16);
      return {r,g,b};
    }
    const r = parseInt(h.slice(1,3),16);
    const g = parseInt(h.slice(3,5),16);
    const b = parseInt(h.slice(5,7),16);
    return {r,g,b};
  }
  function textColorFor(bgHex){
    const {r,g,b} = rgbFromHex(bgHex);
    const L = (0.2126*r + 0.7152*g + 0.0722*b)/255;
    return (L < 0.55) ? "#fff" : "#111";
  }
  function firstChar(name){
    if(!name) return '';
    return Array.from(name.trim())[0] || '';
  }
  function isEquipCard(cardObj){
    const eff = safeText(cardObj?.effect || "").trim();
    if (!eff) return false;
    if (eff === "装備") return true;
    const prefixes = ["装備、","装備,","装備：","装備:","装備 "];
    return prefixes.some(p => eff.startsWith(p));
  }

  const ROOM_ALLOW = {
    1: ["white"],
    2: ["black"],
    5: ["green"],
    6: ["green","white","black"],
  };
  function allowedTypesByRoom(roomId){ return ROOM_ALLOW[roomId] || []; }
  function hasRainbowParasolEquip(uid = state.userId){
    if (!uid) return false;
    return listEquipForUid(uid).some(item => {
      if (isIdentityEquipItem(item)) return false;
      return safeText(item?.name || "").trim() === "虹色のパラソル";
    });
  }
  function canUseParasolGreenDraw(){
    if (!isMyTurn()) return false;
    if (!hasRainbowParasolEquip(state.userId)) return false;
    const turn = turnState() || {};
    if (!turn.moveDone || turn.attackDone) return false;
    return remainingCount(deckCache?.green) > 0;
  }
  function canDrawTypeNormally(type){
    const allowed = allowedTypesByRoom(state.currentRoomId);
    if (!allowed.includes(type)) return false;
    return canDrawSharedDeckNow();
  }
  function canDrawSharedDeckNow(){
    if (!isMyTurn()) return false;
    const t = turnState() || {};
    if (isTestPlayer()) return !!t.moveDone && !t.attackDone;
    return !!t.moveDone && !t.attackDone && !t.deckDrawDone;
  }
  function canClickType(type){
    if (canDrawTypeNormally(type)) return true;
    if (type === "green" && canUseParasolGreenDraw()) return true;
    return false;
  }
  function applyLocked(el, locked, {noDim=false} = {}){
    if (!el) return;
    el.classList.toggle("locked", !!locked && !noDim);
    el.classList.toggle("blocked", !!locked && !!noDim);
    if (!locked){
      el.classList.remove("locked","blocked");
    }
  }

  function ensureCountTag(el){
    let tag = el.querySelector('.count-tag');
    if (!tag){
      tag = document.createElement('div');
      tag.className = 'count-tag';
      el.appendChild(tag);
    }
    return tag;
  }

  function setSlotAsDeck(slotEl, imgUrl, count, { disabled=false, type=null } = {}){
    slotEl.className = 'card72 deck' + (disabled ? ' disabled' : '');
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = `url('${imgUrl}')`;
    slotEl.innerHTML = '';
    const tag = ensureCountTag(slotEl);
    tag.textContent = String(count);
    slotEl.dataset.cardType = type || "";
  }

  function buildWbFrontHTML(cardObj, theme){
    const name = safeText(cardObj?.name || "（なし）").trim();
    const img  = (theme === "green") ? "suiri.jpg" : cardImageFileFromName(name);

    let eff = safeText(cardObj?.effect || "");
    let showEquip = false;

    const trimmed = eff.trim();
    const prefixes = ["装備、","装備,","装備：","装備:","装備 "];
    for (const p of prefixes){
      if (trimmed.startsWith(p)){
        showEquip = true;
        eff = trimmed.slice(p.length).trim();
        break;
      }
    }
    if (!showEquip && trimmed === "装備"){
      showEquip = true;
      eff = "";
    }

    const tagHtml = showEquip ? `<span class="inline-tag">装備</span>` : "";
    const effHtml = escHtml(eff);

    return `
      <div class="wb-name"><span>${escHtml(name)}</span></div>
      <div class="wb-circle" aria-label="card image circle">
        ${img ? `<img src="${escHtml(img)}" alt="${escHtml(name)}">` : ``}
      </div>
      <div class="wb-effect">
        <div class="wb-desc">${tagHtml}${effHtml}</div>
      </div>
    `;
  }

  function setSlotAsWbFront(slotEl, cardObj, theme){
    slotEl.className = `card72 wb-front ${theme === 'black' ? 'wb-black' : theme === 'green' ? 'wb-green' : 'wb-white'}`;
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = buildWbFrontHTML(cardObj, theme);
    slotEl.dataset.cardType = theme || "";
  }

  function setSlotEmpty(slotEl){
    slotEl.className = 'card72';
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = '';
    slotEl.dataset.cardType = "";
  }

  function setSlotEmptyNoFrame(slotEl){
    slotEl.className = 'card72 noframe';
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = '';
    slotEl.dataset.cardType = "";
  }

  const zoomBackdrop = document.getElementById("zoomBackdrop");
  const zoomStage = document.getElementById("zoomStage");
  const zoomCloseBtn = document.getElementById("zoomCloseBtn");
  const greenRevealPanel = document.getElementById("greenRevealPanel");
  const greenRevealLabel = document.getElementById("greenRevealLabel");
  const greenRevealCardWrap = document.getElementById("greenRevealCardWrap");
  const davidSelectPreview = document.getElementById("davidSelectPreview");
  const greenShareDock = document.getElementById("greenShareDock");
  const greenShareList = document.getElementById("greenShareList");
  const greenShareSubtitle = document.getElementById("greenShareSubtitle");
  const greenShareActions = document.getElementById("greenShareActions");
  const greenShareCloseBtn = document.getElementById("greenShareCloseBtn");
  if (greenShareDock && greenShareDock.parentElement === zoomBackdrop){
    document.body.appendChild(greenShareDock);
  }
  let zoomCloseOnBackdrop = true;
  let greenShareCard = null;
  let greenInboxSeenAt = 0;
  let greenInboxInitialized = false;
  let greenReplySeenAt = 0;
  let greenReplyInitialized = false;
  let greenZoomLocked = false;
  let pendingGreenRequestId = "";
  let pendingGreenAnswerMsg = null;
  let pendingGreenCloseSeenAt = 0;
  let pendingGreenCloseInitialized = false;
  let greenRevealByRequestId = {};
  const TURN_START_ONLY_REVEAL_ROLE_IDS = new Set([
    "CIT_D2", // デーヴィッド
    "CIT_D3", // デボラ
    "CIT_A1", // アリス
    "CIT_C3", // クレア
    "CIT_C2", // キャロル
    "RAI_E2", // エリカ
    "RAI_F1", // フェリックス
    "RAI_F2", // フェリシア
    "SHA_U2", // ウラヌス
  ]);
  const REVEAL_ENDS_TURN_ROLE_IDS = new Set([
    "CIT_A3", // アガサ
    "CIT_B2", // ベンジャミン
    "RAI_E3", // エマ
    "RAI_G1", // ゴードン
    "SHA_W1", // ワイト
  ]);
  let cardPlayerSelectActive = false;
  let activeGreenReplies = {};
  let moveDiceEventSeenAt = 0;
  let moveDiceEventInitialized = false;
  let attackDiceEventSeenAt = 0;
  let attackDiceEventInitialized = false;
  let roleFlashEventSeenAt = 0;
  let roleFlashEventInitialized = false;
  let walpurgisSwapEventSeenAt = 0;
  let walpurgisSwapEventInitialized = false;
  let roleFlashTimer = null;
  let roleFlashOverlayEl = null;
  let identityRevealInitialized = false;
  let identityRevealSeenByUid = {};
  let autoDamageRevealLock = {};
  let temporaryRoleTagByUid = {};
  let roomAbilityTurnKey = "";
  let room4StealUsed = false;
  let room3ActionUsed = false;
  let walpurgisSwapUsed = false;
  let movedByDiceRoomId = null;
  let pendingRoomAction = null;
  let uranusMeteorResolved = false;
  let vampireHiddenAttackSuccess = false;
  let vampireHealScheduled = false;
  let pendingEquipAction = null;
  let danielAutoRevealTimer = null;
  let effectResolutionLocks = {};
  let zoomPassthroughMode = false;
  let zoomDismissHandler = null;
  let suppressOutsidePopCloseUntil = 0;
  let pendingRevealAction = "";

  const revealPop = document.getElementById("revealPop");
  const revealMsg = document.getElementById("revealMsg");
  const btnRevealYes = document.getElementById("btnRevealYes");
  const btnRevealNo  = document.getElementById("btnRevealNo");
  const attackPop = document.getElementById("attackPop");
  const attackMsg = document.getElementById("attackMsg");
  const btnAttackYes = document.getElementById("btnAttackYes");
  const btnAttackNo = document.getElementById("btnAttackNo");
  const roomActionPop = document.getElementById("roomActionPop");
  const roomActionMsg = document.getElementById("roomActionMsg");
  const btnRoomActionYes = document.getElementById("btnRoomActionYes");
  const btnRoomActionNo = document.getElementById("btnRoomActionNo");
  const turnHintPop = document.getElementById("turnHintPop");
  const identityPromptPop = document.getElementById("identityPromptPop");
  const identityPromptMsg = document.getElementById("identityPromptMsg");
  const btnIdentityPromptYes = document.getElementById("btnIdentityPromptYes");
  const btnIdentityPromptNo = document.getElementById("btnIdentityPromptNo");
  let pendingAttackTargetUid = "";
  let pendingIdentityPrompt = null;

  function placeFloatingPop(popEl, clientX, clientY, { yOffset = 0 } = {}){
    if (!popEl) return;
    const pad = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const r = popEl.getBoundingClientRect();

    let x = Number(clientX);
    let y = Number(clientY);
    if (!Number.isFinite(x)) x = vw / 2;
    if (!Number.isFinite(y)) y = vh / 2;

    const halfW = r.width / 2;
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;

    let top = y + 18 + Number(yOffset || 0);
    if (top + r.height > vh - pad) top = y - r.height - 18;
    top = Math.max(pad, Math.min(top, vh - pad - r.height));

    popEl.style.left = x + "px";
    popEl.style.top = top + "px";
  }

  function skipRoom3ActionAndStartAttack(){
    if (!canUseRoom3Action()) return;
    room3ActionUsed = true;
    hideRoomActionPop();
    showTurnHint("");
    renderMarkers();
  }

  function roleAbilityName(role){
    const effect = safeText(role?.effect || "").trim();
    if (!effect) return "特殊能力";
    const match = effect.match(/^([^：:]+)[：:]/);
    return safeText(match?.[1] || effect).trim() || "特殊能力";
  }

  function showRevealPopAt(anchorEl, options = {}){
    const role = myRoleInfo();
    const ability = roleAbilityName(role);
    const mode = options.mode === "notice" ? "notice" : "confirm";
    const message = safeText(options.message || "").trim();
    pendingRevealAction = safeText(options.action || "");
    if (revealMsg){
      if (mode === "notice"){
        revealMsg.textContent = message || "手番の初めにだけ正体を公開できます。";
        pendingRevealAction = "";
      } else if (options.messageHtml){
        revealMsg.innerHTML = String(options.messageHtml);
      } else {
        const suffix = options.appendEndTurnNotice ? "使用後に手番が終了します。" : "";
        revealMsg.innerHTML = `正体を公開して、<span class="ability-pill">${ability}</span>を使いますか。${suffix}`;
      }
    }
    btnRevealYes?.classList.toggle("hidden", mode === "notice");
    if (btnRevealNo){
      btnRevealNo.textContent = (mode === "notice") ? "OK" : "いいえ";
    }
    revealPop.classList.remove("hidden");
    if (!anchorEl){
      placeFloatingPop(revealPop, window.innerWidth / 2, window.innerHeight / 2);
      return;
    }
    const pad = 10;
    const gap = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const anchorRect = anchorEl.getBoundingClientRect();
    const popRect = revealPop.getBoundingClientRect();
    const halfW = popRect.width / 2;
    let x = anchorRect.left + (anchorRect.width / 2);
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;
    let top = anchorRect.bottom + gap;
    if (top + popRect.height > vh - pad){
      top = Math.max(pad, anchorRect.top - popRect.height - gap);
    }
    top = Math.max(pad, Math.min(top, vh - pad - popRect.height));
    revealPop.style.left = `${x}px`;
    revealPop.style.top = `${top}px`;
  }
  function hideRevealPop(){
    revealPop.classList.add("hidden");
    pendingRevealAction = "";
  }

  function eliminatedPlayerCount(){
    return latestPlayers.filter(p => isPlayerEliminated(p.id)).length;
  }

  function isWightAbilityUsed(){
    return !!state.room?.abilityUsage?.wight?.[state.userId];
  }

  async function markWightAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/wight/${state.userId}`), true);
  }

  function canUseWightAbilityNow(){
    if (!isMyRole("SHA_W1")) return { ok:false, message:"今は公開できません。" };
    if (isWightAbilityUsed()) return { ok:false, message:"今は公開できません。" };
    if (!turnState()?.moveDone) return { ok:false, message:"今は公開できません。" };
    const eliminated = eliminatedPlayerCount();
    if (eliminated <= 0) return { ok:false, message:"今は公開できません。" };
    return { ok:true, eliminated };
  }

  async function activateWightAbilityAndEndTurn(){
    const check = canUseWightAbilityNow();
    if (!check.ok) return false;
    await markWightAbilityUsed();
    await update(ref(db, `rooms/${state.roomCode}/turn`), {
      repeatTurnRemaining: check.eliminated,
      repeatTurnTotal: check.eliminated,
      updatedAt: Date.now()
    });
    await doEndTurn();
    return true;
  }

  function showAttackPopAt(clientX, clientY, targetName){
    if (!attackPop) return;

    if (hasMyEquipmentByName("ガトリング")){
      attackMsg.textContent = "レンジ内のプレイヤー全員を攻撃します。はい、いいえ";
    } else {
      attackMsg.textContent = `${safeText(targetName || "このプレイヤー")}を攻撃しますか。`;
    }
    attackPop.classList.remove("hidden");
    placeFloatingPop(attackPop, clientX, clientY);
  }
  function hideAttackPop(){
    pendingAttackTargetUid = "";
    attackPop?.classList.add("hidden");
  }

  function showTurnHint(message){
    if (!turnHintPop) return;
    if (message && typeof message === "object"){
      const text = safeText(message.text || "");
      const showSkip = !!message.showRoom3Skip;
      turnHintPop.innerHTML = "";
      if (text){
        const textWrap = document.createElement("span");
        textWrap.textContent = text;
        turnHintPop.appendChild(textWrap);
      }
      if (showSkip){
        const btn = document.createElement("button");
        btn.className = "btn ghost turn-hint-action";
        btn.textContent = "スキップ(して攻撃)";
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          skipRoom3ActionAndStartAttack();
        });
        turnHintPop.appendChild(btn);
      }
      turnHintPop.classList.toggle("hidden", !text && !showSkip);
      return;
    }
    turnHintPop.textContent = safeText(message || "");
    turnHintPop.classList.toggle("hidden", !message);
  }

  function hideDavidSelectPreview(){
    zoomBackdrop?.classList.remove("david-select-active");
    davidSelectPreview?.classList.add("hidden");
    if (davidSelectPreview) davidSelectPreview.innerHTML = "";
  }

  function showDavidSelectPreviewFromCard(cardEl){
    if (!davidSelectPreview || !cardEl) return;
    const clone = cardEl.cloneNode(true);
    clone.classList.remove("locked","blocked","equip-steal-pulse","equip-defeat-pulse","eliminated-dim");
    clone.style.pointerEvents = "none";
    davidSelectPreview.innerHTML = "";
    davidSelectPreview.appendChild(clone);
    davidSelectPreview.classList.remove("hidden");
    zoomBackdrop?.classList.add("david-select-active");
  }

  function hideRoomActionPop(){
    pendingRoomAction = null;
    roomActionPop?.classList.add("hidden");
    roomActionPop?.classList.remove("lower-mode", "room3-mode");
    if (btnRoomActionYes){
      btnRoomActionYes.textContent = "はい";
      btnRoomActionYes.classList.remove("pop-purple","pop-white");
    }
    if (btnRoomActionNo){
      btnRoomActionNo.textContent = "いいえ";
      btnRoomActionNo.classList.remove("pop-purple","pop-white");
    }
    if (pendingEquipAction?.type === "david_select") hideDavidSelectPreview();
  }

  function showRoomActionPopAt(clientX, clientY, message, onYes, options = {}){
    if (!roomActionPop || !roomActionMsg) return;
    const fixedLower = !!options.fixedLower;
    const compactButtons = !!options.compactButtons;
    const yOffset = Number(options.yOffset) || 0;
    pendingRoomAction = {
      onYes: (typeof onYes === "function") ? onYes : null,
      onNo: (typeof options.onNo === "function") ? options.onNo : null,
      closeZoomOnNo: !!options.closeZoomOnNo,
      dismissOnOutside: options.dismissOnOutside !== false
    };
    const yesBtnClass = safeText(options.yesBtnClass || "");
    const noBtnClass = safeText(options.noBtnClass || "");
    if (options.messageHtml){
      roomActionMsg.innerHTML = String(options.messageHtml);
    } else {
      roomActionMsg.textContent = safeText(message || "");
    }
    if (btnRoomActionYes){
      btnRoomActionYes.textContent = safeText(options.yesLabel || "はい");
      btnRoomActionYes.classList.remove("pop-purple","pop-white");
      if (yesBtnClass) btnRoomActionYes.classList.add(yesBtnClass);
    }
    if (btnRoomActionNo){
      btnRoomActionNo.textContent = safeText(options.noLabel || "いいえ");
      btnRoomActionNo.classList.remove("pop-purple","pop-white");
      if (noBtnClass) btnRoomActionNo.classList.add(noBtnClass);
    }
    roomActionPop.classList.remove("hidden");
    roomActionPop.classList.toggle("lower-mode", fixedLower);
    roomActionPop.classList.toggle("room3-mode", compactButtons);

    if (fixedLower){
      roomActionPop.style.left = "";
      roomActionPop.style.top = "";
      return;
    }

    const pad = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const r = roomActionPop.getBoundingClientRect();
    let x = clientX;
    let y = clientY;
    const halfW = r.width / 2;
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;
    let top = y + 18 + yOffset;
    if (top + r.height > vh - pad) top = y - r.height - 18;
    top = Math.max(pad, Math.min(top, vh - pad - r.height));
    roomActionPop.style.left = x + "px";
    roomActionPop.style.top  = top + "px";
  }

  function hideIdentityPrompt(){
    pendingIdentityPrompt = null;
    identityPromptPop?.classList.add("hidden");
  }

  function showIdentityPromptPop({ message, canReveal, onYes, onNo=null, cardObj=null, cardTheme="white", openZoom=false }){
    if (!identityPromptPop || !identityPromptMsg || !btnIdentityPromptYes || !btnIdentityPromptNo) return;
    if (openZoom && cardObj){
      openZoomFromDeckCard(cardObj, cardTheme, { closeOnBackdrop:false, showCloseButton:false });
    }
    pendingIdentityPrompt = {
      onYes: typeof onYes === "function" ? onYes : null,
      onNo: typeof onNo === "function" ? onNo : null,
      closeZoomOnChoice: !!openZoom
    };
    identityPromptMsg.textContent = safeText(message || "");

    btnIdentityPromptYes.classList.toggle("pop-disabled", !canReveal);
    btnIdentityPromptYes.classList.toggle("pop-dark", !!canReveal);
    btnIdentityPromptNo.classList.remove("pop-disabled");
    btnIdentityPromptNo.classList.add("pop-dark");
    btnIdentityPromptYes.disabled = !canReveal;
    btnIdentityPromptNo.disabled = false;

    identityPromptPop.classList.remove("hidden");
  }


  function myRoleInfo(){
    const my = state.hands?.[state.userId];
    return my && my.roleId ? (ROLE_BY_ID[my.roleId] || null) : null;
  }

  function isMyRole(roleId){
    return safeText(state.hands?.[state.userId]?.roleId || "") === safeText(roleId || "");
  }

  function uranusMeteorTargetUids(){
    if (!state.userId) return [];
    const targets = [];
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!uid || uid === state.userId) continue;
      if (!marker || isPlayerEliminated(uid)) continue;
      if (hasGuardianAngelShield(uid)) continue;
      const roomId = markerRoomId(marker);
      if (roomId === 6 || roomId === 7) targets.push(uid);
    }
    return targets;
  }

  function mustResolveUranusMeteorStrike(){
    if (!isMyTurn()) return false;
    if (!isMyRole("SHA_U2")) return false;
    if (!isMyIdentityRevealed()) return false;
    if (!!turnState()?.moveDone) return false;
    if (uranusMeteorResolved) return false;
    return uranusMeteorTargetUids().length > 0;
  }

  function scheduleVampireHeal(){
    if (!isMyRole("SHA_V2")) return;
    if (vampireHealScheduled) return;
    vampireHealScheduled = true;
    setTimeout(async () => {
      await emitRoleFlashEvent("SHA_V2", "vampire_heal");
      await healDamageToPlayer(state.userId, 2);
    }, 1500);
  }

  function maybeResolveVampireHiddenHealOnReveal(){
    if (!isMyRole("SHA_V2")) return;
    if (!vampireHiddenAttackSuccess) return;
    if (!isMyTurn()) return;
    scheduleVampireHeal();
  }

  async function emitRoleFlashEvent(roleId, reason = ""){
    const rid = safeText(roleId || "");
    if (!state.roomCode || !rid) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/roleFlash`), {
      roleId: rid,
      reason: safeText(reason || ""),
      at: Date.now()
    });
  }

  async function emitWalpurgisSwapEvent(uidA, uidB, durationMs = 620){
    const a = safeText(uidA || "");
    const b = safeText(uidB || "");
    if (!state.roomCode || !a || !b || a === b) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/walpurgisSwap`), {
      uidA: a,
      uidB: b,
      durationMs: Math.max(240, Number(durationMs) || 620),
      at: Date.now()
    });
  }

  function hideRoleFlashOverlay(){
    if (roleFlashTimer){
      clearTimeout(roleFlashTimer);
      roleFlashTimer = null;
    }
    if (roleFlashOverlayEl){
      roleFlashOverlayEl.remove();
      roleFlashOverlayEl = null;
    }
  }

  function showRoleFlashOverlay(roleId, durationMs = 1200){
    const role = ROLE_BY_ID[safeText(roleId || "")];
    if (!role) return;
    hideRoleFlashOverlay();

    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.inset = "0";
    overlay.style.zIndex = "11000";
    overlay.style.display = "flex";
    overlay.style.alignItems = "center";
    overlay.style.justifyContent = "center";
    overlay.style.background = "rgba(0,0,0,.35)";
    overlay.style.pointerEvents = "none";

    const card = createIdentityCard(role);
    card.style.transform = "scale(2.1)";
    card.style.transformOrigin = "center center";
    card.style.boxShadow = "0 14px 32px rgba(0,0,0,.35)";
    overlay.appendChild(card);
    document.body.appendChild(overlay);
    roleFlashOverlayEl = overlay;

    roleFlashTimer = setTimeout(() => {
      hideRoleFlashOverlay();
    }, Math.max(100, Number(durationMs) || 1200));
  }

  function showTemporaryRoleTag(uid, text, durationMs = 2000){
    if (!uid || !text) return;
    const until = Date.now() + Math.max(100, Number(durationMs) || 2000);
    temporaryRoleTagByUid[uid] = { text: safeText(text), until };
    renderPositionLine();
    setTimeout(() => {
      const cur = temporaryRoleTagByUid[uid];
      if (!cur || Number(cur.until || 0) !== until) return;
      delete temporaryRoleTagByUid[uid];
      renderPositionLine();
    }, Math.max(100, Number(durationMs) || 2000));
  }


  function hasAnyEquipment(uid){
    return listEquipForUid(uid).some(v => !isIdentityEquipItem(v));
  }

  function setEffectResolutionLock(lockKey, enabled){
    const key = safeText(lockKey || "");
    if (!key) return;
    if (enabled){
      effectResolutionLocks[key] = true;
    } else {
      delete effectResolutionLocks[key];
    }
  }

  function isEffectResolutionLocked(lockKey){
    const key = safeText(lockKey || "");
    return !!(key && effectResolutionLocks[key]);
  }

  function greenCardConditionMatched(cardObj){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const role = myRoleInfo();
    if (!role) return null;

    if (text.includes("A / B / C / E / U")) return ["A","B","C","E","U"].includes(role.initial) && Number(role.hp) <= 11;
    if (text.includes("D / F / G / V / W")) return ["D","F","G","V","W"].includes(role.initial) && Number(role.hp) >= 12;
    if (text.includes("シチズン か シャドウ")) return role.faction === "シチズン" || role.faction === "シャドウ";
    if (text.includes("シチズン か レイダー")) return role.faction === "シチズン" || role.faction === "レイダー";
    if (text.includes("シャドウ？")) return role.faction === "シャドウ";
    if (text.includes("レイダー？")) return role.faction === "レイダー";
    if (text.includes("シチズン？")) return role.faction === "シチズン";

    return null;
  }

  function greenAnswerOptions(cardObj){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const matched = greenCardConditionMatched(cardObj);
    const isUlrich = isMyRole("SHA_U1");
    const canJudge = isUlrich ? false : (matched !== null);

    if (text.includes("正体カードを見せよ")){
      return [{ id:"reveal_identity", label:"私の正体です。", enabled:true }];
    }

    if (text.includes("装備を渡すか、1ダメージ受けよ")){
      const canEquip = hasAnyEquipment(state.userId);
      return [
        { id:"take_damage", label:"1ダメージうける", enabled: canJudge ? !!matched : true },
        { id:"give_equip", label:"装備をわたす", enabled: canJudge ? (!!matched && canEquip) : canEquip },
        { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
      ];
    }

    if (text.includes("❿に移動せよ")){
      const nowRoom = markerRoomId(markerCache?.[state.userId]);
      const moveLabel = (nowRoom === 7) ? "1ダメージうける" : "➓に移動する";
      return [
        { id:"yes", label:moveLabel, enabled: canJudge ? !!matched : true },
        { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
      ];
    }

    if (text.includes("1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ")){
      const nowDamage = clampDamage(damageCache?.[state.userId]);
      const healLabel = (nowDamage <= 0) ? "1ダメージうける" : "1ダメージ回復する";
      return [
        { id:"yes", label:healLabel, enabled: canJudge ? !!matched : true },
        { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
      ];
    }

    const damageMatch = text.match(/(\d+)ダメージ受けよ/);
    const damageLabel = damageMatch ? `${damageMatch[1]}ダメージうける` : "はい";
    return [
      { id:"yes", label:damageLabel, enabled: canJudge ? !!matched : true },
      { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
    ];
  }

  function hideGreenRevealPanel(){
    if (greenRevealLabel) greenRevealLabel.textContent = "";
    if (greenRevealCardWrap) greenRevealCardWrap.innerHTML = "";
    greenRevealPanel?.classList.add("hidden");
    greenRevealPanel?.classList.remove("reveal-slide-in");
    zoomBackdrop?.classList.remove("green-reveal-active");
  }

  function showGreenRevealPanel(roleId, responderId){
    const role = roleId ? ROLE_BY_ID[roleId] : null;
    if (!role || !greenRevealCardWrap || !greenRevealLabel || !greenRevealPanel) return;
    greenRevealCardWrap.innerHTML = "";
    greenRevealCardWrap.appendChild(createIdentityCard(role));
    const me = safeText(state.userId || "");
    const label = (safeText(responderId || "") === me) ? "私の正体です。" : "選択したプレイヤーの正体";
    greenRevealLabel.textContent = label;
    greenRevealPanel.classList.remove("hidden");
    zoomBackdrop?.classList.add("green-reveal-active");
    greenRevealPanel.classList.remove("reveal-slide-in");
    requestAnimationFrame(() => {
      greenRevealPanel.classList.add("reveal-slide-in");
    });
  }

  async function sendGreenResponse(msg, opt, overrideLabel=""){
    if (!state.roomCode || !msg?.from || !msg?.requestId || !opt?.id) return;
    const answerLabel = safeText(overrideLabel || opt.label || "");
    await set(ref(db, `rooms/${state.roomCode}/greenResponses/${msg.from}`), {
      from: msg.from,
      to: state.userId,
      requestId: msg.requestId,
      answerId: opt.id,
      answerLabel,
      card: msg.card,
      at: Date.now()
    });
    await set(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${msg.requestId}`), {
      from: msg.from,
      responderId: state.userId,
      requestId: msg.requestId,
      answerLabel,
      at: Date.now()
    });
  }

  async function applyGreenAnswerEffect(msg, opt){
    const text = safeText(msg?.card?.effect || msg?.card?.text || "");

    if (opt?.id === "take_damage"){
      setTimeout(() => { addDamageToPlayer(state.userId, 1); }, 1000);
      return;
    }

    const isPositive = (opt?.id === "yes" || opt?.id === "reveal_identity");
    if (!isPositive) return;

    if (text.includes("1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ")){
      setTimeout(() => {
        const cur = clampDamage(damageCache?.[state.userId]);
        if (cur <= 0) addDamageToPlayer(state.userId, 1);
        else healDamageToPlayer(state.userId, 1);
      }, 1000);
    } else if (!text.includes("❿に移動せよ")) {
      const damageMatch = text.match(/(\d+)ダメージ受けよ/);
      const damage = damageMatch ? Number(damageMatch[1] || 0) : 0;
      if (damage > 0){
        setTimeout(() => { addDamageToPlayer(state.userId, damage); }, 1000);
      }
    }

    if (text.includes("❿に移動せよ")){
      setTimeout(() => {
        const nowRoom = markerRoomId(markerCache?.[state.userId]);
        if (nowRoom === 7) addDamageToPlayer(state.userId, 1);
        else placePlayerMarkerInRoom(state.userId, 7);
      }, 1000);
    }

    if (text.includes("正体カードを見せよ")){
      const roleId = safeText(state.hands?.[state.userId]?.roleId || "");
      if (roleId){
        await set(ref(db, `rooms/${state.roomCode}/greenReveals/${msg.requestId}`), {
          requestId: msg.requestId,
          from: msg.from,
          responderId: state.userId,
          roleId,
          at: Date.now()
        });
        showGreenRevealPanel(roleId, state.userId);
      }
    }
  }

  function restoreGreenGiveZoomSelection(action){
    if (!action?.cardObj) return;
    openZoomFromDeckCard(action.cardObj, "green", { closeOnBackdrop:false, showCloseButton:false });
    greenShareDock?.classList.add("hidden");
    setZoomPassthrough(true);
    pendingEquipAction = action;
    renderEquipmentDock();
  }

  function setGreenDockMeta({ title="", subtitle="" } = {}){
    const titleEl = greenShareDock?.querySelector(".green-share-title");
    if (titleEl) titleEl.textContent = title;
    if (greenShareSubtitle){
      greenShareSubtitle.textContent = subtitle || "";
      greenShareSubtitle.classList.toggle("hidden", !subtitle);
    }
  }

  function openTargetSelectDock({ title="対象プレイヤーを選択", includeSelf=false, onlyAlive=false, onSelect=null, nameSuffixForUid=null } = {}){
    if (!greenShareDock || !greenShareList) return;
    const players = latestPlayers
      .filter(p => includeSelf || p.id !== state.userId)
      .filter(p => !isPlayerEliminated(p.id))
      .filter(p => !onlyAlive || !isPlayerEliminated(p.id))
      .sort((a,b) => Number(a.seatIndex||999)-Number(b.seatIndex||999));
    if (players.length === 0){
      cardPlayerSelectActive = false;
      renderTurnEndButton();
      return;
    }

    let selected = false;
    setGreenDockMeta({ title, subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";

    for (const p of players){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      const chip = buildChipFor(p.id);
      const name = document.createElement("span");
      const suffix = (typeof nameSuffixForUid === "function") ? safeText(nameSuffixForUid(p.id, p) || "") : "";
      name.textContent = `${nameFromSecondChar(p.name)}${suffix}`;
      btn.appendChild(chip);
      btn.appendChild(name);
      btn.addEventListener("click", async () => {
        if (selected) return;
        selected = true;
        cardPlayerSelectActive = false;
        renderTurnEndButton();
        const handler = (typeof onSelect === "function") ? onSelect : null;
        if (handler) await handler(p.id);
      });
      greenShareList.appendChild(btn);
    }

    cardPlayerSelectActive = true;
    renderTurnEndButton();
    greenShareDock.classList.remove("hidden");
  }

  function openGreenShareDock(cardObj){
    greenShareCard = cardObj || null;
    if (!greenShareCard || !greenShareDock || !greenShareList){
      greenShareDock?.classList.add("hidden");
      return;
    }

    setGreenDockMeta({ title:"誰に渡しますか。", subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";
    const players = latestPlayers
      .filter(p => p.id !== state.userId)
      .filter(p => !isPlayerEliminated(p.id))
      .sort((a,b) => Number(a.seatIndex||999)-Number(b.seatIndex||999));

    for (const p of players){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      btn.title = `${safeText(p.name)} に渡す`;

      const chip = buildChipFor(p.id);
      const name = document.createElement("span");
      name.textContent = nameFromSecondChar(p.name);
      btn.appendChild(chip);
      btn.appendChild(name);

      btn.addEventListener("click", async () => {
        if (!greenShareCard || !state.roomCode || !p?.id) return;
        const requestId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        const payload = {
          from: state.userId,
          to: p.id,
          requestId,
          card: greenShareCard,
          at: Date.now()
        };
        await set(ref(db, `rooms/${state.roomCode}/greenInbox/${p.id}`), payload);
        if (safeText(greenShareCard?.effect || "").includes("正体カードを見せよ")){
          await set(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${requestId}`), {
            from: state.userId,
            responderId: p.id,
            requestId,
            answerLabel: "私の正体です。",
            at: Date.now()
          });
          setGreenDockMeta({ title:"回答が届きました", subtitle:"私の正体です。" });
          greenShareActions?.classList.remove("hidden");
        }

        pendingGreenRequestId = requestId;
        greenShareList.innerHTML = "";
        const selected = btn.cloneNode(true);
        selected.classList.add("waiting-selected");
        selected.setAttribute("aria-disabled", "true");
        selected.style.pointerEvents = "none";
        greenShareList.appendChild(selected);
        if (!safeText(greenShareCard?.effect || "").includes("正体カードを見せよ")){
          setGreenDockMeta({ title:"回答待ち...", subtitle:"" });
          greenShareActions?.classList.add("hidden");
        }
      });

      greenShareList.appendChild(btn);
    }
    greenShareDock.classList.remove("hidden");
  }

  function openGreenAnswerDock(msg){
    if (!greenShareDock || !greenShareList || !msg?.card) return;
    greenShareCard = msg.card;
    pendingGreenAnswerMsg = msg;
    const reveal = greenRevealByRequestId[safeText(msg.requestId || "")];
    if (reveal?.roleId){
      showGreenRevealPanel(reveal.roleId, reveal.responderId);
    } else {
      hideGreenRevealPanel();
    }
    const cardText = safeText(msg.card.effect || "");
    setGreenDockMeta({ title:"回答を選んでください", subtitle:cardText });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";

    if (cardText.includes("正体カードを見せよ")){
      const opt = { id:"reveal_identity", label:"私の正体です。", enabled:true };
      greenShareDock.classList.add("hidden");
      (async () => {
        await sendGreenResponse(msg, opt, "私の正体です。");
        await applyGreenAnswerEffect(msg, opt);
      })();
      return;
    }

    const isUlrich = isMyRole("SHA_U1");
    for (const opt of greenAnswerOptions(msg.card)){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn answer";
      btn.textContent = opt.label;
      btn.disabled = isUlrich ? (opt.id === "give_equip" && !hasAnyEquipment(state.userId)) : !opt.enabled;
      btn.addEventListener("click", async () => {
        if (!state.roomCode || !msg?.from || !msg?.requestId) return;

        if (opt.id === "give_equip"){
          const myItems = listEquipForUid(state.userId).filter(it => !isIdentityEquipItem(it));
          if (myItems.length === 0) return;
          const action = {
            type:"green_give",
            fromUid: state.userId,
            toUid: msg.from,
            requestId: msg.requestId,
            cardObj: msg.card,
            answerOpt: opt
          };
          restoreGreenGiveZoomSelection(action);
          return;
        }

        await applyGreenAnswerEffect(msg, opt);
        await sendGreenResponse(msg, opt);
        closeZoom();
      });
      greenShareList.appendChild(btn);
    }
    greenShareDock.classList.remove("hidden");
  }

  function hideGreenShareDock(){
    greenShareCard = null;
    pendingGreenRequestId = "";
    pendingGreenAnswerMsg = null;
    hideGreenRevealPanel();
    if (greenShareList) greenShareList.innerHTML = "";
    setGreenDockMeta({ title:"誰に渡しますか。", subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareDock?.classList.add("hidden");
    cardPlayerSelectActive = false;
    renderTurnEndButton();
  }

  async function clearPendingGreenBubble(){
    if (!state.roomCode || !pendingGreenRequestId) return;
    const bubbleId = pendingGreenRequestId;
    const bRef = ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${bubbleId}`);
    const snap = await get(bRef);
    const val = snap.val();
    if (val?.from === state.userId){
      await remove(bRef);
    }
    pendingGreenRequestId = "";
  }

  async function notifyGreenCloseToResponder(){
    if (!state.roomCode || !pendingGreenRequestId) return;
    const requestId = safeText(pendingGreenRequestId);
    if (!requestId) return;
    const reveal = greenRevealByRequestId[requestId];
    const responderId = safeText(reveal?.responderId || "");
    if (!responderId || responderId === state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/greenCloseSignals/${responderId}`), {
      requestId,
      from: state.userId,
      at: Date.now()
    });
  }

  greenShareCloseBtn?.addEventListener("click", async () => {
    await notifyGreenCloseToResponder();
    await clearPendingGreenBubble();
    closeZoom();
  });

  function openZoomContent(contentEl, { closeOnBackdrop=true, showCloseButton=true } = {}){
    zoomStage.innerHTML = "";
    hideGreenRevealPanel();
    zoomCloseOnBackdrop = !!closeOnBackdrop;
    zoomPassthroughMode = false;
    zoomDismissHandler = null;
    zoomBackdrop.classList.remove("passthrough");
    greenZoomLocked = !showCloseButton;
    zoomCloseBtn.classList.toggle("hidden", !showCloseButton);
    zoomStage.appendChild(contentEl);
    zoomBackdrop.classList.remove("hidden");
  }

  function setZoomPassthrough(enabled){
    zoomPassthroughMode = !!enabled;
    zoomBackdrop?.classList.toggle("passthrough", zoomPassthroughMode);
  }
  function openZoomFromCard(cardEl, options){
    const clone = cardEl.cloneNode(true);
    clone.classList.remove("locked","blocked");
    clone.classList.remove("equip-steal-pulse","equip-defeat-pulse","eliminated-dim");
    clone.style.pointerEvents = "auto";
    openZoomContent(clone, options);
  }
  function openZoomFromRole(role, options){
    if (!role) return;
    const cardEl = createIdentityCard(role);
    openZoomContent(cardEl, options);
  }
  function openIdentityRevealZoom(role, revealerUid){
    if (!role) return;
    const wrap = document.createElement("div");
    wrap.style.position = "relative";
    const cardEl = createIdentityCard(role);
    wrap.appendChild(cardEl);

    if (revealerUid && revealerUid !== state.userId){
      const owner = playerById(revealerUid);
      if (owner){
        const chip = buildChipFor(revealerUid);
        const label = document.createElement("div");
        label.className = "zoom-identity-owner";
        const name = document.createElement("span");
        name.textContent = nameFromSecondChar(owner.name || "");
        label.appendChild(chip);
        label.appendChild(name);
        wrap.appendChild(label);
      }
    }

    openZoomContent(wrap, { closeOnBackdrop:false, showCloseButton:false });
    setTimeout(() => {
      if (!zoomBackdrop.classList.contains("hidden")) closeZoom();
    }, 2000);
  }
  function openZoomFromDeckCard(cardObj, theme, options){
    if (!cardObj) return;
    const cardEl = document.createElement("div");
    cardEl.className = `card72 wb-front ${theme === "black" ? "wb-black" : theme === "green" ? "wb-green" : "wb-white"}`;
    cardEl.innerHTML = buildWbFrontHTML(cardObj, theme);
    cardEl.dataset.cardType = theme || "";
    openZoomContent(cardEl, options);
  }

  async function waitUntilZoomClosed({ maxWaitMs = 12000, pollMs = 60 } = {}){
    const startedAt = Date.now();
    while (Date.now() - startedAt < Math.max(200, Number(maxWaitMs) || 12000)){
      if (zoomBackdrop?.classList.contains("hidden")) return true;
      await new Promise(resolve => setTimeout(resolve, Math.max(20, Number(pollMs) || 60)));
    }
    return !!zoomBackdrop?.classList.contains("hidden");
  }
  function closeZoom(){
    zoomBackdrop.classList.add("hidden");
    zoomBackdrop.classList.remove("passthrough");
    zoomStage.innerHTML = "";
    hideGreenRevealPanel();
    zoomCloseBtn.classList.add("hidden");
    zoomCloseOnBackdrop = true;
    zoomPassthroughMode = false;
    pendingGreenAnswerMsg = null;
    zoomDismissHandler = null;
    greenZoomLocked = false;
    hideGreenShareDock();
    hideRevealPop();
    hideRoomActionPop();
    hideDavidSelectPreview();
    zoomBackdrop?.classList.remove("david-select-active");
    equipDock?.classList.remove("david-select-front");
  }
  zoomCloseBtn.addEventListener("click", async (e) => {
    e.stopPropagation();
    if (greenZoomLocked) return;
    if (typeof zoomDismissHandler === "function"){
      await zoomDismissHandler();
      return;
    }
    await clearPendingGreenBubble();
    closeZoom();
  });
  zoomBackdrop.addEventListener("click", async (e) => {
    if (e.target === zoomBackdrop && zoomCloseOnBackdrop){
      if (typeof zoomDismissHandler === "function"){
        await zoomDismissHandler();
        return;
      }
      await clearPendingGreenBubble();
      closeZoom();
    }
  });

  let slot1 = document.getElementById('slot1');
  let slot2 = document.getElementById('slot2');
  const slot3 = document.getElementById('slot3');
  let slot4 = document.getElementById('slot4');
  const slot5 = document.getElementById('slot5');

  function updateCardInteractivity(){
    const s1 = document.getElementById('slot1');
    const s2 = document.getElementById('slot2');
    const s3 = document.getElementById('slot3');
    const s4 = document.getElementById('slot4');
    const s5 = document.getElementById('slot5');

    const types = [
      [s1, s1?.dataset.cardType],
      [s2, s2?.dataset.cardType],
      [s3, s3?.dataset.cardType],
      [s4, s4?.dataset.cardType],
      [s5, s5?.dataset.cardType],
    ];

    for (const [el, t] of types){
      if (!el || !t){
        applyLocked(el, false);
        continue;
      }

      const shouldLock = !canClickType(t);

      const noDim =
        (el === slot3 && t === "white") ||
        (el === slot5 && t === "black");

      applyLocked(el, shouldLock, { noDim });
    }
  }

  let equipCache = {};
  const equipBody = document.getElementById("equipBody");

  function subscribeEquipment(){
    const eRef = ref(db, `rooms/${state.roomCode}/equipment`);
    onValue(eRef, snap => {
      const next = snap.val() || {};
      if (!identityRevealInitialized){
        identityRevealInitialized = true;
        const initSeen = {};
        for (const [uid, row] of Object.entries(next)){
          initSeen[uid] = Number(row?.identity?.revealedAt || 0);
        }
        identityRevealSeenByUid = initSeen;
      } else {
        for (const [uid, row] of Object.entries(next)){
          const at = Number(row?.identity?.revealedAt || 0);
          if (!at) continue;
          const seen = Number(identityRevealSeenByUid[uid] || 0);
          if (at <= seen) continue;
          identityRevealSeenByUid[uid] = at;
          const rid = safeText(row?.identity?.roleId || "");
          const role = ROLE_BY_ID[rid];
          if (role && uid !== state.userId) openIdentityRevealZoom(role, uid);
        }
      }
      equipCache = next;
      renderEquipmentDock();
    });
  }
  function isIdentityEquipItem(v){
    return v && (v.kind === "identity") && !!v.roleId;
  }
  function equipItemCopies(item){
    if (!item || isIdentityEquipItem(item)) return 1;
    const raw = Number(item.count ?? item.qty ?? item.quantity ?? 1);
    if (!Number.isFinite(raw)) return 1;
    return Math.max(1, Math.floor(raw));
  }
  function expandedEquipItems(uid){
    const obj = equipCache?.[uid] || {};
    const expanded = [];
    for (const [key, value] of Object.entries(obj)){
      const item = { key, ...(value || {}) };
      const copies = equipItemCopies(item);
      for (let i = 0; i < copies; i++){
        expanded.push({ ...item, key: `${key}_${i}`, sourceKey:key, copyIndex:i });
      }
    }
    return expanded;
  }
  function listEquipForUid(uid){
    const arr = expandedEquipItems(uid);
    arr.sort((a,b) => {
      const ai = isIdentityEquipItem(a) ? 0 : 1;
      const bi = isIdentityEquipItem(b) ? 0 : 1;
      if (ai !== bi) return ai - bi;
      return Number(a.at||0) - Number(b.at||0);
    });
    return arr;
  }

  function buildEquipTag(colorHex, initial){
    const d = document.createElement("div");
    d.className = "equip-tag";
    d.style.background = String(colorHex || "#ddd");
    d.style.color = textColorFor(colorHex || "#ddd");
    d.textContent = String(initial || "").slice(0,1);
    return d;
  }

  function buildEquipCard(item){
    if (isIdentityEquipItem(item)){
      const role = ROLE_BY_ID[item.roleId];
      if (!role) return document.createElement("div");
      return createIdentityCard(role);
    }
    const theme = safeText(item.theme || "white");
    const cardObj = { name: safeText(item.name), effect: safeText(item.effect) };
    const el = document.createElement("div");
    el.className = `card72 wb-front ${theme === "black" ? "wb-black" : theme === "green" ? "wb-green" : "wb-white"}`;
    el.innerHTML = buildWbFrontHTML(cardObj, theme);
    el.dataset.cardType = theme || "";
    return el;
  }

  let latestPlayers = [];
  let defeatLootQueue = [];
  let lastAttackWatch = null;
  let previousEliminatedMap = {};

  function clearDefeatLootState(){
    defeatLootQueue = [];
    renderEquipmentDock();
  }

  function enqueueDefeatLoot(uid){
    const targetUid = safeText(uid);
    if (!targetUid || targetUid === state.userId) return;
    if (defeatLootQueue.includes(targetUid)) return;
    defeatLootQueue.push(targetUid);
  }

  function orderedPlayersForEquip(){
    const byId = new Map(latestPlayers.map(p => [p.id, p]));
    const me = byId.get(state.userId) || null;
    const others = latestPlayers.filter(p => p.id !== state.userId).sort((a,b) => a.seatIndex - b.seatIndex);

    const promotedUid = defeatLootQueue.find(uid => byId.has(uid)) || "";
    const promoted = promotedUid ? byId.get(promotedUid) : null;
    const davidPromoted = (pendingEquipAction?.type === "david_select")
      ? others.filter(p => pendingEquipAction.defeatedUids?.includes(p.id))
      : [];

    const arr = [];
    for (const p of davidPromoted){
      arr.push(p);
    }
    if (promoted && !arr.some(p => p.id === promoted.id)) arr.push(promoted);
    if (me) arr.push(me);
    for (const p of others){
      if (arr.some(row => row.id === p.id)) continue;
      arr.push(p);
    }
    return arr;
  }

  function getEquipCols(){
    const body = equipBody;
    const dock = equipDock;
    const w = (body?.clientWidth || dock?.clientWidth || 0);
    const cardW = 72;
    const gap = 8;
    const usable = Math.max(0, w);
    const cols = Math.floor((usable + gap) / (cardW + gap));
    return Math.max(2, Math.min(10, cols || 6));
  }
  function applyEquipCols(){
    const cols = getEquipCols();
    equipBody?.style.setProperty('--equip-cols', String(cols));
  }
  window.addEventListener('resize', () => applyEquipCols());

  function renderEquipmentDock(){
    syncRoomAbilityTurnState();
    equipDock?.classList.toggle("david-select-front", pendingEquipAction?.type === "david_select");
    if (!state.roomCode) { equipDock.classList.remove("visible"); return; }
    if (!isMyTurn() && defeatLootQueue.length > 0){
      defeatLootQueue = [];
    }

    updateEquipDockTop();

    const players = orderedPlayersForEquip();
    const rows = [];
    for (const p of players){
      const list = listEquipForUid(p.id);
      if (!list || list.length === 0) continue;
      rows.push({ p, list });
    }

    equipBody.innerHTML = "";

    if (rows.length === 0){
      equipDock.classList.remove("visible");
      return;
    }

    equipDock.classList.add("visible");

    for (const {p, list} of rows){
      const row = document.createElement("div");
      row.className = "equip-row";

      const tag = buildEquipTag(p.color || "#ddd", firstChar(p.name));
      row.appendChild(tag);

      const cards = document.createElement("div");
      cards.className = "equip-cards";
      const eliminated = isPlayerEliminated(p.id);
      for (const it of list){
        const cardEl = buildEquipCard(it);
        if (eliminated) cardEl.classList.add("eliminated-dim");
        cardEl.dataset.ownerUid = p.id;
        cardEl.dataset.sourceKey = safeText(it.sourceKey || "");
        cardEl.dataset.cardName = safeText(it.name || "");
        cardEl.dataset.cardTheme = safeText(it.theme || "white");
        cardEl.dataset.cardEffect = safeText(it.effect || "");
        const isNormalStealPulse = canUseRoom4Steal() && p.id !== state.userId && !eliminated && !isIdentityEquipItem(it);
        const isOliverPulse = pendingEquipAction?.type === "oliver_target" && p.id !== state.userId && !eliminated && !isIdentityEquipItem(it);
        const isBananaPulse = pendingEquipAction?.type === "banana_give" && p.id === state.userId && !isIdentityEquipItem(it);
        const isGreenGivePulse = pendingEquipAction?.type === "green_give" && p.id === state.userId && !isIdentityEquipItem(it);
        const promotedUid = defeatLootQueue[0] || "";
        const isDefeatPulse = promotedUid && p.id === promotedUid && p.id !== state.userId && eliminated && !isIdentityEquipItem(it);
        const isDavidPulse = pendingEquipAction?.type === "david_select"
          && pendingEquipAction.defeatedUids?.includes(p.id)
          && p.id !== state.userId
          && eliminated
          && !isIdentityEquipItem(it);
        if (isNormalStealPulse || isOliverPulse || isBananaPulse || isGreenGivePulse){
          cardEl.classList.add("equip-steal-pulse");
        }
        if (isDefeatPulse || isDavidPulse){
          cardEl.classList.add("equip-defeat-pulse");
        }
        cards.appendChild(cardEl);
      }
      row.appendChild(cards);
      equipBody.appendChild(row);
    }
    refreshRoomAbilityHint();
    ensureDavidIdentityZoomVisible();
  }

  async function grantEquipmentToMe(cardObj, theme){
    if (!state.roomCode) return;
    if (!cardObj) return;
    if (!isEquipCard(cardObj)) return;

    const key = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${state.userId}/${key}`);
    await set(eRef, {
      theme: theme || "white",
      name: safeText(cardObj.name),
      effect: safeText(cardObj.effect),
      at: Date.now()
    });
  }

  async function revealMyIdentityToEquipment(options = {}){
    if (!state.roomCode) return;
    const my = state.hands?.[state.userId];
    if (!my || !my.roleId) return;

    const revealedBy = safeText(options.revealedBy || "");
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${state.userId}/identity`);
    await runTransaction(eRef, (cur) => {
      if (cur && cur.kind === "identity" && cur.roleId) return cur;
      const next = {
        kind: "identity",
        roleId: String(my.roleId),
        at: 0,
        revealedAt: Date.now()
      };
      if (revealedBy) next.revealedBy = revealedBy;
      return next;
    });
    maybeResolveVampireHiddenHealOnReveal();
  }

  function hasNonIdentityEquipment(uid){
    return listEquipForUid(uid).some(it => !isIdentityEquipItem(it));
  }

  function getDavidEligibleEliminatedUids(){
    return latestPlayers
      .filter(p => p.id !== state.userId)
      .filter(p => isPlayerEliminated(p.id))
      .filter(p => hasNonIdentityEquipment(p.id))
      .map(p => p.id);
  }

  function isDavidAbilityPending(){
    return pendingEquipAction?.type === "david_select";
  }

  function isDavidAbilityUsed(){
    return !!state.room?.abilityUsage?.david?.[state.userId];
  }

  async function markDavidAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/david/${state.userId}`), true);
  }

  function restoreDavidIdentityZoom(){
    const my = state.hands?.[state.userId];
    const role = my?.roleId ? ROLE_BY_ID[my.roleId] : null;
    if (!role) return;
    openZoomFromRole(role, { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(false);
    hideDavidSelectPreview();
    zoomDismissHandler = null;
  }

  function restoreDavidAbilitySelection(){
    if (pendingEquipAction?.type !== "david_select") return;
    pendingEquipAction = {
      type: "david_select",
      defeatedUids: [...(pendingEquipAction.defeatedUids || [])]
    };
    restoreDavidIdentityZoom();
    renderEquipmentDock();
  }

  function ensureDavidIdentityZoomVisible(){
    if (pendingEquipAction?.type !== "david_select") return;
    if (!zoomBackdrop?.classList.contains("hidden")) return;
    restoreDavidAbilitySelection();
  }

  async function startDavidAbilityFlow(){
    const defeatedUids = getDavidEligibleEliminatedUids();
    if (defeatedUids.length === 0){
      showRevealPopAt(null, { mode:"notice", message:"今は公開できません。" });
      return;
    }
    await revealMyIdentityToEquipment({ revealedBy:"david_ability" });
    pendingEquipAction = { type:"david_select", defeatedUids };
    restoreDavidIdentityZoom();
    renderEquipmentDock();
  }

  async function revealIdentityByDamage(uid){
    if (!state.roomCode || !uid) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const hand = cur.hands?.[uid];
      if (!hand?.roleId) return cur;
      cur.equipment = cur.equipment || {};
      cur.equipment[uid] = cur.equipment[uid] || {};
      const old = cur.equipment[uid].identity;
      if (old && old.kind === "identity" && old.roleId) return cur;
      cur.equipment[uid].identity = {
        kind: "identity",
        roleId: String(hand.roleId),
        at: 0,
        revealedAt: Date.now(),
        revealedBy: "damage"
      };
      return cur;
    });
  }

  function isMyIdentityRevealed(){
    const v = equipCache?.[state.userId]?.identity;
    return !!(v && v.kind === "identity" && v.roleId);
  }

  function isMyRevealedVendetta(){
    return isMyRole("SHA_V3") && isMyIdentityRevealed();
  }

  zoomStage.addEventListener("click", (e) => {
    const idCard = e.target.closest(".id72");
    if (!idCard) return;

    const my = state.hands?.[state.userId];
    if (!my || !my.roleId) return;

    const myRoleId = safeText(my.roleId || "");
    if (isMyIdentityRevealed()){
      if (myRoleId !== "SHA_W1") return;
      const check = canUseWightAbilityNow();
      if (!check.ok){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は公開できません。" });
        return;
      }
      e.stopPropagation();
      showRevealPopAt(idCard, {
        action: "wight_ability",
        messageHtml: `(<span class="ability-pill">亡者の王</span>)を使いますか。`
      });
      return;
    }

    if (myRoleId === "CIT_D1"){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "今は公開できません。" });
      return;
    }
    if (myRoleId === "CIT_D2"){
      if (isDavidAbilityUsed()){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "この能力はすでに使用済みです。" });
        return;
      }
      if (getDavidEligibleEliminatedUids().length === 0){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "今は公開できません。" });
        return;
      }
    }
    if (myRoleId === "SHA_U1"){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "今は公開できません。" });
      return;
    }

    const moved = !!turnState()?.moveDone;
    if (TURN_START_ONLY_REVEAL_ROLE_IDS.has(myRoleId) && moved){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "手番の初めにだけ正体を公開できます。" });
      return;
    }
    if (myRoleId === "SHA_W1"){
      const check = canUseWightAbilityNow();
      if (!check.ok){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は公開できません。" });
        return;
      }
      e.stopPropagation();
      showRevealPopAt(idCard, {
        action: "wight_ability",
        messageHtml: `正体を公開して、<span class="ability-pill">亡者の王</span>を使いますか。<br>この手番を終了して、もう一手番行う。`
      });
      return;
    }
    if (REVEAL_ENDS_TURN_ROLE_IDS.has(myRoleId) && !moved){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "手番の最後にだけ正体を公開できます。" });
      return;
    }

    e.stopPropagation();
    showRevealPopAt(idCard, { appendEndTurnNotice: REVEAL_ENDS_TURN_ROLE_IDS.has(myRoleId) });
  });

  window.__lastPointerX = window.innerWidth / 2;
  window.__lastPointerY = window.innerHeight / 2;
  document.addEventListener("pointerdown", (e) => {
    window.__lastPointerX = Number(e.clientX);
    window.__lastPointerY = Number(e.clientY);
  }, true);

  document.addEventListener("click", (e) => {
    const now = Date.now();
    if (now < suppressOutsidePopCloseUntil) return;
    if (!revealPop.classList.contains("hidden") && !e.target.closest("#revealPop")){
      hideRevealPop();
    }
    if (!attackPop.classList.contains("hidden") && !e.target.closest("#attackPop")){
      hideAttackPop();
    }
    if (!endTurnConfirm?.classList.contains("hidden") && !e.target.closest("#endTurnConfirm") && !e.target.closest("#btnEndTurn")){
      hideEndTurnConfirm();
    }
    if (!roomActionPop.classList.contains("hidden") && !e.target.closest("#roomActionPop")){
      if (pendingRoomAction?.dismissOnOutside !== false){
        hideRoomActionPop();
        if (pendingEquipAction?.type === "david_select"){
          restoreDavidAbilitySelection();
        }
      }
    }
  }, true);

  btnRevealNo.addEventListener("click", (e) => {
    e.stopPropagation();
    hideRevealPop();
  });
  btnRevealYes.addEventListener("click", async (e) => {
    e.stopPropagation();
    const myRoleId = safeText(state.hands?.[state.userId]?.roleId || "");
    if (myRoleId === "CIT_D2"){
      await startDavidAbilityFlow();
      hideRevealPop();
      return;
    }
    if (pendingRevealAction === "wight_ability"){
      if (!isMyIdentityRevealed()){
        await revealMyIdentityToEquipment({ revealedBy:"wight_ability" });
      }
      const ok = await activateWightAbilityAndEndTurn();
      hideRevealPop();
      if (!ok){
        showRevealPopAt(null, { mode:"notice", message:canUseWightAbilityNow().message || "今は公開できません。" });
      }
      return;
    }
    await revealMyIdentityToEquipment({ revealedBy:"manual" });
    if (myRoleId === "CIT_A1"){
      setTimeout(() => {
        setDamageToPlayer(state.userId, 0);
      }, 1500);
    }
    hideRevealPop();
  });

  btnAttackNo.addEventListener("click", (e) => {
    e.stopPropagation();
    hideAttackPop();
  });
  btnRoomActionNo?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const closeZoomOnNo = !!pendingRoomAction?.closeZoomOnNo;
    const onNo = pendingRoomAction?.onNo;
    hideRoomActionPop();
    if (typeof onNo === "function") await onNo();
    if (closeZoomOnNo) closeZoom();
  });
  btnRoomActionYes?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const handler = pendingRoomAction?.onYes;
    hideRoomActionPop();
    if (handler) await handler();
  });
  btnAttackYes.addEventListener("click", async (e) => {
    e.stopPropagation();
    if (!canUseAttackDice()) {
      hideAttackPop();
      return;
    }
    const uid = pendingAttackTargetUid;
    const target = markerCache?.[uid] || null;
    if (!uid || !target){
      hideAttackPop();
      return;
    }
    const x = Number(target.x);
    const y = Number(target.y);
    const point = roomSvg && Number.isFinite(x) && Number.isFinite(y)
      ? (() => {
          const ctm = roomSvg.getScreenCTM();
          if (!ctm) return null;
          const pt = roomSvg.createSVGPoint();
          pt.x = x;
          pt.y = y;
          return pt.matrixTransform(ctm);
        })()
      : null;

    hideAttackPop();
    const selectedSum = chooseSumForTestPlayer("攻撃");
    if (isTestPlayer() && selectedSum == null) return;
    const masamuneMode = hasMyEquipmentByName("妖刀マサムネ");
    const vendettaMode = isMyRevealedVendetta();
    const gatlingMode = hasMyEquipmentByName("ガトリング");
    const gatlingTargetUids = gatlingMode ? [...highlightedMarkerUids()] : [];
    const attackTargetUids = gatlingMode ? gatlingTargetUids : [uid];
    lastAttackWatch = {
      uid: state.userId,
      targetUids: attackTargetUids,
      hasRosary: hasMyEquipmentByName("銀のロザリオ"),
      at: Date.now()
    };
    const selectedPair = selectedSum != null ? pickDiceBySum(selectedSum) : null;
    const d6 = (masamuneMode || vendettaMode) ? 0 : (selectedPair?.d6 ?? (1 + Math.floor(Math.random() * 6)));
    const d4 = selectedPair?.d4 ?? (1 + Math.floor(Math.random() * 4));
    const width = window.innerWidth;
    const height = window.innerHeight;
    const endX = point?.x || width/2;
    const endY = point?.y || height/2;
    const motion = createDiceMotion(width, height, endX, endY);
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/attack`), {
      uid: state.userId,
      targetUid: uid,
      gatlingTargetUids,
      x: endX,
      y: endY,
      d6,
      d4,
      masamuneMode,
      vendettaMode,
      motion,
      at: Date.now()
    });
    if (state.roomCode && isMyTurn()){
      await update(ref(db, `rooms/${state.roomCode}/turn`), {
        attackDone: true,
        attackAt: Date.now()
      });
    }
  });


  btnIdentityPromptNo?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const handler = pendingIdentityPrompt?.onNo;
    const closeZoomOnChoice = !!pendingIdentityPrompt?.closeZoomOnChoice;
    hideIdentityPrompt();
    if (closeZoomOnChoice) closeZoom();
    if (handler) await handler();
  });

  btnIdentityPromptYes?.addEventListener("click", async (e) => {
    e.stopPropagation();
    if (btnIdentityPromptYes.disabled) return;
    const handler = pendingIdentityPrompt?.onYes;
    const closeZoomOnChoice = !!pendingIdentityPrompt?.closeZoomOnChoice;
    hideIdentityPrompt();
    if (closeZoomOnChoice) closeZoom();
    if (handler) await handler();
  });

  equipBody.addEventListener("click", (e) => {
    const card = e.target.closest(".card72.wb-front, .id72");
    if (!card){
      if (pendingEquipAction?.type === "david_select"){
        hideRoomActionPop();
        restoreDavidAbilitySelection();
      }
      return;
    }

    if (pendingEquipAction?.type === "david_select"){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      const isPulseCard = card.classList.contains("equip-defeat-pulse");
      const canPick = isPulseCard && pendingEquipAction.defeatedUids?.includes(ownerUid) && !!sourceKey;
      if (!canPick){
        restoreDavidAbilitySelection();
        return;
      }
      pendingEquipAction = {
        ...pendingEquipAction,
        selectedOwnerUid: ownerUid,
        selectedSourceKey: sourceKey
      };
      renderEquipmentDock();
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      hideDavidSelectPreview();
      zoomDismissHandler = async () => {
        restoreDavidAbilitySelection();
      };
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "このカードを獲得しますか。", async () => {
        const action = pendingEquipAction;
        if (!action || action.type !== "david_select") return;
        zoomDismissHandler = null;
        const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
        if (ok){
          await markDavidAbilityUsed();
          pendingEquipAction = null;
          hideDavidSelectPreview();
          closeZoom();
          renderEquipmentDock();
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          restoreDavidAbilitySelection();
        }
      });
      return;
    }

    if (pendingEquipAction?.type === "green_give"){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (ownerUid !== state.userId || !sourceKey) return;
      const action = { ...pendingEquipAction, sourceKey };
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "このカードをわたしますか。", async () => {
        pendingEquipAction = null;
        zoomDismissHandler = null;
        const ok = await moveEquipmentCardBetweenPlayers(action.fromUid, action.toUid, sourceKey);
        if (ok){
          await sendGreenResponse(
            { from: action.toUid, requestId: action.requestId, card: action.cardObj },
            action.answerOpt,
            "装備をわたす"
          );
          closeZoom();
          renderEquipmentDock();
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          zoomDismissHandler = null;
          restoreGreenGiveZoomSelection(action);
        }
      });
      zoomDismissHandler = async () => {
        restoreGreenGiveZoomSelection(action);
      };
      return;
    }

    if (pendingEquipAction?.type === "banana_give"){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (ownerUid !== state.userId || !sourceKey) return;
      const cardName = safeText(card.dataset.cardName || "この装備");
      pendingEquipAction.selectedSourceKey = sourceKey;
      openTargetSelectDock({
        title: `「${cardName}」を誰かに渡しますか。`,
        includeSelf: false,
        onlyAlive: true,
        onSelect: async (uid) => {
          const chosenSource = safeText(pendingEquipAction?.selectedSourceKey || "");
          pendingEquipAction = null;
          greenShareDock?.classList.add("hidden");
          const ok = await moveEquipmentCardBetweenPlayers(state.userId, uid, chosenSource);
          if (ok){
            closeZoom();
            renderEquipmentDock();
          }
        }
      });
      return;
    }

    if (pendingEquipAction?.type === "oliver_target"){
      if (!card.classList.contains("equip-steal-pulse")) return;
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (!ownerUid || ownerUid === state.userId || !sourceKey) return;
      const cardObj = pendingEquipAction?.cardObj || null;
      pendingEquipAction = { type:"oliver_confirm", ownerUid, sourceKey, cardObj };
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      zoomDismissHandler = async () => {
        restoreOliverZoomSelection();
      };
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "これを奪いますか。", async () => {
        const action = pendingEquipAction;
        pendingEquipAction = null;
        zoomDismissHandler = null;
        const ok = await stealEquipmentFromPlayer(action.ownerUid, action.sourceKey);
        if (ok){
          closeZoom();
          renderEquipmentDock();
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          zoomDismissHandler = null;
          restoreOliverZoomSelection();
        }
      });
      return;
    }

    if (card.classList.contains("equip-defeat-pulse")){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (!ownerUid || ownerUid === state.userId || !sourceKey) return;
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "この装備を奪いますか。", async () => {
        const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
        if (ok){
          clearDefeatLootState();
          lastAttackWatch = null;
          closeZoom();
        }
      }, { fixedLower:true, closeZoomOnNo:true });
      return;
    }

    if (canUseRoom4Steal() && card.classList.contains("equip-steal-pulse")){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (!ownerUid || ownerUid === state.userId || !sourceKey) return;
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "この装備を奪いますか。", async () => {
        room4StealUsed = true;
        const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
        if (ok){
          renderEquipmentDock();
          closeZoom();
        }
      }, { fixedLower:true, closeZoomOnNo:true });
      return;
    }

    openZoomFromCard(card);
  });

  const hpBoard = document.getElementById("hpBoard");
  const positionLine = document.getElementById("positionLine");
  const turnEndWrap = document.getElementById("turnEndWrap");
  const btnEndTurn = document.getElementById("btnEndTurn");
  const endTurnConfirm = document.getElementById("endTurnConfirm");
  const endTurnConfirmMsg = document.getElementById("endTurnConfirmMsg");
  const btnEndTurnYes = document.getElementById("btnEndTurnYes");
  const btnEndTurnNo = document.getElementById("btnEndTurnNo");
  let damageCache = {};

  function clampDamage(v){
    const n = Number(v);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.min(15, Math.floor(n)));
  }

  function buildHpCells(){
    hpBoard.innerHTML = "";
    for (let row=15; row>=0; row--){
      const cell = document.createElement("div");
      cell.className = "hp-cell";
      cell.dataset.damage = String(row);
      hpBoard.appendChild(cell);
    }
  }

  function playerById(uid){
    return latestPlayers.find(p => p.id === uid) || null;
  }

  function isPlayerEliminated(uid){
    if (!uid) return false;
    const hand = state.hands?.[uid];
    const role = hand?.roleId ? ROLE_BY_ID[hand.roleId] : null;
    const hp = Number(role?.hp || 0);
    if (!hp) return false;
    const dmg = clampDamage(damageCache?.[uid]);
    return dmg >= hp;
  }

  function hasGuardianAngelShield(uid){
    const targetUid = safeText(uid);
    if (!targetUid) return false;
    return !!state.room?.guardianAngelShield?.[targetUid];
  }

  function isAttackTargetProtected(uid){
    return hasGuardianAngelShield(uid);
  }

  function buildChipFor(uid){
    const p = playerById(uid);
    const color = p?.color || "#ddd";
    const initial = firstChar(p?.name || "");
    const d = document.createElement("div");
    d.className = "chip16";
    d.style.background = color;
    d.style.color = textColorFor(color);
    d.textContent = initial || "";
    d.title = p ? p.name : "";
    if (isTestPlayer()){
      d.style.cursor = "pointer";
      const longPressMs = 500;
      let longPressTimer = null;
      let longPressDone = false;
      const clearLongPressTimer = () => {
        if (!longPressTimer) return;
        clearTimeout(longPressTimer);
        longPressTimer = null;
      };

      d.addEventListener("pointerdown", (e) => {
        if (!e.target.closest("#hpBoard")) return;
        longPressDone = false;
        clearLongPressTimer();
        longPressTimer = setTimeout(async () => {
          longPressDone = true;
          if (!uid) return;
          await healDamageToPlayer(uid, 1);
        }, longPressMs);
      });
      d.addEventListener("pointerup", clearLongPressTimer);
      d.addEventListener("pointerleave", clearLongPressTimer);
      d.addEventListener("pointercancel", clearLongPressTimer);

      d.addEventListener("click", async (e) => {
        e.stopPropagation();
        clearLongPressTimer();
        if (longPressDone || !e.target.closest("#hpBoard")){
          longPressDone = false;
          return;
        }
        if (!uid) return;
        await addDamageToPlayer(uid, 1);
      });
    }
    return d;
  }

  function bindEliminatedChipRoomUp(chipEl, uid){
    if (!chipEl || !uid) return;
    chipEl.classList.add("eliminated-clickable");
    chipEl.title = `${chipEl.title ? chipEl.title + "\n" : ""}クリックで+1上の部屋へ移動`;
    chipEl.addEventListener("click", async (e) => {
      e.stopPropagation();
      await moveEliminatedPlayerToUpperRoom(uid);
    });
  }

  function turnState(){
    return state.room?.turn || null;
  }

  function currentTurnPlayerId(){
    return safeText(turnState()?.currentPlayerId || "");
  }

  function isMyTurn(){
    const cur = currentTurnPlayerId();
    return !!cur && cur === state.userId;
  }

  function isTestPlayer(){
    return safeText(state.userName).trim().toLowerCase() === "test";
  }

  function chooseSumForTestPlayer(label){
    if (!isTestPlayer()) return null;
    const input = window.prompt(`${label}の合計目を選んでください（2〜10）`, "7");
    if (input == null) return null;
    const sum = Number(input);
    if (!Number.isFinite(sum)) return null;
    return Math.max(2, Math.min(10, Math.floor(sum)));
  }

  function pickDiceBySum(sum){
    const pairs = [];
    for (let d6 = 1; d6 <= 6; d6++){
      const d4 = sum - d6;
      if (d4 >= 1 && d4 <= 4) pairs.push({ d6, d4 });
    }
    if (!pairs.length) return null;
    return pairs[Math.floor(Math.random() * pairs.length)];
  }

  function canUseMoveDice(){
    if (!isMyTurn()) return false;
    if (isDavidAbilityPending()) return false;
    if (mustResolveUranusMeteorStrike()) return false;
    return !turnState()?.moveDone;
  }

  function canUseAttackDice(){
    if (!isMyTurn()) return false;
    return !!turnState()?.moveDone && !turnState()?.attackDone;
  }

  function syncRoomAbilityTurnState(){
    const key = turnCycleKey();
    if (roomAbilityTurnKey === key) return;
    roomAbilityTurnKey = key;
    room4StealUsed = false;
    room3ActionUsed = false;
    walpurgisSwapUsed = false;
    movedByDiceRoomId = null;
    uranusMeteorResolved = false;
    vampireHiddenAttackSuccess = false;
    vampireHealScheduled = false;
    hideRoomActionPop();
    showTurnHint("");
  }

  function canUseRoom4Steal(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    if (room4StealUsed) return false;
    if (movedByDiceRoomId !== 4) return false;
    const others = latestPlayers.filter(p => p.id !== state.userId && !isPlayerEliminated(p.id));
    return others.some(p => hasAnyEquipment(p.id));
  }

  function canUseRoom3Action(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    if (room3ActionUsed) return false;
    return movedByDiceRoomId === 3;
  }


  function canUseWalpurgisSwap(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    if (!isMyRole("SHA_W2")) return false;
    if (!isMyIdentityRevealed()) return false;
    if (walpurgisSwapUsed) return false;
    return true;
  }

  async function animateMarkerSwapVisual(uidA, uidB, durationMs = 560){
    const markerA = markerCache?.[uidA] || null;
    const markerB = markerCache?.[uidB] || null;
    if (!markerA || !markerB) return;
    const ax = Number(markerA.x), ay = Number(markerA.y);
    const bx = Number(markerB.x), by = Number(markerB.y);
    if (![ax, ay, bx, by].every(Number.isFinite)) return;

    const ctm = roomSvg?.getScreenCTM();
    if (!roomSvg || !ctm) return;
    const aPt = roomSvg.createSVGPoint();
    aPt.x = ax; aPt.y = ay;
    const bPt = roomSvg.createSVGPoint();
    bPt.x = bx; bPt.y = by;
    const aScr = aPt.matrixTransform(ctm);
    const bScr = bPt.matrixTransform(ctm);

    const makeChip = (m) => {
      const chip = document.createElement("div");
      chip.className = "chip16";
      chip.style.position = "fixed";
      chip.style.left = "0";
      chip.style.top = "0";
      chip.style.zIndex = "11200";
      chip.style.pointerEvents = "none";
      chip.style.background = String(m.color || "#ddd");
      chip.style.color = textColorFor(String(m.color || "#ddd"));
      chip.style.transform = "translate(-50%,-50%)";
      chip.style.transition = `transform ${durationMs}ms cubic-bezier(.22,.78,.24,1)`;
      chip.textContent = String(m.initial || "").slice(0,1);
      document.body.appendChild(chip);
      return chip;
    };

    const setChipPos = (chip, x, y) => {
      chip.style.transform = `translate(${x}px, ${y}px) translate(-50%,-50%)`;
    };

    const bezierPoint = (p0, p1, p2, t) => {
      const it = 1 - t;
      return {
        x: it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x,
        y: it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y
      };
    };

    const chipA = makeChip(markerA);
    const chipB = makeChip(markerB);
    setChipPos(chipA, aScr.x, aScr.y);
    setChipPos(chipB, bScr.x, bScr.y);

    markerLayer?.classList.add("swap-animating");

    const mid = { x: (aScr.x + bScr.x) / 2, y: (aScr.y + bScr.y) / 2 };
    const dx = bScr.x - aScr.x;
    const dy = bScr.y - aScr.y;
    const dist = Math.hypot(dx, dy) || 1;
    const nx = -dy / dist;
    const ny = dx / dist;
    const arc = Math.max(26, Math.min(96, dist * 0.34));

    const pA0 = { x: aScr.x, y: aScr.y };
    const pA1 = { x: mid.x + nx * arc, y: mid.y + ny * arc };
    const pA2 = { x: bScr.x, y: bScr.y };
    const pB0 = { x: bScr.x, y: bScr.y };
    const pB1 = { x: mid.x - nx * arc, y: mid.y - ny * arc };
    const pB2 = { x: aScr.x, y: aScr.y };

    await new Promise(resolve => {
      const startedAt = performance.now();
      const step = (now) => {
        const elapsed = now - startedAt;
        const raw = Math.max(0, Math.min(1, elapsed / durationMs));
        const eased = 1 - Math.pow(1 - raw, 3);
        const pa = bezierPoint(pA0, pA1, pA2, eased);
        const pb = bezierPoint(pB0, pB1, pB2, eased);
        setChipPos(chipA, pa.x, pa.y);
        setChipPos(chipB, pb.x, pb.y);
        if (raw < 1){
          requestAnimationFrame(step);
          return;
        }
        resolve();
      };
      requestAnimationFrame(step);
    });

    chipA.remove();
    chipB.remove();
    markerLayer?.classList.remove("swap-animating");
  }

  async function swapMarkerPositionWithPlayer(targetUid){
    const myUid = safeText(state.userId || "");
    const otherUid = safeText(targetUid || "");
    if (!state.roomCode || !myUid || !otherUid || myUid === otherUid) return false;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const tx = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      cur.markers = cur.markers || {};
      const mine = cur.markers[myUid];
      const other = cur.markers[otherUid];
      if (!mine || !other) return cur;
      const nextMine = { ...mine };
      const nextOther = { ...other };

      nextMine.x = Number(other.x);
      nextMine.y = Number(other.y);
      nextMine.roomId = Number(other.roomId || mine.roomId || 7);
      nextMine.updatedAt = Date.now();

      nextOther.x = Number(mine.x);
      nextOther.y = Number(mine.y);
      nextOther.roomId = Number(mine.roomId || other.roomId || 7);
      nextOther.updatedAt = Date.now();

      cur.markers[myUid] = nextMine;
      cur.markers[otherUid] = nextOther;
      return cur;
    });
    return !!tx?.committed;
  }

  function showWalpurgisSwapConfirm(clientX, clientY, targetUid){
    const uid = safeText(targetUid || "");
    if (!uid || !canUseWalpurgisSwap()) return;
    const player = playerById(uid);
    const name = safeText(player?.name || "このプレイヤー");
    suppressOutsidePopCloseUntil = Date.now() + 700;
    showRoomActionPopAt(clientX, clientY, "", async () => {
      if (!canUseWalpurgisSwap()) return;
      walpurgisSwapUsed = true;
      await emitRoleFlashEvent("SHA_W2", "walpurgis_swap");
      await new Promise(resolve => setTimeout(resolve, 1200));
      try {
        await emitWalpurgisSwapEvent(state.userId, uid, 620);
        await new Promise(resolve => setTimeout(resolve, 620));
        await swapMarkerPositionWithPlayer(uid);
      } finally {
        markerLayer?.classList.remove("swap-animating");
        renderMarkers();
      }
    }, {
      messageHtml: `${escapeHtml(name)}と位置を交換しますか。`,
      yesLabel: "はい",
      noLabel: "いいえ",
      yesBtnClass: "pop-purple",
      noBtnClass: "pop-white"
    });
  }

  function refreshRoomAbilityHint(){
    if (canUseRoom4Steal()){
      showTurnHint("他プレイヤーの装備を奪うことができます。");
      return;
    }
    if (canUseRoom3Action()){
      showTurnHint({
        text: "任意のプレイヤーへ2ダメージ/1回復できます。",
        showRoom3Skip: true
      });
      return;
    }
    if (canUseWalpurgisSwap()){
      showTurnHint("プレイヤーを長押しで位置を交換");
      return;
    }
    showTurnHint("");
  }

  async function stealEquipmentFromPlayer(targetUid, sourceKey){
    if (!state.roomCode || !targetUid || !sourceKey) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const targetRow = cur.equipment?.[targetUid];
      if (!targetRow) return cur;
      const item = targetRow[sourceKey];
      if (!item || item.kind === "identity") return cur;

      const oldCount = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
      if (oldCount > 1){
        const next = { ...item, count: oldCount - 1 };
        delete next.qty;
        delete next.quantity;
        targetRow[sourceKey] = next;
      } else {
        delete targetRow[sourceKey];
      }

      const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
      cur.equipment[state.userId] = cur.equipment[state.userId] || {};
      cur.equipment[state.userId][addKey] = {
        theme: safeText(item.theme || "white"),
        name: safeText(item.name || ""),
        effect: safeText(item.effect || ""),
        at: Date.now()
      };
      return cur;
    });
    return !!result.committed;
  }


  async function stealAllEquipmentFromPlayer(targetUid){
    const uid = safeText(targetUid);
    if (!state.roomCode || !uid || uid === state.userId) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const targetRow = cur.equipment?.[uid];
      if (!targetRow) return cur;
      const stealItems = Object.entries(targetRow)
        .filter(([, item]) => item && item.kind !== "identity")
        .map(([, item]) => item);
      if (!stealItems.length) return cur;
      cur.equipment = cur.equipment || {};
      cur.equipment[state.userId] = cur.equipment[state.userId] || {};
      for (const item of stealItems){
        const copies = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
        for (let i = 0; i < copies; i++){
          const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
          cur.equipment[state.userId][addKey] = {
            theme: safeText(item.theme || "white"),
            name: safeText(item.name || ""),
            effect: safeText(item.effect || ""),
            at: Date.now()
          };
        }
      }
      for (const [key, item] of Object.entries(targetRow)){
        if (!item || item.kind === "identity") continue;
        delete targetRow[key];
      }
      return cur;
    });
    return !!result.committed;
  }

  async function moveEquipmentCardBetweenPlayers(fromUid, toUid, sourceKey){
    if (!state.roomCode || !fromUid || !toUid || !sourceKey) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const fromRow = cur.equipment?.[fromUid];
      if (!fromRow) return cur;
      const item = fromRow[sourceKey];
      if (!item || item.kind === "identity") return cur;

      const oldCount = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
      if (oldCount > 1){
        const next = { ...item, count: oldCount - 1 };
        delete next.qty;
        delete next.quantity;
        fromRow[sourceKey] = next;
      } else {
        delete fromRow[sourceKey];
      }

      cur.equipment = cur.equipment || {};
      cur.equipment[toUid] = cur.equipment[toUid] || {};
      const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
      cur.equipment[toUid][addKey] = {
        theme: safeText(item.theme || "white"),
        name: safeText(item.name || ""),
        effect: safeText(item.effect || ""),
        at: Date.now()
      };
      return cur;
    });
    return !!result.committed;
  }

  function restoreOliverZoomSelection(){
    const cardObj = pendingEquipAction?.cardObj || null;
    if (!cardObj) return;
    openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(true);
    pendingEquipAction = { type:"oliver_target", cardObj };
    renderEquipmentDock();
  }

  function canShowEndTurnButton(){
    if (!isMyTurn()) return false;
    if (cardPlayerSelectActive) return false;
    if (mustAttackWithMasamune()) return false;
    return !!turnState()?.moveDone;
  }

  function mustAttackWithMasamune(){
    if (!isMyTurn()) return false;
    if (!hasMyEquipmentByName("妖刀マサムネ")) return false;
    if (!!turnState()?.attackDone) return false;
    return highlightedMarkerUids().size > 0;
  }

  function hideEndTurnConfirm(){
    endTurnConfirm?.classList.add("hidden");
  }

  function showEndTurnConfirm(options = {}){
    if (endTurnConfirmMsg){
      endTurnConfirmMsg.textContent = safeText(options.message || "本当に終了しますか。");
    }
    endTurnConfirm?.classList.remove("hidden");
  }

  function repeatTurnPending(){
    return Number(turnState()?.repeatTurnRemaining || 0) > 0;
  }

  function repeatTurnLabel(){
    const rest = Math.max(0, Number(turnState()?.repeatTurnRemaining || 0));
    const total = Math.max(0, Number(turnState()?.repeatTurnTotal || 0));
    if (rest <= 0 || total <= 0) return "もう一度手番を行う";
    return `もう一度手番を行う(${rest}/${total})`;
  }

  function renderTurnEndButton(){
    syncRoomAbilityTurnState();
    if (!turnEndWrap) return;
    const visible = isGameStarted() && canShowEndTurnButton();
    turnEndWrap.classList.toggle("hidden", !visible);
    if (btnEndTurn){
      btnEndTurn.textContent = repeatTurnPending() ? repeatTurnLabel() : "手番を終わる";
    }
    if (!visible) hideEndTurnConfirm();
  }

  function turnCycleKey(){
    const t = turnState() || {};
    const cur = safeText(t.currentPlayerId || "");
    const updatedAt = Number(t.updatedAt || 0);
    return `${cur}:${updatedAt}`;
  }

  function maybeAutoRollMoveDiceOnTurnStart(){
    if (!isGameStarted()) return;
    if (!canUseMoveDice()) return;
    if (!state.userId) return;

    const myMarker = markerCache?.[state.userId] || null;
    if (myMarker) return;

    const key = turnCycleKey();
    if (!key || key === autoMoveTriggeredTurnKey) return;

    autoMoveTriggeredTurnKey = key;
    hideAttackPop();
    setTimeout(() => triggerMoveDiceForAll(), 80);
  }

  async function triggerMoveDiceForAll(){
    if (!state.roomCode || !canUseMoveDice()) return;
    const selectedSum = chooseSumForTestPlayer("移動");
    if (isTestPlayer() && selectedSum == null) return;
    const selectedPair = selectedSum != null ? pickDiceBySum(selectedSum) : null;
    const d6 = selectedPair?.d6 ?? (1 + Math.floor(Math.random() * 6));
    const d4 = selectedPair?.d4 ?? (1 + Math.floor(Math.random() * 4));
    const compass = hasMyEquipmentByName('神秘のコンパス');
    const secondD6 = 1 + Math.floor(Math.random() * 6);
    const secondD4 = 1 + Math.floor(Math.random() * 4);
    const width = window.innerWidth;
    const height = window.innerHeight;
    const motion = createDiceMotion(width, height, width/2, height/2);
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/move`), {
      uid: state.userId,
      d6,
      d4,
      compass,
      secondD6,
      secondD4,
      motion,
      at: Date.now()
    });
  }

  function nameFromSecondChar(name){
    const chars = Array.from(safeText(name || "").trim());
    return chars.slice(1).join("");
  }

  function renderHpBoard(){
    if (!hpBoard) return;
    if (!state.roomCode) return;

    if (!hpBoard.firstChild) buildHpCells();

    const cells = Array.from(hpBoard.querySelectorAll(".hp-cell"));
    for (const c of cells){
      c.querySelectorAll(".chip16").forEach(x => x.remove());
    }

    const entries = Object.entries(damageCache || {}).map(([uid, lvl]) => ({
      uid, lvl: clampDamage(lvl)
    }));

    const started = isGameStarted();
    if (started && entries.length === 0 && latestPlayers.length > 0){
      for (const p of latestPlayers){
        entries.push({ uid: p.id, lvl: 0 });
      }
    }

    const byLvl = new Map();
    for (const e of entries){
      const arr = byLvl.get(e.lvl) || [];
      arr.push(e.uid);
      byLvl.set(e.lvl, arr);
    }

    for (const [lvl, uids] of byLvl.entries()){
      uids.sort((a,b) => {
        const pa = playerById(a);
        const pb = playerById(b);
        return Number(pa?.seatIndex||999) - Number(pb?.seatIndex||999);
      });
      byLvl.set(lvl, uids);
    }

    for (const cell of cells){
      const lvl = Number(cell.dataset.damage);
      const uids = byLvl.get(lvl) || [];
      for (const uid of uids){
        const chip = buildChipFor(uid);
        if (isPlayerEliminated(uid)){
          bindEliminatedChipRoomUp(chip, uid);
        }
        cell.appendChild(chip);
      }
    }
  }

  function renderPositionLine(){
    if (!positionLine) return;

    const started = isGameStarted();
    const order = Array.isArray(state.room?.positionOrder) ? state.room.positionOrder : [];
    const turnPlayerId = currentTurnPlayerId();

    let players = [];
    if (started && order.length > 0){
      players = order
        .map(uid => latestPlayers.find(p => p.id === uid) || null)
        .filter(Boolean);
      const rest = latestPlayers
        .filter(p => !order.includes(p.id))
        .sort((a,b) => Number(a.seatIndex || 999) - Number(b.seatIndex || 999));
      players.push(...rest);
    } else {
      players = latestPlayers
        .slice()
        .sort((a,b) => Number(a.seatIndex || 999) - Number(b.seatIndex || 999));
    }

    positionLine.innerHTML = "";
    if (!started || players.length === 0){
      positionLine.classList.add("hidden");
      renderTurnEndButton();
      return;
    }

    players.forEach((p, idx) => {
      if (idx > 0){
        const arrow = document.createElement("span");
        arrow.className = "position-arrow";
        arrow.textContent = "▶";
        positionLine.appendChild(arrow);
      }
      const item = document.createElement("div");
      item.className = "position-item";

      const eliminated = isPlayerEliminated(p.id);
      const chipWrap = document.createElement("div");
      chipWrap.className = "position-chip-wrap";
      const chip = buildChipFor(p.id);
      if (started && p.id === turnPlayerId && !eliminated){
        chip.classList.add("turn-pulse");
      }
      if (eliminated) bindEliminatedChipRoomUp(chip, p.id);
      chipWrap.appendChild(chip);

      const marker = document.createElement("div");
      marker.className = "starter-mark";
      marker.textContent = (started && p.id === turnPlayerId) ? "△" : "";

      const tempRole = temporaryRoleTagByUid?.[p.id];
      if (tempRole && Number(tempRole.until || 0) <= Date.now()){
        delete temporaryRoleTagByUid[p.id];
      }
      const bubbleText = safeText((temporaryRoleTagByUid?.[p.id]?.text) || (activeGreenReplies?.[p.id] || ""));
      if (bubbleText){
        const bubble = document.createElement("div");
        bubble.className = "position-bubble";
        bubble.textContent = bubbleText;
        chipWrap.appendChild(bubble);
      }

      item.appendChild(chipWrap);
      item.appendChild(marker);

      positionLine.appendChild(item);
    });

    positionLine.classList.remove("hidden");
    updateRoomChoiceUi();
    renderTurnEndButton();
  }


  async function ensureCurrentTurnPlayerAlive(){
    const curId = currentTurnPlayerId();
    if (!curId) return;
    if (!isPlayerEliminated(curId)) return;
    await advanceTurnToNextPlayer();
  }

  function subscribeDamage(){
    const dRef = ref(db, `rooms/${state.roomCode}/damage`);
    onValue(dRef, snap => {
      damageCache = snap.val() || {};

      const eliminatedNow = {};
      for (const p of latestPlayers){
        eliminatedNow[p.id] = isPlayerEliminated(p.id);
      }
      const watchActive = lastAttackWatch
        && lastAttackWatch.uid === state.userId
        && (Date.now() - Number(lastAttackWatch.at || 0) < 12000);
      if (watchActive){
        for (const uid of (lastAttackWatch.targetUids || [])){
          if (!uid) continue;
          const becameEliminated = !!eliminatedNow[uid] && !previousEliminatedMap[uid];
          if (!becameEliminated) continue;
          enqueueDefeatLoot(uid);
          if (lastAttackWatch.hasRosary){
            setTimeout(async () => {
              const ok = await stealAllEquipmentFromPlayer(uid);
              if (ok){
                defeatLootQueue = defeatLootQueue.filter(v => v !== uid);
                renderEquipmentDock();
              }
            }, 2000);
          }
        }
      }

      const myRoleId = safeText(state.hands?.[state.userId]?.roleId || "");
      if (myRoleId === "CIT_D1" && !isMyIdentityRevealed()){
        const othersEliminatedNow = latestPlayers.some(p => p.id !== state.userId && !!eliminatedNow[p.id]);
        const othersEliminatedBefore = latestPlayers.some(p => p.id !== state.userId && !!previousEliminatedMap[p.id]);
        if (othersEliminatedNow && !othersEliminatedBefore && !danielAutoRevealTimer){
          danielAutoRevealTimer = setTimeout(async () => {
            danielAutoRevealTimer = null;
            await waitUntilZoomClosed();
            await revealMyIdentityToEquipment({ revealedBy:"daniel_forced" });
          }, 2000);
        }
      }

      previousEliminatedMap = eliminatedNow;

      renderHpBoard();
      ensureCurrentTurnPlayerAlive();

      for (const [uid, dmgRaw] of Object.entries(damageCache)){
        const myHand = state.hands?.[uid];
        const role = myHand?.roleId ? ROLE_BY_ID[myHand.roleId] : null;
        const hp = Number(role?.hp || 0);
        const dmg = clampDamage(dmgRaw);
        if (!uid || !hp || dmg < hp){
          autoDamageRevealLock[uid] = false;
          continue;
        }
        if (autoDamageRevealLock[uid]) continue;
        autoDamageRevealLock[uid] = true;
        openIdentityRevealZoom(role, uid);
        revealIdentityByDamage(uid);
      }

      renderEquipmentDock();
      const myRoleBack = myRoleCard?.querySelector('.role-back');
      if (myRoleBack){
        myRoleBack.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));
      }
    });
  }


  function subscribeDiceEvents(){
    const moveRef = ref(db, `rooms/${state.roomCode}/diceEvents/move`);
    onValue(moveRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!moveDiceEventInitialized){
        moveDiceEventInitialized = true;
        moveDiceEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= moveDiceEventSeenAt) return;
      moveDiceEventSeenAt = at;
      runDiceRollAnimation({
        force:true,
        finalD6:Number(ev.d6 || 1),
        finalD4:Number(ev.d4 || 1),
        secondD6:Number(ev.secondD6 || 1),
        secondD4:Number(ev.secondD4 || 1),
        compass: !!ev.compass,
        applyMove: safeText(ev.uid || "") === state.userId,
        motion: ev.motion || null
      });
    });

    const attackRef = ref(db, `rooms/${state.roomCode}/diceEvents/attack`);
    onValue(attackRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!attackDiceEventInitialized){
        attackDiceEventInitialized = true;
        attackDiceEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= attackDiceEventSeenAt) return;
      attackDiceEventSeenAt = at;
      runAttackDiceAnimation(safeText(ev.targetUid || ""), Number(ev.x || 0), Number(ev.y || 0), {
        force:true,
        finalD6:Number(ev.d6 || 1),
        finalD4:Number(ev.d4 || 1),
        masamuneMode: !!ev.masamuneMode,
        vendettaMode: !!ev.vendettaMode,
        gatlingTargetUids: Array.isArray(ev.gatlingTargetUids) ? ev.gatlingTargetUids : [],
        applyDamage: safeText(ev.uid || "") === state.userId,
        motion: ev.motion || null
      });
    });
  }

  function subscribeRoleFlashEvents(){
    const flashRef = ref(db, `rooms/${state.roomCode}/effectEvents/roleFlash`);
    onValue(flashRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!roleFlashEventInitialized){
        roleFlashEventInitialized = true;
        roleFlashEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= roleFlashEventSeenAt) return;
      roleFlashEventSeenAt = at;
      showRoleFlashOverlay(safeText(ev.roleId || ""), 1200);
    });
  }

  function subscribeWalpurgisSwapEvents(){
    const swapRef = ref(db, `rooms/${state.roomCode}/effectEvents/walpurgisSwap`);
    onValue(swapRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!walpurgisSwapEventInitialized){
        walpurgisSwapEventInitialized = true;
        walpurgisSwapEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= walpurgisSwapEventSeenAt) return;
      walpurgisSwapEventSeenAt = at;
      const uidA = safeText(ev.uidA || "");
      const uidB = safeText(ev.uidB || "");
      const durationMs = Math.max(240, Number(ev.durationMs) || 620);
      if (!uidA || !uidB || uidA === uidB) return;
      animateMarkerSwapVisual(uidA, uidB, durationMs);
    });
  }

  function subscribeGreenReplyBubbles(){
    const bRef = ref(db, `rooms/${state.roomCode}/greenReplyBubbles`);
    onValue(bRef, snap => {
      const raw = snap.val() || {};
      const next = {};
      for (const row of Object.values(raw)){
        const uid = safeText(row?.responderId || "");
        const label = safeText(row?.answerLabel || "");
        if (!uid || !label) continue;
        next[uid] = label;
      }
      activeGreenReplies = next;
      renderPositionLine();
    });
  }

  async function initDamageAllToZero(players){
    if (!state.roomCode) return;
    const baseRef = ref(db, `rooms/${state.roomCode}/damage`);
    const obj = {};
    for (const p of players){
      obj[p.id] = 0;
    }
    await set(baseRef, obj);
  }

  async function ensureTurnInitialized(){
    if (!state.roomCode || !isGameStarted()) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !(cur.gameStarted || cur.startedAt)) return cur;
      if (cur.turn && cur.turn.currentPlayerId) return cur;
      const startPlayerId = safeText(cur.startPlayerId || "");
      if (!startPlayerId) return cur;
      cur.turn = {
        currentPlayerId: startPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        repeatTurnRemaining: 0,
        repeatTurnTotal: 0,
        updatedAt: Date.now()
      };
      if (cur.guardianAngelShield && cur.guardianAngelShield[startPlayerId]){
        delete cur.guardianAngelShield[startPlayerId];
      }
      return cur;
    });
  }

  async function advanceTurnToNextPlayer(){
    if (!state.roomCode) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !(cur.gameStarted || cur.startedAt)) return cur;
      const order = Array.isArray(cur.positionOrder) ? cur.positionOrder : [];
      if (order.length === 0) return cur;

      const isEliminatedInRoom = (uid) => {
        if (!uid) return false;
        const hand = cur.hands?.[uid];
        const role = hand?.roleId ? ROLE_BY_ID[hand.roleId] : null;
        const hp = Number(role?.hp || 0);
        if (!hp) return false;
        const dmg = clampDamage(cur.damage?.[uid]);
        return dmg >= hp;
      };
      const aliveOrder = order.filter(uid => !isEliminatedInRoom(uid));
      if (aliveOrder.length === 0) return cur;

      const curTurn = cur.turn || {};
      const curId = safeText(curTurn.currentPlayerId || cur.startPlayerId || aliveOrder[0] || "");
      const rest = Math.max(0, Number(curTurn.repeatTurnRemaining || 0));
      const total = Math.max(0, Number(curTurn.repeatTurnTotal || 0));
      const repeat = rest > 0 && !isEliminatedInRoom(curId);
      const nextRepeatRemaining = repeat ? Math.max(0, rest - 1) : 0;
      const nextRepeatTotal = repeat ? Math.max(total, rest) : 0;
      let nextPlayerId = curId;
      if (!repeat){
        let nextIdx = aliveOrder.indexOf(curId);
        if (nextIdx < 0) nextIdx = 0;
        nextPlayerId = safeText(aliveOrder[(nextIdx + 1) % aliveOrder.length] || aliveOrder[0] || "");
      }
      if (!nextPlayerId || isEliminatedInRoom(nextPlayerId)){
        nextPlayerId = safeText(aliveOrder[0] || "");
      }
      if (!nextPlayerId) return cur;

      cur.turn = {
        currentPlayerId: nextPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        repeatTurnRemaining: nextRepeatRemaining,
        repeatTurnTotal: nextRepeatTotal,
        updatedAt: Date.now()
      };
      if (cur.guardianAngelShield && cur.guardianAngelShield[nextPlayerId]){
        delete cur.guardianAngelShield[nextPlayerId];
      }
      return cur;
    });
  }

  function toGreenOrder(){
    return GREEN_DECK.map(x => {
      const text = safeText(x?.text||"").replace(/^推理カード：/,"").trim();
      return { name:"推理カード", effect:text };
    });
  }
  function toWhiteOrder(){ return WHITE_DECK.map(x => ({ name:safeText(x.name), effect:safeText(x.effect) })); }
  function toBlackOrder(){ return BLACK_DECK.map(x => ({ name:safeText(x.name), effect:safeText(x.effect) })); }
  function remainingCount(d){
    const o = Array.isArray(d?.order) ? d.order.length : 0;
    const i = Number(d?.idx||0);
    return Math.max(0, o - i);
  }

  let deckCache = null;
  function subscribeDeckState(){
    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    onValue(dsRef, snap => {
      deckCache = snap.val() || null;
      renderDeckRowFromRoom();
      updateEquipDockTop();
    });
  }

  async function ensureRoomDeckState(){
    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    await runTransaction(dsRef, (cur) => {
      if (cur && cur.green && cur.white && cur.black) return cur;

      const green = { order: shuffle(toGreenOrder()), idx: 0 };
      const white = { order: shuffle(toWhiteOrder()), idx: 0 };
      const black = { order: shuffle(toBlackOrder()), idx: 0 };

      return {
        green, white, black,
        reveal: { slot3: null, slot5: null },
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };
    });
  }

  async function drawFromSharedDeck(type, { viaParasol=false } = {}){
    if (!state.roomCode) return;
    if (viaParasol){
      if (type !== "green" || !canUseParasolGreenDraw()) return;
    } else if (!canDrawTypeNormally(type)){
      return;
    }

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let drawn = null;

    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      if (!cur.turn || safeText(cur.turn.currentPlayerId || "") !== state.userId) return cur;

      const turn = cur.turn;
      const allowUnlimitedDraw = isTestPlayer();
      if (!turn.moveDone || turn.attackDone) return cur;
      if (!viaParasol && !allowUnlimitedDraw && turn.deckDrawDone) return cur;

      const ds = cur.deckState;
      if (!ds || !ds[type] || !Array.isArray(ds[type].order)) return cur;

      const d = ds[type];
      const idx = Number(d.idx || 0);
      if (idx >= d.order.length) return cur;

      drawn = d.order[idx];
      d.idx = idx + 1;

      ds.reveal = ds.reveal || { slot3:null, slot5:null };
      if (type === "black"){
        ds.reveal.slot5 = { theme:"black", card: drawn, at: Date.now() };
      } else if (type === "white"){
        ds.reveal.slot3 = { theme:"white", card: drawn, at: Date.now() };
      }

      if (viaParasol){
        turn.attackDone = true;
        turn.attackAt = Date.now();
      } else if (!allowUnlimitedDraw) {
        turn.deckDrawDone = true;
      }
      turn.updatedAt = Date.now();
      ds.updatedAt = Date.now();
      return cur;
    });

    if (drawn && (type === "white" || type === "black")){
      await grantEquipmentToMe(drawn, type);
      await applyImmediateDeckCardEffect(drawn);
    } else if (drawn && type === "green"){
      openZoomFromDeckCard(drawn, "green", { closeOnBackdrop:false, showCloseButton:false });
      openGreenShareDock(drawn);
    }
  }

  function renderDeckRowFromRoom(){
    if (!deckCache || !deckCache.green || !deckCache.white || !deckCache.black){
      setSlotAsDeck(slot1, 'greendeck.jpg', 0, { disabled:true, type:"green" });
      setSlotAsDeck(slot2, 'whitedeck.jpg', 0, { disabled:true, type:"white" });
      setSlotEmptyNoFrame(slot3);
      setSlotAsDeck(slot4, 'blackdeck.jpg', 0, { disabled:true, type:"black" });
      setSlotEmptyNoFrame(slot5);
      bindDeckClicksShared();
      updateCardInteractivity();
      return;
    }

    const gLeft = remainingCount(deckCache.green);
    const wLeft = remainingCount(deckCache.white);
    const bLeft = remainingCount(deckCache.black);

    setSlotAsDeck(slot1, 'greendeck.jpg', gLeft, { disabled: gLeft===0, type:"green" });
    setSlotAsDeck(slot2, 'whitedeck.jpg', wLeft, { disabled: wLeft===0, type:"white" });
    setSlotAsDeck(slot4, 'blackdeck.jpg', bLeft, { disabled: bLeft===0, type:"black" });

    const r3 = deckCache?.reveal?.slot3;
    const r5 = deckCache?.reveal?.slot5;

    if (r3 && r3.card){
      setSlotAsWbFront(slot3, r3.card, r3.theme || "white");
    } else {
      setSlotEmptyNoFrame(slot3);
    }

    if (r5 && r5.card){
      setSlotAsWbFront(slot5, r5.card, "black");
    } else {
      setSlotEmptyNoFrame(slot5);
    }

    bindDeckClicksShared();
    updateCardInteractivity();
  }

  function bindDeckClicksShared(){
    const s1 = slot1.cloneNode(true);
    slot1.parentNode.replaceChild(s1, slot1);
    slot1 = s1;
    slot1.dataset.cardType = "green";
    slot1.style.backgroundImage = `url('greendeck.jpg')`;
    ensureCountTag(slot1);

    const s2 = slot2.cloneNode(true);
    slot2.parentNode.replaceChild(s2, slot2);
    slot2 = s2;
    slot2.dataset.cardType = "white";
    slot2.style.backgroundImage = `url('whitedeck.jpg')`;
    ensureCountTag(slot2);

    const s4 = slot4.cloneNode(true);
    slot4.parentNode.replaceChild(s4, slot4);
    slot4 = s4;
    slot4.dataset.cardType = "black";
    slot4.style.backgroundImage = `url('blackdeck.jpg')`;
    ensureCountTag(slot4);

    slot1.addEventListener('click', async (e) => {
      const left = remainingCount(deckCache?.green);
      if (!canClickType("green")) return;
      if (left <= 0) return;
      if (canDrawTypeNormally("green")){
        await drawFromSharedDeck("green");
        return;
      }
      if (!canUseParasolGreenDraw()) return;
      showRoomActionPopAt(
        Number(e?.clientX || (window.innerWidth / 2)),
        Number(e?.clientY || (window.innerHeight / 2)),
        "攻撃の代わりにカードを引きますか。（虹色のパラソル）",
        async () => {
          await drawFromSharedDeck("green", { viaParasol:true });
        }
      );
    });
    slot2.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.white);
      if (!canClickType("white")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("white");
    });
    slot4.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.black);
      if (!canClickType("black")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("black");
    });
  }

  const cardsPanelEl = document.getElementById("cardsPanel");
  cardsPanelEl.addEventListener("click", (e) => {
    const card = e.target.closest(".card72.wb-front");
    if (!card) return;
    if (card.classList.contains("locked") || card.classList.contains("blocked")) return;
    openZoomFromCard(card);
  });

  const roomSvg = document.getElementById('roomSvg');
  const roomG   = document.getElementById('roomG');

  function svgEl(name, attrs={}, parent=roomG){
    const n = document.createElementNS('http://www.w3.org/2000/svg', name);
    for(const k in attrs) n.setAttribute(k, attrs[k]);
    parent.appendChild(n);
    return n;
  }
  function ptsToStr(pts){ return pts.map(p=>`${p[0]},${p[1]}`).join(' '); }
  function poly(pts, cls, parent=roomG){ return svgEl('polygon', {points: ptsToStr(pts), class: cls}, parent); }

  function ensureRoomPatterns(){
    let defs = roomSvg.querySelector('#roomPatternDefs');
    if (defs) return defs;
    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.setAttribute('id', 'roomPatternDefs');
    roomSvg.insertBefore(defs, roomSvg.firstChild);

    for (let roomId = 1; roomId <= 7; roomId++){
      const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
      pattern.setAttribute('id', `roomPattern${roomId}`);
      pattern.setAttribute('patternUnits', 'objectBoundingBox');
      pattern.setAttribute('width', '1');
      pattern.setAttribute('height', '1');

      const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      image.setAttribute('href', `room${roomId}.jpg`);
      image.setAttribute('width', '1');
      image.setAttribute('height', '1');
      image.setAttribute('preserveAspectRatio', 'xMidYMid slice');

      pattern.appendChild(image);
      defs.appendChild(pattern);
    }
    return defs;
  }

  function hexFlat(cx, cy, s){
    const rt3 = Math.sqrt(3);
    const h = (rt3/2)*s;
    return [
      [cx+s,   cy],
      [cx+s/2, cy+h],
      [cx-s/2, cy+h],
      [cx-s,   cy],
      [cx-s/2, cy-h],
      [cx+s/2, cy-h],
    ];
  }
  function buildStarRooms(cx, cy, s0, t, tip){
    const P = hexFlat(cx, cy, s0);

    const add=(a,b)=>[a[0]+b[0],a[1]+b[1]];
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
    const mul=(a,k)=>[a[0]*k,a[1]*k];
    const norm=(v)=>{ const L=Math.hypot(v[0],v[1])||1; return [v[0]/L,v[1]/L]; };

    function intersectRayRay(p,u,q,v){
      const det = u[0]*(-v[1]) - u[1]*(-v[0]);
      const b = sub(q,p);
      const s = ( b[0]*(-v[1]) - b[1]*(-v[0]) ) / det;
      return add(p, mul(u, s));
    }
    function outwardNormal(a,b){
      const u = norm(sub(b,a));
      return [u[1], -u[0]];
    }

    const lines = [];
    for(let i=0;i<6;i++){
      const a = P[i], b = P[(i+1)%6];
      const d = norm(sub(b,a));
      const n = outwardNormal(a,b);
      const p0 = add(a, mul(n, t));
      lines.push({ p:p0, d, n });
    }

    const Q = [];
    for(let i=0;i<6;i++){
      const L0 = lines[(i+5)%6];
      const L1 = lines[i];
      Q.push(intersectRayRay(L0.p, L0.d, L1.p, L1.d));
    }

    const T = [];
    for(let i=0;i<6;i++){
      const a = P[i], b = P[(i+1)%6];
      const mid = mul(add(a,b), 0.5);
      const n = lines[i].n;
      T.push(add(mid, mul(n, tip)));
    }

    const rooms = [];
    for(let i=0;i<6;i++){
      const i2 = (i+1)%6;
      rooms.push([ P[i], P[i2], Q[i2], T[i], Q[i] ]);
    }

    return { centerHex:P, rooms };
  }

  const cx  = 0,  cy  = 0;
  const s0  = 48;
  const t   = 26;
  const tip = 90;

  function fitRoomViewBox(margin = 2){
    const bb = roomG.getBBox();
    const x = bb.x - margin;
    const y = bb.y - margin;
    const w = bb.width + margin*2;
    const h = bb.height + margin*2;
    roomSvg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
  }

  let markerLayer = null;
  let markerCache = {};
  const roomShapeEls = {};
  const roomHitEls = {};
  let autoMoveTriggeredTurnKey = "";
  const roomPolygons = {};
  const diceRollOverlay = document.getElementById('diceRollOverlay');
  let diceRollTimers = [];
  let pendingMoveChoice = null;

  function clearDiceRollTimers(){
    for (const id of diceRollTimers) clearTimeout(id);
    diceRollTimers = [];
  }

  function myEquipmentNames(){
    return listEquipForUid(state.userId)
      .filter(v => !isIdentityEquipItem(v))
      .map(v => safeText(v?.name))
      .filter(Boolean);
  }

  function hasMyEquipmentByName(name){
    const n = safeText(name);
    if (!n) return false;
    return myEquipmentNames().includes(n);
  }

  function hasEquipmentByName(uid, name){
    const targetUid = safeText(uid);
    const targetName = safeText(name);
    if (!targetUid || !targetName) return false;
    return listEquipForUid(targetUid)
      .filter(v => !isIdentityEquipItem(v))
      .map(v => safeText(v?.name))
      .includes(targetName);
  }

  function countEquipmentByNames(uid, names){
    const targetUid = safeText(uid);
    const nameSet = new Set((names || []).map(v => safeText(v)).filter(Boolean));
    if (!targetUid || nameSet.size === 0) return 0;
    return listEquipForUid(targetUid)
      .filter(v => !isIdentityEquipItem(v))
      .reduce((sum, item) => sum + (nameSet.has(safeText(item?.name)) ? 1 : 0), 0);
  }

  function calcAttackDamageFromRoll(attackerUid, d6, d4, options = {}){
    const uid = safeText(attackerUid);
    const a = Number(d6) || 0;
    const b = Number(d4) || 0;
    if (!uid) return 0;

    if (options.masamuneMode){
      return Math.max(0, b);
    }

    if (options.vendettaMode){
      return Math.max(0, b);
    }

    if (!didAttackRollSucceed(a, b, options)) return 0;

    let damage = Math.abs(a - b);
    damage += countEquipmentByNames(uid, ["サーベル", "拳銃R", "拳銃L", "クロスボウガン"]);

    const role = myRoleInfo();
    if (uid === state.userId && role && hasEquipmentByName(uid, "エクスカリバー") && isMyIdentityRevealed() && role.faction === "レイダー"){
      damage += 2;
    }

    if (hasEquipmentByName(uid, "賢者のローブ")){
      damage -= 1;
    }

    if (options.excaliburRevealBoost){
      damage += 2;
    }

    return Math.max(0, damage);
  }

  async function maybePromptExcaliburReveal(attackerUid, d6, d4){
    const uid = safeText(attackerUid);
    if (uid !== state.userId) return false;
    const role = myRoleInfo();
    if (!role) return false;
    if (!hasEquipmentByName(uid, "エクスカリバー")) return false;
    if (isMyIdentityRevealed()) return false;
    if ((Number(d6) || 0) === (Number(d4) || 0)) return false;

    return await new Promise((resolve) => {
      showIdentityPromptPop({
        message: "正体を公開して、攻撃しますか。",
        canReveal: role.faction === "レイダー",
        openZoom: false,
        onYes: async () => {
          await revealMyIdentityToEquipment();
          resolve(true);
        },
        onNo: async () => {
          resolve(false);
        }
      });
    });
  }

  function applyIncomingDamageModifiers(uid, amount, options = {}){
    const targetUid = safeText(uid);
    let add = Math.max(0, Number(amount) || 0);
    if (!targetUid || add <= 0) return 0;
    if (options.source === "attack" && hasGuardianAngelShield(targetUid)){
      return 0;
    }
    if (hasEquipmentByName(targetUid, "賢者のローブ")){
      add -= 1;
    }
    return Math.max(0, add);
  }

  function clearPendingMoveChoiceUi(){
    for (let roomId = 1; roomId <= 7; roomId++){
      roomShapeEls[roomId]?.classList.remove('room-choice-once');
      roomHitEls[roomId]?.classList.remove('room-choice-once');
    }
  }

  function setPendingMoveChoice(roomIds){
    clearPendingMoveChoiceUi();
    const unique = [...new Set((roomIds || []).filter(v => Number.isFinite(v) && v >= 1 && v <= 7))];
    pendingMoveChoice = unique.length ? { roomIds: unique, consumed: false } : null;
    for (const rid of unique){
      roomShapeEls[rid]?.classList.add('room-choice-once');
      roomHitEls[rid]?.classList.add('room-choice-once');
    }
    updateRoomChoiceUi();
    refreshRoomAbilityHint();
  }

  async function resolvePendingMoveChoice(roomId){
    if (!pendingMoveChoice || pendingMoveChoice.consumed) return false;
    if (!pendingMoveChoice.roomIds.includes(roomId)) return false;
    pendingMoveChoice.consumed = true;
    clearPendingMoveChoiceUi();
    pendingMoveChoice = null;
    await placeMarkerInRoom(roomId);
    if (state.roomCode && isMyTurn()){
      await update(ref(db, `rooms/${state.roomCode}/turn`), {
        moveDone: true,
        moveAt: Date.now()
      });
    }
    const cleanupTimer = setTimeout(() => {
      diceRollOverlay.innerHTML = '';
      clearDiceRollTimers();
    }, 1000);
    updateRoomChoiceUi();
    diceRollTimers.push(cleanupTimer);
    return true;
  }

  function dicePipsD6(face){
    const map = {
      1:["mc"],
      2:["tl","br"],
      3:["tl","mc","br"],
      4:["tl","tr","bl","br"],
      5:["tl","tr","mc","bl","br"],
      6:["tl","ml","bl","tr","mr","br"]
    };
    return map[face] || map[1];
  }

  function dicePipsD4(face){
    const map = {
      1:["t_center"],
      2:["t_midL","t_midR"],
      3:["t_top","t_botL","t_botR"],
      4:["t_top","t_botL","t_botR","t_center"]
    };
    return map[face] || map[1];
  }

  function renderD6Face(el, face){
    el.innerHTML = '';
    for (const klass of dicePipsD6(face)){
      const pip = document.createElement('span');
      pip.className = `pip ${klass}`;
      el.appendChild(pip);
    }
  }

  function renderD4Face(el, face){
    el.innerHTML = '';
    for (const klass of dicePipsD4(face)){
      const pip = document.createElement('span');
      pip.className = `tpip ${klass}`;
      el.appendChild(pip);
    }
  }

  function randomCornerStart(width, height){
    const corner = Math.floor(Math.random() * 4);
    const pad = 40;
    if (corner === 0) return { x: width - pad, y: pad };      // 右上
    if (corner === 1) return { x: width - pad, y: height - pad }; // 右下
    if (corner === 2) return { x: pad, y: height - pad };      // 左下
    return { x: pad, y: pad };                                  // 左上
  }

  function randomCenterOffsets(){
    let a = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
    let b = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
    let guard = 0;
    while (Math.hypot(a.x-b.x, a.y-b.y) < 62 && guard < 40){
      b = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
      guard++;
    }
    if (Math.hypot(a.x-b.x, a.y-b.y) < 62){
      b = { x:a.x + 64, y:a.y + 10 };
    }
    return [a,b];
  }

  function createDiceMotion(width, height, endX, endY){
    const startBase = randomCornerStart(width, height);
    const [offsetA, offsetB] = randomCenterOffsets();
    const startDegA = Math.random() * 90;
    const startDegB = Math.random() * 90;
    const endDegA = startDegA + 720 + Math.random() * 360;
    const endDegB = startDegB + 720 + Math.random() * 360;
    return { startBase, offsetA, offsetB, startDegA, startDegB, endDegA, endDegB, endX, endY };
  }

  function setFlyerTransform(el, x, y, deg){
    el.style.transform = `translate(${x}px, ${y}px) rotate(${deg}deg)`;
  }

  function diceTotalToRoomId(total){
    if (total === 2 || total === 3) return 5;
    if (total === 4 || total === 5) return 6;
    if (total === 6) return 1;
    if (total === 7) return 2;
    if (total === 8) return 3;
    if (total === 9) return 4;
    if (total === 10) return 7;
    return null;
  }

  function pointInPolygon(x, y, pts){
    let inside = false;
    for (let i = 0, j = pts.length - 1; i < pts.length; j = i++){
      const xi = pts[i][0], yi = pts[i][1];
      const xj = pts[j][0], yj = pts[j][1];
      const intersects = ((yi > y) !== (yj > y))
        && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
      if (intersects) inside = !inside;
    }
    return inside;
  }

  function previousRoomId(roomId){
    if (roomId === 1) return 6;
    if (roomId >= 2 && roomId <= 6) return roomId - 1;
    return null;
  }

  function attackTargetRoomIdsFromRoom(roomId, extraScope = 0){
    const current = Number(roomId);
    if (!Number.isFinite(current) || current < 1 || current > 7) return new Set();
    if (current === 7) return new Set([1,2,3,4,5,6,7]);

    const bonus = Math.max(0, Number(extraScope) || 0);
    const rooms = new Set([current, 7]);
    let cursor = current;

    for (let i = 0; i < 1 + bonus; i++){
      cursor = previousRoomId(cursor);
      if (!cursor) break;
      rooms.add(cursor);
    }
    return rooms;
  }

  function inferRoomIdFromPoint(x, y){
    for (const [ridText, pts] of Object.entries(roomPolygons)){
      const rid = Number(ridText);
      if (!Number.isFinite(rid)) continue;
      if (pointInPolygon(x, y, pts)) return rid;
    }
    return null;
  }

  function markerRoomId(marker){
    if (!marker) return null;
    const roomId = Number(marker.roomId);
    if (Number.isFinite(roomId) && roomId >= 1 && roomId <= 7) return roomId;

    const x = Number(marker.x);
    const y = Number(marker.y);
    if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
    return inferRoomIdFromPoint(x, y);
  }

  function canChooseOuterRoomDirectly(){
    if (!canUseMoveDice()) return false;
    const myMarker = markerCache?.[state.userId] || null;
    return markerRoomId(myMarker) === 7;
  }

  function highlightedMarkerUids(){
    if (mustResolveUranusMeteorStrike()){
      return new Set(uranusMeteorTargetUids());
    }
    if (canUseRoom3Action()){
      return new Set(
        Object.keys(markerCache || {}).filter(uid => !!uid && !isPlayerEliminated(uid) && !hasEquipmentByName(uid, "幸運のブローチ"))
      );
    }
    if (!canUseAttackDice()) return new Set();
    const myMarker = markerCache?.[state.userId] || null;
    const myRoomId = markerRoomId(myMarker);
    if (!myRoomId) return new Set();

    const deadScopeCount = countEquipmentByNames(state.userId, ["死神スコープ"]);
    const attackRooms = attackTargetRoomIdsFromRoom(myRoomId, deadScopeCount);

    const targets = new Set();
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!marker || uid === state.userId) continue;
      const rid = markerRoomId(marker);
      if (!rid) continue;

      if (attackRooms.has(rid)){
        if (isAttackTargetProtected(uid)) continue;
        targets.add(uid);
      }
    }
    return targets;
  }

  function randomPointInRoom(roomId, padding = 12){
    const pts = roomPolygons[roomId];
    if (!Array.isArray(pts) || !pts.length) return null;
    const xs = pts.map(p => p[0]);
    const ys = pts.map(p => p[1]);
    const minX = Math.min(...xs) + padding;
    const maxX = Math.max(...xs) - padding;
    const minY = Math.min(...ys) + padding;
    const maxY = Math.max(...ys) - padding;
    if (!(minX < maxX && minY < maxY)) return null;

    for (let i = 0; i < 180; i++){
      const x = minX + Math.random() * (maxX - minX);
      const y = minY + Math.random() * (maxY - minY);
      if (pointInPolygon(x, y, pts)) return { x, y };
    }
    return { x:(minX + maxX) / 2, y:(minY + maxY) / 2 };
  }

  function hasMarkerCollision(x, y, exceptUid = null, minDistance = 20){
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!marker || uid === exceptUid) continue;
      const mx = Number(marker.x);
      const my = Number(marker.y);
      if (!Number.isFinite(mx) || !Number.isFinite(my)) continue;
      if (Math.hypot(mx - x, my - y) < minDistance) return true;
    }
    return false;
  }

  async function placeMarkerInRoom(roomId){
    if (!roomId || !state.roomCode || !state.userId) return;

    movedByDiceRoomId = roomId;

    let target = null;
    for (let i = 0; i < 120; i++){
      const p = randomPointInRoom(roomId);
      if (!p) break;
      if (!hasMarkerCollision(p.x, p.y, state.userId, 22)){
        target = p;
        break;
      }
      if (!target) target = p;
    }
    if (!target) return;

    setCurrentRoom(roomId);

    if (!hasMarkerCollision(target.x, target.y, state.userId, 22)){
      await writeMyMarker(target.x, target.y);
      return;
    }

    const updates = {};
    const pushLen = 14;
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!marker || uid === state.userId) continue;
      const mx = Number(marker.x);
      const my = Number(marker.y);
      if (!Number.isFinite(mx) || !Number.isFinite(my)) continue;
      const dx = mx - target.x;
      const dy = my - target.y;
      const dist = Math.hypot(dx, dy);
      if (dist >= 22) continue;
      const ux = dist > 0.001 ? dx / dist : Math.cos(Math.random() * Math.PI * 2);
      const uy = dist > 0.001 ? dy / dist : Math.sin(Math.random() * Math.PI * 2);
      updates[`markers/${uid}/x`] = mx + ux * pushLen;
      updates[`markers/${uid}/y`] = my + uy * pushLen;
      updates[`markers/${uid}/updatedAt`] = Date.now();
    }

    const myColor = getMyColor();
    const myInitial = getMyInitial();
    if (!myColor || !myInitial) return;
    updates[`markers/${state.userId}`] = {
      x: target.x,
      y: target.y,
      color: myColor,
      initial: myInitial,
      updatedAt: Date.now(),
      viaDice: true,
      roomId
    };
    await update(ref(db, `rooms/${state.roomCode}`), updates);
  }

  function upperRoomId(roomId){
    const rid = Number(roomId);
    if (!Number.isFinite(rid) || rid < 1 || rid > 7) return null;
    return Math.min(7, rid + 1);
  }

  async function placePlayerMarkerInRoom(uid, roomId){
    if (!uid || !roomId || !state.roomCode) return false;
    let target = null;
    for (let i = 0; i < 120; i++){
      const p = randomPointInRoom(roomId);
      if (!p) break;
      if (!hasMarkerCollision(p.x, p.y, uid, 22)){
        target = p;
        break;
      }
      if (!target) target = p;
    }
    if (!target) return false;

    await update(ref(db, `rooms/${state.roomCode}/markers/${uid}`), {
      x: target.x,
      y: target.y,
      roomId,
      updatedAt: Date.now()
    });
    return true;
  }

  async function moveEliminatedPlayerToUpperRoom(uid){
    if (!uid || !state.roomCode) return;
    if (!isPlayerEliminated(uid)) return;
    const marker = markerCache?.[uid] || null;
    const nowRoomId = markerRoomId(marker);
    const targetRoomId = upperRoomId(nowRoomId);
    if (!targetRoomId) return;
    await placePlayerMarkerInRoom(uid, targetRoomId);
  }

  async function placeMarkerByDice(total){
    const roomId = diceTotalToRoomId(total);
    await placeMarkerInRoom(roomId);
    renderEquipmentDock();
    renderMarkers();
  }

  function clearAttackResultDice(){
    if (!diceRollOverlay) return;
    diceRollOverlay.querySelectorAll('.attack-result-pin').forEach(el => el.remove());
  }

  async function addDamageToPlayer(uid, amount, options = {}){
    const add = applyIncomingDamageModifiers(uid, amount, options);
    if (!uid || !state.roomCode || add <= 0) return;
    const dRef = ref(db, `rooms/${state.roomCode}/damage/${uid}`);
    await runTransaction(dRef, (cur) => clampDamage(Number(cur || 0) + add));
  }

  async function healDamageToPlayer(uid, amount){
    const heal = Math.max(0, Number(amount) || 0);
    if (!uid || !state.roomCode || heal <= 0) return;
    const dRef = ref(db, `rooms/${state.roomCode}/damage/${uid}`);
    await runTransaction(dRef, (cur) => clampDamage(Number(cur || 0) - heal));
  }

  async function fullRecoverPlayer(uid){
    if (!uid || !state.roomCode) return;
    await set(ref(db, `rooms/${state.roomCode}/damage/${uid}`), 0);
  }

  async function enableGuardianAngelShieldForPlayer(uid){
    const targetUid = safeText(uid);
    if (!state.roomCode || !targetUid) return;
    await set(ref(db, `rooms/${state.roomCode}/guardianAngelShield/${targetUid}`), true);
  }


  async function setDamageToPlayer(uid, damage){
    if (!uid || !state.roomCode) return;
    await set(ref(db, `rooms/${state.roomCode}/damage/${uid}`), clampDamage(damage));
  }

  async function enableRepeatTurnOnce(){
    if (!state.roomCode || !isMyTurn()) return;
    await update(ref(db, `rooms/${state.roomCode}/turn`), {
      repeatTurnRemaining: 1,
      repeatTurnTotal: 1,
      updatedAt: Date.now()
    });
  }

  async function runCornerD6Roll(){
    if (!diceRollOverlay) return 1 + Math.floor(Math.random() * 6);
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const wrap = document.createElement('div');
    wrap.className = 'dice-flyer rolling';
    const d6 = document.createElement('div');
    d6.className = 'die';
    wrap.appendChild(d6);
    diceRollOverlay.appendChild(wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const corners = [
      { x: 60, y: 60 },
      { x: Math.max(60, width - 60), y: 60 },
      { x: 60, y: Math.max(60, height - 60) },
      { x: Math.max(60, width - 60), y: Math.max(60, height - 60) }
    ];
    const start = corners[Math.floor(Math.random() * corners.length)];
    const end = { x: width / 2, y: height / 2 };
    setFlyerTransform(wrap, start.x, start.y, Math.floor(Math.random() * 360));

    const animDuration = 900;
    const rollStartAt = Date.now();
    const tick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      const id = setTimeout(tick, 70 + Math.floor(Math.random() * 80));
      diceRollTimers.push(id);
    };
    tick();

    const launch = setTimeout(() => {
      setFlyerTransform(wrap, end.x, end.y, 720 + Math.floor(Math.random() * 360));
    }, 20);
    diceRollTimers.push(launch);

    const finalFace = 1 + Math.floor(Math.random() * 6);
    await new Promise(resolve => {
      const stop = setTimeout(() => {
        wrap.classList.remove('rolling');
        renderD6Face(d6, finalFace);
        resolve();
      }, 980);
      diceRollTimers.push(stop);
    });
    return finalFace;
  }



  async function runCornerD6D4Roll(){
    if (!diceRollOverlay) return { d6: 1 + Math.floor(Math.random() * 6), d4: 1 + Math.floor(Math.random() * 4) };
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer rolling';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer rolling';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    diceRollOverlay.appendChild(d6Wrap);
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const corners = [
      { x: 60, y: 60 },
      { x: Math.max(60, width - 60), y: 60 },
      { x: 60, y: Math.max(60, height - 60) },
      { x: Math.max(60, width - 60), y: Math.max(60, height - 60) }
    ];
    const startA = corners[Math.floor(Math.random() * corners.length)] || corners[0];
    const startB = startA;
    const end = { x: width / 2, y: height / 2 };

    setFlyerTransform(d6Wrap, startA.x, startA.y, Math.floor(Math.random() * 360));
    setFlyerTransform(d4Wrap, startB.x, startB.y, Math.floor(Math.random() * 360));

    const animDuration = 900;
    const rollStartAt = Date.now();
    const tick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      renderD4Face(d4, 1 + Math.floor(Math.random() * 4));
      const id = setTimeout(tick, 70 + Math.floor(Math.random() * 80));
      diceRollTimers.push(id);
    };
    tick();

    const launch = setTimeout(() => {
      setFlyerTransform(d6Wrap, end.x - 18, end.y - 6, 720 + Math.floor(Math.random() * 360));
      setFlyerTransform(d4Wrap, end.x + 18, end.y + 6, 720 + Math.floor(Math.random() * 360));
    }, 20);
    diceRollTimers.push(launch);

    const finalD6 = 1 + Math.floor(Math.random() * 6);
    const finalD4 = 1 + Math.floor(Math.random() * 4);
    await new Promise(resolve => {
      const stop = setTimeout(() => {
        d6Wrap.classList.remove('rolling');
        d4Wrap.classList.remove('rolling');
        renderD6Face(d6, finalD6);
        renderD4Face(d4, finalD4);
        resolve();
      }, 980);
      diceRollTimers.push(stop);
    });

    return { d6: finalD6, d4: finalD4 };
  }

  async function addDamageToAllOtherPlayers(uid, amount){
    const baseAdd = Math.max(0, Number(amount) || 0);
    if (!state.roomCode || baseAdd <= 0) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const order = Array.isArray(cur.positionOrder) ? cur.positionOrder : [];
      if (order.length === 0) return cur;
      cur.damage = cur.damage || {};
      for (const pid of order){
        if (!pid || pid === uid) continue;
        const add = applyIncomingDamageModifiers(pid, baseAdd);
        if (add <= 0) continue;
        cur.damage[pid] = clampDamage(Number(cur.damage[pid] || 0) + add);
      }
      return cur;
    });
  }

  function alivePlayerIds(){
    return latestPlayers
      .map(p => safeText(p?.id || ""))
      .filter(Boolean)
      .filter(uid => !isPlayerEliminated(uid));
  }

  function maxDamageAlivePlayerIds(){
    const alive = alivePlayerIds();
    if (!alive.length) return [];
    let maxDamage = -1;
    for (const uid of alive){
      const dmg = clampDamage(damageCache?.[uid]);
      if (dmg > maxDamage) maxDamage = dmg;
    }
    if (maxDamage < 0) return [];
    return alive.filter(uid => clampDamage(damageCache?.[uid]) === maxDamage);
  }

  function playerIdsInRoom(roomId){
    const rid = Number(roomId);
    if (!Number.isFinite(rid) || rid < 1 || rid > 7) return [];
    const uids = [];
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!uid || !marker) continue;
      if (markerRoomId(marker) === rid) uids.push(uid);
    }
    return uids;
  }

  async function addDamageToPlayers(uids, amount, options = {}){
    const baseAdd = Math.max(0, Number(amount) || 0);
    if (!state.roomCode || baseAdd <= 0) return;
    const targets = [...new Set((uids || []).map(uid => safeText(uid)).filter(Boolean))];
    if (!targets.length) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      cur.damage = cur.damage || {};
      for (const uid of targets){
        const add = applyIncomingDamageModifiers(uid, baseAdd, options);
        if (add <= 0) continue;
        cur.damage[uid] = clampDamage(Number(cur.damage[uid] || 0) + add);
      }
      return cur;
    });
  }

  async function applyImmediateDeckCardEffect(cardObj){
    const name = safeText(cardObj?.name || "");
    if (!name || !state.userId) return;
    const role = myRoleInfo();
    if (!role) return;
    const lockKey = `${name}:${state.userId}`;
    if (isEffectResolutionLocked(lockKey)) return;
    setEffectResolutionLock(lockKey, true);
    const waitMs = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    try {
    if (name === "いやしの聖水"){
      await waitMs(1500);
      await healDamageToPlayer(state.userId, 2);
      return;
    }

    if (name === "裁きの閃光"){
      await waitMs(1500);
      await addDamageToAllOtherPlayers(state.userId, 2);
      return;
    }

    if (name === "戦慄の闇儀式" || name === "光臨"){
      const targetFaction = (name === "戦慄の闇儀式") ? "シャドウ" : "レイダー";
      const message = (name === "戦慄の闇儀式")
        ? "シャドウとして正体を公開しますか。"
        : "レイダーとして正体を公開しますか。";
      const canReveal = role.faction === targetFaction;
      showIdentityPromptPop({
        message,
        canReveal,
        cardObj,
        cardTheme: name === "戦慄の闇儀式" ? "black" : "white",
        openZoom: true,
        onYes: async () => {
          await revealMyIdentityToEquipment();
          await fullRecoverPlayer(state.userId);
        }
      });
      return;
    }

    if (name === "幸せのクッキー"){
      const canReveal = role.initial === "A" || role.initial === "U";
      showIdentityPromptPop({
        message: "AまたはUとして正体を公開しますか。",
        canReveal,
        cardObj,
        cardTheme: "white",
        openZoom: true,
        onYes: async () => {
          await revealMyIdentityToEquipment();
          await fullRecoverPlayer(state.userId);
        }
      });
      return;
    }

    if (name === "闇を祓う鏡"){
      const shouldReveal = role.faction === "シャドウ" && role.name !== "ウルリッヒ" && !isMyIdentityRevealed();
      if (!shouldReveal) return;
      await revealMyIdentityToEquipment();
      showTemporaryRoleTag(state.userId, safeText(role.name || ""), 2000);
      openIdentityRevealZoom(role, state.userId);
      setTimeout(() => closeZoom(), 2000);
      return;
    }

    if (name === "封印の知恵"){
      await enableRepeatTurnOnce();
      return;
    }

    if (name === "守護天使"){
      await enableGuardianAngelShieldForPlayer(state.userId);
      return;
    }

    if (name === "応急手当"){
      openZoomFromDeckCard(cardObj, "white", { closeOnBackdrop:false, showCloseButton:false });
      openTargetSelectDock({
        title: "応急手当：対象プレイヤーを選択してください。",
        includeSelf: true,
        onSelect: async (uid) => {
          await waitMs(1000);
          await setDamageToPlayer(uid, 7);
          closeZoom();
        }
      });
      return;
    }

    if (name === "恩恵"){
      openZoomFromDeckCard(cardObj, "white", { closeOnBackdrop:false, showCloseButton:false });
      openTargetSelectDock({
        title: "恩恵：回復させるプレイヤーを選択してください。",
        includeSelf: false,
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "いにしえの聖杯") ? "🏺" : "",
        onSelect: async (uid) => {
          const eye = await runCornerD6Roll();
          await waitMs(1000);
          await healDamageToPlayer(uid, eye);
          closeZoom();
        }
      });
      return;
    }

    if (name === "吸血コウモリ"){
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      openTargetSelectDock({
        title: "吸血コウモリ：対象プレイヤーを選択してください。",
        includeSelf: false,
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "いにしえの聖杯") ? "🏺" : "",
        onSelect: async (uid) => {
          await waitMs(1000);
          if (!hasEquipmentByName(uid, "いにしえの聖杯")){
            await addDamageToPlayer(uid, 2);
          }
          await healDamageToPlayer(state.userId, 1);
          closeZoom();
        }
      });
      return;
    }

    if (name === "三つ目の黒犬"){
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      openTargetSelectDock({
        title: "三つ目の黒犬：対象プレイヤーを選択してください。",
        includeSelf: false,
        onlyAlive: true,
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "いにしえの聖杯") ? "🏺" : "",
        onSelect: async (uid) => {
          await waitMs(1000);
          const targetHasChalice = hasEquipmentByName(uid, "いにしえの聖杯");
          const myHasChalice = hasEquipmentByName(state.userId, "いにしえの聖杯");
          if (!targetHasChalice){
            await addDamageToPlayer(uid, 2);
          }
          if (!myHasChalice){
            await addDamageToPlayer(state.userId, 2);
          }
          closeZoom();
        }
      });
      return;
    }

    if (name === "バナナの皮"){
      const myItems = listEquipForUid(state.userId).filter(it => !isIdentityEquipItem(it));
      if (myItems.length === 0){
        await waitMs(1000);
        await addDamageToPlayer(state.userId, 1);
        return;
      }
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      setZoomPassthrough(true);
      pendingEquipAction = { type:"banana_give", selectedSourceKey:"", cardObj };
      renderEquipmentDock();
      return;
    }

    if (name === "オリバーの子分"){
      const hasStealableEquip = latestPlayers
        .filter(p => p.id !== state.userId && !isPlayerEliminated(p.id))
        .some(p => hasAnyEquipment(p.id));
      if (!hasStealableEquip){
        return;
      }
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      setZoomPassthrough(true);
      pendingEquipAction = { type:"oliver_target", cardObj };
      renderEquipmentDock();
      return;
    }

    if (name === "人魚の涙"){
      await waitMs(1500);
      const topUids = maxDamageAlivePlayerIds();
      for (const uid of topUids){
        await healDamageToPlayer(uid, 3);
      }
      return;
    }

    if (name === "呪いの人形"){
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      openTargetSelectDock({
        title: "呪いの人形：対象プレイヤーを選択してください。",
        includeSelf: false,
        onlyAlive: true,
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "いにしえの聖杯") ? "🏺" : "",
        onSelect: async (uid) => {
          const eye = await runCornerD6Roll();
          await waitMs(1000);
          if (eye <= 4){
            if (!hasEquipmentByName(uid, "いにしえの聖杯")){
              await addDamageToPlayer(uid, 3);
            }
          } else if (!hasEquipmentByName(state.userId, "いにしえの聖杯")){
            await addDamageToPlayer(state.userId, 3);
          }
          closeZoom();
        }
      });
      return;
    }

    if (name === "暴動"){
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      const rolled = await runCornerD6D4Roll();
      const targetRoomId = diceTotalToRoomId(Number(rolled?.d6 || 0) + Number(rolled?.d4 || 0));
      await waitMs(1500);
      await addDamageToPlayers(playerIdsInRoom(targetRoomId), 3);
      closeZoom();
      return;
    }
    } finally {
      setEffectResolutionLock(lockKey, false);
    }
  }

  async function runAttackDiceAnimation(targetUid, clickClientX, clickClientY, options = {}){
    if (!diceRollOverlay || !targetUid) return;
    const applyDamage = options.applyDamage !== false;
    const masamuneMode = !!options.masamuneMode;
    const vendettaMode = !!options.vendettaMode;
    const d4OnlyMode = masamuneMode || vendettaMode;

    if (vendettaMode){
      showRoleFlashOverlay("SHA_V3", 1200);
      await new Promise(resolve => setTimeout(resolve, 1200));
    }

    clearDiceRollTimers();
    clearAttackResultDice();

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    if (!d4OnlyMode){
      diceRollOverlay.appendChild(d6Wrap);
    }
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const fallbackEndX = Math.max(50, Math.min(width - 50, Number(clickClientX) || width / 2));
    const fallbackEndY = Math.max(50, Math.min(height - 50, Number(clickClientY) || height / 2));
    const motion = options.motion || createDiceMotion(width, height, fallbackEndX, fallbackEndY);

    const startA = { x:Number(motion.startBase?.x || 0) - 16, y:Number(motion.startBase?.y || 0) - 6 };
    const startB = { x:Number(motion.startBase?.x || 0) + 16, y:Number(motion.startBase?.y || 0) + 6 };
    const endX = Number(motion.endX || fallbackEndX);
    const endY = Number(motion.endY || fallbackEndY);
    const offsetA = { x:Number(motion.offsetA?.x || 0), y:Number(motion.offsetA?.y || 0) };
    const offsetB = { x:Number(motion.offsetB?.x || 0), y:Number(motion.offsetB?.y || 0) };

    const startDegA = Number(motion.startDegA || 0);
    const startDegB = Number(motion.startDegB || 0);
    if (!d4OnlyMode){
      setFlyerTransform(d6Wrap, startA.x, startA.y, startDegA);
    }
    setFlyerTransform(d4Wrap, startB.x, startB.y, startDegB);

    const animDuration = 950;
    const rollStartAt = Date.now();
    const rollFaceTick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      if (!d4OnlyMode){
        renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      }
      renderD4Face(d4, 1 + Math.floor(Math.random() * 4));

      const t = elapsed / animDuration;
      const nextInterval = 55 + Math.floor(185 * t);
      const id = setTimeout(rollFaceTick, nextInterval);
      diceRollTimers.push(id);
    };
    rollFaceTick();

    const launchDelayMs = 30;
    const moveDurationMs = 950;
    const settleBufferMs = 80;
    const damageDelayAfterStopMs = 3000;
    const hideAttackDiceAfterDamageMs = 1000;

    const moveTimer = setTimeout(() => {
      if (!d4OnlyMode){
        d6Wrap.classList.add('rolling');
      }
      d4Wrap.classList.add('rolling');
      const endDegA = Number(motion.endDegA || (startDegA + 720));
      const endDegB = Number(motion.endDegB || (startDegB + 720));
      if (!d4OnlyMode){
        setFlyerTransform(d6Wrap, endX + offsetA.x, endY + offsetA.y, endDegA);
      }
      setFlyerTransform(d4Wrap, endX + offsetB.x, endY + offsetB.y, endDegB);
    }, launchDelayMs);
    diceRollTimers.push(moveTimer);

    const finalD6 = Number(options.finalD6 || (1 + Math.floor(Math.random() * 6)));
    const finalD4 = Number(options.finalD4 || (1 + Math.floor(Math.random() * 4)));

    const stopDelayMs = launchDelayMs + moveDurationMs + settleBufferMs;
    const stopTimer = setTimeout(() => {
      if (!d4OnlyMode){
        d6Wrap.classList.remove('rolling');
      }
      d4Wrap.classList.remove('rolling');
      if (!d4OnlyMode){
        renderD6Face(d6, finalD6);
      }
      renderD4Face(d4, finalD4);

      if (!d4OnlyMode){
        d6Wrap.classList.add('attack-result-pin');
      }
      d4Wrap.classList.add('attack-result-pin');

      const damageTimer = setTimeout(async () => {
        const attackSucceeded = didAttackRollSucceed(finalD6, finalD4, { masamuneMode, vendettaMode });
        setAttackRollResultLabel(attackSucceeded);
        try {
          if (!applyDamage) return;
          const revealBoost = d4OnlyMode ? false : await maybePromptExcaliburReveal(state.userId, finalD6, finalD4);
          const damage = calcAttackDamageFromRoll(state.userId, finalD6, finalD4, { masamuneMode, vendettaMode, excaliburRevealBoost: revealBoost });
          const gatlingTargets = Array.isArray(options.gatlingTargetUids)
            ? options.gatlingTargetUids.map(uid => safeText(uid)).filter(Boolean)
            : [];
          const targetUids = (gatlingTargets.length > 0) ? gatlingTargets : [targetUid];
          const dealtDamage = attackSucceeded && damage > 0 && targetUids.some(uid => {
            if (!uid) return false;
            return applyIncomingDamageModifiers(uid, damage, { source:"attack" }) > 0;
          });
          if (damage > 0){
            if (gatlingTargets.length > 0){
              await addDamageToPlayers(gatlingTargets, damage, { source:"attack" });
            } else {
              await addDamageToPlayer(targetUid, damage, { source:"attack" });
            }
          }
          if (dealtDamage && isMyRole("SHA_V2")){
            if (isMyIdentityRevealed()){
              scheduleVampireHeal();
            } else {
              vampireHiddenAttackSuccess = true;
            }
          }
        } finally {
          const hideDiceTimer = setTimeout(() => {
            clearAttackResultDice();
          }, hideAttackDiceAfterDamageMs);
          diceRollTimers.push(hideDiceTimer);
        }
      }, damageDelayAfterStopMs);
      diceRollTimers.push(damageTimer);
    }, stopDelayMs);
    diceRollTimers.push(stopTimer);
  }


  function runDiceRollAnimation(options = {}){
    const force = !!options.force;
    if (!force && !canUseMoveDice()) return;
    const applyMove = options.applyMove !== false;
    const compass = !!options.compass;
    if (!diceRollOverlay) return;
    pendingMoveChoice = null;
    clearPendingMoveChoiceUi();
    updateRoomChoiceUi();
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    diceRollOverlay.appendChild(d6Wrap);
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const center = { x: width / 2, y: height / 2 };
    const animDuration = 950;

    const runSingleRoll = ({ motion, finalD6, finalD4, startAfterMs = 0, onStop = null }) => {
      const m = motion || createDiceMotion(width, height, center.x, center.y);
      const startA = { x:Number(m.startBase?.x || 0) - 16, y:Number(m.startBase?.y || 0) - 6 };
      const startB = { x:Number(m.startBase?.x || 0) + 16, y:Number(m.startBase?.y || 0) + 6 };
      const offsetA = { x:Number(m.offsetA?.x || 0), y:Number(m.offsetA?.y || 0) };
      const offsetB = { x:Number(m.offsetB?.x || 0), y:Number(m.offsetB?.y || 0) };
      const startDegA = Number(m.startDegA || 0);
      const startDegB = Number(m.startDegB || 0);

      const launchTimer = setTimeout(() => {
        setFlyerTransform(d6Wrap, startA.x, startA.y, startDegA);
        setFlyerTransform(d4Wrap, startB.x, startB.y, startDegB);

        const rollStartAt = Date.now();
        const rollFaceTick = () => {
          const elapsed = Date.now() - rollStartAt;
          if (elapsed >= animDuration) return;
          renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
          renderD4Face(d4, 1 + Math.floor(Math.random() * 4));
          const t = elapsed / animDuration;
          const nextInterval = 55 + Math.floor(185 * t);
          const id = setTimeout(rollFaceTick, nextInterval);
          diceRollTimers.push(id);
        };
        rollFaceTick();

        const moveTimer = setTimeout(() => {
          d6Wrap.classList.add('rolling');
          d4Wrap.classList.add('rolling');
          const endDegA = Number(m.endDegA || (startDegA + 720));
          const endDegB = Number(m.endDegB || (startDegB + 720));
          const endX = Number(m.endX || center.x);
          const endY = Number(m.endY || center.y);
          setFlyerTransform(d6Wrap, endX + offsetA.x, endY + offsetA.y, endDegA);
          setFlyerTransform(d4Wrap, endX + offsetB.x, endY + offsetB.y, endDegB);
        }, 30);
        diceRollTimers.push(moveTimer);

        const stopTimer = setTimeout(() => {
          d6Wrap.classList.remove('rolling');
          d4Wrap.classList.remove('rolling');
          renderD6Face(d6, finalD6);
          renderD4Face(d4, finalD4);
          if (typeof onStop === 'function') onStop();
        }, 980);
        diceRollTimers.push(stopTimer);
      }, startAfterMs);
      diceRollTimers.push(launchTimer);
    };

    const finalD6 = Number(options.finalD6 || (1 + Math.floor(Math.random() * 6)));
    const finalD4 = Number(options.finalD4 || (1 + Math.floor(Math.random() * 4)));
    const secondD6 = Number(options.secondD6 || (1 + Math.floor(Math.random() * 6)));
    const secondD4 = Number(options.secondD4 || (1 + Math.floor(Math.random() * 4)));

    if (!compass){
      runSingleRoll({ motion: options.motion || null, finalD6, finalD4 });

      const placeMarkerTimer = setTimeout(async () => {
        if (applyMove) await placeMarkerByDice(finalD6 + finalD4);
        if (applyMove && state.roomCode && isMyTurn()){
          await update(ref(db, `rooms/${state.roomCode}/turn`), {
            moveDone: true,
            moveAt: Date.now()
          });
        }
      }, 1900);
      diceRollTimers.push(placeMarkerTimer);

      const cleanupTimer = setTimeout(() => {
        diceRollOverlay.innerHTML = '';
        clearDiceRollTimers();
      }, 3200);
      diceRollTimers.push(cleanupTimer);
      return;
    }

    runSingleRoll({ motion: options.motion || null, finalD6, finalD4 });
    runSingleRoll({
      motion: options.secondMotion || null,
      finalD6: secondD6,
      finalD4: secondD4,
      startAfterMs: 2980,
      onStop: () => {
        if (!applyMove) return;
        const roomA = diceTotalToRoomId(finalD6 + finalD4);
        const roomB = diceTotalToRoomId(secondD6 + secondD4);
        setPendingMoveChoice([roomA, roomB]);
      }
    });
  }

  function getMyColor(){
    if (state.seatedTable != null){
      return SEAT_COLORS[state.seatedTable-1] || "#ddd";
    }
    return null;
  }
  function getMyInitial(){
    return firstChar(state.userName || "");
  }

  function ensureMarkerLayer(){
    if (markerLayer && markerLayer.isConnected) return markerLayer;
    markerLayer = svgEl('g', { id:"markerLayer" }, roomG);
    return markerLayer;
  }
  function clearMarkerLayer(){
    if (!markerLayer) return;
    while(markerLayer.firstChild) markerLayer.removeChild(markerLayer.firstChild);
  }


  function showUranusSkipPop(clientX, clientY){
    const ability = '<span class="ability-pill">メテオストライク</span>';
    showRoomActionPopAt(clientX, clientY, "", async () => {
      uranusMeteorResolved = true;
      if (canChooseOuterRoomDirectly()){
        renderMarkers();
        return;
      }
      hideAttackPop();
      setTimeout(() => {
        triggerMoveDiceForAll();
      }, 40);
    }, {
      messageHtml: `${ability}を使用せずに移動しますか。`,
      yesLabel: "はい",
      noLabel: "いいえ"
    });
  }

  function showUranusMeteorConfirmPop(clientX, clientY, targetUid){
    const uid = safeText(targetUid || "");
    if (!uid) return;
    const player = playerById(uid);
    const name = safeText(player?.name || "このプレイヤー");
    const ability = '<span class="ability-pill">メテオストライク</span>';
    showRoomActionPopAt(clientX, clientY, "", async () => {
      await emitRoleFlashEvent("SHA_U2", "meteor_strike");
      await new Promise(resolve => setTimeout(resolve, 1200));
      await addDamageToPlayer(uid, 3);
      uranusMeteorResolved = true;
      renderMarkers();
    }, {
      messageHtml: `${ability}${escapeHtml(name)}に3ダメージ与えますか。`,
      yesLabel: "はい",
      noLabel: "いいえ"
    });
  }
 function drawMarker({x,y,color,initial,uid,pulse=false,eliminated=false}){
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  g.setAttribute("data-uid", uid || "");
  if (pulse) g.classList.add("mark-pulse-target");
  if (eliminated) g.classList.add("marker-eliminated");

  const size = 16;
  const rx = 3;

  if (!eliminated && uid && uid === state.userId){
    g.style.cursor = 'pointer';
    g.addEventListener('click', (e) => {
      if (canUseRoom3Action()){
        if (hasEquipmentByName(uid, "幸運のブローチ")) return;
        e.stopPropagation();
        const p = playerById(uid);
        const nm = safeText(p?.name || "このプレイヤー");
        showRoomActionPopAt(e.clientX, e.clientY, `「${nm}」に実行する効果を選んでください。`, async () => {
          room3ActionUsed = true;
          showTurnHint("");
          await new Promise(resolve => setTimeout(resolve, 1000));
          await healDamageToPlayer(uid, 1);
          renderMarkers();
        }, {
          yesLabel: "1回復する",
          noLabel: "2ダメージ与える",
          compactButtons: true,
          yOffset: -14,
          onNo: async () => {
            room3ActionUsed = true;
            showTurnHint("");
            await new Promise(resolve => setTimeout(resolve, 1000));
            await addDamageToPlayer(uid, 2);
            renderMarkers();
          }
        });
        return;
      }
      if (mustResolveUranusMeteorStrike()){
        e.stopPropagation();
        showUranusSkipPop(e.clientX, e.clientY);
        return;
      }
      if (!canUseMoveDice()) return;
      if (canChooseOuterRoomDirectly()) return;
      e.stopPropagation();
      hideAttackPop();
      triggerMoveDiceForAll();
    });
  } else if (!eliminated && uid){
    if (pulse) g.style.cursor = 'pointer';
    const longPressMs = 500;
    let markerLongPressTimer = null;
    let markerLongPressDone = false;
    const clearMarkerLongPress = () => {
      if (!markerLongPressTimer) return;
      clearTimeout(markerLongPressTimer);
      markerLongPressTimer = null;
    };

    g.addEventListener('pointerdown', (e) => {
      markerLongPressDone = false;
      clearMarkerLongPress();
      if (!canUseWalpurgisSwap()) return;
      if (uid === state.userId) return;
      markerLongPressTimer = setTimeout(() => {
        markerLongPressDone = true;
        showWalpurgisSwapConfirm(e.clientX, e.clientY, uid);
      }, longPressMs);
    });
    g.addEventListener('pointerup', clearMarkerLongPress);
    g.addEventListener('pointerleave', clearMarkerLongPress);
    g.addEventListener('pointercancel', clearMarkerLongPress);

    g.addEventListener('click', (e) => {
      clearMarkerLongPress();
      if (markerLongPressDone){
        e.preventDefault();
        e.stopPropagation();
        markerLongPressDone = false;
        return;
      }
      if (!pulse) return;
      e.stopPropagation();
      if (canUseRoom3Action()){
        if (hasEquipmentByName(uid, "幸運のブローチ")) return;
        const p = playerById(uid);
        const nm = safeText(p?.name || "このプレイヤー");
        showRoomActionPopAt(e.clientX, e.clientY, `「${nm}」に実行する効果を選んでください。`, async () => {
          room3ActionUsed = true;
          showTurnHint("");
          await new Promise(resolve => setTimeout(resolve, 1000));
          await healDamageToPlayer(uid, 1);
          renderMarkers();
        }, {
          yesLabel: "1回復する",
          noLabel: "2ダメージ与える",
          compactButtons: true,
          yOffset: -14,
          onNo: async () => {
            room3ActionUsed = true;
            showTurnHint("");
            await new Promise(resolve => setTimeout(resolve, 1000));
            await addDamageToPlayer(uid, 2);
            renderMarkers();
          }
        });
        return;
      }
      if (mustResolveUranusMeteorStrike()){
        showUranusMeteorConfirmPop(e.clientX, e.clientY, uid);
        return;
      }
      if (!canUseAttackDice()) return;
      const p = playerById(uid);
      pendingAttackTargetUid = uid;
      showAttackPopAt(e.clientX, e.clientY, p?.name || 'このプレイヤー');
    });
  }

  // ★自分だけ丸い点線リング（四角マーカーの外側）
  if (uid && uid === state.userId){
    const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
    ring.setAttribute("cx", String(x));
    ring.setAttribute("cy", String(y));
    ring.setAttribute("r", String(size/2 + 5)); // ←リングの大きさ（必要なら調整）
    ring.setAttribute("class", "mark-me-ring");
    g.appendChild(ring);
  }

  const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
  rect.setAttribute("x", String(x - size/2));
  rect.setAttribute("y", String(y - size/2));
  rect.setAttribute("width", String(size));
  rect.setAttribute("height", String(size));
  rect.setAttribute("rx", String(rx));
  rect.setAttribute("class", "mark-rect");
  if (uid && hasGuardianAngelShield(uid)) rect.classList.add("guardian-shield");
  rect.setAttribute("fill", String(color || "#ddd"));

  const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
  txt.setAttribute("x", String(x));
  txt.setAttribute("y", String(y+0.5));
  txt.setAttribute("class","mark-text");
  txt.setAttribute("fill", textColorFor(color || "#ddd"));
  txt.textContent = String(initial || "").slice(0,1);

  g.appendChild(rect);
  g.appendChild(txt);
  markerLayer.appendChild(g);
}

  function updateRoomChoiceUi(){
    const choiceMode = canChooseOuterRoomDirectly();
    for (let roomId = 1; roomId <= 6; roomId++){
      const pending = !!pendingMoveChoice && !pendingMoveChoice.consumed && pendingMoveChoice.roomIds.includes(roomId);
      roomShapeEls[roomId]?.classList.toggle('room-choice-pulse', choiceMode);
      roomHitEls[roomId]?.classList.toggle('room-choice-pulse', choiceMode);
      if (roomHitEls[roomId]){
        roomHitEls[roomId].style.cursor = (choiceMode || pending) ? 'pointer' : (isGameStarted() ? 'default' : 'pointer');
      }
    }

    const centerPending = !!pendingMoveChoice && !pendingMoveChoice.consumed && pendingMoveChoice.roomIds.includes(7);
    if (roomHitEls[7]){
      roomHitEls[7].style.cursor = centerPending ? 'pointer' : (isGameStarted() ? 'default' : 'pointer');
    }
  }


  function renderMarkers(){
    syncRoomAbilityTurnState();
    ensureMarkerLayer();
    clearMarkerLayer();
    const pulseTargets = highlightedMarkerUids();
    if (canUseMoveDice() && !mustResolveUranusMeteorStrike()) pulseTargets.add(state.userId);
    const entries = Object.entries(markerCache || {});
    for (const [uid, m] of entries){
      if (!m) continue;
      const x = Number(m.x);
      const y = Number(m.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
      const eliminated = isPlayerEliminated(uid);
      if (eliminated) continue;
      drawMarker({
        uid,
        x, y,
        color: String(m.color || "#ddd"),
        initial: String(m.initial || ""),
        pulse: pulseTargets.has(uid),
        eliminated
      });
    }
    updateRoomChoiceUi();
    refreshRoomAbilityHint();
  }

  function clientToSvgPoint(svg, clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) return {x:0,y:0};
    const p = pt.matrixTransform(ctm.inverse());
    return { x: p.x, y: p.y };
  }

  async function writeMyMarker(x, y){
    if (!state.roomCode) return;
    const color = getMyColor();
    const initial = getMyInitial();
    if (!color || !initial) return;

    const mRef = ref(db, `rooms/${state.roomCode}/markers/${state.userId}`);
    const roomId = inferRoomIdFromPoint(x, y) || state.currentRoomId || null;
    await set(mRef, { x, y, color, initial, roomId, updatedAt: Date.now() });
  }

  function subscribeMarkers(){
    const mRef = ref(db, `rooms/${state.roomCode}/markers`);
    onValue(mRef, snap => {
      markerCache = snap.val() || {};
      renderMarkers();
      maybeAutoRollMoveDiceOnTurnStart();
    });
  }

  function setCurrentRoom(roomId){
    state.currentRoomId = roomId;
    updateCardInteractivity();
  }

  function renderRoomShape(){
    ensureRoomPatterns();
    while(roomG.firstChild) roomG.removeChild(roomG.firstChild);
    Object.keys(roomPolygons).forEach(k => delete roomPolygons[k]);
    for (const k of Object.keys(roomShapeEls)) delete roomShapeEls[k];
    for (const k of Object.keys(roomHitEls)) delete roomHitEls[k];

    const { centerHex, rooms } = buildStarRooms(cx, cy, s0, t, tip);
    roomPolygons[7] = centerHex.map(([x,y]) => [x,y]);

    const centerShape = poly(centerHex, 'shape');
    centerShape.dataset.roomId = "7";
    centerShape.setAttribute('fill', "url('#roomPattern7')");
    roomShapeEls[7] = centerShape;

    rooms.forEach((pts, idx)=>{
      const shapeEl = poly(pts, 'shape');
      const hit = poly(pts, 'roomhit');
      const roomId = idx + 1;
      shapeEl.setAttribute('fill', `url('#roomPattern${roomId}')`);
      shapeEl.dataset.roomId = String(roomId);
      roomPolygons[roomId] = pts.map(([x,y]) => [x,y]);
      hit.dataset.roomId = String(roomId);
      roomShapeEls[roomId] = shapeEl;
      roomHitEls[roomId] = hit;

      hit.addEventListener('click', async (ev) => {
        if (isGameStarted()){
          if (await resolvePendingMoveChoice(roomId)) return;
          if (!canChooseOuterRoomDirectly()) return;
          await placeMarkerInRoom(roomId);
          if (state.roomCode && isMyTurn()){
            await update(ref(db, `rooms/${state.roomCode}/turn`), {
              moveDone: true,
              moveAt: Date.now()
            });
          }
          return;
        }
        setCurrentRoom(roomId);
        const p = clientToSvgPoint(roomSvg, ev.clientX, ev.clientY);
        await writeMyMarker(p.x, p.y);
      });
    });

    const centerHit = poly(centerHex, 'roomhit');
    centerHit.dataset.roomId = "7";
    roomHitEls[7] = centerHit;
    centerHit.addEventListener('click', async (ev) => {
      if (isGameStarted()){
        if (await resolvePendingMoveChoice(7)) return;
        return;
      }
      setCurrentRoom(7);
      const p = clientToSvgPoint(roomSvg, ev.clientX, ev.clientY);
      await writeMyMarker(p.x, p.y);
    });

    ensureMarkerLayer();
    updateRoomChoiceUi();
    fitRoomViewBox(2);
  }

  const ROLES = [
    { id:"CIT_A1", name:"アリス",    en:"ALICE",    initial:"A", faction:"シチズン", hp:8,  win:"生存している", effect:"うさぎさんヒール：手番初めに使用。ダメージを全回復（1回）" },
    { id:"CIT_A2", name:"アンジェラ", en:"ANGELA",  initial:"A", faction:"シチズン", hp:8,  win:"右隣のプレイヤーが勝利する", effect:"移り気：勝利条件を「左隣のプレイヤーが勝利する」に変更（1回）" },
    { id:"CIT_A3", name:"アガサ",    en:"AGATHA",   initial:"A", faction:"シチズン", hp:8,  win:"自分の手番でゲーム終了", effect:"完全犯罪：手番最後にダイス2個を振り、出目エリアのPL全員に3ダメージ（1回）" },
    { id:"CIT_B1", name:"バイロン",  en:"BYRON",    initial:"B", faction:"シチズン", hp:10, win:"装備カードを5枚以上所持", effect:"念力の懐中時計：2以上の攻撃ダメージ時、代わりに装備を1つ奪う" },
    { id:"CIT_B2", name:"ベンジャミン", en:"BENJAMIN", initial:"B", faction:"シチズン", hp:10, win:"他PLが装備を5つ以上所持", effect:"太鼓持ち：手番最後に同じエリアのPLへ装備を1つ渡せる" },
    { id:"CIT_B3", name:"ブルース",  en:"BRUCE",    initial:"B", faction:"シチズン", hp:10, win:"攻撃でHP12以上のPLを脱落させる、または終了時にマス9にいる", effect:"国士無双：攻撃でHP11以下のPLを脱落させた時、自分の正体を公開" },
    { id:"CIT_C1", name:"クレイグ",  en:"CRAIG",    initial:"C", faction:"シチズン", hp:11, win:"2人脱落後に他PLを攻撃して脱落させる", effect:"死の饗宴：攻撃後、自分に2ダメージ与え再攻撃可" },
    { id:"CIT_C2", name:"キャロル",  en:"CAROL",    initial:"C", faction:"シチズン", hp:11, win:"最初に脱落する、または自分ともう1人だけ生存", effect:"聖痕：手番初めに2ダメージ回復" },
    { id:"CIT_C3", name:"クレア",    en:"CLAIRE",   initial:"C", faction:"シチズン", hp:11, win:"ゲーム終了時、自分のダメージが6～8", effect:"キャスリング：手番初めに自分と他PLのHPを入れ替える（1回）" },
    { id:"CIT_D1", name:"ダニエル",  en:"DANIEL",   initial:"D", faction:"シチズン", hp:13, win:"最初に脱落する、またはシャドウ全員脱落かつ生存", effect:"絶叫：最初に他PLが脱落した時、正体カードを公開" },
    { id:"CIT_D2", name:"デーヴィッド", en:"DAVID",  initial:"D", faction:"シチズン", hp:13, win:"「いにしえの聖杯」「神秘のコンパス」「幸運のブローチ」「銀のロザリオ」のうち3種を所持", effect:"グレイブディガー：手番初めに脱落者の装備カードから任意1枚獲得" },
    { id:"CIT_D3", name:"デボラ",    en:"DEBORAH",  initial:"D", faction:"シチズン", hp:13, win:"5人戦：終了時に最もダメージが多い／6人戦：自分以外のシチズンが勝利", effect:"献身的な愛：手番初めに勝利条件を「脱落する」に変更" },
    { id:"RAI_E1", name:"エミ",      en:"EMI",      initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"テレポート：移動時、出目エリアまたは両隣エリアに移動可" },
    { id:"RAI_E2", name:"エリカ",    en:"ERIKA",    initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"癒しの光：手番終了時に4面ダイスを振り、出目分他PLを回復" },
    { id:"RAI_E3", name:"エマ",      en:"EMMA",     initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"封印の鎖：手番初めに他PL1人の特殊能力をゲーム終了まで封印（1回）" },
    { id:"RAI_F1", name:"フェリックス", en:"FELIX", initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"アストラル・メイス：手番初めに他PL1人へ6面ダイス攻撃（1回）" },
    { id:"RAI_F2", name:"フェリシア", en:"FELICIA", initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"スラム街の天使：手番初めに任意のPLのダメージを7にする（1回）" },
    { id:"RAI_F3", name:"フレディ",  en:"FREDDIE",  initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"ドラゴンアタック：正体公開中のPLへの攻撃成功時 +2ダメージ" },
    { id:"RAI_G1", name:"ゴードン",  en:"GORDON",   initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"絶対無敵バリア：手番終了時に使用。次の自分の手番初めまで全ダメージ無効（1回）" },
    { id:"RAI_G2", name:"ガラハド",  en:"GALAHAD",  initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"魔剣の伝承者：エクスカリバー所持時に攻撃失敗ならダイス振り直し" },
    { id:"RAI_G3", name:"ゴドウィン", en:"GODWIN",  initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"蘇生装置TYPE-G：自分脱落時、既に脱落しているPL1人をダメージ7で復活" },
    { id:"SHA_U1", name:"ウルリッヒ", en:"ULRICH",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員またはシチズン3人の脱落", effect:"推理カードを受け取った時、ウソをついてよい" },
    { id:"SHA_U2", name:"ウラヌス",   en:"URANUS",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員またはシチズン3人の脱落", effect:"メテオストライク：正体公開済みで移動前なら、エリア6-7のPL1人に3ダメージ" },
    { id:"SHA_U3", name:"アルスター", en:"ULSTER",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員またはシチズン3人の脱落", effect:"デル・フリス：2回攻撃できる" },
    { id:"SHA_V1", name:"ヴェノム",    en:"VENOM",   initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員またはシチズン3人の脱落", effect:"反駁の猛毒：攻撃者は1ダメージ受けるか装備を渡すか選択" },
    { id:"SHA_V2", name:"ヴァンパイア", en:"VAMPIRE", initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員またはシチズン3人の脱落", effect:"吸血：攻撃成功時、ダメージを2回復" },
    { id:"SHA_V3", name:"ヴェンデッタ", en:"VENDETTA", initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員またはシチズン3人の脱落", effect:"冥府の大鎌：攻撃は4面ダイスのみ使用" },
    { id:"SHA_W1", name:"ワイト",      en:"WIGHT",    initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員またはシチズン3人の脱落", effect:"亡者の王：移動後に公開して使用。手番を終了して、脱落者数ぶん追加手番（1回）" },
    { id:"SHA_W2", name:"ワルプルギス", en:"WALPURGIS", initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員またはシチズン3人の脱落", effect:"重力の虹：攻撃時、任意のPL1人と位置を交換可" },
    { id:"SHA_W3", name:"ワーウルフ",   en:"WEREWOLF", initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員またはシチズン3人の脱落", effect:"反撃：攻撃を受けた時、そのPLをただちに攻撃" },
  ];

  const ROLE_BY_ID = Object.fromEntries(ROLES.map(r => [r.id, r]));
  const POOL = {
    "シチズン": ROLES.filter(r => r.faction === "シチズン"),
    "レイダー": ROLES.filter(r => r.faction === "レイダー"),
    "シャドウ": ROLES.filter(r => r.faction === "シャドウ"),
  };

  const DEAL_RULE = {
    1: { "レイダー": 1, "シャドウ": 0, "シチズン": 0 },
    2: { "レイダー": 1, "シャドウ": 1, "シチズン": 0 },
    3: { "レイダー": 1, "シャドウ": 1, "シチズン": 1 },
    4: { "レイダー": 2, "シャドウ": 2, "シチズン": 0 },
    5: { "レイダー": 2, "シャドウ": 2, "シチズン": 1 },
    6: { "レイダー": 2, "シャドウ": 2, "シチズン": 2 },
    7: { "レイダー": 2, "シャドウ": 2, "シチズン": 3 },
    8: { "レイダー": 3, "シャドウ": 3, "シチズン": 2 },
    9: { "レイダー": 3, "シャドウ": 3, "シチズン": 3 },
    10:{ "レイダー": 3, "シャドウ": 3, "シチズン": 4 },
  };

  const state = {
    userId: savedUserId,
    userName: null,
    roomCode: null,
    seatedTable: null,
    isHost: false,
    hands: {},
    room: {},
    spectating: false,
    currentRoomId: 0,
  };

  const mainEl = document.getElementById('main');
  const joinBox = document.getElementById('joinBox');
  const inputName = document.getElementById('userName');
  const inputCode = document.getElementById('roomCode');
  const btnJoin = document.getElementById('btnJoin');
  const lobby = document.getElementById('lobby');
  const roomInfo = document.getElementById('roomInfo');
  const attackRollResult = document.getElementById('attackRollResult');
  const roomInfoLobby = document.getElementById('roomInfoLobby');
  const copyLinkBtn = document.getElementById('copyLinkBtn');

  const seatPopBackdrop = document.getElementById('seatPopBackdrop');
  const seatCountBadge = document.getElementById('seatCountBadge');
  const tileGrid = document.getElementById('tileGrid');
  const startWarn = document.getElementById('startWarn');
  const btnSpectate = document.getElementById('btnSpectate');

  const gameArea = document.getElementById('gameArea');

  const myRoleDock = document.getElementById('myRoleDock');
  const myRoleCard = document.getElementById('myRoleCard');

  const kickDialog = document.getElementById('kickDialog');
  const kickMessage = document.getElementById('kickMessage');
  const btnKickYes = document.getElementById('btnKickYes');
  const btnKickNo = document.getElementById('btnKickNo');

  const hostSettingsBtn = document.getElementById('hostSettingsBtn');
  const startPop = document.getElementById('startPop');
  const btnStartPopClose = document.getElementById('btnStartPopClose');
  const btnGameStart = document.getElementById('btnGameStart');
  const btnResetRoom = document.getElementById('btnResetRoom');
  const startBadge = document.getElementById('startBadge');

  const helpBtn = document.getElementById('helpBtn');
  const helpBackdrop = document.getElementById('helpBackdrop');
  const btnHelpClose = document.getElementById('btnHelpClose');
  const helpBody = document.getElementById('helpBody');

  function teamColor(f){
    if (f === "レイダー")  return "#c21d1d";
    if (f === "シャドウ")  return "#0b2a6a";
    if (f === "シチズン") return "#eab308";
    return "#111";
  }
  function cardImageUrl(role){
    const initial = safeText(role?.initial || "").trim();
    const roleName = safeText(role?.name || "").trim();
    const safe = encodeURI(`${initial}${roleName}`.trim());
    return safe ? `url('${safe}.jpg')` : "none";
  }
  function createIdentityCard(role){
    const team = teamColor(role.faction);
    const en = (role.en || "").trim() || (role.name || "").trim();
    const chars = Array.from(en);
    const ini = (role.initial && String(role.initial)) || (chars[0] || "");
    const enSub = chars.length >= 2 ? chars.slice(1).join("") : "";

    const teamLabel = (role.faction === "レイダー") ? "RAIDER"
                  : (role.faction === "シャドウ") ? "SHADOW"
                  : (role.faction === "シチズン") ? "CITIZEN"
                  : String(role.faction || "");

    const card = document.createElement('div');
    card.className = 'id72';
    card.style.setProperty('--team', team);
    card.style.backgroundImage = cardImageUrl(role);

    card.innerHTML = `
      <div class="initial"><span>${ini}</span></div>
      <svg class="team-arc" viewBox="0 0 22 10" aria-hidden="true">
        <path id="teamPath" d="M0,3 Q11,9 22,3" fill="none"></path>
        <text>
          <textPath href="#teamPath" startOffset="50%" text-anchor="middle">${teamLabel}</textPath>
        </text>
      </svg>
      <div class="eng-sub">${enSub}</div>
      <div class="name">${role.name || ""}</div>
      <div class="hp-badge" aria-label="HP ${role.hp ?? ""}">
        <div class="label">HP</div>
        <div class="val">${role.hp ?? ""}</div>
      </div>
      <div class="effect">
        <p class="row"><span class="tag">勝利条件</span>${role.win || ""}</p>
        <p class="row"><span class="tag">${(String(role.effect||"").split("：")[0] || "技名")}</span>${(String(role.effect||"").split("：").slice(1).join("：") || "").trim() || String(role.effect||"")}</p>
      </div>
    `;
    return card;
  }

  function renderHelpList(){
    helpBody.innerHTML = '';
    const sorted = [...ROLES].sort((a,b) => {
      const order = { "レイダー": 0, "シャドウ": 1, "シチズン": 2 };
      const ao = order[a.faction] ?? 9;
      const bo = order[b.faction] ?? 9;
      if (ao !== bo) return ao - bo;
      return a.name.localeCompare(b.name, 'ja');
    });

    sorted.forEach((r) => {
      const row = document.createElement('div');
      row.className = 'role-row';

      const cardWrap = document.createElement('div');
      cardWrap.className = 'role-card-wrap';
      cardWrap.appendChild(createIdentityCard(r));
      if (isTestPlayer()){
        cardWrap.style.cursor = 'pointer';
        cardWrap.title = 'クリックで自分の正体カードをこのカードに変更';
        cardWrap.addEventListener('click', async (e) => {
          e.stopPropagation();
          await replaceMyRoleCardForTest(r);
        });
      }

      const desc = document.createElement('div');
      desc.className = 'role-desc';
      desc.innerHTML = `
        <div class="name">${r.name} <span class="small" style="margin-left:6px;">(${r.faction})</span></div>
        <div class="text">${r.effect}</div>
        <div class="meta">HP：${r.hp}\n勝利条件：${r.win}</div>
      `;

      row.appendChild(cardWrap);
      row.appendChild(desc);
      helpBody.appendChild(row);
    });
  }
  function openHelp(){
    renderHelpList();
    helpBackdrop.classList.remove('hidden');
  }
  async function replaceMyRoleCardForTest(role){
    if (!isTestPlayer()) return;
    if (!state.roomCode || !state.userId || !role?.id) return;
    const prev = state.hands?.[state.userId] || {};
    await update(ref(db, `rooms/${state.roomCode}`), {
      [`hands/${state.userId}`]: {
        ...prev,
        roleId: role.id,
        testReplacedAt: Date.now()
      },
      [`equipment/${state.userId}/identity`]: null
    });
    await resetAllAbilityUsageForUids([state.userId]);
  }
  function closeHelp(){ helpBackdrop.classList.add('hidden'); }
  helpBtn.addEventListener('click', () => {
    if (joinBox.classList.contains('hidden')) openHelp();
  });
  btnHelpClose.addEventListener('click', closeHelp);
  helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

  const SEAT_COLORS = [
    "#ef4444", "#f97316", "#f59e0b", "#eab308",
    "#22c55e", "#10b981", "#06b6d4", "#3b82f6",
    "#6366f1", "#8b5cf6", "#ec4899", "#f43f5e"
  ];

  const seatKey = (room)=>`bbSeat_${room}_${state.userId}`;

  function isGameStarted(){
    return !!(state.room && (state.room.gameStarted || state.room.startedAt));
  }


  async function resetAllAbilityUsageForUids(uids){
    if (!state.roomCode) return;
    const targets = [...new Set((uids || []).map(uid => safeText(uid)).filter(Boolean))];
    if (!targets.length) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !cur.abilityUsage) return cur;
      for (const usageMap of Object.values(cur.abilityUsage || {})){
        if (!usageMap || typeof usageMap !== 'object') continue;
        for (const uid of targets){
          if (Object.prototype.hasOwnProperty.call(usageMap, uid)){
            delete usageMap[uid];
          }
        }
      }
      return cur;
    });
  }
  function isSeated(){ return state.seatedTable != null; }

  function showSeatPop(){ seatPopBackdrop.classList.remove('hidden'); }
  function hideSeatPop(){
    if (!isGameStarted()) return;
    seatPopBackdrop.classList.add('hidden');
  }
  function updateSeatBoardVisibility(){
    const started = isGameStarted();
    const seated = isSeated();
    let shouldShow = false;

    if (!state.roomCode) shouldShow = false;
    else if (!started) shouldShow = !state.spectating;
    else shouldShow = (!seated) && (!state.spectating);

    if (shouldShow) showSeatPop(); else hideSeatPop();
  }

  btnSpectate.addEventListener('click', () => {
    state.spectating = true;
    if (isGameStarted()) hideSeatPop();
  });

  function generateRoomCode(length = 6){
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
    return code;
  }

  function refreshRoomLabels(){
    if (!state.roomCode || !state.userName) return;
    const label = state.isHost ? '（ホスト）' : '';
    const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
    roomInfo.textContent = infoText;
    roomInfoLobby.textContent = infoText;
  }

  function didAttackRollSucceed(d6, d4, options = {}){
    if (options.masamuneMode || options.vendettaMode) return true;
    return (Number(d6) || 0) !== (Number(d4) || 0);
  }

  // TODO: デバッグ用表示。後で消すときは #attackRollResult / .attack-roll-result-debug を非表示にする。
  function setAttackRollResultLabel(isSuccess){
    if (!attackRollResult) return;
    attackRollResult.textContent = isSuccess ? '攻撃成功' : '攻撃失敗';
  }

  function updateHostUI(){
    refreshRoomLabels();
    if (state.isHost){
      hostSettingsBtn.classList.add('visible');
    } else {
      hostSettingsBtn.classList.remove('visible');
      startPop.classList.add('hidden');
    }
    helpBtn.classList.add('visible');
  }

  function subscribeRoom(){
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    onValue(roomRef, snap => {
      state.room = snap.val() || {};
      if (isGameStarted() && !currentTurnPlayerId() && state.isHost){
        ensureTurnInitialized();
      }
      renderSeatTiles();
      refreshStartBadge();
      renderHands();
      updateSeatBoardVisibility();
      renderEquipmentDock();
      renderHpBoard();
      renderPositionLine();
      renderTurnEndButton();
      renderMarkers();
      updateCardInteractivity();
      maybeAutoRollMoveDiceOnTurnStart();
    });
  }

  function subscribeHostState(){
    const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
    onValue(hostRef, snap => {
      const hostId = snap.val();
      state.isHost = (hostId === state.userId);
      updateHostUI();
    });
  }

  function subscribeHands(){
    const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
    onValue(handsRef, snap => {
      state.hands = snap.val() || {};
      renderHands();
    });
  }


  function subscribeGreenInbox(){
    const inboxRef = ref(db, `rooms/${state.roomCode}/greenInbox/${state.userId}`);
    onValue(inboxRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!greenInboxInitialized){
        greenInboxInitialized = true;
        greenInboxSeenAt = at || 0;
        return;
      }

      if (!msg || !msg.card || !at) return;
      if (at <= greenInboxSeenAt) return;
      greenInboxSeenAt = at;
      openZoomFromDeckCard(msg.card, "green", { closeOnBackdrop:false, showCloseButton:false });
      openGreenAnswerDock(msg);
    });
  }

  function subscribeGreenResponses(){
    const resRef = ref(db, `rooms/${state.roomCode}/greenResponses/${state.userId}`);
    onValue(resRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!greenReplyInitialized){
        greenReplyInitialized = true;
        greenReplySeenAt = at || 0;
        return;
      }

      if (!msg || !at) return;
      if (at <= greenReplySeenAt) return;
      if (!pendingGreenRequestId || safeText(msg.requestId || "") !== pendingGreenRequestId) return;
      greenReplySeenAt = at;
      setGreenDockMeta({ title:"回答が届きました", subtitle:safeText(msg.answerLabel || "") });
      const reveal = greenRevealByRequestId[safeText(msg.requestId || "")];
      if (reveal?.roleId){
        showGreenRevealPanel(reveal.roleId, reveal.responderId);
      }
      greenShareActions?.classList.remove("hidden");
    });
  }

  function subscribeGreenReveals(){
    const revealRef = ref(db, `rooms/${state.roomCode}/greenReveals`);
    onValue(revealRef, snap => {
      greenRevealByRequestId = snap.val() || {};
      const pendingReveal = greenRevealByRequestId[safeText(pendingGreenRequestId || "")];
      if (pendingReveal?.roleId){
        showGreenRevealPanel(pendingReveal.roleId, pendingReveal.responderId);
        return;
      }
      const answerReveal = greenRevealByRequestId[safeText(pendingGreenAnswerMsg?.requestId || "")];
      if (answerReveal?.roleId){
        showGreenRevealPanel(answerReveal.roleId, answerReveal.responderId);
        return;
      }
      hideGreenRevealPanel();
    });
  }


  function subscribeGreenCloseSignals(){
    const closeRef = ref(db, `rooms/${state.roomCode}/greenCloseSignals/${state.userId}`);
    onValue(closeRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!pendingGreenCloseInitialized){
        pendingGreenCloseInitialized = true;
        pendingGreenCloseSeenAt = at || 0;
        return;
      }

      if (!msg || !at) return;
      if (at <= pendingGreenCloseSeenAt) return;
      pendingGreenCloseSeenAt = at;

      const requestId = safeText(msg.requestId || "");
      const pendingRequest = safeText(pendingGreenAnswerMsg?.requestId || "");
      if (!requestId || !pendingRequest || requestId !== pendingRequest) return;

      pendingGreenAnswerMsg = null;
      hideGreenShareDock();
      closeZoom();
    });
  }

  function subscribePlayers(){
    const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
    onValue(tablesRef, snap => {
      const wasSeated = state.seatedTable != null;
      const data = snap.val() || {};
      const players = Object.entries(data)
        .map(([seatIndex, t]) => (t && t.playerId ? {
          id: t.playerId,
          name: t.playerName || '名無し',
          seatIndex: Number(seatIndex),
          color: t.color || null
        } : null))
        .filter(Boolean)
        .sort((a,b) => a.seatIndex - b.seatIndex);

      latestPlayers = players;

      const mySeat = players.find(p => p.id === state.userId);
      if (mySeat) {
        state.seatedTable = mySeat.seatIndex;
        sessionStorage.setItem(seatKey(state.roomCode), String(mySeat.seatIndex));
      } else {
        state.seatedTable = null;
        if (wasSeated && !isGameStarted()) state.spectating = false;
        sessionStorage.removeItem(seatKey(state.roomCode));
      }

      renderSeatTiles();
      refreshStartBadge();
      updateSeatBoardVisibility();
      renderEquipmentDock();
      renderHpBoard();
      renderPositionLine();
    });
  }

  function effectiveSeatCount(){
    const mp = Number(state.room.maxPlayers || 0);
    return (mp >= 2) ? mp : SEAT_COLORS.length;
  }
  function occupiedCount(){ return latestPlayers.length; }

  let pendingSeatIndexToSteal = null;
  let pendingSeatPlayerIdToSteal = null;
  let pendingMode = "prestart";

  function renderSeatTiles(){
    if (!state.roomCode) return;

    const started = isGameStarted();
    const N = effectiveSeatCount();
    seatCountBadge.textContent = `${occupiedCount()} / ${N}`;

    tileGrid.innerHTML = '';

    for(let i=1;i<=N;i++){
      const color = SEAT_COLORS[i-1] || "#ddd";
      const seatIndex = i;

      const tile = document.createElement('button');
      tile.type = 'button';
      tile.className = 'seat-tile empty';
      tile.style.background = color;
      tile.setAttribute('aria-label', `席 ${seatIndex}`);

      const taken = latestPlayers.find(p => p.seatIndex === seatIndex);
      if (taken){
        tile.classList.remove('empty');
        tile.classList.add('taken');
        const initial = document.createElement('div');
        initial.className = 'seat-initial';
        initial.textContent = firstChar(taken.name);
        tile.appendChild(initial);
      }

      const num = document.createElement('div');
      num.className = 'seat-num';
      num.textContent = seatIndex;
      tile.appendChild(num);

      if (state.seatedTable === seatIndex) tile.classList.add('me');

      tile.addEventListener('click', async () => {
        if (!state.roomCode) return;

        const startedNow = isGameStarted();

        if (startedNow){
          if (isSeated()) return;
          if (!taken){
            alert("ゲーム開始後は空席に座れません。席を奪取してください。");
            return;
          }
          pendingMode = "started";
          pendingSeatIndexToSteal = seatIndex;
          pendingSeatPlayerIdToSteal = taken.id;

          kickMessage.textContent = `「${taken.name}」を追い出しますか？`;
          kickDialog.classList.remove('hidden');
          return;
        }

        if (state.seatedTable !== null){
          if (seatIndex === state.seatedTable) return;
          if (taken) return;
          await moveSeatToEmpty(seatIndex);
          return;
        }

        if (!taken){
          await sitToSeat(seatIndex);
          state.spectating = true;
          return;
        }

        pendingMode = "prestart";
        pendingSeatIndexToSteal = seatIndex;
        pendingSeatPlayerIdToSteal = taken.id;

        kickMessage.textContent = `「${taken.name}」を追い出して、この色の席を奪取しますか？`;
        kickDialog.classList.remove('hidden');
      });

      tileGrid.appendChild(tile);
    }

    startWarn.textContent = started
      ? "※ゲーム開始済み（再入室には座席をクリックして追い出してください。）"
      : "※ホストが「スタート」を押すと配布されます";
  }

  async function sitToSeat(seatIndex){
    const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
    await set(tRef, {
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[seatIndex-1] || null,
      seatedAt: Date.now()
    });
    state.seatedTable = seatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(seatIndex));
  }

  async function moveSeatToEmpty(newSeatIndex){
    if (!state.roomCode) return;
    const oldSeatIndex = state.seatedTable;
    if (oldSeatIndex == null) return;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap = await get(roomRef);
    const roomData = snap.val() || {};
    if (roomData.gameStarted || roomData.startedAt) return;

    const tables = roomData.tables || {};
    const oldSeat = tables[String(oldSeatIndex)];
    const newSeat = tables[String(newSeatIndex)];

    if (!oldSeat || oldSeat.playerId !== state.userId) return;
    if (newSeat && newSeat.playerId) return;

    const updates = {};
    updates[`tables/${oldSeatIndex}`] = null;
    updates[`tables/${newSeatIndex}`] = {
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[newSeatIndex-1] || null,
      seatedAt: Date.now(),
      movedFrom: oldSeatIndex,
      movedAt: Date.now()
    };

    await update(roomRef, updates);

    state.seatedTable = newSeatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(newSeatIndex));
  }

  async function stealSeatPrestart(seatIndex, previousPlayerId){
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    if (roomData.gameStarted || roomData.startedAt) return;

    await sitToSeat(seatIndex);

    const updates = {};
    const markers = roomData.markers || {};
    const prevMarker = previousPlayerId ? markers[previousPlayerId] : null;
    if (prevMarker){
      updates[`markers/${state.userId}`] = { ...prevMarker, updatedAt: Date.now(), inheritedFrom: previousPlayerId };
      updates[`markers/${previousPlayerId}`] = null;
    }

    if (Object.keys(updates).length){
      await update(roomRef, updates);
      await resetAllAbilityUsageForUids([state.userId, previousPlayerId]);
    }

    if (roomData.hostId && previousPlayerId && roomData.hostId === previousPlayerId) {
      await update(roomRef, { hostId: state.userId });
    }

    state.spectating = true;
  }

  async function stealSeatStarted(seatIndex, previousPlayerId){
    if (!state.roomCode) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap = await get(roomRef);
    const roomData = snap.val() || {};

    if (!(roomData.gameStarted || roomData.startedAt)) return;

    const tables = roomData.tables || {};
    const alreadySeated = Object.values(tables).some(t => t && t.playerId === state.userId);
    if (alreadySeated) return;

    const cur = tables[String(seatIndex)];
    if (!cur || cur.playerId !== previousPlayerId) return;

    const updates = {};
    updates[`tables/${seatIndex}`] = {
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[seatIndex-1] || null,
      seatedAt: Date.now(),
      stolenFrom: previousPlayerId,
      stolenAt: Date.now()
    };

    const hands = roomData.hands || {};
    const prevHand = hands[previousPlayerId] || null;
    if (prevHand){
      updates[`hands/${state.userId}`] = { ...prevHand, inheritedAt: Date.now(), inheritedFrom: previousPlayerId };
      updates[`hands/${previousPlayerId}`] = null;
    }

    const markers = roomData.markers || {};
    const prevMarker = markers[previousPlayerId] || null;
    if (prevMarker){
      updates[`markers/${state.userId}`] = { ...prevMarker, updatedAt: Date.now(), inheritedFrom: previousPlayerId };
      updates[`markers/${previousPlayerId}`] = null;
    }

    await update(roomRef, updates);
    await resetAllAbilityUsageForUids([state.userId, previousPlayerId]);

    state.seatedTable = seatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(seatIndex));

    state.spectating = true;
    hideSeatPop();
  }

  kickDialog.addEventListener('click', (e) => { if (e.target === kickDialog) closeKickDialog(); });
  btnKickNo.addEventListener('click', (e) => { e.stopPropagation(); closeKickDialog(); });
  btnKickYes.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (pendingSeatIndexToSteal == null || !state.roomCode) { closeKickDialog(); return; }

    if (pendingMode === "started"){
      await stealSeatStarted(pendingSeatIndexToSteal, pendingSeatPlayerIdToSteal);
    } else {
      await stealSeatPrestart(pendingSeatIndexToSteal, pendingSeatPlayerIdToSteal);
    }
    closeKickDialog();
  });
  function closeKickDialog(){
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
    pendingMode = "prestart";
  }

  /* =========================================================
     ★④右下：正体カードは「裏面(browncard.jpg)」で表示し、
        クリックで「オモテ(拡大)」を表示
     ========================================================= */
  function renderMyRoleCard(role){
    myRoleCard.innerHTML = '';
    if (!role){
      myRoleDock.classList.remove('visible');
      renderEquipmentDock();
      return;
    }

    const identity = equipCache?.[state.userId]?.identity;
    const isIdentityRevealed = !!(identity && identity.kind === 'identity' && identity.roleId === role.id);

    if (isIdentityRevealed){
      const face = createIdentityCard(role);
      face.title = "公開済みの正体カード";
      face.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));
      face.addEventListener('click', (e) => {
        e.stopPropagation();
        openZoomFromRole(role);
      });
      myRoleCard.appendChild(face);
    } else {
      const back = document.createElement('div');
      back.className = 'role-back';
      back.style.backgroundImage = `url('browncard.jpg')`;
      back.title = "クリックで拡大表示";
      back.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));

      back.addEventListener('click', (e) => {
        e.stopPropagation();
        openZoomFromRole(role); // 拡大はオモテ（id72）
      });

      myRoleCard.appendChild(back);
    }

    myRoleDock.classList.add('visible');
    renderEquipmentDock();
  }

  function renderHands(){
    const started = isGameStarted();
    updateSeatBoardVisibility();

    const my = state.hands[state.userId];
    if (my && my.roleId && ROLE_BY_ID[my.roleId]){
      renderMyRoleCard(ROLE_BY_ID[my.roleId]);
    } else {
      renderMyRoleCard(null);
    }

    startWarn.textContent = started
      ? "※ゲーム開始済み（未着席は席を奪取して参加できます）"
      : "※ホストが「スタート」を押すと配布されます";
  }

  function pickUnique(pool, k){
    const s = shuffle(pool);
    return s.slice(0, Math.max(0, k));
  }
  function buildDeckByPlayerCount(n){
    const rule = DEAL_RULE[n];
    if (!rule) throw new Error(`対応外の人数: ${n}`);

    const deck = [];
    deck.push(...pickUnique(POOL["レイダー"], rule["レイダー"]));
    deck.push(...pickUnique(POOL["シャドウ"], rule["シャドウ"]));
    deck.push(...pickUnique(POOL["シチズン"], rule["シチズン"]));

    if (deck.length !== n){
      throw new Error(`デッキ枚数が一致しません（n=${n}, deck=${deck.length}）`);
    }
    return shuffle(deck);
  }

  async function dealIdentityCards(){
    if (!state.roomCode) return;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};

    if (roomData.gameStarted || roomData.startedAt) return;

    const tables = roomData.tables || {};
    const players = Object.entries(tables)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        seatIndex: Number(seatIndex),
        name: String(t.playerName || "")
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    const n = players.length;
    if (n < 1 || n > 10) return;

    const deck = buildDeckByPlayerCount(n);

    const hands = {};
    for (let i=0;i<n;i++){
      hands[players[i].id] = { roleId: deck[i].id, dealtAt: Date.now() };
    }

    const positionOrder = shuffle(players.map(p => p.id));
    const startPlayerId = positionOrder[Math.floor(Math.random()*positionOrder.length)] || null;
    const freshDeckState = {
      green: { order: shuffle(toGreenOrder()), idx: 0 },
      white: { order: shuffle(toWhiteOrder()), idx: 0 },
      black: { order: shuffle(toBlackOrder()), idx: 0 },
      reveal: { slot3: null, slot5: null },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    const markers = { ...(roomData.markers || {}) };
    for (const p of players){
      if (safeText(p.name).trim().toLowerCase() !== "test") continue;
      const pt = randomPointInRoom(4, 14);
      if (!pt) continue;
      const color = SEAT_COLORS[(Number(p.seatIndex) || 1) - 1] || "#ddd";
      const initial = firstChar(p.name || "T");
      markers[p.id] = {
        x: pt.x,
        y: pt.y,
        color,
        initial,
        roomId: 4,
        updatedAt: Date.now(),
        forcedSpawn: true
      };
    }

    await update(roomRef, {
      hands,
      deckState: freshDeckState,
      gameStarted: true,
      startedAt: Date.now(),
      playerCountAtStart: n,
      markers,
      positionOrder,
      startPlayerId,
      turn: {
        currentPlayerId: startPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        repeatTurnRemaining: 0,
        repeatTurnTotal: 0,
        updatedAt: Date.now()
      }
    });

    await initDamageAllToZero(players);
  }

  function refreshStartBadge(){
    const n = latestPlayers.length;
    startBadge.textContent = `参加人数：${n}`;
    if (state.isHost){
      const rule = DEAL_RULE[n];
      if (rule){
        startBadge.textContent = `参加人数：${n}（R${rule["レイダー"]}/S${rule["シャドウ"]}/C${rule["シチズン"]}）`;
      }
    }
  }

  hostSettingsBtn.addEventListener('click', () => {
    if (!state.isHost) return;
    startPop.classList.toggle('hidden');
  });
  btnStartPopClose.addEventListener('click', () => startPop.classList.add('hidden'));
  btnGameStart.addEventListener('click', async () => {
    if (!state.isHost) return;
    await dealIdentityCards();
    startPop.classList.add('hidden');
  });

  btnResetRoom.addEventListener('click', async () => {
    if (!state.isHost || !state.roomCode) return;

    const base = `rooms/${state.roomCode}`;
    await Promise.all([
      remove(ref(db, `${base}/tables`)),
      remove(ref(db, `${base}/hands`)),
      remove(ref(db, `${base}/maxPlayers`)),
      remove(ref(db, `${base}/gameStarted`)),
      remove(ref(db, `${base}/startedAt`)),
      remove(ref(db, `${base}/playerCountAtStart`)),
      remove(ref(db, `${base}/markers`)),
      remove(ref(db, `${base}/deckState`)),
      remove(ref(db, `${base}/equipment`)),
      remove(ref(db, `${base}/damage`)),
      remove(ref(db, `${base}/positionOrder`)),
      remove(ref(db, `${base}/startPlayerId`)),
      remove(ref(db, `${base}/greenInbox`)),
      remove(ref(db, `${base}/greenResponses`)),
      remove(ref(db, `${base}/greenReplyBubbles`)),
      remove(ref(db, `${base}/greenReveals`)),
      remove(ref(db, `${base}/turn`)),
    ]);

    deckCache = null;
    equipCache = {};
    damageCache = {};

    state.seatedTable = null;
    state.spectating = false;
    sessionStorage.removeItem(seatKey(state.roomCode));
    startPop.classList.add('hidden');

    renderSeatTiles();
    renderHands();
    updateSeatBoardVisibility();

    renderDeckRowFromRoom();
    renderEquipmentDock();
    buildHpCells();
    renderHpBoard();

    updateEquipDockTop();
  });

  async function doEndTurn(){
    clearDefeatLootState();
    lastAttackWatch = null;
    await advanceTurnToNextPlayer();
    hideAttackPop();
    hideEndTurnConfirm();
    renderTurnEndButton();
  }

  btnEndTurn?.addEventListener('click', async () => {
    if (!canShowEndTurnButton()) return;
    if (!turnState()?.attackDone){
      showEndTurnConfirm({ message:"本当に終了しますか。" });
      return;
    }
    await doEndTurn();
  });

  btnEndTurnNo?.addEventListener('click', () => {
    hideEndTurnConfirm();
  });

  btnEndTurnYes?.addEventListener('click', async () => {
    if (!canShowEndTurnButton()){
      hideEndTurnConfirm();
      return;
    }
    await doEndTurn();
  });

  const urlParams = new URLSearchParams(window.location.search);
  const roomFromUrl = urlParams.get('room');
  if(roomFromUrl) inputCode.value = roomFromUrl;

  const cachedUserName = localStorage.getItem(USER_NAME_CACHE_KEY);
  if (cachedUserName != null) inputName.value = cachedUserName;

  inputName.addEventListener("input", () => {
    localStorage.setItem(USER_NAME_CACHE_KEY, inputName.value || "");
  });

  btnJoin.addEventListener('click', async () => {
    state.userName = (inputName.value || '名無し').slice(0,4);
    localStorage.setItem(USER_NAME_CACHE_KEY, state.userName);
    state.roomCode = inputCode.value.trim() || generateRoomCode();
    state.spectating = false;
    state.currentRoomId = 0;

    await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
      name: state.userName,
      joinedAt: Date.now()
    });

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val();

    if(!roomData || !roomData.hostId){
      await update(roomRef, { hostId: state.userId });
      state.isHost = true;
    } else {
      state.isHost = (roomData.hostId === state.userId);
    }

    updateHostUI();

    mainEl.classList.remove('prejoin');
    mainEl.classList.add('joined');

    joinBox.classList.add('hidden');
    lobby.classList.remove('hidden');
    lobby.classList.add('entered');

    gameArea.classList.remove('hidden');

    renderRoomShape();
    buildHpCells();

    await ensureRoomDeckState();
    subscribeDeckState();
    renderDeckRowFromRoom();

    const cachedSeat = sessionStorage.getItem(seatKey(state.roomCode));
    if (cachedSeat) state.seatedTable = Number(cachedSeat) || null;

    subscribeRoom();
    subscribeHostState();
    subscribePlayers();
    subscribeHands();
    subscribeGreenInbox();
    subscribeGreenResponses();
    subscribeGreenReveals();
    subscribeGreenCloseSignals();
    subscribeGreenReplyBubbles();
    subscribeMarkers();
    subscribeEquipment();
    subscribeDamage();
    subscribeDiceEvents();
    subscribeRoleFlashEvents();
    subscribeWalpurgisSwapEvents();

    renderSeatTiles();
    refreshStartBadge();
    renderHands();
    updateSeatBoardVisibility();

    updateCardInteractivity();
    renderEquipmentDock();
    renderHpBoard();

    requestAnimationFrame(() => {
      updateEquipDockTop();
      applyEquipCols();
    });
  });

  copyLinkBtn.addEventListener('click', async () => {
    const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
    try {
      await navigator.clipboard.writeText(url);
      copyLinkBtn.classList.add('copied');
      copyLinkBtn.textContent = 'COPIED';
      inputCode.value = state.roomCode;
      setTimeout(()=>{
        copyLinkBtn.classList.remove('copied');
        copyLinkBtn.textContent='COPY';
      },1500);
    } catch {
      prompt('コピーできません。手動でコピーしてください', url);
    }
  });
</script>

</body>
</html>
