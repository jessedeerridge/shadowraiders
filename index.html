<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>オンラインルーム（色選択＋配布＋図形②＋山札）</title>
<style>
  :root { --gap:10px; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px;border-bottom:1px solid #eee;gap:12px}
  h1{margin:0;font-size:18px}
  .small{font-size:12px;opacity:.85;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .copybtn{padding:6px 10px;border:1px solid #ddd;border-radius:10px;background:#f7f7f7;cursor:pointer}
  main{padding:14px;display:grid;gap:16px;max-width:980px;margin:0 auto}
  .join-box{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .join-box input{padding:10px;border:1px solid #ddd;border-radius:8px;font-size:16px}
  .btn{padding:10px 14px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  .hidden{display:none !important}

  /* 図形（②） */
  html,body{height:100%}
  #art{display:block;margin:auto;max-width:96vmin;height:auto}
  .shape{fill:#fff;stroke:#111;stroke-width:0.8;stroke-linejoin:round;stroke-linecap:round}

  /* 左長方形内のユーザーアイコン（正方形＋角丸） */
  .usericon rect{fill:#fff;stroke:#111;stroke-width:0.8;rx:6;ry:6}
  .usericon text{font-size:12px;font-weight:700;dominant-baseline:middle;text-anchor:middle}
  .usericon{cursor:grab}
  .usericon.dragging{cursor:grabbing;opacity:.85}

  /* 右側の席アイコン（正方形＋角丸） */
  .seaticon rect{stroke:#111;stroke-width:0.8;rx:6;ry:6}
  .seaticon text{font-size:12px;font-weight:700;dominant-baseline:middle;text-anchor:middle}

  /* 7部屋のヒット領域（通常は透明、クリック時だけフラッシュ） */
  .roomhit{fill:transparent;stroke:none;pointer-events:auto}
  .roomhit.flash{fill:#eee;transition:fill 60ms}

  /* 山札UI（右の図形の真下に） */
  .decks{display:flex;gap:16px;justify-content:flex-start;align-items:flex-start;margin-top:12px;margin-left:40px}
  .deck{display:flex;flex-direction:column;align-items:center;gap:8px}
  .deck-back,.deck-face{
    width:80px;height:110px;border:1px solid #111;border-radius:10px;
    display:flex;align-items:center;justify-content:center;font-weight:700;color:#111;user-select:none;
  }
  .deck-back{cursor:pointer}
  .deck-back.disabled{opacity:.35;cursor:not-allowed;filter:grayscale(1)}
  .deck-back.green{background:#c7f5c1;}
  .deck-back.white{background:#ffffff;}
  .deck-back.black{background:#cfcfcf;} /* 真っ黒にするなら #000; color:#fff; に変更 */
  .deck-label{font-size:12px;opacity:.8}

  /* ダイス欄 */
  .dicebar{display:flex;gap:8px;align-items:center;margin-top:6px;margin-left:8px;flex-wrap:wrap}
  .dicebtn{padding:8px 10px;border:1px solid #ddd;border-radius:10px;background:#fafafa;cursor:pointer}
  .diceres{font-weight:700}

  /* ホスト用 右クリック風ポップ */
  .popover{
    position:fixed;z-index:2147483600;background:#fff;border:1px solid #111;border-radius:10px;
    padding:6px 10px;box-shadow:0 6px 16px rgba(0,0,0,.12);display:flex;gap:10px;align-items:center
  }
  .popover button{padding:6px 10px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}

  /* --- 色選択ポップ --- */
  .overlay{
    position:fixed;inset:0;background:rgba(0,0,0,.08);backdrop-filter:saturate(1.2) blur(2px);
    display:flex;align-items:center;justify-content:center;z-index:2147483601;
  }
  .color-modal{
    width:min(640px,90vw);border:1px solid #111;border-radius:16px;background:#fff;box-shadow:0 8px 24px rgba(0,0,0,.16);
    padding:14px 16px;display:flex;flex-direction:column;gap:12px;
  }
  .color-grid{
    display:grid;grid-template-columns:repeat(5,1fr);gap:10px;
  }
  .chip{
    height:68px;border:1px solid #111;border-radius:12px;display:grid;place-items:center;position:relative;cursor:pointer;
    user-select:none;font-weight:800;font-size:18px;
  }
  .chip.disabled{opacity:.35;cursor:not-allowed}
  .chip .label{position:absolute;bottom:6px;right:8px;font-size:10px;font-weight:600;opacity:.8}
  .chip .owner{font-size:22px;}

  /* --- 設定ギア（ホストのみ） --- */
  .gear{
    position:fixed;left:10px;bottom:10px;width:42px;height:42px;border-radius:50%;
    border:1px solid #111;background:#fff;display:grid;place-items:center;cursor:pointer;z-index:2147483602;
    box-shadow:0 6px 16px rgba(0,0,0,.12);
  }
  .settings{
    position:fixed;left:10px;bottom:60px;border:1px solid #111;border-radius:14px;background:#fff;z-index:2147483602;
    padding:10px;box-shadow:0 8px 24px rgba(0,0,0,.16);min-width:200px;
  }
  .settings .row{display:flex;justify-content:space-between;gap:8px;align-items:center;margin:6px 0}
  .settings button{padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}

  /* --- 配られたカード（各参加者の画面右下） --- */
  .mycard-dock{
    position:fixed;right:12px;bottom:12px;z-index:2147483601;
  }
  .card-small{
    width:54px;height:76px;border-radius:10px;border:1px solid #000;background:#000;color:#fff;display:grid;place-items:center;
    font-weight:800;cursor:pointer;user-select:none;
  }
  .card-modal{
    position:fixed;inset:0;background:rgba(0,0,0,.2);display:flex;align-items:center;justify-content:center;z-index:2147483603;
  }
  .card-modal .card-face{
    width:220px;height:300px;border:2px solid #111;border-radius:18px;background:#fff;display:grid;place-items:center;
    font-size:42px;font-weight:900;box-shadow:0 12px 28px rgba(0,0,0,.25);
  }
</style>
</head>
<body>
<header>
  <h1>オンラインルーム</h1>
  <div class="small" id="headerInfo"></div>
  <div class="small" id="myRoomBadge">部屋：未選択</div>
</header>

<main>
  <!-- 入室 -->
  <section id="joinPanel" class="join-box">
    <input id="nameInput" placeholder="名前（1文字）" maxlength="1" inputmode="text" />
    <input id="codeInput" placeholder="ルームコード（例: 1234）" maxlength="12" inputmode="numeric" />
    <button id="btnJoin" class="btn">入室</button>
  </section>

  <!-- ルーム -->
  <section id="roomPanel" class="hidden">
    <div style="margin-top:10px;">
      <!-- 図形②：左に狭い長方形＋右に星形（中央六角形＋外周五角形6） -->
      <svg id="art" viewBox="-220 -230 440 460" aria-label="左に長方形・右に星形"></svg>
    </div>

    <!-- ダイス（左長方形の下／ローカル表示） -->
    <div class="dicebar" id="diceBar">
      <button class="dicebtn" id="rollD6">d6 を振る</button>
      <span class="diceres" id="resD6">-</span>
      <button class="dicebtn" id="rollD4">d4 を振る</button>
      <span class="diceres" id="resD4">-</span>
    </div>

    <!-- ▼ 右画像の下：山札（緑・白・黒の3デッキを横並び） -->
    <div id="decks" class="decks" aria-label="山札（左から緑・白・黒）"></div>
  </section>
</main>

<!-- カラー選択オーバーレイ -->
<div id="colorOverlay" class="overlay hidden" role="dialog" aria-modal="true">
  <div class="color-modal">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
      <div style="font-weight:900;">色を選んでください（2行×5列）</div>
      <div id="colorLockNotice" class="small"></div>
    </div>
    <div id="colorGrid" class="color-grid"></div>
    <div class="small" style="opacity:.75">※ 他のプレイヤーが選択済みの色は選べません。選んだあともホストが「スタート」を押すまでこの画面のままです。</div>
  </div>
</div>

<!-- 設定（ホストのみ） -->
<div id="gear" class="gear hidden" title="設定（ホスト）">⚙️</div>
<div id="settings" class="settings hidden">
  <div class="row"><div>ゲーム状態：</div><div id="gameStateText" style="font-weight:800;">未開始</div></div>
  <div class="row"><button id="btnStart">スタート</button><span class="small" id="startHint">全員にカードを1枚ずつ配ります</span></div>
</div>

<!-- 自分の配られたカード：右下 -->
<div id="myCardDock" class="mycard-dock hidden">
  <div id="mySmallCard" class="card-small" title="クリックで拡大表示">裏</div>
</div>

<!-- Firebase（v9 モジュール） -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import {
    getDatabase, ref, set, onValue, onDisconnect, remove, get, update, runTransaction
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  /* Firebase 設定 */
  const firebaseConfig = {
    apiKey: "AIzaSyASUJcPyybcD9q77XDatI5bCzZxDvsBH_o",
    authDomain: "shadowraiders-a2dbc.firebaseapp.com",
    projectId: "shadowraiders-a2dbc",
    storageBucket: "shadowraiders-a2dbc.firebasestorage.app",
    messagingSenderId: "577276689873",
    appId: "1:577276689873:web:9a13faf90c3d6a791e34f0",
    measurementId: "G-PKNEPDBVSS"
  };

  // --- 初期化 ---
  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // --- DOM ---
  const headerInfo    = document.getElementById('headerInfo');
  const myRoomBadge   = document.getElementById('myRoomBadge');
  const joinPanel     = document.getElementById('joinPanel');
  const nameInput     = document.getElementById('nameInput');
  const codeInput     = document.getElementById('codeInput');
  const btnJoin       = document.getElementById('btnJoin');
  const roomPanel     = document.getElementById('roomPanel');
  const decksEl       = document.getElementById('decks');
  const rollD6Btn     = document.getElementById('rollD6');
  const rollD4Btn     = document.getElementById('rollD4');
  const resD6         = document.getElementById('resD6');
  const resD4         = document.getElementById('resD4');

  const colorOverlay  = document.getElementById('colorOverlay');
  const colorGrid     = document.getElementById('colorGrid');
  const colorLockNotice = document.getElementById('colorLockNotice');
  const gearEl        = document.getElementById('gear');
  const settingsEl    = document.getElementById('settings');
  const btnStart      = document.getElementById('btnStart');
  const gameStateText = document.getElementById('gameStateText');
  const myCardDock    = document.getElementById('myCardDock');
  const mySmallCard   = document.getElementById('mySmallCard');

  // --- 状態 ---
  const state = {
    uid: crypto.randomUUID(),
    name: "",
    code: "",
    joined: false,
    unsub: [],
    rectBBox: null,
    draggingUid: null,
    isPointerDown: false,
    dragOffset: {x:0,y:0},
    isHost: false,
    myColorKey: null,
    users: {},        // uid -> {color}
    colors: {},       // colorKey -> {uid,name}
    game: { started:false },
    myHand: null,
  };

  // --- ユーティリティ ---
  function randomLetter(){ return String.fromCharCode(65 + Math.floor(Math.random()*26)); }
  function random4(){ return String(Math.floor(Math.random()*10000)).padStart(4, '0'); }
  const NAME_RE = /^[A-Za-z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]$/;
  function normalizeName(raw){
    const t = (raw || "").trim(); if (!t) return randomLetter();
    const c = t[0]; return NAME_RE.test(c) ? c : randomLetter();
  }
  function show(el, yes){ el.classList.toggle('hidden', !yes); }
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

  // ===== ヘッダ表示・コピー =====
  function updateHeader(){
    headerInfo.innerHTML = '';
    const spanRoom = document.createElement('span');
    spanRoom.textContent = `コード：${state.code || '-'}`;
    const spanMe = document.createElement('span');
    spanMe.textContent = `あなた：${state.name || '-'}`;
    const btn = document.createElement('button');
    btn.className = 'copybtn';
    btn.textContent = 'リンクコピー';
    btn.onclick = ()=>{
      const url = new URL(location.href);
      url.searchParams.set('room', state.code);
      url.searchParams.set('name', state.name);
      navigator.clipboard.writeText(url.toString());
      btn.textContent = 'コピー済み！';
      setTimeout(()=> btn.textContent='リンクコピー', 1200);
    };
    headerInfo.appendChild(spanRoom);
    headerInfo.appendChild(spanMe);
    headerInfo.appendChild(btn);
  }

  // === 図形②：左長方形＋右星形（7部屋ヒット領域付き） ===
  function drawFigure2(){
    const svg = document.getElementById('art');
    if (!svg) return;
    svg.innerHTML = '';
    const rt3 = Math.sqrt(3);

    // ---- パラメータ ----
    const s0 = 48;   // 中央六角形の一辺
    const s1 = 82;   // 中間六角形の一辺（五角形の根元）
    const rectScale = 0.40;
    const gap = 20;

    function hexFlat(cx, cy, s){
      const h = (rt3/2)*s;
      return [
        [cx+s,   cy],
        [cx+s/2, cy+h],
        [cx-s/2, cy+h],
        [cx-s,   cy],
        [cx-s/2, cy-h],
        [cx+s/2, cy-h],
      ];
    }
    const add=(a,b)=>[a[0]+b[0],a[1]+b[1]];
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
    const mul=(a,k)=>[a[0]*k,a[1]*k];
    const norm=(v)=>{ const L=Math.hypot(v[0],v[1])||1; return [v[0]/L,v[1]/L]; };
    function intersectRayRay(p,u,q,v){
      const A = [[u[0], -v[0]], [u[1], -v[1]]];
      const b = sub(q,p);
      const det = A[0][0]*A[1][1] - A[0][1]*A[1][0];
      const t = ( b[0]*A[1][1] - b[1]*A[0][1]) / det;
      return add(p, mul(u, t));
    }

    // 星本体（表示用）
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('id','star');
    svg.appendChild(g);

    function poly(pts, cls='shape', parent=g){
      const el = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      el.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
      el.setAttribute('class', cls);
      parent.appendChild(el);
      return el;
    }

    const H0 = hexFlat(0,0,s0);
    const H1 = hexFlat(0,0,s1);

    // 中央六角形（表示）
    poly(H0);

    // 外周五角形（表示）
    const pentPoints = [];
    for(let i=0;i<6;i++){
      const ip=(i+5)%6, inx=(i+1)%6, inx2=(i+2)%6;
      const a0=H0[i], b0=H0[inx], a1=H1[i], b1=H1[inx];
      const dirFromA1=norm(sub(H1[i],H1[ip]));
      const dirFromB1=norm(sub(H1[inx2],H1[inx]));
      const tip=intersectRayRay(a1,dirFromA1,b1,dirFromB1);
      const p = [a0,b0,b1,tip,a1];
      pentPoints.push(p);
      poly(p);
    }

    // 左の長方形
    const starBox = g.getBBox();
    const rectH = starBox.height;
    const rectW = rectH * rectScale;
    const rectX = starBox.x - gap - rectW;
    const rectY = starBox.y;

    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', rectX);
    rect.setAttribute('y', rectY);
    rect.setAttribute('width', rectW);
    rect.setAttribute('height', rectH);
    rect.setAttribute('class','shape');
    rect.setAttribute('id','leftRect');
    svg.appendChild(rect);

    // 左長方形内のアイコン用レイヤ
    const iconsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    iconsLayer.setAttribute('id','icons');
    svg.appendChild(iconsLayer);

    // 7部屋ヒット層
    const roomsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    roomsLayer.setAttribute('id','rooms');
    svg.appendChild(roomsLayer);

    // 中央六角形（room 1）
    const hitHex = poly(H0, 'roomhit', roomsLayer);
    hitHex.dataset.room = '1';
    hitHex.addEventListener('click', onRoomClick);

    // 外周五角形（room 2〜7）
    for(let i=0;i<6;i++){
      const hitPent = poly(pentPoints[i], 'roomhit', roomsLayer);
      hitPent.dataset.room = String(2 + i); // 2..7
      hitPent.addEventListener('click', onRoomClick);
    }

    // 席アイコン用レイヤ
    const seatsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    seatsLayer.setAttribute('id','seats');
    svg.appendChild(seatsLayer);

    // viewBox 調整
    (function fit(){
      const pad=14, box=svg.getBBox();
      svg.setAttribute('viewBox',[box.x-pad, box.y-pad, box.width+pad*2, box.height+pad*2].join(' '));
    })();

    // 左長方形の矩形を保持（ドラッグ範囲クランプ用）
    state.rectBBox = { x: rectX, y: rectY, w: rectW, h: rectH };

    // 左長方形クリック：同名が既に存在すれば新規出現しない
    rect.addEventListener('click', onRectClickWithDupCheck);
  }

  // ===== 山札 =====
  const DECKS_DEF = {
    green: { label:'緑', colorClass:'green', cards:['あ','か','た','ら','わ','は'] },
    white: { label:'白', colorClass:'white', cards:['し','き','に','み','ぎ','ち'] },
    black: { label:'黒', colorClass:'black', cards:['ろ','も','こ','ど','そ','ぼ'] },
  };

  function setupDecks(){
    decksEl.innerHTML = '';
    ['green','white','black'].forEach(deckId=>{
      const def = DECKS_DEF[deckId];

      const wrap = document.createElement('div');
      wrap.className = 'deck';
      wrap.dataset.deck = deckId;

      const back = document.createElement('div');
      back.className = `deck-back ${def.colorClass}`;
      back.textContent = '裏';
      back.title = `${def.label}デッキをめくる`;
      back.addEventListener('click', ()=> advanceDeckGuarded(deckId));

      const face = document.createElement('div');
      face.className = 'deck-face';
      face.dataset.role = 'face';
      face.textContent = '';

      const label = document.createElement('div');
      label.className = 'deck-label';
      label.textContent = `${def.label}デッキ`;

      wrap.appendChild(back);
      wrap.appendChild(face);
      wrap.appendChild(label);
      decksEl.appendChild(wrap);
    });

    // DB同期購読
    const decksRef = ref(db, `rooms/${state.code}/decks`);
    const off = onValue(decksRef, (snap)=>{
      const v = snap.val() || {};
      ['green','white','black'].forEach(id=>{
        const idx = (v[id]?.idx ?? -1);
        const faceEl = decksEl.querySelector(`.deck[data-deck="${id}"] .deck-face`);
        const card = (idx >= 0) ? DECKS_DEF[id].cards[idx % DECKS_DEF[id].cards.length] : '';
        faceEl.textContent = card;
      });
      refreshDeckEnable();
    });
    state.unsub.push(off);
  }

  // ルーム制限に従ってクリック可否を判定
  function canFlip(deckId, myRoom){
    if (!myRoom) return false;
    switch(deckId){
      case 'green': return (myRoom===6 || myRoom===7);
      case 'white': return (myRoom===7 || myRoom===2);
      case 'black': return (myRoom===7 || myRoom===3);
      default: return false;
    }
  }
  function refreshDeckEnable(){
    const myRoom = state.myRoomNumber || null;
    ['green','white','black'].forEach(id=>{
      const back = decksEl.querySelector(`.deck[data-deck="${id}"] .deck-back`);
      if (!back) return;
      const ok = canFlip(id, myRoom);
      back.classList.toggle('disabled', !ok);
    });
  }

  async function advanceDeckGuarded(deckId){
    const ok = canFlip(deckId, state.myRoomNumber || null);
    if (!ok) return; // 禁止
    await advanceDeck(deckId);
  }

  async function advanceDeck(deckId){
    const def = DECKS_DEF[deckId];
    const deckPath = ref(db, `rooms/${state.code}/decks/${deckId}`);
    const snap = await get(deckPath);
    const curIdx = snap.exists() && typeof snap.val().idx === 'number' ? snap.val().idx : -1;
    const nextIdx = (curIdx + 1) % def.cards.length;
    await set(deckPath, { idx: nextIdx, at: Date.now() });
  }

  // ===== 右側：部屋クリック =====
  async function onRoomClick(ev){
    const svg = document.getElementById('art');
    const el = ev.currentTarget;
    const roomNo = Number(el.dataset.room || 0);

    el.classList.add('flash');
    setTimeout(()=> el.classList.remove('flash'), 140);

    // 既存の同名席があれば“引き継ぎ”（新規生成しない）
    const seatsSnap = await get(ref(db, `rooms/${state.code}/seats`));
    const seats = seatsSnap.val() || {};
    let sameNameUid = null, sameData = null;
    for (const [uid, data] of Object.entries(seats)){
      if ((data?.name||'') === state.name){
        sameNameUid = uid; sameData = data; break;
      }
    }
    if (sameNameUid && sameNameUid !== state.uid){
      // 所有を自分に移す（位置はそのまま）
      await set(ref(db, `rooms/${state.code}/seats/${state.uid}`), { ...sameData, name: state.name, at: Date.now() });
      await remove(ref(db, `rooms/${state.code}/seats/${sameNameUid}`));
      return; // 位置変更は行わない
    }

    // 新規または自分の既存を更新
    const p = toSvgCoords(svg, ev.clientX, ev.clientY);
    await set(ref(db, `rooms/${state.code}/seats/${state.uid}`), {
      name: state.name,
      room: roomNo,
      x: p.x - 12,  // 正方形中心補正
      y: p.y - 12,
      at: Date.now()
    });
  }

  // SVG座標変換
  function toSvgCoords(svg, clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const m = svg.getScreenCTM(); if (!m) return {x:0,y:0};
    const sp = pt.matrixTransform(m.inverse());
    return {x: sp.x, y: sp.y};
  }

  // ===== 席アイコン描画（色適用） =====
  function seatTextColorFor(colorKey){
    // 黒・緑(両方)・紫・青・赤 → 白文字、それ以外 → 黒文字
    const whiteText = new Set(['black','green','green2','purple','blue','red']);
    return whiteText.has(colorKey) ? '#fff' : '#111';
  }
  const COLOR_DEF = [
    { key:'red',    label:'赤',    css:'#e53935' },
    { key:'blue',   label:'青',    css:'#1e88e5' },
    { key:'black',  label:'黒',    css:'#111111' },
    { key:'green',  label:'緑',    css:'#43a047' },
    { key:'white',  label:'白',    css:'#ffffff' },
    { key:'green2', label:'緑',    css:'#2e7d32' }, // 2つ目の緑
    { key:'purple', label:'紫',    css:'#8e24aa' },
    { key:'aqua',   label:'水色',  css:'#26c6da' },
    { key:'orange', label:'オレンジ', css:'#fb8c00' },
    { key:'yellow', label:'黄色',  css:'#fdd835' },
  ];
  const COLOR_MAP = Object.fromEntries(COLOR_DEF.map(c=>[c.key,c]));

  function renderOrUpdateSeat(uid, data){
    const svg = document.getElementById('art');
    const layer = document.getElementById('seats');
    if (!svg || !layer || !data) return;

    let g = layer.querySelector(`g[data-uid="${uid}"]`);
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','seaticon');
      g.setAttribute('data-uid', uid);

      const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
      box.setAttribute('width', 24);
      box.setAttribute('height', 24);
      // 初期は白
      box.setAttribute('fill', '#fff');
      g.appendChild(box);

      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', 12);
      label.setAttribute('y', 12);
      label.textContent = (data.name || '?');
      label.setAttribute('fill', '#111');
      g.appendChild(label);

      // ホスト削除ポップ
      g.addEventListener('click', (e)=> maybeShowDeletePopover(e, 'seat', uid));

      layer.appendChild(g);
    }

    // 名前更新
    const text = g.querySelector('text');
    if (text && text.textContent !== (data.name || '?')) text.textContent = (data.name || '?');

    // 色適用（users/uid/color を参照）
    const myU = state.users[uid] || {};
    const colorKey = myU.color || null;
    const rect = g.querySelector('rect');
    if (rect){
      const fillCss = colorKey ? (COLOR_MAP[colorKey]?.css || '#fff') : '#fff';
      rect.setAttribute('fill', fillCss);
    }
    if (text){
      const tColor = colorKey ? seatTextColorFor(colorKey) : '#111';
      text.setAttribute('fill', tColor);
    }

    // 位置更新
    g.setAttribute('transform', `translate(${data.x},${data.y})`);
  }

  // ===== 左長方形：クランプ =====
  function clampToRect(x, y){
    const r = state.rectBBox;
    const w = 24, h = 24;
    const minX = r.x + 4;
    const maxX = r.x + r.w - w - 4;
    const minY = r.y + 4;
    const maxY = r.y + r.h - h - 4;
    return {
      x: Math.min(maxX, Math.max(minX, x)),
      y: Math.min(maxY, Math.max(minY, y))
    };
  }

  // 左長方形クリック：同名が存在すれば新規出現しない
  async function onRectClickWithDupCheck(ev){
    const svg = document.getElementById('art');
    const myIconRef = ref(db, `rooms/${state.code}/icons/${state.uid}`);

    // 左長方形内で同名が既にあるかチェック
    const allIconsSnap = await get(ref(db, `rooms/${state.code}/icons`));
    const allIcons = allIconsSnap.val() || {};
    const dup = Object.values(allIcons).some(ic => (ic?.name||'') === state.name);
    if (dup) return; // 同名があれば新規出現しない

    // 自分は未配置なら作成、配置済なら無視
    const snap = await get(myIconRef);
    if (snap.exists()) return;

    const p = toSvgCoords(svg, ev.clientX, ev.clientY);
    const pos = clampToRect(p.x - 12, p.y - 12);

    await set(myIconRef, { name: state.name, x: pos.x, y: pos.y, placedAt: Date.now() });
  }

  function renderOrUpdateIcon(uid, data){
    const svg = document.getElementById('art');
    const layer = document.getElementById('icons');
    if (!svg || !layer || !data) return;

    let g = layer.querySelector(`g[data-uid="${uid}"]`);
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','usericon');
      g.setAttribute('data-uid', uid);

      const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
      box.setAttribute('width', 24);
      box.setAttribute('height', 24);
      g.appendChild(box);

      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', 12);
      label.setAttribute('y', 12);
      label.textContent = (data.name || '?');
      g.appendChild(label);

      // ドラッグ
      g.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        state.isPointerDown = true;
        state.draggingUid = uid;
        g.classList.add('dragging');
        const p = toSvgCoords(svg, e.clientX, e.clientY);
        const gx = parseFloat(g.getAttribute('data-x') || data.x || 0);
        const gy = parseFloat(g.getAttribute('data-y') || data.y || 0);
        state.dragOffset.x = p.x - gx;
        state.dragOffset.y = p.y - gy;
        g.setPointerCapture(e.pointerId);
      });
      g.addEventListener('pointerup', (e)=>{
        if (!state.isPointerDown) return;
        state.isPointerDown = false;
        g.classList.remove('dragging');
        g.releasePointerCapture(e.pointerId);
      });
      g.addEventListener('pointercancel', ()=>{
        state.isPointerDown = false;
        g.classList.remove('dragging');
      });
      svg.addEventListener('pointermove', throttle((e)=>{
        if (!state.isPointerDown || state.draggingUid !== uid) return;
        const p = toSvgCoords(svg, e.clientX, e.clientY);
        const pos = clampToRect(p.x - state.dragOffset.x, p.y - state.dragOffset.y);
        g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
        g.setAttribute('data-x', pos.x);
        g.setAttribute('data-y', pos.y);
        update(ref(db, `rooms/${state.code}/icons/${uid}`), { x: pos.x, y: pos.y });
      }, 40), { passive: true });

      // ホスト削除ポップ
      g.addEventListener('click', (e)=> maybeShowDeletePopover(e, 'icon', uid));

      layer.appendChild(g);
    }

    // 名前更新
    const text = g.querySelector('text');
    if (text && text.textContent !== (data.name || '?')) text.textContent = (data.name || '?');

    // 自分がドラッグ中はリモート更新を抑止
    if (!(state.isPointerDown && state.draggingUid === uid)) {
      g.setAttribute('transform', `translate(${data.x},${data.y})`);
      g.setAttribute('data-x', data.x);
      g.setAttribute('data-y', data.y);
    }
  }

  function throttle(fn, ms){
    let t = 0, lastArgs = null, tid = null;
    return function(...args){
      const now = Date.now();
      if (now - t >= ms){ t = now; fn.apply(this, args); }
      else {
        lastArgs = args; clearTimeout(tid);
        tid = setTimeout(()=>{ t = Date.now(); fn.apply(this, lastArgs); lastArgs = null; }, ms - (now - t));
      }
    };
  }

  // ===== ホスト管理 & 削除ポップ =====
  async function becomeHostIfVacant(){
    const hostRef = ref(db, `rooms/${state.code}/host`);
    await runTransaction(hostRef, cur => cur ?? state.uid);
    const snap = await get(hostRef);
    state.isHost = (snap.val() === state.uid);
    updateHostUI();
 updateGameUI(); 
  }

  function updateHostUI(){
    show(gearEl, state.isHost);
    show(settingsEl, false);
  }

  // ホストの変化を購読（譲渡など）
  function watchHost(){
    const hostRef = ref(db, `rooms/${state.code}/host`);
    const off = onValue(hostRef, (snap)=>{
      state.isHost = (snap.val() === state.uid);
      updateHostUI();
  updateGameUI(); 
    });
    state.unsub.push(off);
  }

  let popEl = null;
  function closePopover(){ if (popEl){ popEl.remove(); popEl=null; } }
  function maybeShowDeletePopover(ev, kind, uidTarget){
    if (!state.isHost) return;
    closePopover();
    popEl = document.createElement('div');
    popEl.className = 'popover';
    popEl.innerHTML = `<span>この${kind==='icon'?'アイコン':'席'}を削除</span>`;
    const b = document.createElement('button');
    b.textContent = '消す';
    b.onclick = async ()=>{
      if (kind==='icon') await remove(ref(db, `rooms/${state.code}/icons/${uidTarget}`));
      else await remove(ref(db, `rooms/${state.code}/seats/${uidTarget}`));
      closePopover();
    };
    popEl.appendChild(b);
    document.body.appendChild(popEl);
    const x = ev.clientX, y = ev.clientY;
    const r = popEl.getBoundingClientRect();
    popEl.style.left = Math.max(8, x - r.width/2) + 'px';
    popEl.style.top  = (y + 6) + 'px';
    setTimeout(()=>{
      document.addEventListener('click', clickAwayOnce, { once:true });
    },0);
    function clickAwayOnce(e){
      if (!popEl) return;
      if (!popEl.contains(e.target)) closePopover();
    }
  }

  // ===== 色選択ポップ =====
  function buildColorGrid(){
    colorGrid.innerHTML = '';
    for (const c of COLOR_DEF){
      const cell = document.createElement('div');
      cell.className = 'chip';
      cell.style.background = c.css;
      const ownerSpan = document.createElement('div');
      ownerSpan.className = 'owner';
      ownerSpan.textContent = ''; // 所有者の一文字
      ownerSpan.style.color = seatTextColorFor(c.key);
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = c.label;
      cell.appendChild(ownerSpan);
      cell.appendChild(label);
      cell.dataset.key = c.key;
      cell.addEventListener('click', ()=> chooseColor(c.key));
      colorGrid.appendChild(cell);
    }
  }

  async function chooseColor(colorKey){
    // 開始後は変更不可
    const gameSnap = await get(ref(db, `rooms/${state.code}/game/started`));
    const started = !!gameSnap.val();
    if (started) return;

    // 既に他人が保持していれば不可（トランザクション）
    const slotRef = ref(db, `rooms/${state.code}/colors/${colorKey}`);
    let ok = false;
    await runTransaction(slotRef, cur => {
      if (cur && cur.uid && cur.uid !== state.uid) return cur; // 埋まっている
      return { uid: state.uid, name: state.name, at: Date.now() };
    }).then(res => {
      ok = !!res.committed;
    });

    if (!ok) return;

    // 自分が他の色を持っていれば解放（単純検索）
    const allSnap = await get(ref(db, `rooms/${state.code}/colors`));
    const all = allSnap.val() || {};
    const entries = Object.entries(all);
    for (const [k, v] of entries){
      if (k !== colorKey && v?.uid === state.uid){
        await remove(ref(db, `rooms/${state.code}/colors/${k}`));
      }
    }

    // users/uid/color に反映
    await set(ref(db, `rooms/${state.code}/users/${state.uid}`), { color: colorKey, name: state.name, at: Date.now() });
  }

  function applyColorGridState(){
    // 取り込み
    const gridCells = colorGrid.querySelectorAll('.chip');
    gridCells.forEach(cell => {
      const key = cell.dataset.key;
      const taken = state.colors[key];
      const ownerEl = cell.querySelector('.owner');
      ownerEl.textContent = taken ? (taken.name || '?') : '';
      // 文字色（背景次第）
      ownerEl.style.color = seatTextColorFor(key);
      // 自分ではない所有者がいれば disabled
      const disabled = !!taken && taken.uid !== state.uid;
      cell.classList.toggle('disabled', disabled);
    });
  }

  // ===== ゲーム開始＆配布 =====
  const CARD_POOL = ['ああ','いい','ええ','かか','きき','すす','ちち','もも','ええ','じじ'];

  function shuffle(a){
    for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
    return a;
  }

  async function startGame(){
    // すでに開始済なら何もしない
    const gRef = ref(db, `rooms/${state.code}/game/started`);
    const gSnap = await get(gRef);
    if (gSnap.val()) return;

    // 参加者一覧を取得
    const pSnap = await get(ref(db, `rooms/${state.code}/participants`));
    const participants = pSnap.val() || {};
    const uids = Object.keys(participants);
    if (uids.length === 0) return;

    // カードプールをシャッフル
    const pool = shuffle([...CARD_POOL]);

    // 各参加者に1枚ずつ配布（人数>プールならループ）
    const handsRef = ref(db, `rooms/${state.code}/hands`);
    const now = Date.now();
    let i = 0;
    for (const uid of uids){
      const card = pool[i % pool.length];
      i++;
      await set(ref(handsRef, uid), { card, at: now });
    }

    // startedフラグを立て、色ロック
    await set(gRef, true);
    await set(ref(db, `rooms/${state.code}/game/colorLock`), true);
  }

  // ===== 設定UI =====
  gearEl.addEventListener('click', ()=>{
    settingsEl.classList.toggle('hidden');
  });
  btnStart.addEventListener('click', startGame);

  function updateGameUI(){
    gameStateText.textContent = state.game.started ? '開始済' : '未開始';
    btnStart.disabled = state.game.started || !state.isHost;
    colorLockNotice.textContent = state.game.started ? 'ゲーム開始：色はロックされています' : '';
  }

  // ===== 自分のカードUI =====
  mySmallCard.addEventListener('click', ()=>{
    if (!state.myHand) return;
    const modal = document.createElement('div');
    modal.className = 'card-modal';
    const cardFace = document.createElement('div');
    cardFace.className = 'card-face';
    cardFace.textContent = state.myHand.card || '';
    modal.appendChild(cardFace);
    modal.addEventListener('click', (e)=>{
      if (e.target === modal) modal.remove();
    });
    document.body.appendChild(modal);
  });

  // ===== 入室処理 =====
  async function join(){
    const name = normalizeName(nameInput.value);
    const code = (codeInput.value || "").trim() || random4();

    state.name = name;
    state.code = code;

    // 在室登録
    const meRef = ref(db, `rooms/${code}/participants/${state.uid}`);
    await set(meRef, { name, at: Date.now() });
    onDisconnect(meRef).remove();

    // ホスト就任（空いていれば）
    await becomeHostIfVacant();
    watchHost();

    updateHeader();
    show(joinPanel, false);
    show(roomPanel, true);

    // 図形構築
    drawFigure2();

    // 左長方形アイコンの同期
    const iconsRef = ref(db, `rooms/${code}/icons`);
    const offIcons = onValue(iconsRef, (snap)=>{
      const data = snap.val() || {};
      Object.entries(data).forEach(([uid, icon])=> renderOrUpdateIcon(uid, icon));
      const layer = document.getElementById('icons');
      if (layer){
        [...layer.querySelectorAll('g.usericon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          if (!(uid in data)) el.remove();
        });
      }
    });
    state.unsub.push(offIcons);

    // 席アイコンの同期＋自分の部屋/バッジ
    const seatsRef = ref(db, `rooms/${code}/seats`);
    const offSeats = onValue(seatsRef, (snap)=>{
      const data = snap.val() || {};
      Object.entries(data).forEach(([uid, seat])=> renderOrUpdateSeat(uid, seat));
      const layer = document.getElementById('seats');
      if (layer){
        [...layer.querySelectorAll('g.seaticon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          if (!(uid in data)) el.remove();
        });
      }
      const mine = data[state.uid];
      state.myRoomNumber = mine?.room ?? null;
      myRoomBadge.textContent = mine ? `部屋：${mine.room}` : '部屋：未選択';
      refreshDeckEnable();
    });
    state.unsub.push(offSeats);

    // users（色）を購読 → 席色に反映
    const usersRef = ref(db, `rooms/${code}/users`);
    const offUsers = onValue(usersRef, (snap)=>{
      state.users = snap.val() || {};
      // 座席の色更新には seats の再描画が必要（軽く全件再適用）
      const layer = document.getElementById('seats');
      if (layer){
        [...layer.querySelectorAll('g.seaticon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          const seatDataSnap = null; // 最小限、transformは維持し、色だけ塗り替える
          // 直塗り
          const rect = el.querySelector('rect');
          const text = el.querySelector('text');
          const colorKey = (state.users[uid]?.color) || null;
          const fillCss = colorKey ? (COLOR_MAP[colorKey]?.css || '#fff') : '#fff';
          if (rect) rect.setAttribute('fill', fillCss);
          if (text) text.setAttribute('fill', colorKey ? seatTextColorFor(colorKey) : '#111');
        });
      }
    });
    state.unsub.push(offUsers);

    // 色スロットの購読 → グリッド更新
    const colorsRef = ref(db, `rooms/${code}/colors`);
    const offColors = onValue(colorsRef, (snap)=>{
      state.colors = snap.val() || {};
      applyColorGridState();
    });
    state.unsub.push(offColors);

    // ゲーム状態の購読（開始フラグ）
    const gameRef = ref(db, `rooms/${code}/game`);
    const offGame = onValue(gameRef, (snap)=>{
      state.game = { started: false, ...(snap.val() || {}) };
      updateGameUI();
      // 開始後は色選択を閉じる
      show(colorOverlay, !state.game.started);
    });
    state.unsub.push(offGame);

    // 自分の手札の購読
    const myHandRef = ref(db, `rooms/${code}/hands/${state.uid}`);
    const offHand = onValue(myHandRef, (snap)=>{
      state.myHand = snap.val() || null;
      show(myCardDock, !!state.myHand);
    });
    state.unsub.push(offHand);

    // 山札UI
    setupDecks();

    // ダイス
    rollD6Btn.onclick = ()=>{ resD6.textContent = String(1 + Math.floor(Math.random()*6)); };
    rollD4Btn.onclick = ()=>{ resD4.textContent = String(1 + Math.floor(Math.random()*4)); };

    // 色選択ポップを表示（未開始時）
    buildColorGrid();
    show(colorOverlay, true);

    state.joined = true;
  }

  // 離脱時
  window.addEventListener('beforeunload', ()=>{
    if (state.joined) remove(ref(db, `rooms/${state.code}/participants/${state.uid}`));
  });

  btnJoin.onclick = join;

  // 事前入力
  try{
    const qs = new URLSearchParams(location.search);
    const qRoom = (qs.get('room')||'').trim();
    const qName = (qs.get('name')||'').trim();
    if (qRoom) codeInput.value = qRoom.slice(0, 12);
    if (qName) nameInput.value = qName.slice(0, 1);
  }catch(_e){}
</script>
</body>
</html>
