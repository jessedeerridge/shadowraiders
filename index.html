<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>„Ç∑„É£„Éâ„Ç¶„Éª„É¨„Ç§„ÉÄ„Éº„Ç∫</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:272; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .attack-roll-result-debug{font-weight:700;min-width:52px;text-align:left;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn.danger{background:#ef4444;color:#fff;border-color:#ef4444;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:hidden;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('back.jpg'); }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;
    z-index:271;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}

  /* ÂÖ¨ÈñãÁ¢∫Ë™ç„Éù„ÉÉ„Éó */
  .confirm-pop{
    position:fixed;
    left:0; top:0;
    transform:translate(-50%,-10px);
    background:#fff;
    border:1px solid rgba(0,0,0,.18);
    border-radius:12px;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    padding:10px 10px 10px;
    z-index:284;
    min-width:210px;
  }
  .confirm-pop.hidden{display:none;}
  .confirm-pop .msg{font-size:13px;line-height:1.45;margin:0 0 10px;}
  .confirm-pop .msg .ability-pill{display:inline-block;padding:1px 6px;border-radius:999px;background:#111;color:#fff;font-weight:700;}
  .ability-pill{display:inline-block;padding:1px 6px;border-radius:999px;background:#111;color:#fff;font-weight:700;}
  .confirm-pop .actions{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}
  .confirm-pop .caret{
    position:absolute;
    left:50%; top:-7px;
    width:12px; height:12px;
    background:#fff;
    border-left:1px solid rgba(0,0,0,.18);
    border-top:1px solid rgba(0,0,0,.18);
    transform:translateX(-50%) rotate(45deg);
  }
  .confirm-pop.bottom-fixed{
    left:50%;
    top:auto;
    bottom:16px;
    transform:translateX(-50%);
    min-width:280px;
    max-width:min(92vw, 420px);
  }
  .confirm-pop.bottom-fixed .caret{display:none;}
  .btn.pop-dark{background:#111;color:#fff;border-color:#111;}
  .btn.pop-disabled{background:#bcbcbc;color:#fff;border-color:#bcbcbc;cursor:not-allowed;}
  .btn.pop-purple{background:#6d28d9;color:#fff;border-color:#6d28d9;}
  .btn.pop-white{background:#fff;color:#111;border-color:#d1d5db;}

  .attack-result-pop-rows{display:flex;flex-direction:column;gap:8px;margin:0 0 10px;max-height:220px;overflow:auto;}
.attack-result-pop-row{display:flex;align-items:center;justify-content:center;gap:6px;font-size:14px;line-height:1.4;text-align:center;}
.attack-result-plus-two{font-size:12px;color:#d97878;}
.attack-result-pop-name{display:inline-flex;align-items:center;justify-content:flex-start;gap:6px;min-width:0;width:70px;max-width:70px;cursor:default;padding:4px 6px;}
.attack-result-pop-name-text{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:left;}
.attack-result-pop-row .chip16{flex:0 0 auto;}
.btn-excalibur{background:#c21d1d;color:#fff;border-color:#c21d1d;}
.btn-excalibur:hover{filter:brightness(1.05);}

  #attackResultPop{
    min-width:min(92vw, 250px);
    width:fit-content;
    max-width:min(92vw, 320px);
  }
  #attackResultPop .actions{justify-content:center;flex-wrap:nowrap;}

  .help-btn{
    position:fixed;left:16px;bottom:24px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:1000;cursor:pointer;
    z-index:274;
  }
  .help-btn.visible{display:flex;}

  .room-guide-btn{
    position:fixed;left:16px;bottom:74px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:20px;font-weight:1000;cursor:pointer;
    z-index:274;
  }
  .room-guide-btn.host-position{bottom:124px;}
  .room-guide-btn.visible{display:flex;}
 .room-guide-btn.active{background:#111;color:#fff;box-shadow:0 0 0 2px rgba(255,255,255,.35), 0 8px 20px rgba(0,0,0,.25);}
  .room-guide-btn img{width:22px;height:22px;display:block;object-fit:contain;pointer-events:none;}


  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:291;
    padding:16px 16px 64px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(560px, calc(100% - 0px));
    max-height:min(82vh, 780px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:1000;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(82vh - 48px);}

  .equip-expand-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:290;
    padding:16px 16px 64px;
  }
  .equip-expand-backdrop.hidden{display:none;}
  .equip-expand-pop{
    width:min(560px, calc(100% - 0px));
    max-height:min(82vh, 780px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  .equip-expand-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .equip-expand-title{font-weight:1000;font-size:14px;}
  .equip-expand-body{
    padding:12px;
    overflow:auto;
    max-height:calc(82vh - 48px);
    background-color:#ffffff;
    background-image:url('gear.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }

  .attack-loot-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.48);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:288;
    padding:16px;
  }
  .attack-loot-backdrop.hidden{display:none;}
  .attack-loot-pop{
    width:min(760px, calc(100% - 20px));
    max-height:min(86vh, 820px);
    background:#fff;
    border-radius:16px;
    border:1px solid rgba(0,0,0,.14);
    box-shadow:0 22px 44px rgba(0,0,0,.4);
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  .attack-loot-header{padding:10px 12px;border-bottom:1px solid #eee;font-weight:1000;font-size:14px;}
  .attack-loot-body{padding:12px;overflow:auto;display:flex;flex-direction:column;gap:10px;background:url('gear.jpg') center/cover no-repeat;}
  .attack-loot-row{display:flex;gap:8px;align-items:flex-start;}
  .attack-loot-cards{display:flex;gap:8px;flex-wrap:wrap;}
  .attack-loot-no-steal{border:2px solid #111 !important;color:#111 !important;background:#fff !important;display:flex;align-items:center;justify-content:center;font-weight:1000;flex:0 0 auto;}

  .help-section{padding:6px 0 10px;}
  .help-section + .help-section{border-top:1px solid rgba(0,0,0,.16);}
  .help-section-title{font-weight:900;font-size:13px;margin:0 0 8px;}
  .help-card-grid{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:8px;}
  .help-card-grid .card72,.help-card-grid .id72{margin:0 auto;}
  .help-role-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px;}
  .help-role-row:last-child{margin-bottom:0;}

  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;border-bottom:1px solid rgba(0,0,0,.06);
  }
  .role-row:last-child{border-bottom:none;}
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:1000;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}
  .role-desc .meta{font-size:12px;opacity:.8;margin-top:6px;white-space:pre-wrap;}

  .seat-pop-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:270;
    padding:16px;
  }
  .seat-pop-backdrop.hidden{display:none;}

  .seat-board{
    width:min(420px, calc(100% - 32px));
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.22);
    padding:12px 12px 14px;
    position:relative;
    margin:0;
  }
  .seat-board-title{
    font-weight:1000;
    font-size:13px;
    opacity:.9;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin:0 0 10px;
  }
  .seat-count-badge{
    font-size:12px;
    font-weight:900;
    background:#111;
    color:#fff;
    padding:4px 8px;
    border-radius:999px;
    white-space:nowrap;
  }
  .tile-grid{
    display:grid;
    grid-template-columns:repeat(4, 54px);
    grid-auto-rows:54px;
    gap:10px;
    justify-content:flex-start;
    padding:4px 0 2px;
  }
  .seat-tile{
    width:54px;height:54px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.12);
    box-shadow:0 6px 16px rgba(0,0,0,.16);
    cursor:pointer;
    position:relative;
    overflow:hidden;
    outline:none;
  }
  .seat-tile:focus{box-shadow:0 0 0 3px rgba(37,99,235,.25), 0 6px 16px rgba(0,0,0,.16);}
  .seat-tile.me::after{ display:none; }
  .seat-initial{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    font-weight:1000;
    font-size:16px;
    line-height:1;
    color:#111;
    pointer-events:none;
    user-select:none;
  }
  .seat-tile.empty{opacity:.95;}
  .seat-tile.taken{opacity:1;}
  .seat-tile .seat-num{
    position:absolute;right:6px;bottom:6px;
    font-size:11px;font-weight:1000;
    color:rgba(0,0,0,.55);
    background:rgba(255,255,255,.7);
    border:1px solid rgba(0,0,0,.08);
    padding:2px 6px;border-radius:999px;
    pointer-events:none;
  }

  .warn{
    font-size:12px;
    opacity:.75;
    text-align:center;
    margin-top:10px;
  }

  .seat-board-actions{
    display:flex;
    justify-content:flex-end;
    margin-top:10px;
    gap:8px;
    flex-wrap:wrap;
  }

  :root{
    --outer:#0b3b2e;
    --gold:#d6b35a;
    --brown:#5a4032;
    --team:#c21d1d;
    --black:#111;
    --paper:#f7f4ee;
    --effect:#ffd9a3;
    --inner-gap:-0.5px;
    --inner-w:1px;
    --inner-r:9px;
    --ini-stroke:0.3px;
    --ini-stroke-shadow:0.3px;
    --ini-y:-0.4px;

    /* =========================================================
       ‚òÖHP„Éú„Éº„ÉâÔºöÂêÑ„É´„Éº„É†Ôºàdamage 15‚Üí0Ôºâ„ÅÆÈ´ò„Åï„ÇíÂÄãÂà•Ë™øÊï¥
       ========================================================= */
    --hp-r15: 25px;
    --hp-r14: 29px;
    --hp-r13: 23px;
    --hp-r12: 21px;
    --hp-r11: 24px;
    --hp-r10: 23px;
    --hp-r9:  23px;
    --hp-r8:  21px;
    --hp-r7:  22px;
    --hp-r6:  22px;
    --hp-r5:  22px;
    --hp-r4:  23px;
    --hp-r3:  22px;
    --hp-r2:  22px;
    --hp-r1:  20px;
    --hp-r0:  28px;

    /* HP„Çª„É´„ÅÆÂ∑¶Âè≥‰ΩôÁôΩÔºàÈ´ò„Åï„ÇíÂ§â„Åà„Åü„Åè„Å™„ÅÑÂ†¥Âêà„ÅØÁ∏¶padding„Çí0Êé®Â•®Ôºâ */
    --hp-cell-pad-x: 6px;
    --hp-cell-pad-y: 0px;
  }

  .my-role-dock{
    position:fixed;
    right:16px;
    bottom:16px;
    z-index:260;
    display:none;
  }
  .my-role-dock.visible{ display:block; }

  /* =========================
     Ë£ÖÂÇôÊû†Ôºà‚òÖ„Ç´„Éº„Éâ„Éë„Éç„É´Áõ¥‰∏ã„Åæ„Åß‰∏ä„Å´‰º∏„Å∞„ÅôÔºâ
     ========================= */
  .equip-dock{
    position:fixed;
    left:16px;
    right:calc(2px + 72px + 12px);
    top:var(--equip-top, auto);
    bottom:16px;
    z-index:259;
    display:none;
    min-height:120px;
  }
  .equip-dock.visible{ display:block; }
  .equip-dock.david-select-front{ z-index:283; }
  .equip-dock.deduction-front{ z-index:286; }

  .equip-board{
    background-color:#ffffff;
    background-image:url('gear.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    border:1px solid rgba(0,0,0,.10);
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.18);
    padding:10px;
    height:100%;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    overflow:visible;
  }

  .equip-body{
    flex:1 1 auto;
    display:flex;
    flex-wrap:wrap;
    align-content:flex-start;
    align-items:flex-start;
    gap:6px;
    min-height:0;
    overflow-y:auto;
    overflow-x:visible;
    padding:8px 4px 8px 0;
    margin:-8px -4px -8px 0;
    -ms-overflow-style:none;
    scrollbar-width:none;
  }
  .equip-body::-webkit-scrollbar{
    width:0;
    height:0;
    display:none;
  }

  .equip-row{
    display:inline-flex;
    align-items:flex-start;
    gap:5px;
    padding:2px 0;
    overflow:visible;
  }

  .equip-tag{
    width:18px;height:18px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.35);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:12px;
    line-height:1;
    user-select:none;
    flex:0 0 auto;
  }
  .equip-cards{
    display:flex;
    flex-wrap:wrap;
    gap:5px;
    align-items:flex-start;
    justify-content:flex-start;
    overflow:visible;
    padding-bottom:2px;
    flex:0 1 auto;
  }

  .id72{
    width:72px;height:108px;
    background-color: var(--paper);
    background-image: none;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border:1.4px solid var(--outer);
    border-radius:10px;
    box-sizing:border-box;
    position:relative;
    overflow:hidden;
    cursor:pointer;
  }
  .id72::before{
    content:"";
    position:absolute;
    left:var(--inner-gap);right:var(--inner-gap);
    top:var(--inner-gap);bottom:var(--inner-gap);
    border:var(--inner-w) solid var(--gold);
    border-radius:var(--inner-r);
    pointer-events:none;
    z-index:1;
    opacity:1;
  }
  .id72 .initial{
    position:absolute;top:1px;left:1px;
    width:16px;height:16px;
    border:1px solid var(--black);
    border-radius:999px;
    display:grid;place-items:center;
    font-weight:900;font-size:13px;
    background:var(--team);
    line-height:1;z-index:5;
  }
  .id72 .initial span{
    display:inline-block;line-height:1;
    color:var(--black);
    transform: translateY(var(--ini-y));
    -webkit-text-stroke: var(--ini-stroke) var(--gold);
    text-stroke: var(--ini-stroke) var(--gold);
    text-shadow:
      0 0 0 var(--gold),
      0 var(--ini-stroke-shadow) 0 var(--gold),
      0 calc(var(--ini-stroke-shadow) * -1) 0 var(--gold),
      var(--ini-stroke-shadow) 0 0 var(--gold),
      calc(var(--ini-stroke-shadow) * -1) 0 0 var(--gold);
  }
  .id72 .team-arc{
    position:absolute;left:2px;top:18px;
    width:16px;height:10px;
    z-index:6;pointer-events:none;overflow:visible;
  }
  .id72 .team-arc text{
    font-weight:600;font-size:6px;letter-spacing:.40px;
    fill:var(--team);
  }
  .id72 .eng-sub{
    position:absolute;top:3px;left:15px;
    padding:1px 3px 1px 3px;
    background:var(--black);color:var(--gold);
    border:1px solid var(--gold);
    border-radius:0 6px 6px 0;
    font-weight:900;letter-spacing:.2px;
    font-size:10px;line-height:1;
    box-sizing:border-box;z-index:4;
  }
  .id72 .name{
    position:absolute;top:48px;left:2px;right:4px;
    text-align:left;padding:0px 4px;
    background:var(--black);color:var(--gold);
    border:1px solid var(--gold);
    border-radius:6px;
    font-weight:900;font-size:9px;
    letter-spacing:.3px;
    box-sizing:border-box;z-index:2;
  }
  .id72 .hp-badge{
    position:absolute;top:46px;right:1px;
    width:18px;height:18px;border-radius:999px;
    background:var(--brown);
    border:1px solid var(--gold);
    box-sizing:border-box;z-index:3;
    display:flex;flex-direction:column;
    align-items:center;justify-content:center;
    gap:0;padding-top:1px;
  }
  .id72 .hp-badge .label{
    font-size:5px;font-weight:900;line-height:0.5;
    color:var(--gold);letter-spacing:.2px;opacity:.98;
  }
  .id72 .hp-badge .val{
    font-size:12px;font-weight:1000;line-height:1;
    color:var(--gold);
    transform:translateY(-1px);
  }
  .id72 .effect{
    position:absolute;left:3px;right:3px;bottom:2px;top:64px;
    background:var(--effect);
    border-radius:4px;
    padding:1px 1px;
    box-sizing:border-box;
    font-size:5.5px;line-height:1.25;
    color:var(--black);
    overflow:hidden;z-index:2;
  }
  .id72 .tag{
    display:inline-block;
    background:var(--black);
    color:#fff;
    font-weight:900;
    padding:1px 2px;
    border-radius:3px;
    margin-right:1px;
    font-size:5.5px;
    letter-spacing:.2px;
    line-height:1;
    vertical-align:baseline;
  }
  .id72 .row{ margin:0 0 1px 0; }
  .id72 .row:last-child{ margin-bottom:0; }
  .role-card-wrap{ flex:0 0 auto; }

  .host-settings-btn{
    position:fixed;
    left:16px;
    bottom:74px;
    width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;
    z-index:274;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;
    left:16px;
    bottom:120px;
    background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:273;min-width:280px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:900;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}
  .start-badge{
    display:inline-flex;align-items:center;gap:6px;
    font-size:12px;font-weight:900;
    padding:4px 10px;border-radius:999px;
    border:1px solid rgba(0,0,0,.12);
    background:#f8f8f8;
  }

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    min-height:calc(100vh - 60px);
    padding-top:12px;
    gap:12px;
  }

  .game-area{
    width:min(980px, calc(100% - 24px));
    display:flex;
    flex-direction:column;
    gap:1px;
    align-items:center;
    justify-content:flex-start;
    padding-bottom:18px;  

  }
  .top-row{
    width:100%;
    display:flex;
    gap:14px;
    align-items:flex-start;
    justify-content:center;
    margin-top:-10px;
  }

  /* „Éë„Éç„É´ÂÖ±ÈÄö */
  .panel{
    background:rgba(255,255,255,.78);
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    box-shadow:0 12px 28px rgba(0,0,0,.10);
    padding:12px;
    box-sizing:border-box;
  }

  .left-panel{
    width:170px; 
    padding:0px;
    display:flex;
    align-items:stretch;
    justify-content:stretch;
    background:transparent !important;
    border:none !important;
    box-shadow:none !important;

    aspect-ratio: 2 / 4.5;
    height:auto;
    min-height:0;
  }

  /* =========================================================
     ‚òÖ‚ë†Â∑¶Âõ≥ÂΩ¢ÔºöÊû†/„Çª„É´Á∑ö/ËÉåÊôØ„ÇíÈÄèÊòéÔºàÁîªÂÉè„Å†„ÅëË°®Á§∫Ôºâ
     ========================================================= */
  .hp-board{
    width:100%;
    height:100%;
    min-height:0;

    border:none;                 /* Êû†„Å™„Åó */
    border-radius:12px;

    overflow:hidden;
    position:relative;
    display:grid;

    grid-template-rows:
      var(--hp-r15) var(--hp-r14) var(--hp-r13) var(--hp-r12)
      var(--hp-r11) var(--hp-r10) var(--hp-r9)  var(--hp-r8)
      var(--hp-r7)  var(--hp-r6)  var(--hp-r5)  var(--hp-r4)
      var(--hp-r3)  var(--hp-r2)  var(--hp-r1)  var(--hp-r0);

    background-image:url('hp.png'); /* ÁîªÂÉè„Å†„Åë */
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    transform:none;
  }
  .hp-cell{
    position:relative;
    min-height:0;
    overflow:hidden;

    display:flex;
    align-items:center;
    justify-content:flex-start;
    flex-wrap:nowrap;
    gap:6px;

    padding:var(--hp-cell-pad-y) var(--hp-cell-pad-x);
    box-sizing:border-box;

    background:transparent; /* „Çª„É´ËÉåÊôØ„ÇÇÈÄèÊòé */
  }
  .hp-cell::after{ display:none; } /* „Çª„É´Á∑ö„ÇíÊ∂à„Åô */

.chip16{
    width:18px;height:18px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.42);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:11px;
    line-height:1;
    user-select:none;
    box-shadow:0 4px 10px rgba(0,0,0,.16);
    flex:0 0 auto;
  }

  .right-panel{
    width:min(520px, 52vw);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
  }
/* Ëá™ÂàÜ„ÅÆ„Éû„Éº„Ç´„Éº„Å†„Åë„ÄÅ‰∏∏„ÅÑÁÇπÁ∑ö„É™„É≥„Ç∞ */
  .mark-me-ring{
  fill: transparent;
  stroke: rgba(17,17,17,.95);
  stroke-width: 2;
  stroke-dasharray: 3.5 3.5;
  stroke-linecap: round;
  vector-effect: non-scaling-stroke;
  cursor:pointer;
  pointer-events:all;
}

#markerLayer.swap-animating{
  opacity:0;
}

.chip16.turn-pulse{
  animation:markerPulse 1.2s ease-in-out infinite;
}


.dice-roll-overlay{
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:287;
}
.agatha-reveal-overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
  z-index:286;
}
.agatha-reveal-overlay.hidden{ display:none; }
.agatha-reveal-overlay .id72{
  transform:scale(2.1);
  transform-origin:center center;
  box-shadow:0 18px 50px rgba(0,0,0,.45);
  animation:none !important;
  transition:none !important;
}
.dice-flyer{
  position:absolute;
  left:0;
  top:0;
  transform:translate(-9999px,-9999px);
  will-change:transform;
}
.dice-flyer.rolling{
  transition:transform .95s cubic-bezier(.08,.62,.18,1);
}

.dice-flyer,
.dice-flyer *{
  box-sizing:border-box;
}

.dice-flyer{
  --die: 48px;
  --pip: 8px;
  --pad: 6px;
  --d4-2-gap: 13%;
}

.attack-result-pin{
  position:absolute;
  left:0;
  top:0;
  pointer-events:none;
}

.die{
  width:var(--die); height:var(--die);
  background:#e53935;
  border:1px solid #b71c1c;
  border-radius:5px;
  position:relative;
}
.pip{
  width:var(--pip); height:var(--pip);
  background:#fff; border-radius:50%;
  position:absolute;
}
.tl{left:var(--pad); top:var(--pad);}
.tr{right:var(--pad); top:var(--pad);}
.ml{left:var(--pad); top:50%; transform:translateY(-50%);}
.mc{left:50%; top:50%; transform:translate(-50%,-50%);}
.mr{right:var(--pad); top:50%; transform:translateY(-50%);}
.bl{left:var(--pad); bottom:var(--pad);}
.br{right:var(--pad); bottom:var(--pad);}

.d4{
  width:var(--die);
  height:calc(var(--die) * 0.8660254038);
  position:relative;
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
  background:#1e88e5;
  border:none;
  --vTopX: 50%;  --vTopY: 0%;
  --vLftX: 0%;   --vLftY: 100%;
  --vRgtX: 100%; --vRgtY: 100%;
  --cx: 50%;
  --cy: calc(100% * 2 / 3);
  --k: 0.45;
}
.d4-num{
  position:absolute;
  left:50%;
  top:60%;
  transform:translate(-50%,-50%);
  color:#fff;
  font-size:18px;
  font-weight:1000;
  line-height:1;
}

  /* =========================================================
     ‚òÖ‚ë°Âè≥Âõ≥ÂΩ¢ÔºöÂõ≥ÂΩ¢Â§ñ„ÅÆËÉåÊôØ„ÇíÈÄèÊòéÔºà„Éë„Éç„É´„ÅÆÁôΩËÉåÊôØ/Êû†/ÂΩ±„ÇíÊ∂à„ÅôÔºâ
     ========================================================= */
  .map-panel{
    width:110%;
    height:min(62vh, 340px);
    display:flex;
    justify-content:center;
    align-items:center;
    padding:0;
    overflow:hidden;

    background:transparent !important;
    border:none !important;
    box-shadow:none !important;
  }

  .position-line{
    position:absolute;
    right:12px;
    bottom:calc(100% + 6px);
    min-height:16px;
    display:flex;
    flex-wrap:wrap;
    align-items:flex-start;
    justify-content:flex-end;
    gap:4px;
    max-width:min(280px, calc(100vw - 28px));
    z-index:3;
  }
  .position-item{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
    position:relative;
  }
  .position-chip-wrap{
    position:relative;
    display:flex;
    justify-content:center;
    align-items:center;
  }
  .position-bubble{
    position:absolute;
    bottom:calc(100% + 10px);
    left:50%;
    transform:translateX(-50%);
    max-width:120px;
    padding:4px 8px;
    border-radius:8px;
    background:#111;
    border:1px solid #fff;
    color:#fff;
    font-size:10px;
    font-weight:900;
    white-space:nowrap;
    overflow:visible;
    text-overflow:clip;
    line-height:1.2;
    pointer-events:none;
    z-index:2;
  }
  .position-bubble::after{
    content:"";
    position:absolute;
    left:50%;
    top:100%;
    transform:translateX(-50%);
    border:7px solid transparent;
    border-top-color:#111;
  }
  .position-bubble::before{
    content:"";
    position:absolute;
    left:50%;
    top:100%;
    transform:translateX(-50%);
    border:8px solid transparent;
    border-top-color:#fff;
    z-index:-1;
  }
  .starter-mark{
    min-height:10px;
    font-size:10px;
    font-weight:900;
    line-height:1;
    color:#111;
  }
  .position-line.hidden{ display:none; }
  .turn-end-wrap{
    position:fixed;
    right:24px;
    bottom:135px;
    z-index:261;
    display:flex;
    justify-content:center;
  }
  .turn-end-wrap.hidden{display:none;}
  #btnEndTurn{
    width:60px;
    height:60px;
    border-radius:50%;
    padding:0 6px;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    line-height:1.15;
    font-size:8px;
    font-weight:1000;
    border:none;
    background:url('endgear.png') center/cover no-repeat;
    color:#fff;
    text-shadow:0 1px 2px rgba(0,0,0,.65);
    box-shadow:0 8px 18px rgba(0,0,0,.24);
  }

  .endturn-confirm{
    position:fixed;
    left:50%;
    bottom:16px;
    transform:translateX(-50%);
    background:#fff;
    border:1px solid rgba(0,0,0,.18);
    border-radius:12px;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    padding:10px;
    z-index:285;
    min-width:240px;
  }
  .endturn-confirm.hidden{display:none;}
  .endturn-confirm .msg{font-size:13px;line-height:1.45;margin:0 0 10px;}
  .endturn-confirm .actions{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}
  .position-arrow{
    font-size:12px;
    font-weight:900;
    line-height:1;
    color:#111;
    user-select:none;
    margin-top:2px;
  }

  :root{
    --card-w:72px;
    --card-h:108px;
    --card-gap:6px;

    --wb-black:#111;
    --wb-gold:#caa44a;
    --wb-gold2:#f3dc8a;
    --wb-gray:#e5e5e5;

    --green-dark:#0b3b2e;
    --green-soft:#e9fff4;
  }

  /* =========================================================
     ‚òÖ‚ë¢„Ç´„Éº„Éâ„ÉÜ„Éº„Éñ„É´ÔºöËÉåÊôØ„Çígear.jpg„Å´
     ========================================================= */
  .cards-panel{
    width:calc(100% + 50px);
    max-width:calc(100% + 50px);
    margin-left:-30px;    
    margin-right:-30px;    
    display:flex;
    justify-content:center;
    align-items:flex-start;
    padding:6px 5px 6px 5px;
    overflow-x:auto;
    overflow-y:hidden;
    -webkit-overflow-scrolling:touch;

    background-color:#ffffff;
    background-image:url('gear.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    border:1px solid rgba(0,0,0,.08);
    box-shadow:0 12px 28px rgba(0,0,0,.10);
    border-radius:16px;
  }

  .cards-zone{
    width:100%;
    position:relative;
    display:flex;
    justify-content:center;
    margin-top:3px;
  }

  .empty-cards-row{
    display:flex;
    gap:var(--card-gap);
    justify-content:flex-start;
    align-items:flex-start;
    flex-wrap:nowrap;
    width:max-content;
    padding:0;
  }

  .room-svg{width:100%;height:100%;display:block;}
  .shape{stroke:#111;stroke-width:1;vector-effect:non-scaling-stroke;}
  .attack-range-layer{pointer-events:none;}
  .attack-range-edge-outline{stroke:var(--brown);stroke-width:1.6;stroke-linecap:round;vector-effect:non-scaling-stroke;}
  .attack-range-edge{stroke:var(--gold);stroke-width:2.5;stroke-linecap:round;vector-effect:non-scaling-stroke;}
  .roomhit{fill:transparent;cursor:pointer;}
  .roomhit:hover{fill:rgba(0,0,0,.06);}
  .room-choice-pulse{
    transform-box:fill-box;
    transform-origin:center;
    animation:roomChoicePulse 1.2s ease-in-out infinite;
  }
  .room-choice-once{
    transform-box:fill-box;
    transform-origin:center;
    animation:roomChoicePulse 1.2s ease-in-out infinite;
  }
  .shape.room-choice-pulse,
  .shape.room-choice-once{
    stroke:#a855f7;
    stroke-width:2;
  }
  @keyframes roomChoicePulse{
    0%,100%{ transform:scale(1); }
    50%{ transform:scale(1.05); }
  }

  .room-guide-layer{pointer-events:none;}
  .room-guide-note{
    fill:rgba(229,229,229,.84);
    stroke:rgba(0,0,0,.22);
    stroke-width:0.6;
    vector-effect:non-scaling-stroke;
  }
  .room-guide-note-text{
    fill:#111;
    font-size:8px;
    font-weight:800;
    text-anchor:middle;
    user-select:none;
  }

.mark-rect{stroke:#111;stroke-width:1;vector-effect:non-scaling-stroke;}
.mark-rect.guardian-shield{stroke:#d4af37;stroke-width:2;}
.mark-text{font-weight:1000;font-size:10px;dominant-baseline:middle;text-anchor:middle;user-select:none;pointer-events:none;}
.mark-pulse-target{
  transform-box:fill-box;
  transform-origin:center;
  animation:markerPulse 1.2s ease-in-out infinite;
}
.equip-steal-pulse{
  animation:equipStealPulse 1.1s ease-in-out infinite;
  cursor:pointer;
}
.equip-defeat-pulse{
  animation:equipDefeatPulse .9s ease-in-out infinite;
  cursor:pointer;
}
@keyframes equipStealPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.06); }
}
@keyframes equipDefeatPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.14); }
}
@keyframes markerPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.2); }
}
.turn-hint-pop{
  position:fixed;
  top:55px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:nowrap;
  background:#111;
  color:#fff;
  border-radius:10px;
  padding:8px 12px;
  font-size:12px;
  font-weight:800;
  white-space:nowrap;
  z-index:286;
  box-shadow:0 8px 18px rgba(0,0,0,.28);
}
.turn-hint-pop.hidden{ display:none; }
.turn-hint-action{
  display:inline-block;
  margin:0;
  width:max-content;
  white-space:nowrap;
  font-size:13px;
  color:#fff !important;
  border-color:rgba(255,255,255,.78) !important;
  background:rgba(255,255,255,.08);
}
#roomActionPop{
  z-index:293;
}
#roomActionPop.lower-mode{
  left:50% !important;
  top:auto !important;
  bottom:160px;
  transform:translateX(-50%);
}
#roomActionPop.lower-mode .caret{ display:none; }
#roomActionPop.no-caret .caret{ display:none; }
#roomActionPop.room3-mode .actions{
  flex-wrap:nowrap;
  justify-content:center;
}
#roomActionPop.room3-mode .actions .btn{
  white-space:nowrap;
}

  .card72{
    width:var(--card-w);
    height:var(--card-h);
    border-radius:10px;
    box-sizing:border-box;
    background:rgba(255,255,255,.92);
    border:1.4px solid rgba(17,17,17,.55);
    position:relative;
    overflow:hidden;
    flex:0 0 auto;
    user-select:none;
  }
  .card72.deck{
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    cursor:pointer;
  }

  /* Êó¢Â≠ò„ÅÆ„ÄåËñÑ„Åè„Åô„Çã„Äç„É≠„ÉÉ„ÇØ */
  .card72.locked{
    opacity:.35;
    filter:grayscale(.55);
    cursor:default !important;
    pointer-events:none;
  }

  /* ‚òÖËøΩÂä†ÔºöËñÑ„Åè„Åó„Å™„ÅÑ„Åå„ÇØ„É™„ÉÉ„ÇØ‰∏çÂèØÔºàÁôΩË°® / Èªí„Ç™„É¢„ÉÜÁî®Ôºâ */
  .card72.blocked{
    opacity:1;
    filter:none;
    cursor:default !important;
    pointer-events:none;
  }

  .count-tag{
    position:absolute;
    top:4px;
    right:4px;
    background:rgba(235,235,235,.95);
    color:#111;
    font-weight:1000;
    font-size:12px;
    line-height:1;
    padding:4px 7px;
    border-radius:999px;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 6px 16px rgba(0,0,0,.12);
    z-index:5;
    pointer-events:none;
  }

  .card72.wb-front{
    border:1px solid var(--wb-black);
    border-radius:10px;
    background:#fff;
    cursor:pointer;
  }
  .card72.wb-front.wb-white{ background:#fff; }
  .card72.wb-front.wb-black{ background:#000; }
  .card72.wb-front.wb-green{ background:#74745a; border-color:#0b3b2e; }

  .card72.wb-front .wb-name{
    position:absolute;
    left:2px; right:2px; top:2px;
    height:18px;
    border:2px solid var(--wb-gold);
    border-radius:8px;
    background:#000;
    display:flex;align-items:center;justify-content:center;
    box-sizing:border-box;
    padding:0 4px;
    z-index:3;
  }
  .card72.wb-front.wb-green .wb-name{
    background:var(--green-dark);
    border-color:#d6b35a;
  }
  .card72.wb-front .wb-name span{
    display:block;
    font-size:8px;
    line-height:1;
    font-weight:900;
    letter-spacing:.04em;
    color:var(--wb-gold);
    text-shadow:0 1px 0 rgba(255,255,255,.08);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:clip;
    width:100%;
    text-align:center;
    transform-origin:center center;
  }
  .card72.wb-front .wb-circle{
    position:absolute;
    top:14px;
    left:50%;
    transform:translateX(-50%);
    width:60px;height:60px;
    border-radius:50%;
    border:transparent;
    background: radial-gradient(circle at 30% 30%, rgba(243,220,138,.45), rgba(0,0,0,0) 55%);
    box-sizing:border-box;
    overflow:hidden;
    z-index:1;
  }
  .card72.wb-front.wb-green .wb-circle{
    background: radial-gradient(circle at 30% 30%, rgba(34,197,94,.25), rgba(0,0,0,0) 60%);
  }
  .card72.wb-front .wb-circle img{
    width:100%;
    height:100%;
    display:block;
    object-fit:cover;
  }
  .card72.wb-front .wb-effect{
    position:absolute;
    left:2px; right:2px; bottom:2px;
    top:69px;
    background:var(--wb-gray);
    border-radius:6px;
    padding:2px;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    gap:4px;
    overflow:hidden;
    z-index:2;
  }
  .card72.wb-front.wb-green .wb-effect{
    background:rgba(238,223,200,.92);
    border:1px solid rgba(11,59,46,.28);
  }
  .card72.wb-front .wb-desc{
    position:relative;
    z-index:6;
    font-size:6px;
    line-height:1.25;
    font-weight:700;
    color:#111;
    overflow:hidden;
    white-space:pre-wrap;
  }
  .card72.wb-front.wb-black .wb-desc{ color:#111; }
  .card72.wb-front .wb-desc .inline-tag{
    display:inline-block;
    background:#000;
    color:#fff;
    font-weight:900;
    font-size:6px;
    line-height:1;
    padding:2px 4px;
    border-radius:4px;
    margin-right:2px;
    vertical-align:baseline;
  }

  /* ‚òÖËøΩÂä†Ôºö0ÊûöÔºàÁ©∫Ôºâ„ÅÆ„Å®„Åç„ÅØÊû†„Å™„Åó */
  .card72.noframe{
    background:transparent;
    border:none !important;
  }

  /* ‚òÖ‚ë£ Ê≠£‰Ωì„Ç´„Éº„ÉâÔºàÂè≥‰∏ãÔºâÔºöË£èÈù¢Ë°®Á§∫Áî® */
  .role-back{
    width:72px;height:108px;
    border-radius:10px;
    border:1.4px solid rgba(17,17,17,.55);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    cursor:pointer;
    box-shadow:0 10px 26px rgba(0,0,0,.18);
  }

  .zoom-backdrop{
    position:fixed;
    inset:0;
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:280;
    padding:18px;
  }
  .zoom-backdrop.hidden{ display:none; }
  .zoom-backdrop.over-panel{ z-index:292; }
  .zoom-backdrop.passthrough{
    pointer-events:none;
    background:transparent;
  }
  .zoom-backdrop.passthrough .zoom-stage{
    pointer-events:none;
  }
  .zoom-stage{
    position:relative;
    width:72px;
    height:108px;
    transform:scale(var(--zoom, 4));
    transform-origin:center;
    will-change:transform;
    transition:transform .35s ease;
  }
  .zoom-stage.zoom-stage-multi{
    width:min(98vw, 1400px);
    height:auto;
    transform:none;
    transition:none;
  }
  .zoom-backdrop.green-reveal-active .zoom-stage{
    transform:translateX(-90px) scale(var(--zoom, 4));
  }
  .zoom-backdrop.david-select-active .zoom-stage{
    transform:translateX(-90px) scale(var(--zoom, 4));
  }
  .zoom-stage .card72,
  .zoom-stage .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
  }
  .zoom-stage .equip-steal-pulse{
    animation:none;
  }
  .zoom-stage .equip-defeat-pulse{
    animation:none;
  }
  .zoom-identity-owner{
    position:absolute;
    left:50%;
    top:-22px;
    transform:translateX(-50%);
    display:flex;
    align-items:center;
    gap:4px;
    background:#fff;
    border:1px solid rgba(0,0,0,.15);
    border-radius:999px;
    padding:3px 6px;
    font-size:8px;
    font-weight:700;
    color:#111;
    white-space:nowrap;
    line-height:1;
  }
  .zoom-identity-owner .chip16{
    width:9px;
    height:9px;
    min-width:9px;
    min-height:9px;
    font-size:8px;
    border-width:1px;
    border-radius:3px;
    box-shadow:none;
  }
  .zoom-identity-multi{
    display:flex;
    align-items:flex-start;
    justify-content:center;
    gap:18px;
    flex-wrap:nowrap;
    max-width:min(98vw, 1500px);
    overflow-x:auto;
    padding:14px 16px 14px;
  }
  .zoom-identity-multi-item{
    position:relative;
    flex:0 0 auto;
    width:144px;
    height:286px;
  }
  .zoom-identity-multi-item-inner{
    position:relative;
    width:72px;
    height:108px;
    margin-top:44px;
    transform:scale(2);
    transform-origin:top left;
  }
  .eliminated-dim{
    opacity:.7;
  }
  .marker-eliminated{
    opacity:.45;
  }
  .chip16.eliminated-clickable{
    opacity:.45;
    cursor:pointer;
  }
  .green-share-dock{
    position:fixed;
    left:50%;
    top:500px;
    transform:translateX(-50%);
    z-index:289;
    width:min(380px, calc(100vw - 40px));
    background:rgba(255,255,255,.96);
    border:1px solid rgba(0,0,0,.12);
    border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.26);
    padding:10px;
  }
  .green-share-dock.hidden{ display:none; }
  .green-share-dock.over-equip-expand{ z-index:294; }
  .green-share-title{
    font-size:13px;
    font-weight:900;
    margin:0 0 8px;
  }
  .green-share-subtitle{
    font-size:12px;
    margin:0 0 8px;
    color:#333;
    line-height:1.4;
  }
  .green-share-list{
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:8px;
  }
  .green-share-actions{
    display:flex;
    justify-content:flex-end;
    margin-top:-30px;
  }
  .green-share-actions.hidden{ display:none; }
  .green-share-btn{
    border:1px solid rgba(0,0,0,.15);
    border-radius:999px;
    background:#fff;
    width:100%;
    padding:4px 8px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    font-weight:700;
  }
  .green-share-btn.answer{
    justify-content:center;
    border-radius:8px;
    border-color:#111;
    background:#111;
    color:#fff;
  }
  .green-share-btn.answer:disabled{
    opacity:1;
    background:#b8b8b8;
    border-color:#b8b8b8;
    color:#fff;
  }
  .green-share-btn:disabled{
    opacity:.45;
    cursor:default;
  }
  .green-share-btn.waiting-selected{
    opacity:1;
  }

  .green-reveal-panel{
    position:fixed;
    left:50%;
    top:50%;
    width:72px;
    height:108px;
    transform:translate(-50%,-50%) translateX(60px);
    z-index:281;
    pointer-events:none;
    opacity:0;
    transition:transform .35s ease, opacity .35s ease;
  }
  .zoom-backdrop.green-reveal-active .green-reveal-panel{
    transform:translate(-50%,-50%) translateX(95px);
    opacity:1;
  }
  .green-reveal-panel.hidden{ display:none; }
  .green-reveal-panel.reveal-slide-in .green-reveal-card-wrap .id72{
    animation:greenRevealSlideIn .42s cubic-bezier(.16,.84,.28,1);
  }
  @keyframes greenRevealSlideIn{
    from{ transform:translateX(220px) scale(2); opacity:0; }
    to{ transform:translateX(0) scale(2); opacity:1; }
  }
  .green-reveal-label{
    position:absolute;
    left:50%;
    top:calc(100% + 8px);
    transform:translateX(-50%);
    font-size:12px;
    font-weight:900;
    color:#fff;
    text-shadow:0 2px 8px rgba(0,0,0,.55);
    white-space:nowrap;
  }
  .green-reveal-card-wrap{
    position:absolute;
    inset:0;
  }
  .green-reveal-card-wrap .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    transform:scale(2);
    transform-origin:center;
  }

  .david-select-preview{
    position:fixed;
    left:50%;
    top:50%;
    width:72px;
    height:108px;
    transform:translate(-50%,-50%) translateX(95px);
    z-index:282;
    pointer-events:none;
    opacity:0;
    transition:transform .2s ease, opacity .2s ease;
  }
  .zoom-backdrop.david-select-active .david-select-preview{
    opacity:1;
  }
  .david-select-preview.hidden{ display:none; }
  .david-select-preview .card72,
  .david-select-preview .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    transform:scale(2);
    transform-origin:center;
  }
</style>
</head>
<body>

<header>
  <h1>„Ç∑„É£„Éâ„Ç¶„Éª„É¨„Ç§„ÉÄ„Éº„Ç∫</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <div class="small" id="lastAttackToMeHeader" aria-live="polite"></div>
    <div class="small attack-roll-result-debug" id="attackRollResult" aria-live="polite"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="ÂêçÂâçÔºà4ÊñáÂ≠ó‰ª•ÂÜÖÔºâ" maxlength="4" />
    <input id="roomCode" placeholder="„É´„Éº„É†„Ç≥„Éº„ÉâÔºàÊú™ÂÖ•Âäõ„ÅßËá™ÂãïÁîüÊàêÔºâ" maxlength="12" />
    <button class="btn primary" id="btnJoin">ÂÖ•ÂÆ§</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>„É≠„Éì„Éº</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>„Åì„Åì„Å´„ÉÜ„Éº„Éñ„É´„ÇÑÊÉÖÂ†±„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>

    <div id="gameArea" class="game-area hidden" aria-label="„Ç≤„Éº„É†Èù¢">
      <div class="top-row">
        <div class="panel left-panel">
          <div id="hpBoard" class="hp-board" aria-label="HP„Éú„Éº„Éâ"></div>
        </div>

        <div class="right-panel">
          <div class="panel map-panel">
            <svg id="roomSvg" class="room-svg" viewBox="-170 -170 340 340" preserveAspectRatio="xMidYMid meet" aria-label="ÈÉ®Â±ã„Éû„ÉÉ„Éó">
              <g id="roomG"></g>
            </svg>
          </div>
          <div id="turnEndWrap" class="turn-end-wrap hidden">
            <button id="btnEndTurn" class="btn primary">ÊâãÁï™„ÇíÁµÇ„Çè„Çã</button>
          </div>
        </div>
      </div>

      <div class="cards-zone">
        <div id="positionLine" class="position-line hidden" aria-label="‰ΩçÁΩÆÂàó"></div>
        <div class="panel cards-panel" id="cardsPanel" aria-label="„Éá„ÉÉ„Ç≠">
          <div class="empty-cards-row">
            <div id="slot1" class="card72"></div>
            <div id="slot2" class="card72"></div>
            <div id="slot3" class="card72"></div>
            <div id="slot4" class="card72"></div>
            <div id="slot5" class="card72"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</main>

<!-- Êã°Â§ßË°®Á§∫ -->
<div id="zoomBackdrop" class="zoom-backdrop hidden" aria-label="Êã°Â§ßË°®Á§∫">
  <div id="zoomStage" class="zoom-stage" style="--zoom:2"></div>
  <div id="greenRevealPanel" class="green-reveal-panel hidden" aria-live="polite">
    <div id="greenRevealLabel" class="green-reveal-label"></div>
    <div id="greenRevealCardWrap" class="green-reveal-card-wrap"></div>
  </div>
  <div id="davidSelectPreview" class="david-select-preview hidden" aria-hidden="true"></div>
  <div id="greenShareDock" class="green-share-dock hidden" aria-label="Á∑ë„Ç´„Éº„ÉâÂÖ±Êúâ">
    <p class="green-share-title">Ë™∞„Å´Ê∏°„Åó„Åæ„Åô„Åã„ÄÇ</p>
    <p id="greenShareSubtitle" class="green-share-subtitle hidden"></p>
    <div id="greenShareList" class="green-share-list"></div>
    <div id="greenShareActions" class="green-share-actions hidden">
      <button id="greenShareCloseBtn" class="btn ghost" type="button">Èñâ„Åò„Çã</button>
    </div>
  </div>
</div>

<!-- ÂÖ¨ÈñãÁ¢∫Ë™ç„Éù„ÉÉ„Éó -->
<div id="revealPop" class="confirm-pop hidden" role="dialog" aria-label="ÂÖ¨ÈñãÁ¢∫Ë™ç">
  <p class="msg" id="revealMsg">ÂÖ¨Èñã„Åó„Åæ„Åô„ÅãÔºü</p>
  <div class="actions">
    <button class="btn primary" id="btnRevealYes">„ÅØ„ÅÑ</button>
    <button class="btn ghost" id="btnRevealNo">„ÅÑ„ÅÑ„Åà</button>
  </div>
</div>

<div id="attackPop" class="confirm-pop hidden" role="dialog" aria-label="ÊîªÊíÉÁ¢∫Ë™ç">
  <div class="caret" aria-hidden="true"></div>
  <p class="msg" id="attackMsg">ÊîªÊíÉ„Åó„Åæ„Åô„Åã„ÄÇ</p>
  <div class="actions">
    <button class="btn primary" id="btnAttackYes">„ÅØ„ÅÑ</button>
    <button class="btn ghost" id="btnAttackNo">„ÅÑ„ÅÑ„Åà</button>
  </div>
</div>

<div id="attackResultPop" class="confirm-pop bottom-fixed hidden" role="dialog" aria-label="ÊîªÊíÉÁµêÊûúÁ¢∫Ë™ç">
  <div id="attackResultRows" class="attack-result-pop-rows"></div>
  <div class="actions">
    <button class="btn btn-excalibur hidden" id="btnAttackResultExcalibur">üó°Ô∏è</button>
    <button class="btn primary" id="btnAttackResultEnd">OK„Åä„Çè„Çã</button>
    <button class="btn ghost" id="btnAttackResultKeep">OK„Åä„Çè„Çâ„Å™„ÅÑ</button>
  </div>
</div>

<div id="identityPromptPop" class="confirm-pop bottom-fixed hidden" role="dialog" aria-label="Èô£Âñ∂ÂÖ¨ÈñãÁ¢∫Ë™ç">
  <p class="msg" id="identityPromptMsg"></p>
  <div class="actions">
    <button class="btn" id="btnIdentityPromptYes">„ÅØ„ÅÑ</button>
    <button class="btn" id="btnIdentityPromptNo">„ÅÑ„ÅÑ„Åà</button>
  </div>
</div>

<div id="roomActionPop" class="confirm-pop hidden" role="dialog" aria-label="ÈÉ®Â±ãÂäπÊûúÁ¢∫Ë™ç">
  <div class="caret" aria-hidden="true"></div>
  <p class="msg" id="roomActionMsg"></p>
  <div class="actions">
    <button class="btn primary" id="btnRoomActionYes">„ÅØ„ÅÑ</button>
    <button class="btn ghost" id="btnRoomActionNo">„ÅÑ„ÅÑ„Åà</button>
  </div>
</div>

<div id="turnHintPop" class="turn-hint-pop hidden" aria-live="polite"></div>

<div id="endTurnConfirm" class="endturn-confirm hidden" role="dialog" aria-label="ÊâãÁï™ÁµÇ‰∫ÜÁ¢∫Ë™ç">
  <p class="msg" id="endTurnConfirmMsg">Êú¨ÂΩì„Å´ÁµÇ‰∫Ü„Åó„Åæ„Åô„Åã„ÄÇ</p>
  <div class="actions">
    <button class="btn primary" id="btnEndTurnYes">„ÅØ„ÅÑ</button>
    <button class="btn ghost" id="btnEndTurnNo">„ÅÑ„ÅÑ„Åà</button>
  </div>
</div>


<div id="seatPopBackdrop" class="seat-pop-backdrop hidden" aria-label="Â∫ßÂ∏≠„Ç´„É©„Éº„Çø„Ç§„É´">
  <div class="seat-board" id="seatBoard">
    <div class="seat-board-title">
      <span>„Éó„É¨„Ç§„É§„Éº„Ç´„É©„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</span>
      <span class="seat-count-badge" id="seatCountBadge">0 / 12</span>
    </div>
    <div id="tileGrid" class="tile-grid"></div>
    <div class="warn" id="startWarn">‚Äª„Éõ„Çπ„Éà„Åå„Äå„Çπ„Çø„Éº„Éà„Äç„ÇíÊäº„Åô„Å®ÈÖçÂ∏É„Åï„Çå„Åæ„Åô</div>

    <div class="seat-board-actions">
      <button id="btnSpectate" class="btn ghost">Ë¶≥Êà¶</button>
    </div>
  </div>
</div>

<!-- Ë£ÖÂÇôÊû† -->
<div id="equipDock" class="equip-dock" aria-label="Ë£ÖÂÇôÊû†">
  <div class="equip-board">
    <div class="equip-body" id="equipBody"></div>
  </div>
</div>

<div id="myRoleDock" class="my-role-dock" aria-label="Ëá™ÂàÜ„ÅÆÊ≠£‰Ωì„Ç´„Éº„Éâ">
  <div id="myRoleCard"></div>
</div>

<div id="agathaRevealOverlay" class="agatha-reveal-overlay hidden" aria-hidden="true"></div>
<div id="diceRollOverlay" class="dice-roll-overlay" aria-hidden="true"></div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">Êó¢Â≠ò„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÇíËøΩ„ÅÑÂá∫„Åó„Å¶„ÄÅÁùÄÂ∏≠„Åó„Åæ„Åô„ÅãÔºü</p>
    <div class="dialog-buttons">
      <button class="btn danger" id="btnKickYes">„ÅØ„ÅÑ</button>
      <button class="btn ghost" id="btnKickNo">„Ç≠„É£„É≥„Çª„É´</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="Ë®≠ÂÆö">‚öô</button>
<button id="roomGuideBtn" class="room-guide-btn" title="„É´„Éº„É†ÂäπÊûú" aria-label="„É´„Éº„É†ÂäπÊûú"><img src="map.png" alt="map"></button>
<button id="helpBtn" class="help-btn" title="„Ç´„Éº„Éâ„É™„Çπ„Éà">Ôºü</button>


<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="„Ç´„Éº„Éâ„É™„Çπ„Éà">
    <div class="help-pop-header">
      <div class="help-pop-title">„Ç´„Éº„Éâ„É™„Çπ„Éà</div>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="equipExpandBackdrop" class="equip-expand-backdrop hidden">
  <div class="equip-expand-pop" role="dialog" aria-modal="true" aria-label="Ë£ÖÂÇô„Ç´„Éº„Éâ„É™„Çπ„Éà">
    <div class="equip-expand-header">
      <div class="equip-expand-title">Ë£ÖÂÇô„Ç´„Éº„Éâ„É™„Çπ„Éà</div>
    </div>
    <div class="equip-expand-body" id="equipExpandBody"></div>
  </div>
</div>

<div id="attackLootBackdrop" class="attack-loot-backdrop hidden">
  <div class="attack-loot-pop" role="dialog" aria-modal="true" aria-label="ÊîªÊíÉËÑ±ËêΩÂæå„ÅÆË£ÖÂÇôÂ•™Âèñ">
    <div class="attack-loot-header">ËÑ±ËêΩËÄÖ„ÅÆË£ÖÂÇô„Ç´„Éº„Éâ</div>
    <div class="attack-loot-body" id="attackLootBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">„Éõ„Çπ„ÉàË®≠ÂÆö</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">√ó</button>
  </div>
  <div class="start-pop-main">
    <span class="start-badge" id="startBadge">ÂèÇÂä†‰∫∫Êï∞Ôºö0</span><br>
    „Äå„Çπ„Çø„Éº„Éà„Äç„ÅßÂèÇÂä†‰∫∫Êï∞„Å´Âøú„Åò„ÅüÊßãÊàê„Åß„ÄÅÂÖ®Âì°„Å´Ê≠£‰Ωì„Ç´„Éº„Éâ„Çí1ÊûöÈÖçÂ∏É„ÄÇ<br>
    „Äå„É™„Çª„ÉÉ„Éà„Äç„ÅßÂ∏≠„ÉªÊ≠£‰Ωì„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÄÇ<br>
    <span class="small">ÈñãÂßãÂæå„ÅØÂ∫ßÂ∏≠Â§âÊõ¥„Åß„Åç„Åæ„Åõ„Çì„ÄÇ</span>
  </div>
  <div class="start-pop-actions">
    <button id="btnHostDice" class="btn ghost">„ÉÄ„Ç§„Çπ</button>
    <button id="btnResetRoom" class="btn ghost">„É™„Çª„ÉÉ„Éà</button>
    <button id="btnGameStart" class="btn primary">„Çπ„Çø„Éº„Éà</button>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, set, get, update, onValue, remove, runTransaction } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
    authDomain: "timebomb-3b0c7.firebaseapp.com",
    databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
    projectId: "timebomb-3b0c7",
    storageBucket: "timebomb-3b0c7.firebasestorage.app",
    messagingSenderId: "532935786630",
    appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
    measurementId: "G-K8NRR8K64Y"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);
  const USER_NAME_CACHE_KEY = "bbCachedUserName";

  const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
  sessionStorage.setItem('bbUserId', savedUserId);

  function setHpRowHeights(map){
    const root = document.documentElement;
    for (let i=0;i<=15;i++){
      const key = `--hp-r${i}`;
      if (map && Object.prototype.hasOwnProperty.call(map, i)) {
        root.style.setProperty(key, String(map[i]));
      }
    }
  }

  const equipDock = document.getElementById("equipDock");
  const cardsPanel = document.getElementById("cardsPanel");

  function updateEquipDockTop(){
    if (!equipDock || !cardsPanel) return;
    const rect = cardsPanel.getBoundingClientRect();
    if (!Number.isFinite(rect.bottom) || rect.bottom <= 0) return;
    const gap = 6;
    const top = Math.round(rect.bottom + gap);
    const minTop = 80;
    equipDock.style.setProperty('--equip-top', `${Math.max(minTop, top)}px`);
  }
  window.addEventListener('resize', () => { updateEquipDockTop(); });

  const GREEN_DECK = [
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºöÊ≠£‰Ωì„Ç´„Éº„Éâ„ÇíË¶ã„Åõ„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ D / F / G / V / W ?ÔºàHP12‰ª•‰∏äÔºâ„Å†„Å£„Åü„Çâ2„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ A / B / C / E / U ?ÔºàHP11‰ª•‰∏ãÔºâ„Å†„Å£„Åü„Çâ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„Çâ2„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„Çâ‚ùø„Å´ÁßªÂãï„Åõ„Çà„ÄÇÊó¢„Å´‚ûì„Å´„ÅÑ„ÇãÂ†¥Âêà„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„Çâ1„ÉÄ„É°„Éº„Ç∏ÂõûÂæ©„Åõ„Çà„ÄÇ„ÉÄ„É°„Éº„Ç∏„Åå0„Å™„Çâ„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„Çâ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„Çâ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „É¨„Ç§„ÉÄ„Éº „Åã „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„ÇâË£ÖÂÇô„ÇíÊ∏°„Åô„Åã„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „É¨„Ç§„ÉÄ„Éº „Åã „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„ÇâË£ÖÂÇô„ÇíÊ∏°„Åô„Åã„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „É¨„Ç§„ÉÄ„ÉºÔºü„Å†„Å£„Åü„Çâ1„ÉÄ„É°„Éº„Ç∏ÂõûÂæ©„Åõ„Çà„ÄÇ„ÉÄ„É°„Éº„Ç∏„Åå0„Å™„Çâ„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „É¨„Ç§„ÉÄ„ÉºÔºü„Å†„Å£„Åü„Çâ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „É¨„Ç§„ÉÄ„ÉºÔºü„Å†„Å£„Åü„Çâ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „É¨„Ç§„ÉÄ„ÉºÔºü„Å†„Å£„Åü„Çâ‚ùø„Å´ÁßªÂãï„Åõ„Çà„ÄÇÊó¢„Å´‚ûì„Å´„ÅÑ„ÇãÂ†¥Âêà„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„ÉÅ„Ç∫„É≥ „Åã „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„ÇâË£ÖÂÇô„ÇíÊ∏°„Åô„Åã„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„ÉÅ„Ç∫„É≥ „Åã „Ç∑„É£„Éâ„Ç¶Ôºü„Å†„Å£„Åü„ÇâË£ÖÂÇô„ÇíÊ∏°„Åô„Åã„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„ÉÅ„Ç∫„É≥ „Åã „É¨„Ç§„ÉÄ„ÉºÔºü„Å†„Å£„Åü„ÇâË£ÖÂÇô„ÇíÊ∏°„Åô„Åã„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„ÉÅ„Ç∫„É≥ „Åã „É¨„Ç§„ÉÄ„ÉºÔºü„Å†„Å£„Åü„ÇâË£ÖÂÇô„ÇíÊ∏°„Åô„Åã„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„ÉÅ„Ç∫„É≥Ôºü„Å†„Å£„Åü„Çâ‚ùø„Å´ÁßªÂãï„Åõ„Çà„ÄÇÊó¢„Å´‚ûì„Å´„ÅÑ„ÇãÂ†¥Âêà„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
    { text:"Êé®ÁêÜ„Ç´„Éº„ÉâÔºö„ÅÇ„Å™„Åü„ÅØ „Ç∑„ÉÅ„Ç∫„É≥Ôºü„Å†„Å£„Åü„Çâ1„ÉÄ„É°„Éº„Ç∏ÂõûÂæ©„Åõ„Çà„ÄÇ„ÉÄ„É°„Éº„Ç∏„Åå0„Å™„Çâ„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà„ÄÇ" },
  ];

  const WHITE_DECK = [
    { name:"ÈäÄ„ÅÆ„É≠„Ç∂„É™„Ç™", effect:"Ë£ÖÂÇô„ÄÅ„ÉÄ„Ç§„Çπ„ÅÆÊîªÊíÉ„Å´„Çà„Å£„Å¶ÂÄí„Åó„ÅüPL„ÅÆÂÖ®„Å¶„ÅÆË£ÖÂÇô„ÇíÂ•™„ÅÜ„ÄÇ" },
    { name:"ÈäÄ„ÅÆ„É≠„Ç∂„É™„Ç™", effect:"Ë£ÖÂÇô„ÄÅ„ÉÄ„Ç§„Çπ„ÅÆÊîªÊíÉ„Å´„Çà„Å£„Å¶ÂÄí„Åó„ÅüPL„ÅÆÂÖ®„Å¶„ÅÆË£ÖÂÇô„ÇíÂ•™„ÅÜ„ÄÇ" },
    { name:"ËôπËâ≤„ÅÆ„Éë„É©„ÇΩ„É´", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„Åô„Çã‰ª£„Çè„Çä„Å´ÊîªÊíÉ„É¨„É≥„Ç∏„ÅÆPL„Å´Êé®ÁêÜ„Ç´„Éº„Éâ„ÇíÊ∏°„Åô„ÄÇ" },
    { name:"„Ç®„ÇØ„Çπ„Ç´„É™„Éê„Éº", effect:"Ë£ÖÂÇô„ÄÅ„ÅÇ„Å™„Åü„Åå„É¨„Ç§„ÉÄ„Éº„Å™„Çâ„ÄÅÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏„Åå 2 ‰∏ä„Åå„Çã„ÄÇ" },
    { name:"Á•ûÁßò„ÅÆ„Ç≥„É≥„Éë„Çπ", effect:"Ë£ÖÂÇô„ÄÅÁßªÂãï„ÅÆÊôÇ„Å´„ÉÄ„Ç§„Çπ„Çí‰∫åÂõûÊåØ„Å£„Å¶„ÄÅÈÅ∏„Å∂„Åì„Å®„Åå„Åß„Åç„Çã„ÄÇ" },
    { name:"Âπ∏ÈÅã„ÅÆ„Éñ„É≠„Éº„ÉÅ", effect:"Ë£ÖÂÇô„ÄÅÂ∏ÇÂ∫ÅËàé(8)„ÅÆÂäπÊûú„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Å™„ÅÑ„ÄÇ" },
    { name:"Ë≥¢ËÄÖ„ÅÆ„É≠„Éº„Éñ", effect:"Ë£ÖÂÇô„ÄÅ‰∏é„Åà„ÇãÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏„ÄÅÂèó„Åë„ÇãÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏„Åå 1 Ê∏õÂ∞ë„Åô„Çã„ÄÇ" },
    { name:"„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ", effect:"Ë£ÖÂÇô„ÄÅ‰∏â„Å§ÁõÆ„ÅÆÈªíÁä¨,Âê∏Ë°Ä„Ç≥„Ç¶„É¢„É™,Âë™„ÅÑ„ÅÆ‰∫∫ÂΩ¢„ÅÆÂäπÊûú„ÇíÂèó„Åë„Å™„ÅÑ„ÄÇ" },
    { name:"ÂÖâËá®", effect:"„ÅÇ„Å™„Åü„Åå„É¨„Ç§„ÉÄ„Éº„Å™„Çâ„ÄÅÂÖ®„ÉÄ„É°„Éº„Ç∏„ÇíÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"ÂÆàË≠∑Â§©‰Ωø", effect:"Ê¨°„ÅÆËá™ÂàÜ„ÅÆÊâãÁï™„ÅÆÂßã„ÇÅ„Åæ„Åß„ÄÅÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Å™„ÅÑ„ÄÇ" },
    { name:"Â∞ÅÂç∞„ÅÆÁü•ÊÅµ", effect:"„Åì„ÅÆÊâãÁï™„ÅÆÁµÇ‰∫ÜÂæå„ÄÅ„ÇÇ„ÅÜ1ÊâãÁï™„ÇíË°å„ÅÜ„ÄÇ" },
    { name:"ÂøúÊÄ•ÊâãÂΩì", effect:"‰ªªÊÑè„ÅÆPLÔºàËá™ÂàÜ„ÇÇÂèØÔºâ„ÇíÈÅ∏„Å≥„ÄÅ„Åù„ÅÆPL„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí7„Å´„Åô„Çã„ÄÇ" },
    { name:"‰∫∫È≠ö„ÅÆÊ∂ô", effect:"ÊúÄ„ÇÇ„ÉÄ„É°„Éº„Ç∏„ÅåÂ§ö„ÅÑ‰∫∫„Çí 3 ÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"Âπ∏„Åõ„ÅÆ„ÇØ„ÉÉ„Ç≠„Éº", effect:"„ÅÇ„Å™„Åü„Åå A „Åæ„Åü„ÅØ U „Å™„Çâ„ÄÅHP„ÇíÂÖ®ÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"Èóá„ÇíÁ•ì„ÅÜÈè°", effect:"„ÅÇ„Å™„Åü„Åå„Ç∑„É£„Éâ„Ç¶Èô£Âñ∂„Åß„Ç¶„É´„É™„ÉÉ„Éí„Åß„Å™„ÅÑ„Å™„Çâ„ÄÅÂøÖ„ÅöÊ≠£‰Ωì„Ç´„Éº„Éâ„ÇíÂÖ¨Èñã„Åô„Çã„ÄÇ" },
    { name:"„ÅÑ„ÇÑ„Åó„ÅÆËÅñÊ∞¥", effect:"Ëá™ÂàÜ„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí 2 ÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"„ÅÑ„ÇÑ„Åó„ÅÆËÅñÊ∞¥", effect:"Ëá™ÂàÜ„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí 2 ÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"„ÅÑ„ÇÑ„Åó„ÅÆËÅñÊ∞¥", effect:"Ëá™ÂàÜ„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí 2 ÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"Ë£Å„Åç„ÅÆÈñÉÂÖâ", effect:"Ëá™ÂàÜ‰ª•Â§ñ„ÅÆPLÂÖ®Âì°„Å´ 2 „ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Çã„ÄÇ" },
    { name:"ÊÅ©ÊÅµ", effect:"Ëá™ÂàÜ‰ª•Â§ñ„ÅÆPL„ÇíÈÅ∏„Å≥„ÄÅ6Èù¢„ÉÄ„Ç§„Çπ„ÇíÊåØ„Çã„ÄÇÁõÆ„ÅÆÊï∞ÂõûÂæ©„Åô„Çã„ÄÇ" },
  ];

  const BLACK_DECK = [
    { name:"„Çµ„Éº„Éô„É´", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏„Åå 1 Â¢óÂä†„Åô„Çã„ÄÇ" },
    { name:"Êã≥ÈäÉR", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏„Åå 1 Â¢óÂä†„Åô„Çã„ÄÇ" },
    { name:"Êã≥ÈäÉL", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏„Åå 1 Â¢óÂä†„Åô„Çã„ÄÇ" },
    { name:"„ÇØ„É≠„Çπ„Éú„Ç¶„Ç¨„É≥", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏„Åå 1 Â¢óÂä†„Åô„Çã„ÄÇ" },
    { name:"Â¶ñÂàÄ„Éû„Çµ„É†„Éç", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„É¨„É≥„Ç∏„Å´PL„Åå„ÅÑ„Çå„Å∞ÂøÖ„ÅöÊîªÊíÉ„ÇíË°å„ÅÜ„ÄÇ4Èù¢„ÉÄ„Ç§„Çπ„Å†„Åë„Çí‰Ωø„ÅÜ„ÄÇ" },
    { name:"„Ç¨„Éà„É™„É≥„Ç∞", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„É¨„É≥„Ç∏„ÅÆPLÂÖ®Âì°„Å´ÊîªÊíÉ„Åô„Çã„ÄÇ" },
    { name:"Ê≠ªÁ•û„Çπ„Ç≥„Éº„Éó", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„É¨„É≥„Ç∏„Åå 1 Â¢óÂä†„Åô„Çã„ÄÇ" },
    { name:"Ê≠ªÁ•û„Çπ„Ç≥„Éº„Éó", effect:"Ë£ÖÂÇô„ÄÅÊîªÊíÉ„É¨„É≥„Ç∏„Åå 1 Â¢óÂä†„Åô„Çã„ÄÇ" },
    { name:"„Ç™„É™„Éê„Éº„ÅÆÂ≠êÂàÜ", effect:"‰ªªÊÑè„ÅÆPL„ÇíÈÅ∏„Çì„Åß„ÄÅË£ÖÂÇô„Çí1„Å§Â•™„ÅÜ„ÄÇ" },
    { name:"„Ç™„É™„Éê„Éº„ÅÆÂ≠êÂàÜ", effect:"‰ªªÊÑè„ÅÆPL„ÇíÈÅ∏„Çì„Åß„ÄÅË£ÖÂÇô„Çí1„Å§Â•™„ÅÜ„ÄÇ" },
    { name:"„Ç™„É™„Éê„Éº„ÅÆÂ≠êÂàÜ", effect:"‰ªªÊÑè„ÅÆPL„ÇíÈÅ∏„Çì„Åß„ÄÅË£ÖÂÇô„Çí1„Å§Â•™„ÅÜ„ÄÇ" },
    { name:"Âê∏Ë°Ä„Ç≥„Ç¶„É¢„É™", effect:"Ëá™ÂàÜ‰ª•Â§ñ„ÅÆPL1‰∫∫„Å´2„ÉÄ„É°„Éº„Ç∏‰∏é„Åà,Ëá™ÂàÜ„ÅØ1ÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"Âê∏Ë°Ä„Ç≥„Ç¶„É¢„É™", effect:"Ëá™ÂàÜ‰ª•Â§ñ„ÅÆPL1‰∫∫„Å´2„ÉÄ„É°„Éº„Ç∏‰∏é„Åà,Ëá™ÂàÜ„ÅØ1ÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"Âê∏Ë°Ä„Ç≥„Ç¶„É¢„É™", effect:"Ëá™ÂàÜ‰ª•Â§ñ„ÅÆPL1‰∫∫„Å´2„ÉÄ„É°„Éº„Ç∏‰∏é„Åà,Ëá™ÂàÜ„ÅØ1ÂõûÂæ©„Åô„Çã„ÄÇ" },
    { name:"‰∏â„Å§ÁõÆ„ÅÆÈªíÁä¨", effect:"Ëá™ÂàÜ„Å®ÈÅ∏„Çì„Å†PL1‰∫∫„Å´2„ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Çã„ÄÇ" },
    { name:"‰∏â„Å§ÁõÆ„ÅÆÈªíÁä¨", effect:"Ëá™ÂàÜ„Å®ÈÅ∏„Çì„Å†PL1‰∫∫„Å´2„ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Çã„ÄÇ" },
    { name:"Êö¥Âãï", effect:"„ÉÄ„Ç§„Çπ„Çí2„Å§ÊåØ„Çä„ÄÅÁõÆ„ÅÆ„Ç®„É™„Ç¢„Å´„ÅÑ„ÇãPLÂÖ®Âì°„Å´3„ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Çã„ÄÇ" },
    { name:"„Éê„Éä„Éä„ÅÆÁöÆ", effect:"Ë£ÖÂÇô„Çí1„Å§Ë™∞„Åã„Å´Ê∏°„Åô„ÄÇ„Å™„Åë„Çå„Å∞ 1 „ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çã„ÄÇ" },
    { name:"Âë™„ÅÑ„ÅÆ‰∫∫ÂΩ¢", effect:"PL„Çí1‰∫∫ÈÅ∏„Å≥6Èù¢„ÉÄ„Ç§„Çπ„ÇíÊåØ„Çã„ÄÇ1-4„Å™„ÇâÈÅ∏„Çì„Å†PL„Å´„ÄÅ5-6„Å™„ÇâËá™ÂàÜ„Å´3„ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Çã„ÄÇ" },
    { name:"Êà¶ÊÖÑ„ÅÆÈóáÂÑÄÂºè", effect:"„ÅÇ„Å™„Åü„Åå„Ç∑„É£„Éâ„Ç¶„ÅßÊ≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Åü„Çâ„ÄÅÂÖ®ÂõûÂæ©„Åô„Çã„ÄÇ" },
  ];

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  function safeText(s){ return String(s ?? ""); }
  function escapeHtml(s){
    return safeText(s)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }
  function escHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function cardImageFileFromName(cardName){
    const safe = encodeURI(String(cardName || "").trim());
    return safe ? `${safe}.jpg` : "";
  }
  function rgbFromHex(hex){
    const h = String(hex||"").trim();
    if(!h.startsWith("#") || (h.length!==7 && h.length!==4)) return {r:0,g:0,b:0};
    if(h.length===4){
      const r = parseInt(h[1]+h[1],16);
      const g = parseInt(h[2]+h[2],16);
      const b = parseInt(h[3]+h[3],16);
      return {r,g,b};
    }
    const r = parseInt(h.slice(1,3),16);
    const g = parseInt(h.slice(3,5),16);
    const b = parseInt(h.slice(5,7),16);
    return {r,g,b};
  }
  function textColorFor(bgHex){
    const {r,g,b} = rgbFromHex(bgHex);
    const L = (0.2126*r + 0.7152*g + 0.0722*b)/255;
    return (L < 0.55) ? "#fff" : "#111";
  }
  function firstChar(name){
    if(!name) return '';
    return Array.from(name.trim())[0] || '';
  }
  function isEquipCard(cardObj){
    const eff = safeText(cardObj?.effect || "").trim();
    if (!eff) return false;
    if (eff === "Ë£ÖÂÇô") return true;
    const prefixes = ["Ë£ÖÂÇô„ÄÅ","Ë£ÖÂÇô,","Ë£ÖÂÇôÔºö","Ë£ÖÂÇô:","Ë£ÖÂÇô "];
    return prefixes.some(p => eff.startsWith(p));
  }

  const ROOM_ALLOW = {
    1: ["white"],
    2: ["black"],
    5: ["green"],
    6: ["green","white","black"],
  };
  function allowedTypesByRoom(roomId){ return ROOM_ALLOW[roomId] || []; }
  function hasRainbowParasolEquip(uid = state.userId){
    if (!uid) return false;
    return listEquipForUid(uid).some(item => {
      if (isIdentityEquipItem(item)) return false;
      return safeText(item?.name || "").trim() === "ËôπËâ≤„ÅÆ„Éë„É©„ÇΩ„É´";
    });
  }
  function canUseParasolGreenDraw(){
    if (!isMyTurn()) return false;
    if (!hasRainbowParasolEquip(state.userId)) return false;
    const turn = turnState() || {};
    if (!turn.moveDone || turn.attackDone) return false;
    if (remainingCount(deckCache?.green) <= 0) return false;

    const targetsInRange = highlightedMarkerUids();
    if (!(targetsInRange instanceof Set) || targetsInRange.size <= 0) return false;

    const drawnTypes = turn?.drawnTypes || {};
    const drewGreenThisTurn = !!drawnTypes.green;
    const drewAnyThisTurn = !!(drawnTypes.green || drawnTypes.white || drawnTypes.black);

    const roomId = Number(state.currentRoomId || 0);
    const roomForRule = roomId === 7 ? 10 : roomId;
    if ([1, 2, 3, 4, 10].includes(roomForRule)) return true;
    if (roomForRule === 5) return drewGreenThisTurn;
    if (roomForRule === 6) return drewAnyThisTurn;
    return false;
  }
  function canDrawTypeNormally(type){
    const allowed = allowedTypesByRoom(state.currentRoomId);
    if (!allowed.includes(type)) return false;
    return canDrawSharedDeckNow();
  }
  function canDrawSharedDeckNow(){
    if (!isMyTurn()) return false;
    const t = turnState() || {};
    if (isTestPlayer()) return !!t.moveDone && !t.attackDone;
    return !!t.moveDone && !t.attackDone && !t.deckDrawDone;
  }
  function canClickType(type){
    if (isIdentityPromptInteractionLockActive()) return false;
    if (cardPlayerSelectActive) return false;
    if (isEquipSelectionLockActive()) return false;
    if (canDrawTypeNormally(type)) return true;
    if (type === "green" && canUseParasolGreenDraw()) return true;
    return false;
  }

  function parasolBlockedDrawWarningMessage(){
    const roomId = Number(state.currentRoomId || 0);
    const drawnTypes = turnState()?.drawnTypes || {};
    if (roomId === 1 && !drawnTypes.white){
      return "„Åì„ÅÆÂæå„ÄÅÁôΩ„Ç´„Éº„Éâ„Åå„Å≤„Åë„Åæ„Åõ„Çì„ÄÇ";
    }
    if (roomId === 2 && !drawnTypes.black){
      return "„Åì„ÅÆÂæå„ÄÅÁôΩ„Ç´„Éº„Éâ„Åå„Å≤„Åë„Åæ„Åõ„Çì„ÄÇ";
    }
    return "";
  }
  function applyLocked(el, locked, {noDim=false} = {}){
    if (!el) return;
    el.classList.toggle("locked", !!locked && !noDim);
    el.classList.toggle("blocked", !!locked && !!noDim);
    if (!locked){
      el.classList.remove("locked","blocked");
    }
  }

  function adjustCardNameFont(rootEl, retryCount = 0){
    const nameEl = rootEl?.querySelector?.('.wb-name span');
    if (!nameEl) return;

    const frameEl = nameEl.closest('.wb-name');
    if (!frameEl) return;

    const availableWidth = frameEl.clientWidth;
    if (availableWidth <= 0){
      if (retryCount < 4){
        requestAnimationFrame(() => adjustCardNameFont(rootEl, retryCount + 1));
      }
      return;
    }

    const text = (nameEl.textContent || '').trim();
    if (!text){
      nameEl.style.fontSize = '';
      nameEl.style.transform = 'scaleX(1)';
      return;
    }

    const maxFontSize = 8;
    const minFontSize = 4;
    const frameWidth = Math.max(0, frameEl.clientWidth - 2);
    if (frameWidth <= 0) return;

    const computed = getComputedStyle(nameEl);
    const canvas = adjustCardNameFont._canvas || (adjustCardNameFont._canvas = document.createElement('canvas'));
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const measureTextWidth = (fontSize) => {
      ctx.font = `${computed.fontWeight} ${fontSize}px ${computed.fontFamily}`;
      return ctx.measureText(text).width;
    };

    let low = minFontSize;
    let high = maxFontSize;
    let best = minFontSize;
    while ((high - low) > 0.1){
      const mid = (low + high) / 2;
      if (measureTextWidth(mid) <= frameWidth){
        best = mid;
        low = mid;
      } else {
        high = mid;
      }
    }

    nameEl.style.fontSize = `${best.toFixed(2)}px`;
    const finalWidth = measureTextWidth(best);
    if (finalWidth > frameWidth){
      const scaleX = Math.max(0.72, frameWidth / Math.max(finalWidth, 1));
      nameEl.style.transform = `scaleX(${scaleX.toFixed(3)})`;
    } else {
      nameEl.style.transform = 'scaleX(1)';
    }
  }

  function ensureCountTag(el){
    let tag = el.querySelector('.count-tag');
    if (!tag){
      tag = document.createElement('div');
      tag.className = 'count-tag';
      el.appendChild(tag);
    }
    return tag;
  }

  function setSlotAsDeck(slotEl, imgUrl, count, { disabled=false, type=null } = {}){
    const left = Math.max(0, Number(count) || 0);
    const hideImage = left <= 0;
    slotEl.className = 'card72 deck' + (disabled ? ' disabled' : '');
    slotEl.classList.toggle("noframe", hideImage);
    slotEl.style.backgroundImage = hideImage ? 'none' : `url('${imgUrl}')`;
    slotEl.style.backgroundColor = hideImage ? 'transparent' : '';
    slotEl.innerHTML = '';
    if (!hideImage){
      const tag = ensureCountTag(slotEl);
      tag.textContent = String(left);
    }
    slotEl.dataset.cardType = type || "";
  }

  function buildWbFrontHTML(cardObj, theme){
    const name = safeText(cardObj?.name || "Ôºà„Å™„ÅóÔºâ").trim();
    const img  = (theme === "green") ? "suiri.jpg" : cardImageFileFromName(name);

    let eff = safeText(cardObj?.effect || "");
    let showEquip = false;

    const trimmed = eff.trim();
    const prefixes = ["Ë£ÖÂÇô„ÄÅ","Ë£ÖÂÇô,","Ë£ÖÂÇôÔºö","Ë£ÖÂÇô:","Ë£ÖÂÇô "];
    for (const p of prefixes){
      if (trimmed.startsWith(p)){
        showEquip = true;
        eff = trimmed.slice(p.length).trim();
        break;
      }
    }
    if (!showEquip && trimmed === "Ë£ÖÂÇô"){
      showEquip = true;
      eff = "";
    }

    const tagHtml = showEquip ? `<span class="inline-tag">Ë£ÖÂÇô</span>` : "";
    const effHtml = escHtml(eff);

    return `
      <div class="wb-name"><span>${escHtml(name)}</span></div>
      <div class="wb-circle" aria-label="card image circle">
        ${img ? `<img src="${escHtml(img)}" alt="${escHtml(name)}">` : ``}
      </div>
      <div class="wb-effect">
        <div class="wb-desc">${tagHtml}${effHtml}</div>
      </div>
    `;
  }

  function setSlotAsWbFront(slotEl, cardObj, theme){
    slotEl.className = `card72 wb-front ${theme === 'black' ? 'wb-black' : theme === 'green' ? 'wb-green' : 'wb-white'}`;
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = buildWbFrontHTML(cardObj, theme);
    adjustCardNameFont(slotEl);
    slotEl.dataset.cardType = theme || "";
  }

  function setSlotEmpty(slotEl){
    slotEl.className = 'card72';
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = '';
    slotEl.dataset.cardType = "";
  }

  function setSlotEmptyNoFrame(slotEl){
    slotEl.className = 'card72 noframe';
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = '';
    slotEl.dataset.cardType = "";
  }

  const zoomBackdrop = document.getElementById("zoomBackdrop");
  const zoomStage = document.getElementById("zoomStage");
  const greenRevealPanel = document.getElementById("greenRevealPanel");
  const greenRevealLabel = document.getElementById("greenRevealLabel");
  const greenRevealCardWrap = document.getElementById("greenRevealCardWrap");
  const davidSelectPreview = document.getElementById("davidSelectPreview");
  const greenShareDock = document.getElementById("greenShareDock");
  const greenShareList = document.getElementById("greenShareList");
  const greenShareSubtitle = document.getElementById("greenShareSubtitle");
  const greenShareActions = document.getElementById("greenShareActions");
  const greenShareCloseBtn = document.getElementById("greenShareCloseBtn");
  if (greenShareDock && greenShareDock.parentElement === zoomBackdrop){
    document.body.appendChild(greenShareDock);
  }
  let zoomCloseOnBackdrop = true;
  let zoomCloseOnAnyClick = false;
  let greenShareCard = null;
  let greenInboxSeenAt = 0;
  let greenInboxInitialized = false;
  let greenReplySeenAt = 0;
  let greenReplyInitialized = false;
  let greenZoomLocked = false;
  let pendingGreenRequestId = "";
  let pendingGreenAnswerMsg = null;
  let pendingGreenCloseSeenAt = 0;
  let pendingGreenCloseInitialized = false;
  let greenRevealByRequestId = {};
  let greenSessionInitialized = false;
  let greenSessionRestoring = false;
  let greenSessionSeenAt = 0;
  let pendingGreenSessionEntry = null;
  let cardTargetSessionInitialized = false;
  let cardTargetSessionRestoring = false;
  let cardTargetSessionSeenAt = 0;
  let pendingCardTargetSessionEntry = null;
  let roleAbilitySelectionInitialized = false;
  let roleAbilitySelectionSeenAt = 0;
  let activeRoleAbilitySelection = null;
  const TURN_START_ONLY_REVEAL_ROLE_IDS = new Set([
    "CIT_D2", // „Éá„Éº„É¥„Ç£„ÉÉ„Éâ
    "CIT_D3", // „Éá„Éú„É©
    "CIT_A1", // „Ç¢„É™„Çπ
    "CIT_C3", // „ÇØ„É¨„Ç¢
    "CIT_C2", // „Ç≠„É£„É≠„É´
    "RAI_E2", // „Ç®„É™„Ç´
    "RAI_F1", // „Éï„Çß„É™„ÉÉ„ÇØ„Çπ
    "RAI_F2", // „Éï„Çß„É™„Ç∑„Ç¢
    "SHA_U2", // „Ç¶„É©„Éå„Çπ
  ]);
  const REVEAL_ENDS_TURN_ROLE_IDS = new Set([
    "CIT_B2", // „Éô„É≥„Ç∏„É£„Éü„É≥
    "RAI_E3", // „Ç®„Éû
    "RAI_G1", // „Ç¥„Éº„Éâ„É≥
    "SHA_W1", // „ÉØ„Ç§„Éà
  ]);
  let cardPlayerSelectActive = false;
  let activeGreenReplies = {};
  let moveDiceEventSeenAt = 0;
  let moveDiceEventInitialized = false;
  let attackDiceEventSeenAt = 0;
  let attackDiceEventInitialized = false;
  let cardDiceEventSeenAt = 0;
  let cardDiceEventInitialized = false;
  const deckRebuildTimers = { green:null, white:null, black:null };
  let roleFlashEventSeenAt = 0;
  let roleFlashEventInitialized = false;
  let hpSwapEventSeenAt = 0;
  let hpSwapEventInitialized = false;
  let walpurgisSwapEventSeenAt = 0;
  let walpurgisSwapEventInitialized = false;
  let roleFlashTimer = null;
  let roleFlashOverlayEl = null;
  let identityRevealInitialized = false;
  let identityRevealSeenByUid = {};
  let autoDamageRevealLock = {};
  let temporaryRoleTagByUid = {};
  let roomAbilityTurnKey = "";
  let room4StealUsed = false;
  let room3ActionUsed = false;
  let walpurgisSwapUsed = false;
  let movedByDiceRoomId = null;
  let pendingRoomAction = null;
  let uranusMeteorResolved = false;
  let vampireHiddenAttackSuccess = false;
  let vampireHealScheduled = false;
  let pendingEquipAction = null;
  let pendingCardTargetSelection = null;
  let danielAutoRevealTimer = null;
  let bruceAutoRevealTimer = null;
  let carolTurnHealTimer = null;
  let carolTurnHealKey = "";
  let effectResolutionLocks = {};
  let zoomPassthroughMode = false;
  let zoomDismissHandler = null;
  let hpBoardAnimationActive = false;
  let suppressOutsidePopCloseUntil = 0;
  let pendingRevealAction = "";
  let attackTurnEndChoicePending = false;
  let pendingAttackResolution = null;
  let pendingAttackResultMeta = null;
  let attackResultChoiceBusy = false;
  let ulsterExtraAttackPending = 0;
  let attackFlowUiLockActive = false;
  let suppressEndTurnButton = false;
  let pendingHpSwapAnimation = null;
  let attackAbilityUsedTurnByRole = {};
  let attackAbilityUsageTurnOwnerUid = "";

  const waitMs = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  const revealPop = document.getElementById("revealPop");
  const revealMsg = document.getElementById("revealMsg");
  const btnRevealYes = document.getElementById("btnRevealYes");
  const btnRevealNo  = document.getElementById("btnRevealNo");
  const attackPop = document.getElementById("attackPop");
  const attackMsg = document.getElementById("attackMsg");
  const btnAttackYes = document.getElementById("btnAttackYes");
  const btnAttackNo = document.getElementById("btnAttackNo");
  const attackResultPop = document.getElementById("attackResultPop");
  const attackResultRows = document.getElementById("attackResultRows");
  const btnAttackResultEnd = document.getElementById("btnAttackResultEnd");
  const btnAttackResultKeep = document.getElementById("btnAttackResultKeep");
  const btnAttackResultExcalibur = document.getElementById("btnAttackResultExcalibur");
  const roomActionPop = document.getElementById("roomActionPop");
  const roomActionMsg = document.getElementById("roomActionMsg");
  const btnRoomActionYes = document.getElementById("btnRoomActionYes");
  const btnRoomActionNo = document.getElementById("btnRoomActionNo");
  const turnHintPop = document.getElementById("turnHintPop");
  const identityPromptPop = document.getElementById("identityPromptPop");
  const identityPromptMsg = document.getElementById("identityPromptMsg");
  const btnIdentityPromptYes = document.getElementById("btnIdentityPromptYes");
  const btnIdentityPromptNo = document.getElementById("btnIdentityPromptNo");
  let pendingAttackTargetUid = "";
  let pendingIdentityPrompt = null;
  let seatPromptUnsubscribe = null;
  let subscribedSeatPromptIndex = null;
  let restoringSeatIdentityPrompt = false;
  let seatEquipSelectionUnsubscribe = null;
  let subscribedSeatEquipSelectionIndex = null;
  let restoringSeatEquipSelection = false;

  const IDENTITY_PROMPT_CARD_NAMES = new Set(["Âπ∏„Åõ„ÅÆ„ÇØ„ÉÉ„Ç≠„Éº", "ÂÖâËá®", "Êà¶ÊÖÑ„ÅÆÈóáÂÑÄÂºè"]);
  const IDENTITY_REVEAL_POP_BLOCK_CARD_NAMES = new Set([
    "‰∏â„Å§ÁõÆ„ÅÆÈªíÁä¨",
    "Âê∏Ë°Ä„Ç≥„Ç¶„É¢„É™",
    "Âë™„ÅÑ„ÅÆ‰∫∫ÂΩ¢",
    "Êà¶ÊÖÑ„ÅÆÈóáÂÑÄÂºè",
    "ÂøúÊÄ•ÊâãÂΩì",
    "ÂÖâËá®",
    "ÊÅ©ÊÅµ",
    "Âπ∏„Åõ„ÅÆ„ÇØ„ÉÉ„Ç≠„Éº"
  ]);

  function turnRoomActionState(){
    const t = turnState() || {};
    return {
      movedByDiceRoomId: Number(t.movedByDiceRoomId || 0) || null,
      room3ActionUsed: !!t.room3ActionUsed,
      room4StealUsed: !!t.room4StealUsed
    };
  }

  async function updateTurnRoomActionState(patch = {}){
    if (!state.roomCode) return;
    const next = {};
    if (Object.prototype.hasOwnProperty.call(patch, "movedByDiceRoomId")){
      const rid = Number(patch.movedByDiceRoomId || 0) || null;
      next.movedByDiceRoomId = rid;
    }
    if (Object.prototype.hasOwnProperty.call(patch, "room3ActionUsed")){
      next.room3ActionUsed = !!patch.room3ActionUsed;
    }
    if (Object.prototype.hasOwnProperty.call(patch, "room4StealUsed")){
      next.room4StealUsed = !!patch.room4StealUsed;
    }
    if (!Object.keys(next).length) return;
    await update(ref(db, `rooms/${state.roomCode}/turn`), next);
  }

  function placeFloatingPop(popEl, clientX, clientY, { yOffset = 0 } = {}){
    if (!popEl) return;
    const pad = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const r = popEl.getBoundingClientRect();

    let x = Number(clientX);
    let y = Number(clientY);
    if (!Number.isFinite(x)) x = vw / 2;
    if (!Number.isFinite(y)) y = vh / 2;

    const halfW = r.width / 2;
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;

    let top = y + 18 + Number(yOffset || 0);
    if (top + r.height > vh - pad) top = y - r.height - 18;
    top = Math.max(pad, Math.min(top, vh - pad - r.height));

    popEl.style.left = x + "px";
    popEl.style.top = top + "px";
  }

  function skipRoom3ActionAndStartAttack(){
    if (!canUseRoom3Action()) return;
    room3ActionUsed = true;
    updateTurnRoomActionState({ room3ActionUsed:true });
    hideRoomActionPop();
    hideAttackResultPop();
    clearAttackResultDice();
    pendingAttackResolution = null;
    pendingAttackResultMeta = null;
    attackTurnEndChoicePending = false;
    attackFlowUiLockActive = false;
    cachePendingAttackResolution(null);
    showTurnHint("");
    renderMarkers();
  }

  function roleAbilityName(role){
    const effect = safeText(role?.effect || "").trim();
    if (!effect) return "ÁâπÊÆäËÉΩÂäõ";
    const match = effect.match(/^([^Ôºö:]+)[Ôºö:]/);
    return safeText(match?.[1] || effect).trim() || "ÁâπÊÆäËÉΩÂäõ";
  }

  const ROLE_SELECTION_SPECS = {
    "RAI_F2": { usageKey:"felicia", abilityName:"„Çπ„É©„É†Ë°ó„ÅÆÂ§©‰Ωø", prompt:"„ÉÄ„É°„Éº„Ç∏„Çí7„Å´„Åô„Çã„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ" },
    "RAI_F1": { usageKey:"felix", abilityName:"„Ç¢„Çπ„Éà„É©„É´„Éª„É°„Ç§„Çπ", prompt:"„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ" },
    "RAI_E2": { usageKey:"erika", abilityName:"Â∞ÅÂç∞„ÅÆÈéñ", prompt:"ÁâπÊÆäËÉΩÂäõ„ÇíÂ§±„Çè„Åõ„Çã„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ" },
    "RAI_E3": { usageKey:"emma", abilityName:"Áôí„Åó„ÅÆÂÖâ", prompt:"ÂõûÂæ©„Åï„Åõ„Çã„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ", perTurn:true },
    "RAI_G3": { usageKey:"godwin", abilityName:"ËòáÁîüË£ÖÁΩÆTYPE-G", prompt:"Âæ©Ê¥ª„Åï„Åõ„Çã„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ" },
    "CIT_C3": { usageKey:"claire", abilityName:"„Ç≠„É£„Çπ„É™„É≥„Ç∞TYPE-G", prompt:"„ÉÄ„É°„Éº„Ç∏„ÇíÂÖ•„ÇåÊõø„Åà„Çã„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ" },
    "SHA_U2": { usageKey:"uranus", abilityName:"„É°„ÉÜ„Ç™„Çπ„Éà„É©„Ç§„ÇØ", prompt:"„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Çã„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ", perTurn:true },
  };

  function roleSelectionSpec(roleId){ return ROLE_SELECTION_SPECS[safeText(roleId || "")] || null; }
  function isRoleSelectionAbility(roleId){ return !!roleSelectionSpec(roleId); }
  function isRoleAbilityUsed(roleId){
    const spec = roleSelectionSpec(roleId);
    if (!spec || !state.userId) return false;
    if (spec.perTurn){
      const usedTurn = safeText(state.room?.abilityUsage?.[spec.usageKey]?.[state.userId] || "");
      return usedTurn && usedTurn === currentTurnKey();
    }
    return !!state.room?.abilityUsage?.[spec.usageKey]?.[state.userId];
  }
  async function markRoleAbilityUsed(roleId){
    const spec = roleSelectionSpec(roleId);
    if (!spec || !state.roomCode || !state.userId) return;
    const value = spec.perTurn ? currentTurnKey() : true;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/${spec.usageKey}/${state.userId}`), value);
  }

  function currentTurnKey(){
    const turn = turnState();
    return `${safeText(turn?.currentPlayerId || "")}@${Number(turn?.updatedAt || 0)}`;
  }

  function showRevealPopAt(anchorEl, options = {}){
    const role = myRoleInfo();
    const ability = roleAbilityName(role);
    const mode = options.mode === "notice" ? "notice" : "confirm";
    const message = safeText(options.message || "").trim();
    pendingRevealAction = safeText(options.action || "");
    if (revealMsg){
      if (mode === "notice"){
        revealMsg.textContent = message || "ÊâãÁï™„ÅÆÂàù„ÇÅ„Å´„Å†„ÅëÊ≠£‰Ωì„ÇíÂÖ¨Èñã„Åß„Åç„Åæ„Åô„ÄÇ";
        pendingRevealAction = "";
      } else if (options.messageHtml){
        revealMsg.innerHTML = String(options.messageHtml);
      } else {
        const suffix = options.appendEndTurnNotice ? "‰ΩøÁî®Âæå„Å´ÊâãÁï™„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åô„ÄÇ" : "";
        revealMsg.innerHTML = `Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Å¶„ÄÅ<span class="ability-pill">${ability}</span>„Çí‰Ωø„ÅÑ„Åæ„Åô„Åã„ÄÇ${suffix}`;
      }
    }
    btnRevealYes?.classList.toggle("hidden", mode === "notice");
    btnRevealNo?.classList.toggle("hidden", mode === "notice");
    if (btnRevealNo){
      btnRevealNo.textContent = "„ÅÑ„ÅÑ„Åà";
    }
    revealPop.classList.remove("hidden");
    if (!anchorEl){
      placeFloatingPop(revealPop, window.innerWidth / 2, window.innerHeight / 2);
      return;
    }
    const pad = 10;
    const gap = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const anchorRect = anchorEl.getBoundingClientRect();
    const popRect = revealPop.getBoundingClientRect();
    const halfW = popRect.width / 2;
    let x = anchorRect.left + (anchorRect.width / 2);
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;
    let top = anchorRect.bottom + gap;
    if (top + popRect.height > vh - pad){
      top = Math.max(pad, anchorRect.top - popRect.height - gap);
    }
    top = Math.max(pad, Math.min(top, vh - pad - popRect.height));
    revealPop.style.left = `${x}px`;
    revealPop.style.top = `${top}px`;
  }
  function hideRevealPop(){
    revealPop.classList.add("hidden");
    pendingRevealAction = "";
  }

  function eliminatedPlayerCount(){
    return latestPlayers.filter(p => isPlayerEliminated(p.id)).length;
  }

  function isWightAbilityUsed(){
    return !!state.room?.abilityUsage?.wight?.[state.userId];
  }

  async function markWightAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/wight/${state.userId}`), true);
  }

  function isAliceAbilityUsed(){
    return !!state.room?.abilityUsage?.alice?.[state.userId];
  }

  async function markAliceAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/alice/${state.userId}`), true);
  }

  function canUseAliceAbilityNow(){
    if (!isMyRole("CIT_A1")) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (!isMyTurn()) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (isAliceAbilityUsed()) return { ok:false, message:"„Åì„ÅÆËÉΩÂäõ„ÅØ„Åô„Åß„Å´‰ΩøÁî®Ê∏à„Åø„Åß„Åô„ÄÇ" };
    if (!!turnState()?.moveDone) return { ok:false, message:"ÊâãÁï™„ÅÆÂàù„ÇÅ„Å´„Å†„Åë‰Ωø„Åà„Åæ„Åô„ÄÇ" };
    return { ok:true };
  }

  function canUseWightAbilityNow(){
    if (!isMyRole("SHA_W1")) return { ok:false, message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" };
    if (isWightAbilityUsed()) return { ok:false, message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" };
    if (!turnState()?.moveDone) return { ok:false, message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" };
    const eliminated = eliminatedPlayerCount();
    if (eliminated <= 0) return { ok:false, message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" };
    return { ok:true, eliminated };
  }

  async function activateWightAbilityAndEndTurn(){
    const check = canUseWightAbilityNow();
    if (!check.ok) return false;
    await markWightAbilityUsed();
    await update(ref(db, `rooms/${state.roomCode}/turn`), {
      repeatTurnRemaining: check.eliminated,
      repeatTurnTotal: check.eliminated,
      updatedAt: Date.now()
    });
    await doEndTurn();
    return true;
  }

  function showAttackPopAt(clientX, clientY, targetName){
    if (!attackPop) return;

    if (hasMyEquipmentByName("„Ç¨„Éà„É™„É≥„Ç∞")){
      attackMsg.textContent = "„É¨„É≥„Ç∏ÂÜÖ„ÅÆ„Éó„É¨„Ç§„É§„ÉºÂÖ®Âì°„ÇíÊîªÊíÉ„Åó„Åæ„Åô„ÄÇ„ÅØ„ÅÑ„ÄÅ„ÅÑ„ÅÑ„Åà";
    } else {
      attackMsg.textContent = `${safeText(targetName || "„Åì„ÅÆ„Éó„É¨„Ç§„É§„Éº")}„ÇíÊîªÊíÉ„Åó„Åæ„Åô„Åã„ÄÇ`;
    }
    attackPop.classList.remove("hidden");
    placeFloatingPop(attackPop, clientX, clientY);
  }
  function hideAttackPop(){
    pendingAttackTargetUid = "";
    attackPop?.classList.add("hidden");
  }

  function showTurnHint(message){
    if (!turnHintPop) return;
    if (message && typeof message === "object"){
      const text = safeText(message.text || "");
      const showSkip = !!message.showRoom3Skip;
      turnHintPop.innerHTML = "";
      if (text){
        const textWrap = document.createElement("span");
        textWrap.textContent = text;
        turnHintPop.appendChild(textWrap);
      }
      if (showSkip){
        const btn = document.createElement("button");
        btn.className = "btn ghost turn-hint-action";
        btn.textContent = "„Çπ„Ç≠„ÉÉ„Éó(„Åó„Å¶ÊîªÊíÉ)";
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          skipRoom3ActionAndStartAttack();
        });
        turnHintPop.appendChild(btn);
      }
      turnHintPop.classList.toggle("hidden", !text && !showSkip);
      return;
    }
    turnHintPop.textContent = safeText(message || "");
    turnHintPop.classList.toggle("hidden", !message);
  }

  function hideDavidSelectPreview(){
    zoomBackdrop?.classList.remove("david-select-active");
    davidSelectPreview?.classList.add("hidden");
    if (davidSelectPreview) davidSelectPreview.innerHTML = "";
  }

  function showDavidSelectPreviewFromCard(cardEl){
    if (!davidSelectPreview || !cardEl) return;
    const clone = cardEl.cloneNode(true);
    clone.classList.remove("locked","blocked","equip-steal-pulse","equip-defeat-pulse","eliminated-dim");
    clone.style.pointerEvents = "none";
    davidSelectPreview.innerHTML = "";
    davidSelectPreview.appendChild(clone);
    davidSelectPreview.classList.remove("hidden");
    zoomBackdrop?.classList.add("david-select-active");
  }

  function hideRoomActionPop(){
    pendingRoomAction = null;
    roomActionPop?.classList.add("hidden");
    roomActionPop?.classList.remove("lower-mode", "room3-mode", "no-caret");
    if (btnRoomActionYes){
      btnRoomActionYes.textContent = "„ÅØ„ÅÑ";
      btnRoomActionYes.classList.remove("pop-purple","pop-white");
    }
    if (btnRoomActionNo){
      btnRoomActionNo.textContent = "„ÅÑ„ÅÑ„Åà";
      btnRoomActionNo.classList.remove("pop-purple","pop-white");
    }
    if (pendingEquipAction?.type === "david_select") hideDavidSelectPreview();
  }

  function showRoomActionPopAt(clientX, clientY, message, onYes, options = {}){
    if (!roomActionPop || !roomActionMsg) return;
    const fixedLower = !!options.fixedLower;
    const compactButtons = !!options.compactButtons;
    const yOffset = Number(options.yOffset) || 0;
    const noCaret = !!options.noCaret;
    pendingRoomAction = {
      onYes: (typeof onYes === "function") ? onYes : null,
      onNo: (typeof options.onNo === "function") ? options.onNo : null,
      closeZoomOnNo: !!options.closeZoomOnNo,
      dismissOnOutside: options.dismissOnOutside !== false
    };
    const yesBtnClass = safeText(options.yesBtnClass || "");
    const noBtnClass = safeText(options.noBtnClass || "");
    if (options.messageHtml){
      roomActionMsg.innerHTML = String(options.messageHtml);
    } else {
      roomActionMsg.textContent = safeText(message || "");
    }
    if (btnRoomActionYes){
      btnRoomActionYes.textContent = safeText(options.yesLabel || "„ÅØ„ÅÑ");
      btnRoomActionYes.classList.remove("pop-purple","pop-white");
      if (yesBtnClass) btnRoomActionYes.classList.add(yesBtnClass);
    }
    if (btnRoomActionNo){
      btnRoomActionNo.textContent = safeText(options.noLabel || "„ÅÑ„ÅÑ„Åà");
      btnRoomActionNo.classList.remove("pop-purple","pop-white");
      if (noBtnClass) btnRoomActionNo.classList.add(noBtnClass);
    }
    roomActionPop.classList.remove("hidden");
    roomActionPop.classList.toggle("lower-mode", fixedLower);
    roomActionPop.classList.toggle("room3-mode", compactButtons);
    roomActionPop.classList.toggle("no-caret", noCaret);

    if (fixedLower){
      roomActionPop.style.left = "";
      roomActionPop.style.top = "";
      return;
    }

    const pad = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const r = roomActionPop.getBoundingClientRect();
    let x = clientX;
    let y = clientY;
    const halfW = r.width / 2;
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;
    let top = y + 18 + yOffset;
    if (top + r.height > vh - pad) top = y - r.height - 18;
    top = Math.max(pad, Math.min(top, vh - pad - r.height));
    roomActionPop.style.left = x + "px";
    roomActionPop.style.top  = top + "px";
  }

  function hideIdentityPrompt(){
    pendingIdentityPrompt = null;
    identityPromptPop?.classList.add("hidden");
  }

  function isIdentityPromptInteractionLockActive(){
    if (!pendingIdentityPrompt?.closeZoomOnChoice) return false;
    return !identityPromptPop?.classList.contains("hidden");
  }

  function canInteractWithMapPlayerIcons(){
    return !isIdentityPromptInteractionLockActive() && !cardPlayerSelectActive;
  }

  function isIdentityRevealPopBlockedByEffectPop(){
    const promptCardName = safeText(pendingIdentityPrompt?.cardObj?.name || "");
    if (!identityPromptPop?.classList.contains("hidden") && IDENTITY_REVEAL_POP_BLOCK_CARD_NAMES.has(promptCardName)){
      return true;
    }

    const selectionCardName = safeText(pendingCardTargetSelection?.cardObj?.name || "");
    if (pendingCardTargetSelection && IDENTITY_REVEAL_POP_BLOCK_CARD_NAMES.has(selectionCardName)){
      return true;
    }

    return false;
  }

  function restoreIdentityPromptSelection(action = null){
    const next = action || pendingIdentityPrompt;
    const cardObj = next?.cardObj || null;
    if (!cardObj) return;
    const canReveal = !!next?.canReveal;
    openZoomFromDeckCard(cardObj, safeText(next?.cardTheme || "white") || "white", { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(true);
    identityPromptMsg.textContent = safeText(next?.message || "");
    btnIdentityPromptYes?.classList.toggle("pop-disabled", !canReveal);
    btnIdentityPromptYes?.classList.toggle("pop-dark", canReveal);
    if (btnIdentityPromptYes) btnIdentityPromptYes.disabled = !canReveal;
    identityPromptPop?.classList.remove("hidden");
  }

  function cardByName(name){
    const target = safeText(name || "");
    if (!target) return null;
    return [...WHITE_DECK, ...BLACK_DECK, ...GREEN_DECK].find((c) => safeText(c?.name || "") === target) || null;
  }

  async function setSeatIdentityPromptState(payload){
    if (restoringSeatIdentityPrompt) return;
    if (!state.roomCode) return;
    const seat = Number(state.seatedTable || 0);
    if (!seat) return;
    const promptRef = ref(db, `rooms/${state.roomCode}/seatPromptState/${seat}`);
    if (!payload){
      await remove(promptRef).catch(() => {});
      return;
    }
    await set(promptRef, {
      ...payload,
      seat,
      ownerUid: state.userId,
      at: Date.now()
    });
  }

  async function setSeatEquipSelectionState(payload){
    if (restoringSeatEquipSelection) return;
    if (!state.roomCode) return;
    const seat = Number(state.seatedTable || 0);
    if (!seat) return;
    const selectionRef = ref(db, `rooms/${state.roomCode}/seatEquipSelectionState/${seat}`);
    if (!payload){
      await remove(selectionRef).catch(() => {});
      return;
    }
    await set(selectionRef, {
      ...payload,
      seat,
      ownerUid: state.userId,
      at: Date.now()
    });
  }

  function identityPromptRevealOptions(cardName){
    const name = safeText(cardName || "");
    if (!IDENTITY_PROMPT_CARD_NAMES.has(name)) return {};
    if (name === "Âπ∏„Åõ„ÅÆ„ÇØ„ÉÉ„Ç≠„Éº"){
      return {
        revealedBy: "happy_cookie",
        useAgathaAbilityOnReveal: false
      };
    }
    return {};
  }

  function buildIdentityPromptResolver(cardName){
    const name = safeText(cardName || "");
    if (!IDENTITY_PROMPT_CARD_NAMES.has(name)) return null;
    return async () => {
      const role = myRoleInfo();
      if (!role) return;
      await revealMyIdentityToEquipment(identityPromptRevealOptions(name));
      openIdentityRevealZoom(role, state.userId);
      await fullRecoverPlayer(state.userId);
    };
  }

  function identityPromptPayloadFromCard(cardName){
    const role = myRoleInfo();
    const name = safeText(cardName || "");
    if (!role || !IDENTITY_PROMPT_CARD_NAMES.has(name)) return null;
    if (name === "Êà¶ÊÖÑ„ÅÆÈóáÂÑÄÂºè"){
      return {
        message: "„Ç∑„É£„Éâ„Ç¶„Å®„Åó„Å¶Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Åæ„Åô„Åã„ÄÇ",
        canReveal: role.faction === "„Ç∑„É£„Éâ„Ç¶",
        cardTheme: "black"
      };
    }
    if (name === "ÂÖâËá®"){
      return {
        message: "„É¨„Ç§„ÉÄ„Éº„Å®„Åó„Å¶Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Åæ„Åô„Åã„ÄÇ",
        canReveal: role.faction === "„É¨„Ç§„ÉÄ„Éº",
        cardTheme: "white"
      };
    }
    return {
      message: "A„Åæ„Åü„ÅØU„Å®„Åó„Å¶Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Åæ„Åô„Åã„ÄÇ",
      canReveal: role.initial === "A" || role.initial === "U",
      cardTheme: "white"
    };
  }

  function showIdentityPromptPop({ message, canReveal, onYes, onNo=null, cardObj=null, cardTheme="white", openZoom=false }){
    if (!identityPromptPop || !identityPromptMsg || !btnIdentityPromptYes || !btnIdentityPromptNo) return;
    if (openZoom && cardObj){
      openZoomFromDeckCard(cardObj, cardTheme, { closeOnBackdrop:false, showCloseButton:false });
    }
    pendingIdentityPrompt = {
      onYes: typeof onYes === "function" ? onYes : null,
      onNo: typeof onNo === "function" ? onNo : null,
      closeZoomOnChoice: !!openZoom,
      cardObj: cardObj || null,
      cardTheme: safeText(cardTheme || "white") || "white",
      message: safeText(message || ""),
      canReveal: !!canReveal
    };
    identityPromptMsg.textContent = safeText(message || "");

    btnIdentityPromptYes.classList.toggle("pop-disabled", !canReveal);
    btnIdentityPromptYes.classList.toggle("pop-dark", !!canReveal);
    btnIdentityPromptNo.classList.remove("pop-disabled");
    btnIdentityPromptNo.classList.add("pop-dark");
    btnIdentityPromptYes.disabled = !canReveal;
    btnIdentityPromptNo.disabled = false;

    identityPromptPop.classList.remove("hidden");
    if (openZoom) setZoomPassthrough(true);

    const cardName = safeText(cardObj?.name || "");
    if (IDENTITY_PROMPT_CARD_NAMES.has(cardName)){
      setSeatIdentityPromptState({
        type: "identity_prompt",
        cardName,
        message: safeText(message || ""),
        canReveal: !!canReveal,
        cardTheme: safeText(cardTheme || "white") || "white"
      }).catch(() => {});
    }
  }


  function myRoleInfo(){
    const my = state.hands?.[state.userId];
    return my && my.roleId ? (ROLE_BY_ID[my.roleId] || null) : null;
  }

  function isMyRole(roleId){
    return safeText(state.hands?.[state.userId]?.roleId || "") === safeText(roleId || "");
  }

  function uranusMeteorTargetUids(){
    if (!state.userId) return [];
    const targets = [];
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!uid || uid === state.userId) continue;
      if (!marker || isPlayerEliminated(uid)) continue;
      if (hasGuardianAngelShield(uid)) continue;
      const roomId = markerRoomId(marker);
      if (roomId === 6 || roomId === 7) targets.push(uid);
    }
    return targets;
  }

  function mustResolveUranusMeteorStrike(){
    return false;
  }

  function scheduleVampireHeal(){
    if (!isMyRole("SHA_V2")) return;
    if (vampireHealScheduled) return;
    vampireHealScheduled = true;
    setTimeout(async () => {
      await emitRoleFlashEvent("SHA_V2", "vampire_heal");
      await healDamageToPlayer(state.userId, 2);
    }, 1500);
  }

  function maybeResolveVampireHiddenHealOnReveal(){
    if (!isMyRole("SHA_V2")) return;
    if (!vampireHiddenAttackSuccess) return;
    if (!isMyTurn()) return;
    scheduleVampireHeal();
  }

  function clearCarolTurnHealTimer(){
    if (!carolTurnHealTimer) return;
    clearTimeout(carolTurnHealTimer);
    carolTurnHealTimer = null;
  }

  function scheduleCarolTurnStartHeal(){
    clearCarolTurnHealTimer();
    const key = turnCycleKey();
    if (!key || key === carolTurnHealKey) return;
    if (!isMyTurn() || !isMyRole("CIT_C2") || !isMyIdentityRevealed()) return;
    carolTurnHealKey = key;
    carolTurnHealTimer = setTimeout(async () => {
      carolTurnHealTimer = null;
      if (!isMyTurn() || !isMyRole("CIT_C2") || !isMyIdentityRevealed()) return;
      await emitRoleFlashEvent("CIT_C2", "carol_turn_heal", 1200);
      await healDamageToPlayer(state.userId, 2);
    }, 1000);
  }

  async function emitRoleFlashEvent(roleId, reason = "", durationMs = 1200){
    const rid = safeText(roleId || "");
    if (!state.roomCode || !rid) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/roleFlash`), {
      roleId: rid,
      reason: safeText(reason || ""),
      durationMs: Math.max(100, Number(durationMs) || 1200),
      at: Date.now()
    });
  }

  function attackAbilitySpecFromRows(rows = []){
    const role = myRoleInfo();
    const roleId = safeText(role?.id || "");
    if (!roleId) return null;
    const normalizedRows = Array.isArray(rows)
      ? rows.map(item => ({ uid:safeText(item?.uid || ""), damage:Math.max(0, Number(item?.damage || 0)) })).filter(item => item.uid)
      : [];
    const hasSuccessDamage = normalizedRows.some(item => item.damage > 0);
    const maxDamage = normalizedRows.reduce((max, item) => Math.max(max, Number(item.damage || 0)), 0);
    const attackFailed = normalizedRows.length > 0 && !hasSuccessDamage;

    if (roleId === "CIT_C1" && !isAttackAbilityUsedThisTurn(roleId)){
      return { abilityName:"Ê≠ª„ÅÆÈ•óÂÆ¥", description:"Ëá™ÂàÜ„Å´2„ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Å¶„ÄÅ„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊîªÊíÉ„Åó„Åæ„Åô„Åã„ÄÇ" };
    }
    if (roleId === "CIT_B1" && maxDamage >= 2){
      return { abilityName:"ÂøµÂäõ„ÅÆÊáê‰∏≠ÊôÇË®à", description:"„ÉÄ„É°„Éº„Ç∏„ÅÆ‰ª£„Çè„Çä„Å´Áõ∏Êâã„ÅÆË£ÖÂÇô„Ç´„Éº„Éâ„ÇíÁç≤Âæó„Åó„Åæ„Åô„Åã„ÄÇ" };
    }
    if (roleId === "RAI_F3" && !isMyIdentityRevealed() && pendingAttackResultMeta?.freddieSpecial){
      return { abilityName:"„Éâ„É©„Ç¥„É≥„Ç¢„Çø„ÉÉ„ÇØ", description:"Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Å¶„ÅÑ„ÇãÁõ∏Êâã„Å∏„ÅÆ„ÉÄ„É°„Éº„Ç∏„Åå+2„Å´„Å™„Çä„Åæ„Åô„ÄÇ" };
    }
    if (roleId === "RAI_G2" && hasMyEquipmentByName("„Ç®„ÇØ„Çπ„Ç´„É™„Éê„Éº") && attackFailed){
      return { abilityName:"È≠îÂâ£„ÅÆ‰ºùÊâøËÄÖ", description:"„Ç®„ÇØ„Çπ„Ç´„É™„Éê„Éº„ÇíÊâÄÊúâ„Åó„Å¶„ÅÑ„ÇãÊôÇ„ÄÅÊîªÊíÉ„ÅåÊàêÂäü„Åô„Çã„Åæ„ÅßÊåØ„ÇäÁõ¥„Åô„ÄÇ" };
    }
    if (roleId === "SHA_U3" && !isAttackAbilityUsedThisTurn(roleId)){
      return { abilityName:"„Éá„É´„Éª„Éï„É™„Çπ", description:"„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊîªÊíÉ„ÇíË°å„ÅÑ„Åæ„Åô„Åã„ÄÇ" };
    }
    if (roleId === "SHA_V2" && hasSuccessDamage){
      return { abilityName:"Âê∏Ë°Ä", description:"2„ÉÄ„É°„Éº„Ç∏ÂõûÂæ©„Åß„Åç„Åæ„Åô„ÄÇ" };
    }
    return null;
  }

  function isAttackAbilityUsedThisTurn(roleId){
    const rid = safeText(roleId || "");
    if (!rid) return false;
    return !!attackAbilityUsedTurnByRole?.[rid];
  }

  function markAttackAbilityUsedThisTurn(roleId){
    const rid = safeText(roleId || "");
    if (!rid) return;
    attackAbilityUsageTurnOwnerUid = currentTurnPlayerId();
    const next = { ...(attackAbilityUsedTurnByRole || {}) };
    next[rid] = true;
    attackAbilityUsedTurnByRole = next;
  }

  function resetAttackAbilityUsageTurnState(){
    attackAbilityUsedTurnByRole = {};
    attackAbilityUsageTurnOwnerUid = "";
  }

  function formatAttackAbilityPillLabel(name){
    const raw = safeText(name || "").trim();
    if (!raw) return "";
    return Array.from(raw).length <= 2 ? ` ${raw} ` : raw;
  }

  function primaryAttackTargetUidFromRows(rows = []){
    const list = Array.isArray(rows) ? rows : [];
    for (const item of list){
      const uid = safeText(item?.uid || "");
      if (uid) return uid;
    }
    return "";
  }

  function markerClientPointByUid(uid){
    const marker = markerCache?.[safeText(uid || "")] || null;
    const x = Number(marker?.x);
    const y = Number(marker?.y);
    if (!roomSvg || !Number.isFinite(x) || !Number.isFinite(y)){
      return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    }
    const ctm = roomSvg.getScreenCTM();
    if (!ctm){
      return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    }
    const pt = roomSvg.createSVGPoint();
    pt.x = x;
    pt.y = y;
    const out = pt.matrixTransform(ctm);
    return { x: Number(out.x || (window.innerWidth / 2)), y: Number(out.y || (window.innerHeight / 2)) };
  }

  async function runFollowupAttackToTarget(uid, delayMs = 0){
    const targetUid = safeText(uid || "");
    if (!targetUid) return;
    const wait = Math.max(0, Number(delayMs) || 0);
    if (wait > 0) await waitMs(wait);
    const point = markerClientPointByUid(targetUid);
    attackTurnEndChoicePending = true;
    attackFlowUiLockActive = true;
    renderTurnEndButton();
    await runAttackDiceAnimation(targetUid, point.x, point.y, { force:true, applyDamage:true });
  }

  async function resolveAttackAbilityReveal(role){
    if (!role) return;
    if (!isMyIdentityRevealed()){
      await revealMyIdentityToEquipment({ revealedBy:"attack_ability" });
    } else {
      await emitRoleFlashEvent(role.id, "attack_ability_reveal_repeat", 1500);
    }
  }

  async function startUlsterExtraAttackSelection(){
    if (!state.roomCode) return;
    ulsterExtraAttackPending = Math.max(ulsterExtraAttackPending, 1);
    suppressEndTurnButton = true;
    attackFlowUiLockActive = false;
    await update(ref(db, `rooms/${state.roomCode}/turn`), {
      attackDone: false,
      updatedAt: Date.now()
    });
    showTurnHint("„Éá„É´„Éª„Éï„É™„ÇπÔºö„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊîªÊíÉÂØæË±°„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ", { clearRoom3Skip:true });
    renderTurnEndButton();
  }


  async function emitHpSwapEvent(aUid, bUid){
    const a = safeText(aUid || "");
    const b = safeText(bUid || "");
    if (!state.roomCode || !a || !b || a === b) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/hpSwap`), {
      aUid: a,
      bUid: b,
      at: Date.now()
    });
  }

  async function emitWalpurgisSwapEvent(uidA, uidB, durationMs = 620){
    const a = safeText(uidA || "");
    const b = safeText(uidB || "");
    if (!state.roomCode || !a || !b || a === b) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/walpurgisSwap`), {
      uidA: a,
      uidB: b,
      durationMs: Math.max(240, Number(durationMs) || 620),
      at: Date.now()
    });
  }

  function hideRoleFlashOverlay(){
    if (roleFlashTimer){
      clearTimeout(roleFlashTimer);
      roleFlashTimer = null;
    }
    if (roleFlashOverlayEl){
      roleFlashOverlayEl.remove();
      roleFlashOverlayEl = null;
    }
  }

  function showRoleFlashOverlay(roleId, durationMs = 1200){
    const role = ROLE_BY_ID[safeText(roleId || "")];
    if (!role) return;
    hideRoleFlashOverlay();

    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.inset = "0";
    overlay.style.zIndex = "11000";
    overlay.style.display = "flex";
    overlay.style.alignItems = "center";
    overlay.style.justifyContent = "center";
    overlay.style.background = "transparent";
    overlay.style.pointerEvents = "none";

    const card = createIdentityCard(role);
    card.style.transform = "scale(2.1)";
    card.style.transformOrigin = "center center";
    card.style.boxShadow = "0 14px 32px rgba(0,0,0,.35)";
    overlay.appendChild(card);
    document.body.appendChild(overlay);
    roleFlashOverlayEl = overlay;

    roleFlashTimer = setTimeout(() => {
      hideRoleFlashOverlay();
    }, Math.max(100, Number(durationMs) || 1200));
  }

  function showTemporaryRoleTag(uid, text, durationMs = 2000){
    if (!uid || !text) return;
    const until = Date.now() + Math.max(100, Number(durationMs) || 2000);
    temporaryRoleTagByUid[uid] = { text: safeText(text), until };
    renderPositionLine();
    setTimeout(() => {
      const cur = temporaryRoleTagByUid[uid];
      if (!cur || Number(cur.until || 0) !== until) return;
      delete temporaryRoleTagByUid[uid];
      renderPositionLine();
    }, Math.max(100, Number(durationMs) || 2000));
  }


  function hasAnyEquipment(uid){
    return listEquipForUid(uid).some(v => !isIdentityEquipItem(v));
  }

  function setEffectResolutionLock(lockKey, enabled){
    const key = safeText(lockKey || "");
    if (!key) return;
    if (enabled){
      effectResolutionLocks[key] = true;
    } else {
      delete effectResolutionLocks[key];
    }
  }

  function isEffectResolutionLocked(lockKey){
    const key = safeText(lockKey || "");
    return !!(key && effectResolutionLocks[key]);
  }

  function greenCardConditionMatched(cardObj){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const compactText = text.replace(/[\s„ÄÄ]+/g, "");
    const role = myRoleInfo();
    if (!role) return null;

    if (text.includes("A / B / C / E / U")) return ["A","B","C","E","U"].includes(role.initial) && Number(role.hp) <= 11;
    if (text.includes("D / F / G / V / W")) return ["D","F","G","V","W"].includes(role.initial) && Number(role.hp) >= 12;
    if (compactText.includes("„Ç∑„ÉÅ„Ç∫„É≥„Åã„Ç∑„É£„Éâ„Ç¶")) return role.faction === "„Ç∑„ÉÅ„Ç∫„É≥" || role.faction === "„Ç∑„É£„Éâ„Ç¶";
    if (compactText.includes("„Ç∑„ÉÅ„Ç∫„É≥„Åã„É¨„Ç§„ÉÄ„Éº")) return role.faction === "„Ç∑„ÉÅ„Ç∫„É≥" || role.faction === "„É¨„Ç§„ÉÄ„Éº";
    if (compactText.includes("„É¨„Ç§„ÉÄ„Éº„Åã„Ç∑„É£„Éâ„Ç¶")) return role.faction === "„É¨„Ç§„ÉÄ„Éº" || role.faction === "„Ç∑„É£„Éâ„Ç¶";
    if (text.includes("„Ç∑„É£„Éâ„Ç¶Ôºü")) return role.faction === "„Ç∑„É£„Éâ„Ç¶";
    if (text.includes("„É¨„Ç§„ÉÄ„ÉºÔºü")) return role.faction === "„É¨„Ç§„ÉÄ„Éº";
    if (text.includes("„Ç∑„ÉÅ„Ç∫„É≥Ôºü")) return role.faction === "„Ç∑„ÉÅ„Ç∫„É≥";

    return null;
  }

  function greenAnswerOptions(cardObj){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const matched = greenCardConditionMatched(cardObj);
    const isUlrich = isMyRole("SHA_U1");
    const canJudge = isUlrich ? false : (matched !== null);

    if (text.includes("Ê≠£‰Ωì„Ç´„Éº„Éâ„ÇíË¶ã„Åõ„Çà")){
      return [{ id:"reveal_identity", label:"ÁßÅ„ÅÆÊ≠£‰Ωì„Åß„Åô„ÄÇ", enabled:true }];
    }

    if (text.includes("Ë£ÖÂÇô„ÇíÊ∏°„Åô„Åã„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà")){
      const canEquip = hasAnyEquipment(state.userId);
      return [
        { id:"take_damage", label:"1„ÉÄ„É°„Éº„Ç∏„ÅÜ„Åë„Çã", enabled: canJudge ? !!matched : true },
        { id:"give_equip", label:"Ë£ÖÂÇô„Çí„Çè„Åü„Åô", enabled: canJudge ? (!!matched && canEquip) : canEquip },
        { id:"no", label:"„ÅÑ„ÅÑ„Åà", enabled: canJudge ? !matched : true }
      ];
    }

    if (text.includes("‚ùø„Å´ÁßªÂãï„Åõ„Çà")){
      const nowRoom = markerRoomId(markerCache?.[state.userId]);
      const moveLabel = (nowRoom === 7) ? "1„ÉÄ„É°„Éº„Ç∏„ÅÜ„Åë„Çã" : "‚ûì„Å´ÁßªÂãï„Åô„Çã";
      return [
        { id:"yes", label:moveLabel, enabled: canJudge ? !!matched : true },
        { id:"no", label:"„ÅÑ„ÅÑ„Åà", enabled: canJudge ? !matched : true }
      ];
    }

    if (text.includes("1„ÉÄ„É°„Éº„Ç∏ÂõûÂæ©„Åõ„Çà„ÄÇ„ÉÄ„É°„Éº„Ç∏„Åå0„Å™„Çâ„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà")){
      const nowDamage = clampDamage(damageCache?.[state.userId]);
      const healLabel = (nowDamage <= 0) ? "1„ÉÄ„É°„Éº„Ç∏„ÅÜ„Åë„Çã" : "1„ÉÄ„É°„Éº„Ç∏ÂõûÂæ©„Åô„Çã";
      return [
        { id:"yes", label:healLabel, enabled: canJudge ? !!matched : true },
        { id:"no", label:"„ÅÑ„ÅÑ„Åà", enabled: canJudge ? !matched : true }
      ];
    }

    const damageMatch = text.match(/(\d+)„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà/);
    const damageLabel = damageMatch ? `${damageMatch[1]}„ÉÄ„É°„Éº„Ç∏„ÅÜ„Åë„Çã` : "„ÅØ„ÅÑ";
    return [
      { id:"yes", label:damageLabel, enabled: canJudge ? !!matched : true },
      { id:"no", label:"„ÅÑ„ÅÑ„Åà", enabled: canJudge ? !matched : true }
    ];
  }

  function isRevealIdentityGreenCard(cardObj){
    return safeText(cardObj?.effect || cardObj?.text || "").includes("Ê≠£‰Ωì„Ç´„Éº„Éâ„ÇíË¶ã„Åõ„Çà");
  }

  function hideGreenRevealPanel(){
    if (greenRevealLabel) greenRevealLabel.textContent = "";
    if (greenRevealCardWrap) greenRevealCardWrap.innerHTML = "";
    greenRevealPanel?.classList.add("hidden");
    greenRevealPanel?.classList.remove("reveal-slide-in");
    zoomBackdrop?.classList.remove("green-reveal-active");
  }

  function showGreenRevealPanel(roleId, responderId){
    const role = roleId ? ROLE_BY_ID[roleId] : null;
    if (!role || !greenRevealCardWrap || !greenRevealLabel || !greenRevealPanel) return;
    greenRevealCardWrap.innerHTML = "";
    greenRevealCardWrap.appendChild(createIdentityCard(role));
    const me = safeText(state.userId || "");
    const label = (safeText(responderId || "") === me) ? "ÁßÅ„ÅÆÊ≠£‰Ωì„Åß„Åô„ÄÇ" : "ÈÅ∏Êäû„Åó„Åü„Éó„É¨„Ç§„É§„Éº„ÅÆÊ≠£‰Ωì";
    greenRevealLabel.textContent = label;
    greenRevealPanel.classList.remove("hidden");
    zoomBackdrop?.classList.add("green-reveal-active");
    greenRevealPanel.classList.remove("reveal-slide-in");
    requestAnimationFrame(() => {
      greenRevealPanel.classList.add("reveal-slide-in");
    });
  }

  async function sendGreenResponse(msg, opt, overrideLabel=""){
    if (!state.roomCode || !msg?.from || !msg?.requestId || !opt?.id) return;
    const answerLabel = safeText(overrideLabel || opt.label || "");
    let requesterUid = safeText(msg.from || "");
    try {
      const reqSnap = await get(ref(db, `rooms/${state.roomCode}/greenRequests/${msg.requestId}`));
      const req = reqSnap.val() || null;
      if (req?.from) requesterUid = safeText(req.from || requesterUid);
    } catch (_) {}
    if (!requesterUid) return;
    await set(ref(db, `rooms/${state.roomCode}/greenResponses/${requesterUid}`), {
      from: requesterUid,
      to: state.userId,
      requestId: msg.requestId,
      answerId: opt.id,
      answerLabel,
      card: msg.card,
      at: Date.now()
    });
    await set(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${msg.requestId}`), {
      from: msg.from,
      responderId: state.userId,
      requestId: msg.requestId,
      answerLabel,
      at: Date.now()
    });
    await remove(ref(db, `rooms/${state.roomCode}/greenInbox/${state.userId}`)).catch(() => {});
  }

  async function applyGreenAnswerEffect(msg, opt){
    const text = safeText(msg?.card?.effect || msg?.card?.text || "");

    if (opt?.id === "take_damage"){
      setTimeout(() => { addDamageToPlayer(state.userId, 1); }, 1000);
      return;
    }

    const isPositive = (opt?.id === "yes" || opt?.id === "reveal_identity");
    if (!isPositive) return;

    if (text.includes("1„ÉÄ„É°„Éº„Ç∏ÂõûÂæ©„Åõ„Çà„ÄÇ„ÉÄ„É°„Éº„Ç∏„Åå0„Å™„Çâ„ÄÅ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà")){
      setTimeout(() => {
        const cur = clampDamage(damageCache?.[state.userId]);
        if (cur <= 0) addDamageToPlayer(state.userId, 1);
        else healDamageToPlayer(state.userId, 1);
      }, 1000);
    } else if (!text.includes("‚ùø„Å´ÁßªÂãï„Åõ„Çà")) {
      const damageMatch = text.match(/(\d+)„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çà/);
      const damage = damageMatch ? Number(damageMatch[1] || 0) : 0;
      if (damage > 0){
        setTimeout(() => { addDamageToPlayer(state.userId, damage); }, 1000);
      }
    }

    if (text.includes("‚ùø„Å´ÁßªÂãï„Åõ„Çà")){
      setTimeout(() => {
        const nowRoom = markerRoomId(markerCache?.[state.userId]);
        if (nowRoom === 7) addDamageToPlayer(state.userId, 1);
        else placePlayerMarkerInRoom(state.userId, 7);
      }, 1000);
    }

    if (text.includes("Ê≠£‰Ωì„Ç´„Éº„Éâ„ÇíË¶ã„Åõ„Çà")){
      const roleId = safeText(state.hands?.[state.userId]?.roleId || "");
      if (roleId){
        await set(ref(db, `rooms/${state.roomCode}/greenReveals/${msg.requestId}`), {
          requestId: msg.requestId,
          from: msg.from,
          responderId: state.userId,
          roleId,
          at: Date.now()
        });
        showGreenRevealPanel(roleId, state.userId);
      }
    }
  }

  function restoreGreenGiveZoomSelection(action){
    if (!action?.cardObj) return;
    openZoomFromDeckCard(action.cardObj, "green", { closeOnBackdrop:false, showCloseButton:false });
    greenShareDock?.classList.remove("over-equip-expand");
    greenShareDock?.classList.add("hidden");
    setZoomPassthrough(true);
    pendingEquipAction = action;
    renderEquipmentDock();
  }

  function setGreenDockMeta({ title="", subtitle="" } = {}){
    const titleEl = greenShareDock?.querySelector(".green-share-title");
    if (titleEl) titleEl.innerHTML = title;
    if (greenShareSubtitle){
      greenShareSubtitle.textContent = subtitle || "";
      greenShareSubtitle.classList.toggle("hidden", !subtitle);
    }
  }

  async function setGreenSessionState(payload){
    if (greenSessionRestoring) return;
    if (!state.roomCode || !state.userId) return;
    const gsRef = ref(db, `rooms/${state.roomCode}/greenSessions/${state.userId}`);
    if (!payload){
      await remove(gsRef);
      return;
    }
    await set(gsRef, {
      ...payload,
      uid: state.userId,
      at: Date.now()
    });
  }

  async function setRoleAbilitySelectionState(payload){
    if (!state.roomCode || !state.userId) return;
    const sessionRef = ref(db, `rooms/${state.roomCode}/roleAbilitySelection`);
    if (!payload){
      await remove(sessionRef).catch(() => {});
      return;
    }
    await set(sessionRef, {
      ...payload,
      at: Date.now()
    });
  }

  function roleSelectionTargetPlayers(entry){
    const roleId = safeText(entry?.roleId || "");
    const actorUid = safeText(entry?.actorUid || "");
    const actorRoom = markerRoomId(markerCache?.[actorUid]);
    const alive = latestPlayers.filter(p => !isPlayerEliminated(p.id));
    const eliminated = latestPlayers.filter(p => isPlayerEliminated(p.id));
    if (roleId === "RAI_F2") return alive;
    if (roleId === "RAI_E3") return alive.filter(p => p.id !== actorUid && markerRoomId(markerCache?.[p.id]) === actorRoom);
    if (roleId === "RAI_G3") return eliminated.filter(p => p.id !== actorUid);
    if (roleId === "SHA_U2") return alive.filter(p => p.id !== actorUid && [6,7].includes(markerRoomId(markerCache?.[p.id])));
    return alive.filter(p => p.id !== actorUid);
  }

  function buildRoleSelectionMessage(roleId){
    const spec = roleSelectionSpec(roleId);
    if (!spec) return "";
    return `<span class="ability-pill">${escapeHtml(spec.abilityName)}</span>${escapeHtml(spec.prompt)}`;
  }

  function canStartRoleSelection(roleId, actorUid){
    const entry = { roleId, actorUid };
    const candidates = roleSelectionTargetPlayers(entry);
    return candidates.length > 0;
  }

  function isCornerRoomForEmma(roomId){
    const rid = Number(roomId || 0);
    return [1,3,5,7].includes(rid);
  }

  function emmaAbilityAvailability(){
    if (!isMyRole("RAI_E3")) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (!isMyTurn()) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (!isMyIdentityRevealed()) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (!turnState()?.moveDone) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (isRoleAbilityUsed("RAI_E3")) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (!canStartRoleSelection("RAI_E3", state.userId)) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    return { ok:true };
  }

  function uranusAbilityAvailability(){
    if (!isMyRole("SHA_U2")) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (!isMyTurn()) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (!isMyIdentityRevealed()) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (isRoleAbilityUsed("SHA_U2")) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    if (!canStartRoleSelection("SHA_U2", state.userId)) return { ok:false, message:"‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" };
    return { ok:true };
  }

  async function completeRoleAbilitySelection(entry, targetUid){
    const actorUid = safeText(entry?.actorUid || "");
    const roleId = safeText(entry?.roleId || "");
    const selectedUid = safeText(targetUid || "");
    if (!actorUid || !roleId || actorUid !== state.userId || !selectedUid) return;

    if (roleId === "RAI_F2"){
      await setDamageToPlayer(selectedUid, 7);
    } else if (roleId === "RAI_F1"){
      const eye = 1 + Math.floor(Math.random() * 6);
      await emitCardDiceEvent({ kind:"role_felix", uid: actorUid, d6: eye });
      await waitMs(1000);
      await addDamageToPlayer(selectedUid, eye);
    } else if (roleId === "RAI_E3"){
      const eye = 1 + Math.floor(Math.random() * 4);
      await emitCardDiceEvent({ kind:"role_emma", uid: actorUid, d4: eye });
      await waitMs(1000);
      await healDamageToPlayer(selectedUid, eye);
      await update(ref(db, `rooms/${state.roomCode}/turn`), {
        attackDone: true,
        deckDrawDone: true,
        updatedAt: Date.now()
      });
    } else if (roleId === "RAI_G3"){
      await setDamageToPlayer(selectedUid, 7);
      await update(ref(db, `rooms/${state.roomCode}`), {
        [`markers/${selectedUid}`]: null
      });
    } else if (roleId === "SHA_U2"){
      await addDamageToPlayer(selectedUid, 3);
      uranusMeteorResolved = true;
    } else if (roleId === "CIT_C3"){
      const me = clampDamage(damageCache?.[actorUid]);
      const target = clampDamage(damageCache?.[selectedUid]);
      pendingHpSwapAnimation = { aUid: actorUid, bUid: selectedUid, at: Date.now() };
      const roomRef = ref(db, `rooms/${state.roomCode}`);
      await runTransaction(roomRef, (cur) => {
        if (!cur) return cur;
        cur.damage = cur.damage || {};
        const curMe = clampDamage(cur.damage?.[actorUid]);
        const curTarget = clampDamage(cur.damage?.[selectedUid]);
        cur.damage[actorUid] = curTarget;
        cur.damage[selectedUid] = curMe;
        return cur;
      });
      if (me === target){
        pendingHpSwapAnimation = null;
      }
      await emitHpSwapEvent(actorUid, selectedUid);
    }

    await markRoleAbilityUsed(roleId);
    await setRoleAbilitySelectionState(null);
    if (roleId === "RAI_E3" && !!entry?.endTurnAfterResolve){
      await doEndTurn();
    }
  }

  function openRoleAbilitySelectionUI(entry){
    const roleId = safeText(entry?.roleId || "");
    const actorUid = safeText(entry?.actorUid || "");
    let selectionBusy = false;
    const role = ROLE_BY_ID[roleId];
    if (!role) return;
    activeRoleAbilitySelection = entry;
    const isActor = actorUid === state.userId;
    if (!!entry?.privateToActor && !isActor){
      greenShareDock?.classList.add("hidden");
      return;
    }
    openIdentityRevealZoom(role, actorUid, { persist:true });
    setZoomPassthrough(true);
    if (!isActor){
      greenShareDock?.classList.add("hidden");
      return;
    }
    const candidates = roleSelectionTargetPlayers(entry);
    if (candidates.length === 0){
      setRoleAbilitySelectionState(null).catch(() => {});
      showRevealPopAt(null, { mode:"notice", message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
      return;
    }
    setGreenDockMeta({ title:"", subtitle:"" });
    if (greenShareList) greenShareList.innerHTML = "";
    if (!greenShareList || !greenShareDock) return;
    const text = buildRoleSelectionMessage(roleId);
    setGreenDockMeta({ title:text, subtitle:"" });
    const lockRoleSelectionButtons = () => {
      if (!greenShareList) return;
      greenShareList.querySelectorAll("button").forEach((el) => {
        el.disabled = true;
        el.style.pointerEvents = "none";
      });
    };
    for (const p of candidates){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      const chip = buildChipFor(p.id);
      const label = document.createElement("span");
      label.textContent = nameFromSecondChar(p.name || "");
      btn.appendChild(chip);
      btn.appendChild(label);
      btn.addEventListener("click", () => {
        if (selectionBusy) return;
        showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, `„Äå${safeText(p.name || "„Åì„ÅÆ„Éó„É¨„Ç§„É§„Éº")}„Äç„ÇíÈÅ∏„Å≥„Åæ„Åô„Åã„ÄÇ`, async () => {
          if (selectionBusy) return;
          selectionBusy = true;
          lockRoleSelectionButtons();
          await completeRoleAbilitySelection(entry, p.id);
        }, { fixedLower:true, noCaret:true });
      });
      greenShareList.appendChild(btn);
    }
    if (roleId === "RAI_E3" || roleId === "SHA_U2"){
      const skipBtn = document.createElement("button");
      skipBtn.type = "button";
      skipBtn.className = "green-share-btn";
      skipBtn.textContent = "‰Ωø„Çè„Å™„ÅÑ";
      const spec = roleSelectionSpec(roleId);
      const disableSkip = !!entry?.justRevealed;
      if (disableSkip){
        skipBtn.style.opacity = "0.45";
        skipBtn.style.cursor = "not-allowed";
      }
      skipBtn.addEventListener("click", () => {
        if (disableSkip || selectionBusy) return;
        const abilityName = safeText(spec?.abilityName || "ËÉΩÂäõ");
        showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "", async () => {
          if (selectionBusy) return;
          selectionBusy = true;
          lockRoleSelectionButtons();
          await setRoleAbilitySelectionState(null);
          if (roleId === "RAI_E3" && !!entry?.endTurnAfterResolve){
            await doEndTurn();
          }
        }, {
          messageHtml: `<span class="ability-pill">${escapeHtml(abilityName)}</span>„Çí‰Ωø„ÅÑ„Åæ„Åõ„Çì„Åã„ÄÇ`,
          yesLabel: "„ÅØ„ÅÑ",
          noLabel: "„ÅÑ„ÅÑ„Åà",
          fixedLower:true,
          noCaret:true,
          dismissOnOutside:true
        });
      });
      greenShareList.appendChild(skipBtn);
    }
    greenShareActions?.classList.add("hidden");
    greenShareDock.classList.remove("hidden");
    cardPlayerSelectActive = true;
    updateCardInteractivity();
    renderTurnEndButton();
  }

  async function setCardTargetSessionState(payload){
    if (cardTargetSessionRestoring) return;
    if (!state.roomCode || !state.userId) return;
    const sessionRef = ref(db, `rooms/${state.roomCode}/cardTargetSessions/${state.userId}`);
    if (!payload){
      pendingCardTargetSessionEntry = null;
      await remove(sessionRef);
      return;
    }
    const at = Date.now();
    cardTargetSessionSeenAt = Math.max(cardTargetSessionSeenAt, at);
    await set(sessionRef, {
      ...payload,
      uid: state.userId,
      at
    });
  }

  function currentMySeatIndex(){
    const fromPlayers = latestPlayers.find(p => p.id === state.userId);
    if (fromPlayers?.seatIndex) return Number(fromPlayers.seatIndex || 0);
    const tables = state.room?.tables || {};
    for (const [seatIndex, t] of Object.entries(tables)){
      if (t && safeText(t.playerId || "") === safeText(state.userId || "")) return Number(seatIndex || 0);
    }
    return Number(state.seatedTable || 0);
  }

  function renderGreenWaitingSelection(toUid, toName="", toInitial="", toColor=""){
    if (!greenShareList) return;
    greenShareList.innerHTML = "";
    const selected = document.createElement("button");
    selected.type = "button";
    selected.className = "green-share-btn waiting-selected";
    selected.setAttribute("aria-disabled", "true");
    selected.style.pointerEvents = "none";
    const targetPlayer = toUid ? playerById(toUid) : null;
    if (targetPlayer){
      selected.appendChild(buildChipFor(toUid));
    } else if (toUid || toName){
      const fallback = document.createElement("div");
      fallback.className = "chip16";
      const chipColor = safeText(toColor || "") || "#ddd";
      const chipInitial = firstChar(safeText(toInitial || "") || safeText(toName || ""));
      fallback.style.background = chipColor;
      fallback.style.color = textColorFor(chipColor);
      fallback.textContent = chipInitial || "";
      fallback.title = safeText(toName || "");
      selected.appendChild(fallback);
    }
    const name = document.createElement("span");
    if (toUid){
      name.textContent = targetPlayer ? nameFromSecondChar(targetPlayer.name) : safeText(toName || "");
    } else {
      name.textContent = safeText(toName || "");
    }
    selected.appendChild(name);
    greenShareList.appendChild(selected);
  }

  function openTargetSelectDock({ title="ÂØæË±°„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏Êäû", includeSelf=false, onlyAlive=false, onSelect=null, nameSuffixForUid=null, lockEndTurnUntilResolved=false, overEquipExpand=false } = {}){
    if (!greenShareDock || !greenShareList) return;
    const mySeat = currentMySeatIndex();
    const players = latestPlayers
      .filter(p => includeSelf || (p.id !== state.userId && Number(p.seatIndex || 0) !== mySeat))
      .filter(p => !isPlayerEliminated(p.id))
      .filter(p => !onlyAlive || !isPlayerEliminated(p.id))
      .sort((a,b) => Number(a.seatIndex||999)-Number(b.seatIndex||999));
    if (players.length === 0){
      cardPlayerSelectActive = false;
      updateCardInteractivity();
      renderTurnEndButton();
      return false;
    }

    let selected = false;
    greenShareDock?.classList.toggle("over-equip-expand", !!overEquipExpand);
    setGreenDockMeta({ title, subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";

    for (const p of players){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      const chip = buildChipFor(p.id);
      const name = document.createElement("span");
      const suffix = (typeof nameSuffixForUid === "function") ? safeText(nameSuffixForUid(p.id, p) || "") : "";
      name.textContent = `${nameFromSecondChar(p.name)}${suffix}`;
      btn.appendChild(chip);
      btn.appendChild(name);
      btn.addEventListener("click", async () => {
        if (selected) return;
        selected = true;
        if (greenShareDock) greenShareDock.classList.add("hidden");
        if (!lockEndTurnUntilResolved){
          cardPlayerSelectActive = false;
          updateCardInteractivity();
          renderTurnEndButton();
        }
        const handler = (typeof onSelect === "function") ? onSelect : null;
        try {
          if (handler) await handler(p.id, p);
        } finally {
          if (lockEndTurnUntilResolved){
            cardPlayerSelectActive = false;
            updateCardInteractivity();
            renderTurnEndButton();
          }
        }
      });
      greenShareList.appendChild(btn);
    }

    cardPlayerSelectActive = true;
    updateCardInteractivity();
    renderTurnEndButton();
    greenShareDock.classList.remove("hidden");
    return true;
  }

  function cardTargetSelectionSpec(cardObj){
    const name = safeText(cardObj?.name || "");
    if (!name) return null;
    if (name === "ÂøúÊÄ•ÊâãÂΩì"){
      return {
        theme:"white",
        title:"ÂøúÊÄ•ÊâãÂΩìÔºöÂØæË±°„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        includeSelf:true,
        instantCloseOnSelect:true,
        resolver: async (uid) => {
          await waitMs(1000);
          await setDamageToPlayer(uid, 7);
        }
      };
    }
    if (name === "ÊÅ©ÊÅµ"){
      return {
        theme:"white",
        title:"ÊÅ©ÊÅµÔºöÂõûÂæ©„Åï„Åõ„Çã„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ") ? "üè∫" : "",
        resolver: async (uid) => {
          const eye = 1 + Math.floor(Math.random() * 6);
          await emitCardDiceEvent({ kind:"blessing", uid:state.userId, d6:eye });
          await runCornerD6Roll(eye);
          await waitMs(1000);
          await healDamageToPlayer(uid, eye);
        }
      };
    }
    if (name === "Âê∏Ë°Ä„Ç≥„Ç¶„É¢„É™"){
      return {
        theme:"black",
        title:"Âê∏Ë°Ä„Ç≥„Ç¶„É¢„É™ÔºöÂØæË±°„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ") ? "üè∫" : "",
        resolver: async (uid) => {
          await waitMs(1000);
          if (!hasEquipmentByName(uid, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ")){
            await addDamageToPlayer(uid, 2);
          }
          await healDamageToPlayer(state.userId, 1);
        }
      };
    }
    if (name === "‰∏â„Å§ÁõÆ„ÅÆÈªíÁä¨"){
      return {
        theme:"black",
        title:"‰∏â„Å§ÁõÆ„ÅÆÈªíÁä¨ÔºöÂØæË±°„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        onlyAlive:true,
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ") ? "üè∫" : "",
        resolver: async (uid) => {
          await waitMs(1000);
          const targetHasChalice = hasEquipmentByName(uid, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ");
          const myHasChalice = hasEquipmentByName(state.userId, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ");
          if (!targetHasChalice) await addDamageToPlayer(uid, 2);
          if (!myHasChalice) await addDamageToPlayer(state.userId, 2);
        }
      };
    }
    if (name === "Âë™„ÅÑ„ÅÆ‰∫∫ÂΩ¢"){
      return {
        theme:"black",
        title:"Âë™„ÅÑ„ÅÆ‰∫∫ÂΩ¢ÔºöÂØæË±°„Éó„É¨„Ç§„É§„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        onlyAlive:true,
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ") ? "üè∫" : "",
        resolver: async (uid) => {
          const eye = 1 + Math.floor(Math.random() * 6);
          await emitCardDiceEvent({ kind:"curse_doll", uid: state.userId, d6: eye });
          await waitMs(1000);
          if (eye <= 4){
            if (!hasEquipmentByName(uid, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ")) await addDamageToPlayer(uid, 3);
          } else if (!hasEquipmentByName(state.userId, "„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ")){
            await addDamageToPlayer(state.userId, 3);
          }
        }
      };
    }
    return null;
  }

  async function resolveCardTargetSessionEntry(entry){
    const card = entry?.card || null;
    const targetUid = safeText(entry?.targetUid || "");
    const spec = cardTargetSelectionSpec(card);
    if (!spec || !targetUid){
      await setCardTargetSessionState(null);
      return;
    }
    if (spec.instantCloseOnSelect){
      try {
        await spec.resolver(targetUid);
      } finally {
        pendingCardTargetSelection = null;
        cardPlayerSelectActive = false;
        updateCardInteractivity();
        renderTurnEndButton();
        await setCardTargetSessionState(null);
        greenShareDock?.classList.add("hidden");
        closeZoom();
      }
      return;
    }
    openZoomFromDeckCard(card, spec.theme, { closeOnBackdrop:false, showCloseButton:false });
    setGreenDockMeta({ title:`${safeText(card?.name || "") }ÔºöÂäπÊûú„ÇíÂá¶ÁêÜ‰∏≠„Åß„Åô„ÄÇ`, subtitle:"" });
    greenShareActions?.classList.add("hidden");
    renderGreenWaitingSelection(targetUid, safeText(entry?.targetName || ""), safeText(entry?.targetInitial || ""), safeText(entry?.targetColor || ""));
    greenShareDock?.classList.remove("hidden");
    cardPlayerSelectActive = true;
    updateCardInteractivity();
    renderTurnEndButton();
    try {
      await spec.resolver(targetUid);
    } finally {
      pendingCardTargetSelection = null;
      cardPlayerSelectActive = false;
      updateCardInteractivity();
      renderTurnEndButton();
      await setCardTargetSessionState(null);
      greenShareDock?.classList.add("hidden");
      closeZoom();
    }
  }

  async function openPersistentCardTargetSelection(cardObj, { restore=false } = {}){
    const spec = cardTargetSelectionSpec(cardObj);
    if (!spec) return false;
    openZoomFromDeckCard(cardObj, spec.theme, { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(true);
    pendingCardTargetSelection = { cardObj };
    const opened = openTargetSelectDock({
      title: spec.title,
      lockEndTurnUntilResolved: true,
      includeSelf: !!spec.includeSelf,
      onlyAlive: !!spec.onlyAlive,
      nameSuffixForUid: spec.nameSuffixForUid,
      onSelect: async (uid, player) => {
        if (spec.instantCloseOnSelect){
          greenShareDock?.classList.add("hidden");
          cardPlayerSelectActive = false;
          updateCardInteractivity();
          renderTurnEndButton();
          closeZoom();
        }
        await setCardTargetSessionState({
          phase:"resolving",
          card: cardObj,
          targetUid: safeText(uid || ""),
          targetName: safeText(player?.name || ""),
          targetInitial: firstChar(player?.name || ""),
          targetColor: safeText(player?.color || "")
        });
        try {
          await spec.resolver(uid);
        } finally {
          pendingCardTargetSelection = null;
          await setCardTargetSessionState(null);
          closeZoom();
        }
      }
    });

    if (!opened){
      pendingCardTargetSelection = null;
      await setCardTargetSessionState(null);
      closeZoom();
      return false;
    }

    if (!restore){
      await setCardTargetSessionState({
        phase:"selecting",
        card: cardObj
      });
    }
    return true;
  }

  function openGreenShareDock(cardObj, { attackRangeOnly=false } = {}){
    greenShareCard = cardObj || null;
    if (!greenShareCard || !greenShareDock || !greenShareList){
      greenShareDock?.classList.add("hidden");
      return;
    }

    setGreenDockMeta({ title:"Ë™∞„Å´Ê∏°„Åó„Åæ„Åô„Åã„ÄÇ", subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";
    const mySeat = currentMySeatIndex();
    const attackRangeTargetUids = attackRangeOnly ? attackRangeTargetUidsFor(state.userId) : null;
    const players = latestPlayers
      .filter(p => p.id !== state.userId && Number(p.seatIndex || 0) !== mySeat)
      .filter(p => !attackRangeOnly || (attackRangeTargetUids instanceof Set && attackRangeTargetUids.has(p.id)))
      .filter(p => !isPlayerEliminated(p.id))
      .sort((a,b) => Number(a.seatIndex||999)-Number(b.seatIndex||999));

    for (const p of players){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      btn.title = `${safeText(p.name)} „Å´Ê∏°„Åô`;

      const chip = buildChipFor(p.id);
      const name = document.createElement("span");
      name.textContent = nameFromSecondChar(p.name);
      btn.appendChild(chip);
      btn.appendChild(name);

      btn.addEventListener("click", async () => {
        if (!greenShareCard || !state.roomCode || !p?.id) return;
        const requestId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        const payload = {
          from: state.userId,
          to: p.id,
          requestId,
          card: greenShareCard,
          at: Date.now()
        };
        await set(ref(db, `rooms/${state.roomCode}/greenRequests/${requestId}`), payload);
        await set(ref(db, `rooms/${state.roomCode}/greenInbox/${p.id}`), payload);
        if (isRevealIdentityGreenCard(greenShareCard)){
          await set(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${requestId}`), {
            from: state.userId,
            responderId: p.id,
            requestId,
            answerLabel: "ÁßÅ„ÅÆÊ≠£‰Ωì„Åß„Åô„ÄÇ",
            at: Date.now()
          });
          setGreenDockMeta({ title:"ÂõûÁ≠î„ÅåÂ±ä„Åç„Åæ„Åó„Åü", subtitle:"ÁßÅ„ÅÆÊ≠£‰Ωì„Åß„Åô„ÄÇ" });
          greenShareActions?.classList.remove("hidden");
        }

        pendingGreenRequestId = requestId;
        renderGreenWaitingSelection(p.id, p.name, firstChar(p.name || ""), safeText(p.color || ""));
        if (!isRevealIdentityGreenCard(greenShareCard)){
          setGreenDockMeta({ title:"ÂõûÁ≠îÂæÖ„Å°...", subtitle:"" });
          greenShareActions?.classList.add("hidden");
        }
        setGreenSessionState({
          phase: isRevealIdentityGreenCard(greenShareCard) ? "confirm" : "waiting",
          card: greenShareCard,
          requestId,
          toUid: p.id,
          toName: safeText(p.name || ""),
          toInitial: firstChar(p.name || ""),
          toColor: safeText(p.color || ""),
          answerLabel: isRevealIdentityGreenCard(greenShareCard) ? "ÁßÅ„ÅÆÊ≠£‰Ωì„Åß„Åô„ÄÇ" : ""
        }).catch(() => {});
      });

      greenShareList.appendChild(btn);
    }
    greenShareDock.classList.remove("hidden");
    setGreenSessionState({ phase:"selecting", card:greenShareCard, attackRangeOnly: !!attackRangeOnly }).catch(() => {});
  }

  function openGreenAnswerDock(msg){
    if (!greenShareDock || !greenShareList || !msg?.card) return;
    greenShareCard = msg.card;
    pendingGreenAnswerMsg = msg;
    setGreenSessionState({ phase:"answering", msg }).catch(() => {});
    const reveal = greenRevealByRequestId[safeText(msg.requestId || "")];
    if (reveal?.roleId){
      showGreenRevealPanel(reveal.roleId, reveal.responderId);
    } else {
      hideGreenRevealPanel();
    }
    const cardText = safeText(msg.card.effect || "");
    const isRevealIdentity = isRevealIdentityGreenCard(msg.card);
    setGreenDockMeta({
      title: isRevealIdentity ? "Ë≥™Âïè„ÅåÂ±ä„Åç„Åæ„Åó„Åü" : "ÂõûÁ≠î„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ",
      subtitle:cardText
    });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";

    if (isRevealIdentity){
      const requestId = safeText(msg.requestId || "");
      const reveal = greenRevealByRequestId[requestId];
      if (!reveal?.roleId){
        applyGreenAnswerEffect(msg, { id:"reveal_identity", label:"ÁßÅ„ÅÆÊ≠£‰Ωì„Åß„Åô„ÄÇ" }).catch(() => {});
      }
      remove(ref(db, `rooms/${state.roomCode}/greenInbox/${state.userId}`)).catch(() => {});
      greenShareDock.classList.remove("hidden");
      return;
    }

    const isUlrich = isMyRole("SHA_U1");
    for (const opt of greenAnswerOptions(msg.card)){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn answer";
      btn.textContent = opt.label;
      const canUlrichGiveEquip = (opt.id !== "give_equip") || hasAnyEquipment(state.userId);
      btn.disabled = !opt.enabled || (isUlrich && !canUlrichGiveEquip);
      btn.addEventListener("click", async () => {
        if (!state.roomCode || !msg?.from || !msg?.requestId) return;

        if (opt.id === "give_equip"){
          const myItems = listEquipForUid(state.userId).filter(it => !isIdentityEquipItem(it));
          if (myItems.length === 0) return;
          const action = {
            type:"green_give",
            fromUid: state.userId,
            toUid: msg.from,
            requestId: msg.requestId,
            cardObj: msg.card,
            answerOpt: opt
          };
          restoreGreenGiveZoomSelection(action);
          return;
        }

        await applyGreenAnswerEffect(msg, opt);
        await sendGreenResponse(msg, opt);
        await setGreenSessionState(null);
        closeZoom();
      });
      greenShareList.appendChild(btn);
    }
    greenShareDock.classList.remove("hidden");
  }

  function hideGreenShareDock(){
    if (activeRoleAbilitySelection) return;
    greenShareCard = null;
    pendingGreenRequestId = "";
    pendingGreenAnswerMsg = null;
    hideGreenRevealPanel();
    if (greenShareList) greenShareList.innerHTML = "";
    setGreenDockMeta({ title:"Ë™∞„Å´Ê∏°„Åó„Åæ„Åô„Åã„ÄÇ", subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareDock?.classList.remove("over-equip-expand");
    greenShareDock?.classList.add("hidden");
    cardPlayerSelectActive = false;
    updateCardInteractivity();
    renderTurnEndButton();
    setGreenSessionState(null).catch(() => {});
    pendingGreenSessionEntry = null;
  }

  function restoreGreenSessionUI(entry){
    const phase = safeText(entry?.phase || "");
    if (!phase) return;
    greenSessionRestoring = true;
    try {
      if (phase === "answering" && entry?.msg?.card){
        openZoomFromDeckCard(entry.msg.card, "green", { closeOnBackdrop:false, showCloseButton:false });
        openGreenAnswerDock(entry.msg);
        return;
      }
      if (!entry?.card) return;
      openZoomFromDeckCard(entry.card, "green", { closeOnBackdrop:false, showCloseButton:false });
      greenShareCard = entry.card;
      if (phase === "selecting"){
        openGreenShareDock(entry.card, { attackRangeOnly: !!entry.attackRangeOnly });
        return;
      }

      if (!greenShareDock || !greenShareList) return;
      greenShareDock.classList.remove("hidden");
      greenShareActions?.classList.add("hidden");
      pendingGreenRequestId = safeText(entry.requestId || "");
      renderGreenWaitingSelection(safeText(entry.toUid || ""), safeText(entry.toName || ""), safeText(entry.toInitial || ""), safeText(entry.toColor || ""));
      const restoreReveal = greenRevealByRequestId[pendingGreenRequestId];
      if (restoreReveal?.roleId){
        showGreenRevealPanel(restoreReveal.roleId, restoreReveal.responderId);
      } else {
        hideGreenRevealPanel();
      }
      if (phase === "confirm"){
        setGreenDockMeta({ title:"ÂõûÁ≠î„ÅåÂ±ä„Åç„Åæ„Åó„Åü", subtitle:safeText(entry.answerLabel || "") });
        greenShareActions?.classList.remove("hidden");
      } else {
        setGreenDockMeta({ title:"ÂõûÁ≠îÂæÖ„Å°...", subtitle:"" });
        greenShareActions?.classList.add("hidden");
        syncGreenResponseForPendingRequest(pendingGreenRequestId).catch(() => {});
      }
    } finally {
      greenSessionRestoring = false;
    }
  }

  async function syncGreenResponseForPendingRequest(requestId){
    const rid = safeText(requestId || "");
    if (!state.roomCode || !state.userId || !rid) return;
    const snap = await get(ref(db, `rooms/${state.roomCode}/greenResponses/${state.userId}`));
    const msg = snap.val() || null;
    if (!msg || safeText(msg.requestId || "") !== rid) return;
    setGreenDockMeta({ title:"ÂõûÁ≠î„ÅåÂ±ä„Åç„Åæ„Åó„Åü", subtitle:safeText(msg.answerLabel || "") });
    const reveal = greenRevealByRequestId[rid];
    if (reveal?.roleId){
      showGreenRevealPanel(reveal.roleId, reveal.responderId);
    }
    greenShareActions?.classList.remove("hidden");
    const responder = playerById(safeText(msg.to || ""));
    await setGreenSessionState({
      phase:"confirm",
      card: greenShareCard || msg.card || null,
      requestId: rid,
      toUid: safeText(msg.to || ""),
      toName: safeText(responder?.name || ""),
      toInitial: firstChar(responder?.name || ""),
      toColor: safeText(responder?.color || ""),
      answerLabel: safeText(msg.answerLabel || "")
    });
  }

  async function clearPendingGreenBubble(){
    if (!state.roomCode || !pendingGreenRequestId) return;
    const bubbleId = pendingGreenRequestId;
    const bRef = ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${bubbleId}`);
    await remove(bRef).catch(() => {});
    pendingGreenRequestId = "";
  }

  async function notifyGreenCloseToResponder(){
    if (!state.roomCode || !pendingGreenRequestId) return;
    const requestId = safeText(pendingGreenRequestId);
    if (!requestId) return;
    const reveal = greenRevealByRequestId[requestId];
    const responderId = safeText(reveal?.responderId || "");
    if (!responderId || responderId === state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/greenCloseSignals/${responderId}`), {
      requestId,
      from: state.userId,
      at: Date.now()
    });
  }

  greenShareCloseBtn?.addEventListener("click", async () => {
    await notifyGreenCloseToResponder();
    await clearPendingGreenBubble();
    closeZoom();
  });

  function openZoomContent(contentEl, { closeOnBackdrop=true, showCloseButton=true, closeOnAnyClick=false, stageClass="" } = {}){
    zoomStage.innerHTML = "";
    zoomStage.classList.remove("zoom-stage-multi");
    if (stageClass) zoomStage.classList.add(stageClass);
    hideGreenRevealPanel();
    zoomCloseOnBackdrop = !!closeOnBackdrop;
    zoomCloseOnAnyClick = !!closeOnAnyClick;
    zoomPassthroughMode = false;
    zoomDismissHandler = null;
    zoomBackdrop.classList.remove("passthrough");
    zoomBackdrop.classList.remove("over-panel");
    greenZoomLocked = !showCloseButton;
    zoomStage.appendChild(contentEl);
    zoomBackdrop.classList.remove("hidden");
    refreshEquipDockLayer();
  }

  function isDeductionZoomActive(){
    if (zoomBackdrop?.classList.contains("hidden")) return false;
    return !!zoomStage?.querySelector('.card72.wb-front[data-card-type="green"]');
  }

  function refreshEquipDockLayer(){
    equipDock?.classList.toggle("deduction-front", isDeductionZoomActive());
  }

  function setZoomPassthrough(enabled){
    zoomPassthroughMode = !!enabled;
    zoomBackdrop?.classList.toggle("passthrough", zoomPassthroughMode);
  }
  function openZoomFromCard(cardEl, options){
    const clone = cardEl.cloneNode(true);
    clone.classList.remove("locked","blocked");
    clone.classList.remove("equip-steal-pulse","equip-defeat-pulse","eliminated-dim");
    clone.style.pointerEvents = "auto";
    openZoomContent(clone, options);
  }
  function setZoomOverPanel(enabled){
    zoomBackdrop?.classList.toggle("over-panel", !!enabled);
  }
  function openZoomFromRole(role, options){
    if (!role) return;
    const cardEl = createIdentityCard(role);
    if (options?.enableRevealPop) cardEl.dataset.revealInteractive = "1";
    openZoomContent(cardEl, { showCloseButton:false, ...(options || {}) });
  }
  function openIdentityRevealZoom(role, revealerUid, options = {}){
    if (!role) return;
    const wrap = document.createElement("div");
    wrap.style.position = "relative";
    const cardEl = createIdentityCard(role);
    wrap.appendChild(cardEl);

    if (revealerUid && revealerUid !== state.userId){
      const owner = playerById(revealerUid);
      if (owner){
        const chip = buildChipFor(revealerUid);
        const label = document.createElement("div");
        label.className = "zoom-identity-owner";
        const name = document.createElement("span");
        name.textContent = nameFromSecondChar(owner.name || "");
        label.appendChild(chip);
        label.appendChild(name);
        wrap.appendChild(label);
        setTimeout(() => { label.remove(); }, 3000);
      }
    }

    openZoomContent(wrap, { closeOnBackdrop:false, showCloseButton:false });
    if (options.persist) return;
    setTimeout(() => {
      if (activeRoleAbilitySelection) return;
      if (!zoomBackdrop.classList.contains("hidden")) closeZoom();
    }, 2000);
  }
  function openMultiIdentityRevealZoom(entries = []){
    const targets = (entries || []).filter(v => v?.role && v?.uid);
    if (!targets.length) return;
    const row = document.createElement("div");
    row.className = "zoom-identity-multi";

    for (const item of targets){
      const owner = playerById(item.uid);
      const cell = document.createElement("div");
      cell.className = "zoom-identity-multi-item";

      const inner = document.createElement("div");
      inner.className = "zoom-identity-multi-item-inner";
      const cardEl = createIdentityCard(item.role);
      inner.appendChild(cardEl);

      if (owner){
        const chip = buildChipFor(item.uid);
        const label = document.createElement("div");
        label.className = "zoom-identity-owner";
        const name = document.createElement("span");
        name.textContent = nameFromSecondChar(owner.name || "");
        label.appendChild(chip);
        label.appendChild(name);
        inner.appendChild(label);
      }

      cell.appendChild(inner);
      row.appendChild(cell);
    }

    openZoomContent(row, { closeOnBackdrop:false, showCloseButton:false, stageClass:"zoom-stage-multi" });
    setTimeout(() => {
      if (!zoomBackdrop.classList.contains("hidden")) closeZoom();
    }, 2000);
  }
  function openZoomFromDeckCard(cardObj, theme, options){
    if (!cardObj) return;
    const cardEl = document.createElement("div");
    cardEl.className = `card72 wb-front ${theme === "black" ? "wb-black" : theme === "green" ? "wb-green" : "wb-white"}`;
    cardEl.innerHTML = buildWbFrontHTML(cardObj, theme);
    adjustCardNameFont(cardEl);
    cardEl.dataset.cardType = theme || "";
    openZoomContent(cardEl, options);
  }

  async function waitUntilZoomClosed({ maxWaitMs = 12000, pollMs = 60 } = {}){
    const startedAt = Date.now();
    while (Date.now() - startedAt < Math.max(200, Number(maxWaitMs) || 12000)){
      if (zoomBackdrop?.classList.contains("hidden")) return true;
      await new Promise(resolve => setTimeout(resolve, Math.max(20, Number(pollMs) || 60)));
    }
    return !!zoomBackdrop?.classList.contains("hidden");
  }
  function closeZoom(){
    zoomBackdrop.classList.add("hidden");
    zoomBackdrop.classList.remove("passthrough");
    zoomStage.innerHTML = "";
    hideGreenRevealPanel();
    zoomCloseOnBackdrop = true;
    zoomCloseOnAnyClick = false;
    zoomPassthroughMode = false;
    pendingGreenAnswerMsg = null;
    zoomDismissHandler = null;
    greenZoomLocked = false;
    hideGreenShareDock();
    hideRevealPop();
    hideRoomActionPop();
    hideDavidSelectPreview();
    zoomBackdrop?.classList.remove("david-select-active");
    equipDock?.classList.remove("david-select-front");
    refreshEquipDockLayer();
  }
  zoomBackdrop.addEventListener("click", async (e) => {
    const canClose = zoomCloseOnAnyClick || (e.target === zoomBackdrop && zoomCloseOnBackdrop);
    if (canClose){
      if (typeof zoomDismissHandler === "function"){
        await zoomDismissHandler();
        return;
      }
      await clearPendingGreenBubble();
      closeZoom();
    }
  });

  let slot1 = document.getElementById('slot1');
  let slot2 = document.getElementById('slot2');
  const slot3 = document.getElementById('slot3');
  let slot4 = document.getElementById('slot4');
  const slot5 = document.getElementById('slot5');

  function updateCardInteractivity(){
    const s1 = document.getElementById('slot1');
    const s2 = document.getElementById('slot2');
    const s3 = document.getElementById('slot3');
    const s4 = document.getElementById('slot4');
    const s5 = document.getElementById('slot5');

    const types = [
      [s1, s1?.dataset.cardType],
      [s2, s2?.dataset.cardType],
      [s3, s3?.dataset.cardType],
      [s4, s4?.dataset.cardType],
      [s5, s5?.dataset.cardType],
    ];

    for (const [el, t] of types){
      if (!el || !t){
        applyLocked(el, false);
        continue;
      }

      const isRevealSlot = (el.id === "slot3" || el.id === "slot5") && el.classList.contains("wb-front");
      if (isRevealSlot){
        applyLocked(el, false);
        continue;
      }

      const shouldLock = !canClickType(t);

      const noDim = !isMyTurn() && ["white", "black", "green"].includes(t);

      applyLocked(el, shouldLock, { noDim });
    }
  }

  let equipCache = {};
  const equipBody = document.getElementById("equipBody");

  function subscribeEquipment(){
    const eRef = ref(db, `rooms/${state.roomCode}/equipment`);
    onValue(eRef, snap => {
      const next = snap.val() || {};
      if (!identityRevealInitialized){
        identityRevealInitialized = true;
        const initSeen = {};
        for (const [uid, row] of Object.entries(next)){
          initSeen[uid] = Number(row?.identity?.revealedAt || 0);
        }
        identityRevealSeenByUid = initSeen;
      } else {
        for (const [uid, row] of Object.entries(next)){
          const at = Number(row?.identity?.revealedAt || 0);
          if (!at) continue;
          if (Number(row?.identity?.inheritedAt || 0) > 0){
            identityRevealSeenByUid[uid] = at;
            continue;
          }
          const seen = Number(identityRevealSeenByUid[uid] || 0);
          if (at <= seen) continue;
          identityRevealSeenByUid[uid] = at;
          const rid = safeText(row?.identity?.roleId || "");
          const role = ROLE_BY_ID[rid];
          if (role) openIdentityRevealZoom(role, uid);
        }
      }
      equipCache = next;
      renderEquipmentDock();
    });
  }
  function isIdentityEquipItem(v){
    return v && (v.kind === "identity") && !!v.roleId;
  }
  function isPlayableEquipItem(v){
    if (!v || typeof v !== "object") return false;
    if (isIdentityEquipItem(v)) return true;
    const name = safeText(v.name || "").trim();
    const effect = safeText(v.effect || "").trim();
    return !!name && !!effect;
  }
  function equipItemCopies(item){
    if (!item || isIdentityEquipItem(item)) return 1;
    const raw = Number(item.count ?? item.qty ?? item.quantity ?? 1);
    if (!Number.isFinite(raw)) return 1;
    return Math.max(1, Math.floor(raw));
  }
  function expandedEquipItems(uid){
    const obj = equipCache?.[uid] || {};
    const expanded = [];
    for (const [key, value] of Object.entries(obj)){
      if (!isPlayableEquipItem(value)) continue;
      const item = { key, ...(value || {}) };
      const copies = equipItemCopies(item);
      for (let i = 0; i < copies; i++){
        expanded.push({ ...item, key: `${key}_${i}`, sourceKey:key, copyIndex:i });
      }
    }
    return expanded;
  }
  function listEquipForUid(uid){
    const arr = expandedEquipItems(uid);
    arr.sort((a,b) => {
      const ai = isIdentityEquipItem(a) ? 0 : 1;
      const bi = isIdentityEquipItem(b) ? 0 : 1;
      if (ai !== bi) return ai - bi;
      return Number(a.at||0) - Number(b.at||0);
    });
    return arr;
  }

  function buildEquipTag(colorHex, initial){
    const d = document.createElement("div");
    d.className = "equip-tag";
    d.style.background = String(colorHex || "#ddd");
    d.style.color = textColorFor(colorHex || "#ddd");
    d.textContent = String(initial || "").slice(0,1);
    return d;
  }

  function buildEquipCard(item){
    if (isIdentityEquipItem(item)){
      const role = ROLE_BY_ID[item.roleId];
      if (!role) return document.createElement("div");
      return createIdentityCard(role);
    }
    const theme = safeText(item.theme || "white");
    const cardObj = { name: safeText(item.name), effect: safeText(item.effect) };
    const el = document.createElement("div");
    el.className = `card72 wb-front ${theme === "black" ? "wb-black" : theme === "green" ? "wb-green" : "wb-white"}`;
    el.innerHTML = buildWbFrontHTML(cardObj, theme);
    adjustCardNameFont(el);
    el.dataset.cardType = theme || "";
    return el;
  }

  let latestPlayers = [];
  let lastAttackWatch = null;
  let attackExpectedEliminationUids = new Set();
  let attackExpectedEliminationAt = 0;
  let previousEliminatedMap = {};
  let pendingAttackLoot = null;
  const attackLootBackdrop = document.getElementById("attackLootBackdrop");
  const attackLootBody = document.getElementById("attackLootBody");

  function normalizeAttackLootPayload(raw){
    if (!raw || typeof raw !== "object") return null;
    const uid = safeText(raw.uid || "");
    const defeatedUids = Array.isArray(raw.defeatedUids)
      ? raw.defeatedUids.map(v => safeText(v || "")).filter(v => v && v !== uid)
      : [];
    const selected = raw.selected && typeof raw.selected === "object"
      ? {
          ownerUid: safeText(raw.selected.ownerUid || ""),
          sourceKey: safeText(raw.selected.sourceKey || ""),
          noSteal: !!raw.selected.noSteal
        }
      : null;
    if (!uid || !defeatedUids.length) return null;
    return { uid, defeatedUids:[...new Set(defeatedUids)], selected, at:Number(raw.at || Date.now()) };
  }

  async function setAttackLootPending(payload){
    const roomCode = safeText(state.roomCode || "");
    const uid = safeText(state.userId || "");
    if (!roomCode || !uid) return;
    const normalized = normalizeAttackLootPayload(payload);
    await set(ref(db, `rooms/${roomCode}/attackLootPending/${uid}`), normalized);
  }

  function closeAttackLootPanel(){
    attackLootBackdrop?.classList.add("hidden");
    if (attackLootBody) attackLootBody.innerHTML = "";
  }

  async function clearAttackLootPending(){
    pendingAttackLoot = null;
    closeAttackLootPanel();
    await setAttackLootPending(null);
  }

  async function createOrMergeAttackLootPending(defeatedUids = []){
    const uid = safeText(state.userId || "");
    if (!uid) return;
    const list = (defeatedUids || []).map(v => safeText(v || "")).filter(v => v && v !== uid);
    if (!list.length) return;
    const merged = new Set([...(pendingAttackLoot?.defeatedUids || []), ...list]);
    pendingAttackLoot = {
      uid,
      defeatedUids:[...merged],
      selected: pendingAttackLoot?.selected || null,
      at: Date.now()
    };
    await setAttackLootPending(pendingAttackLoot);
    renderAttackLootPanel();
  }

  function orderedPlayersForEquip(){
    const byId = new Map(latestPlayers.map(p => [p.id, p]));
    const me = byId.get(state.userId) || null;
    const others = latestPlayers.filter(p => p.id !== state.userId).sort((a,b) => a.seatIndex - b.seatIndex);

    const davidPromoted = (pendingEquipAction?.type === "david_select")
      ? others.filter(p => pendingEquipAction.defeatedUids?.includes(p.id))
      : [];

    const arr = [];
    for (const p of davidPromoted){
      arr.push(p);
    }
    if (me) arr.push(me);
    for (const p of others){
      if (arr.some(row => row.id === p.id)) continue;
      arr.push(p);
    }
    return arr;
  }

  function getEquipCols(){
    const body = equipBody;
    const dock = equipDock;
    const w = (body?.clientWidth || dock?.clientWidth || 0);
    const cardW = 72;
    const gap = 8;
    const usable = Math.max(0, w);
    const cols = Math.floor((usable + gap) / (cardW + gap));
    return Math.max(2, Math.min(10, cols || 6));
  }
  function applyEquipCols(){
    const cols = getEquipCols();
    equipBody?.style.setProperty('--equip-cols', String(cols));
  }
  window.addEventListener('resize', () => applyEquipCols());

  function renderEquipmentDock(){
    syncRoomAbilityTurnState();
    equipDock?.classList.toggle("david-select-front", pendingEquipAction?.type === "david_select");
    refreshEquipDockLayer();
    if (!state.roomCode) { equipDock.classList.remove("visible"); closeEquipExpand(); return; }

    updateEquipDockTop();

    const players = orderedPlayersForEquip();
    const rows = [];
    for (const p of players){
      const list = listEquipForUid(p.id);
      if (!list || list.length === 0) continue;
      rows.push({ p, list });
    }

    equipBody.innerHTML = "";

    if (rows.length === 0){
      equipDock.classList.remove("visible");
      closeEquipExpand();
      return;
    }

    equipDock.classList.add("visible");

    for (const {p, list} of rows){
      const row = document.createElement("div");
      row.className = "equip-row";

      const tag = buildEquipTag(p.color || "#ddd", firstChar(p.name));
      row.appendChild(tag);

      const cards = document.createElement("div");
      cards.className = "equip-cards";
      const eliminated = isPlayerEliminated(p.id);
      for (const it of list){
        const cardEl = buildEquipCard(it);
        if (eliminated) cardEl.classList.add("eliminated-dim");
        cardEl.dataset.ownerUid = p.id;
        cardEl.dataset.sourceKey = safeText(it.sourceKey || "");
        cardEl.dataset.cardName = safeText(it.name || "");
        cardEl.dataset.cardTheme = safeText(it.theme || "white");
        cardEl.dataset.cardEffect = safeText(it.effect || "");
        const isNormalStealPulse = canUseRoom4Steal() && p.id !== state.userId && !eliminated && !isIdentityEquipItem(it);
        const isOliverPulse = pendingEquipAction?.type === "oliver_target" && p.id !== state.userId && !eliminated && !isIdentityEquipItem(it);
        const isBananaPulse = pendingEquipAction?.type === "banana_give" && p.id === state.userId && !isIdentityEquipItem(it);
        const isGreenGivePulse = pendingEquipAction?.type === "green_give" && p.id === state.userId && !isIdentityEquipItem(it);
        const isDavidPulse = pendingEquipAction?.type === "david_select"
          && pendingEquipAction.defeatedUids?.includes(p.id)
          && p.id !== state.userId
          && eliminated
          && !isIdentityEquipItem(it);
        if (isNormalStealPulse || isOliverPulse || isBananaPulse || isGreenGivePulse){
          cardEl.classList.add("equip-steal-pulse");
        }
        if (isDavidPulse){
          cardEl.classList.add("equip-defeat-pulse");
        }
        cards.appendChild(cardEl);
      }
      row.appendChild(cards);
      equipBody.appendChild(row);
    }
    refreshRoomAbilityHint();
    ensureDavidIdentityZoomVisible();
    if (equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden')){
      renderEquipExpandBody();
    }
  }

  function renderAttackLootPanel(){
    const payload = pendingAttackLoot;
    if (!attackLootBackdrop || !attackLootBody){
      return;
    }
    if (!payload || !Array.isArray(payload.defeatedUids) || !payload.defeatedUids.length){
      closeAttackLootPanel();
      return;
    }

    attackLootBody.innerHTML = "";
    const byId = new Map(latestPlayers.map(p => [p.id, p]));
    const selected = payload.selected || null;
    let lastCardsWrap = null;
    let hasLootableCard = false;

    for (const uid of payload.defeatedUids){
      const p = byId.get(uid);
      if (!p) continue;
      const list = listEquipForUid(uid);
      const hasLootableEquip = list.some(it => !isIdentityEquipItem(it));
      if (!hasLootableEquip) continue;

      const row = document.createElement("div");
      row.className = "attack-loot-row";
      row.appendChild(buildEquipTag(p.color || "#ddd", firstChar(p.name)));

      const cardsWrap = document.createElement("div");
      cardsWrap.className = "attack-loot-cards";
      for (const it of list){
        const cardEl = buildEquipCard(it);
        cardEl.dataset.ownerUid = uid;
        cardEl.dataset.sourceKey = safeText(it.sourceKey || "");
        cardEl.dataset.cardName = safeText(it.name || "");
        cardEl.dataset.itemKind = isIdentityEquipItem(it) ? "identity" : "equip";
        if (!isIdentityEquipItem(it)){
          hasLootableCard = true;
          cardEl.classList.add("equip-defeat-pulse");
        }
        if (selected && !selected.noSteal && selected.ownerUid === uid && selected.sourceKey === safeText(it.sourceKey || "") && !isIdentityEquipItem(it)){
          cardEl.classList.remove("equip-defeat-pulse");
          cardEl.classList.add("equip-steal-pulse");
        }
        cardsWrap.appendChild(cardEl);
      }
      row.appendChild(cardsWrap);
      attackLootBody.appendChild(row);
      lastCardsWrap = cardsWrap;
    }

    if (!hasLootableCard){
      closeAttackLootPanel();
      return;
    }

    const noStealCard = document.createElement("div");
    noStealCard.className = "card72 wb-front wb-white attack-loot-no-steal equip-defeat-pulse";
    noStealCard.dataset.noSteal = "1";
    noStealCard.textContent = "Â•™„Çè„Å™„ÅÑ";
    if (selected?.noSteal){
      noStealCard.classList.remove("equip-defeat-pulse");
      noStealCard.classList.add("equip-steal-pulse");
    }
    if (lastCardsWrap){
      lastCardsWrap.appendChild(noStealCard);
    } else {
      const row = document.createElement("div");
      row.className = "attack-loot-row";
      const cardsWrap = document.createElement("div");
      cardsWrap.className = "attack-loot-cards";
      cardsWrap.appendChild(noStealCard);
      row.appendChild(cardsWrap);
      attackLootBody.appendChild(row);
    }
    attackLootBackdrop.classList.remove("hidden");
  }

  async function commitAttackLootSelection(selection){
    if (!pendingAttackLoot) return;
    if (selection?.noSteal){
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "Â•™„Çè„Å™„Åè„Å¶Êú¨ÂΩì„Å´„ÅÑ„ÅÑ„Åß„Åô„Åã„ÄÇ", async () => {
        await clearAttackLootPending();
      }, { fixedLower:true, closeZoomOnNo:true });
      return;
    }
    const ownerUid = safeText(selection?.ownerUid || "");
    const sourceKey = safeText(selection?.sourceKey || "");
    if (!ownerUid || !sourceKey) return;
    closeAttackLootPanel();
    const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
    if (ok){
      await clearAttackLootPending();
      closeZoom();
      renderEquipmentDock();
    }
  }

  async function grantEquipmentToMe(cardObj, theme){
    if (!state.roomCode) return;
    if (!cardObj) return;
    if (!isEquipCard(cardObj)) return;

    const key = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${state.userId}/${key}`);
    await set(eRef, {
      theme: theme || "white",
      name: safeText(cardObj.name),
      effect: safeText(cardObj.effect),
      at: Date.now()
    });
  }

  async function revealMyIdentityToEquipment(options = {}){
    if (!state.roomCode) return;
    const my = state.hands?.[state.userId];
    if (!my || !my.roleId) return;

    const revealedBy = safeText(options.revealedBy || "");
    const useAgathaAbilityOnReveal = options.useAgathaAbilityOnReveal !== false;
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${state.userId}/identity`);
    let revealedNow = false;
    await runTransaction(eRef, (cur) => {
      if (cur && cur.kind === "identity" && cur.roleId) return cur;
      revealedNow = true;
      const next = {
        kind: "identity",
        roleId: String(my.roleId),
        at: 0,
        revealedAt: Date.now()
      };
      if (revealedBy) next.revealedBy = revealedBy;
      return next;
    });
    maybeResolveVampireHiddenHealOnReveal();
    if (revealedNow && safeText(my.roleId) === "CIT_C2"){
      await healDamageToPlayer(state.userId, 2);
      if (isMyTurn()){
        carolTurnHealKey = turnCycleKey();
      }
    }
    if (revealedNow && safeText(my.roleId) === "CIT_A3" && useAgathaAbilityOnReveal){
      if (zoomBackdrop && !zoomBackdrop.classList.contains("hidden")) closeZoom();
      await triggerAgathaRevealAbility();
    }
  }

  function hasNonIdentityEquipment(uid){
    return listEquipForUid(uid).some(it => !isIdentityEquipItem(it));
  }

  function getDavidEligibleEliminatedUids(){
    return latestPlayers
      .filter(p => p.id !== state.userId)
      .filter(p => isPlayerEliminated(p.id))
      .filter(p => hasNonIdentityEquipment(p.id))
      .map(p => p.id);
  }

  function isDavidAbilityPending(){
    return pendingEquipAction?.type === "david_select";
  }

  function isDavidAbilityUsed(){
    return !!state.room?.abilityUsage?.david?.[state.userId];
  }

  async function markDavidAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/david/${state.userId}`), true);
  }

  function isAgathaAbilityUsed(){
    return !!state.room?.abilityUsage?.agatha?.[state.userId];
  }

  async function markAgathaAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/agatha/${state.userId}`), true);
  }

  async function triggerAgathaRevealAbility(options = {}){
    if (!state.userId || !state.roomCode) return;
    if (isAgathaAbilityUsed()) return;

    await markAgathaAbilityUsed();
    const rolled = {
      d6: 1 + Math.floor(Math.random() * 6),
      d4: 1 + Math.floor(Math.random() * 4)
    };
    const revealCloseAt = Date.now() + 1200;
    showAgathaRevealCardOverlay(state.userId, { closeAt: revealCloseAt });
    await emitCardDiceEvent({ kind:"role_agatha", uid:state.userId, d6:rolled.d6, d4:rolled.d4, closeAt: revealCloseAt });
    await waitMs(1000);
    const targetRoomId = diceTotalToRoomId(Number(rolled?.d6 || 0) + Number(rolled?.d4 || 0));
    await waitMs(1200);
    await addDamageToPlayers(playerIdsInRoom(targetRoomId), 3);
    await waitMs(500);
    const cleanupTimer = setTimeout(() => {
      diceRollOverlay.innerHTML = '';
      clearDiceRollTimers();
    }, 2000);
    diceRollTimers.push(cleanupTimer);

    if (options.endTurnAfterResolve && isMyTurn()){
      await doEndTurn();
    }
  }

  function restoreDavidIdentityZoom(){
    const my = state.hands?.[state.userId];
    const role = my?.roleId ? ROLE_BY_ID[my.roleId] : null;
    if (!role) return;
    openZoomFromRole(role, { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(false);
    hideDavidSelectPreview();
    zoomDismissHandler = null;
  }

  function restoreDavidAbilitySelection(){
    if (pendingEquipAction?.type !== "david_select") return;
    pendingEquipAction = {
      type: "david_select",
      defeatedUids: [...(pendingEquipAction.defeatedUids || [])]
    };
    restoreDavidIdentityZoom();
    renderEquipmentDock();
  }

  function ensureDavidIdentityZoomVisible(){
    if (pendingEquipAction?.type !== "david_select") return;
    if (!zoomBackdrop?.classList.contains("hidden")) return;
    restoreDavidAbilitySelection();
  }

  async function startDavidAbilityFlow(){
    const defeatedUids = getDavidEligibleEliminatedUids();
    if (defeatedUids.length === 0){
      showRevealPopAt(null, { mode:"notice", message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
      return;
    }
    await revealMyIdentityToEquipment({ revealedBy:"david_ability" });
    pendingEquipAction = { type:"david_select", defeatedUids };
    restoreDavidIdentityZoom();
    renderEquipmentDock();
  }

  async function revealIdentityByDamage(uid){
    if (!state.roomCode || !uid) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const hand = cur.hands?.[uid];
      if (!hand?.roleId) return cur;
      cur.equipment = cur.equipment || {};
      cur.equipment[uid] = cur.equipment[uid] || {};
      const old = cur.equipment[uid].identity;
      if (old && old.kind === "identity" && old.roleId) return cur;
      cur.equipment[uid].identity = {
        kind: "identity",
        roleId: String(hand.roleId),
        at: 0,
        revealedAt: Date.now(),
        revealedBy: "damage"
      };
      return cur;
    });
  }

  function isMyIdentityRevealed(){
    const v = equipCache?.[state.userId]?.identity;
    return !!(v && v.kind === "identity" && v.roleId);
  }

  function isIdentityRevealedFor(uid){
    const targetUid = safeText(uid);
    if (!targetUid) return false;
    const v = equipCache?.[targetUid]?.identity;
    return !!(v && v.kind === "identity" && v.roleId);
  }

  function isMyRevealedVendetta(){
    return isMyRole("SHA_V3") && isMyIdentityRevealed();
  }

  zoomStage.addEventListener("click", (e) => {
    const idCard = e.target.closest(".id72");
    if (!idCard) return;
    if (idCard.dataset.revealInteractive !== "1") return;
    if (isEquipSelectionLockActive()){
      e.stopPropagation();
      return;
    }
    if (isIdentityRevealPopBlockedByEffectPop()){
      e.stopPropagation();
      return;
    }

    const my = state.hands?.[state.userId];
    if (!my || !my.roleId) return;

    const myRoleId = safeText(my.roleId || "");
    if (myRoleId === "CIT_A1" && isAliceAbilityUsed()){
      e.stopPropagation();
      return;
    }
    if (!isMyTurn()){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode:"notice", message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
      return;
    }
    if (isMyIdentityRevealed()){
      if (isRoleSelectionAbility(myRoleId)){
        if (myRoleId === "RAI_G3"){
          e.stopPropagation();
          showRevealPopAt(idCard, { mode:"notice", message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
          return;
        }
        if (!isMyTurn()) return;
        if (myRoleId === "RAI_E3"){
          if (isRoleAbilityUsed("RAI_E3")) return;
          const check = emmaAbilityAvailability();
          if (!check.ok){
            e.stopPropagation();
            showRevealPopAt(idCard, { mode:"notice", message:check.message || "‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" });
            return;
          }
        } else if (myRoleId === "SHA_U2"){
          if (isRoleAbilityUsed("SHA_U2")) return;
          const check = uranusAbilityAvailability();
          if (!check.ok){
            e.stopPropagation();
            showRevealPopAt(idCard, { mode:"notice", message:check.message || "‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" });
            return;
          }
        } else {
          if (isRoleAbilityUsed(myRoleId)) return;
          if (!canStartRoleSelection(myRoleId, state.userId)){
            e.stopPropagation();
            showRevealPopAt(idCard, { mode:"notice", message:"‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
            return;
          }
        }
        const spec = roleSelectionSpec(myRoleId);
        e.stopPropagation();
        showRevealPopAt(idCard, {
          action: `role_select:${myRoleId}`,
          messageHtml: `<span class="ability-pill">${escapeHtml(spec.abilityName)}</span>„Çí‰Ωø„ÅÑ„Åæ„Åô„Åã„ÄÇ`
        });
        return;
      }
      if (myRoleId === "CIT_A3"){
        if (isAgathaAbilityUsed()) return;
        if (!turnState()?.moveDone){
          e.stopPropagation();
          showRevealPopAt(idCard, { mode:"notice", message:"ÊâãÁï™„ÅÆÊúÄÂæå„Å´„Å†„ÅëÊ≠£‰Ωì„ÇíÂÖ¨Èñã„Åß„Åç„Åæ„Åô„ÄÇ" });
          return;
        }
        e.stopPropagation();
        showRevealPopAt(idCard, {
          action: "agatha_ability",
          messageHtml: `<span class="ability-pill">ÂÆåÂÖ®ÁäØÁΩ™</span>„Çí‰Ωø„ÅÑ„Åæ„Åô„Åã„ÄÇ<br>‰ΩøÁî®Âæå„Å´ÊâãÁï™„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åô„ÄÇ`
        });
        return;
      }
      if (myRoleId === "CIT_A1"){
        const check = canUseAliceAbilityNow();
        if (!check.ok){
          if (isAliceAbilityUsed()){
            e.stopPropagation();
            return;
          }
          e.stopPropagation();
          showRevealPopAt(idCard, { mode:"notice", message:check.message || "‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" });
          return;
        }
        e.stopPropagation();
        showRevealPopAt(idCard, {
          action: "alice_ability",
          messageHtml: `<span class="ability-pill">„ÅÜ„Åï„Åé„Åï„Çì„Éí„Éº„É´</span>„Çí‰Ωø„ÅÑ„Åæ„Åô„Åã„ÄÇ`
        });
        return;
      }
      if (myRoleId !== "SHA_W1") return;
      const check = canUseWightAbilityNow();
      if (!check.ok){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode:"notice", message:check.message || "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
        return;
      }
      e.stopPropagation();
      showRevealPopAt(idCard, {
        action: "wight_ability",
        messageHtml: `<span class="ability-pill">‰∫°ËÄÖ„ÅÆÁéã</span>„Çí‰Ωø„ÅÑ„Åæ„Åô„Åã„ÄÇ`
      });
      return;
    }

    if (myRoleId === "CIT_D1"){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
      return;
    }
    if (myRoleId === "CIT_D2"){
      if (isDavidAbilityUsed()){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "„Åì„ÅÆËÉΩÂäõ„ÅØ„Åô„Åß„Å´‰ΩøÁî®Ê∏à„Åø„Åß„Åô„ÄÇ" });
        return;
      }
      if (getDavidEligibleEliminatedUids().length === 0){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
        return;
      }
    }
    if (myRoleId === "SHA_U1" || myRoleId === "RAI_G3"){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
      return;
    }
    if (myRoleId === "CIT_A3"){
      if (isAgathaAbilityUsed()){
        e.stopPropagation();
        return;
      }
      if (!turnState()?.moveDone){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "ÊâãÁï™„ÅÆÊúÄÂæå„Å´„Å†„ÅëÊ≠£‰Ωì„ÇíÂÖ¨Èñã„Åß„Åç„Åæ„Åô„ÄÇ" });
        return;
      }
    }
    if (myRoleId === "SHA_U2" && !canStartRoleSelection(myRoleId, state.userId)){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
      return;
    }

    const moved = !!turnState()?.moveDone;
    if (TURN_START_ONLY_REVEAL_ROLE_IDS.has(myRoleId) && moved){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "ÊâãÁï™„ÅÆÂàù„ÇÅ„Å´„Å†„ÅëÊ≠£‰Ωì„ÇíÂÖ¨Èñã„Åß„Åç„Åæ„Åô„ÄÇ" });
      return;
    }
    if (myRoleId === "SHA_W1"){
      const check = canUseWightAbilityNow();
      if (!check.ok){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode:"notice", message:check.message || "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
        return;
      }
      e.stopPropagation();
      showRevealPopAt(idCard, {
        action: "wight_ability",
        messageHtml: `Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Å¶„ÄÅ<span class="ability-pill">‰∫°ËÄÖ„ÅÆÁéã</span>„Çí‰Ωø„ÅÑ„Åæ„Åô„Åã„ÄÇ<br>„Åì„ÅÆÊâãÁï™„ÇíÁµÇ‰∫Ü„Åó„Å¶„ÄÅ„ÇÇ„ÅÜ‰∏ÄÊâãÁï™Ë°å„ÅÜ„ÄÇ`
      });
      return;
    }
    if (REVEAL_ENDS_TURN_ROLE_IDS.has(myRoleId) && !moved){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "ÊâãÁï™„ÅÆÊúÄÂæå„Å´„Å†„ÅëÊ≠£‰Ωì„ÇíÂÖ¨Èñã„Åß„Åç„Åæ„Åô„ÄÇ" });
      return;
    }

    e.stopPropagation();
    showRevealPopAt(idCard, { appendEndTurnNotice: REVEAL_ENDS_TURN_ROLE_IDS.has(myRoleId) || myRoleId === "CIT_A3" });
  });

  window.__lastPointerX = window.innerWidth / 2;
  window.__lastPointerY = window.innerHeight / 2;
  document.addEventListener("pointerdown", (e) => {
    window.__lastPointerX = Number(e.clientX);
    window.__lastPointerY = Number(e.clientY);
  }, true);

  document.addEventListener("click", (e) => {
    const now = Date.now();
    if (now < suppressOutsidePopCloseUntil) return;
    if (!revealPop.classList.contains("hidden") && !e.target.closest("#revealPop")){
      hideRevealPop();
    }
    if (!attackPop.classList.contains("hidden") && !e.target.closest("#attackPop")){
      hideAttackPop();
    }
    if (!endTurnConfirm?.classList.contains("hidden") && !e.target.closest("#endTurnConfirm") && !e.target.closest("#btnEndTurn")){
      hideEndTurnConfirm();
    }
    if (!roomActionPop.classList.contains("hidden") && !e.target.closest("#roomActionPop")){
      if (pendingRoomAction?.dismissOnOutside !== false){
        hideRoomActionPop();
        if (pendingEquipAction?.type === "david_select"){
          restoreDavidAbilitySelection();
        }
      }
    }
  }, true);

  btnRevealNo.addEventListener("click", (e) => {
    e.stopPropagation();
    hideRevealPop();
  });
  btnRevealYes.addEventListener("click", async (e) => {
    e.stopPropagation();
    const myRoleId = safeText(state.hands?.[state.userId]?.roleId || "");
    if (myRoleId === "CIT_D2"){
      await startDavidAbilityFlow();
      hideRevealPop();
      return;
    }
    if (pendingRevealAction === "wight_ability"){
      if (!isMyIdentityRevealed()){
        await revealMyIdentityToEquipment({ revealedBy:"wight_ability" });
      }
      const ok = await activateWightAbilityAndEndTurn();
      hideRevealPop();
      if (!ok){
        showRevealPopAt(null, { mode:"notice", message:canUseWightAbilityNow().message || "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ" });
      }
      return;
    }
    if (pendingRevealAction === "agatha_ability"){
      hideRevealPop();
      if (zoomBackdrop && !zoomBackdrop.classList.contains("hidden")) closeZoom();
      if (!isMyIdentityRevealed()){
        await revealMyIdentityToEquipment({ revealedBy:"manual" });
      } else {
        await triggerAgathaRevealAbility({ endTurnAfterResolve:true });
      }
      return;
    }
    if (pendingRevealAction === "alice_ability"){
      const check = canUseAliceAbilityNow();
      hideRevealPop();
      if (!check.ok){
        showRevealPopAt(null, { mode:"notice", message:check.message || "‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" });
        return;
      }
      await markAliceAbilityUsed();
      setTimeout(() => {
        setDamageToPlayer(state.userId, 0);
      }, 1500);
      return;
    }
    if (pendingRevealAction.startsWith("role_select:")){
      const roleId = safeText(pendingRevealAction.split(":")[1] || "");
      const role = ROLE_BY_ID[roleId];
      if (role && !isRoleAbilityUsed(roleId)){
        if (!canStartRoleSelection(roleId, state.userId)){
          hideRevealPop();
          showRevealPopAt(null, { mode:"notice", message:((roleId === "RAI_E3" || roleId === "SHA_U2") ? "‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" : "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ") });
          return;
        }
        await setRoleAbilitySelectionState({ roleId, actorUid: state.userId, privateToActor: (roleId === "SHA_U2") });
      }
      hideRevealPop();
      return;
    }
    await revealMyIdentityToEquipment({ revealedBy:"manual" });
    if (isRoleSelectionAbility(myRoleId) && !isRoleAbilityUsed(myRoleId)){
      if (!canStartRoleSelection(myRoleId, state.userId)){
        hideRevealPop();
        showRevealPopAt(null, { mode:"notice", message:((myRoleId === "RAI_E3" || myRoleId === "SHA_U2") ? "‰ªä„ÅØ‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇ" : "‰ªä„ÅØÂÖ¨Èñã„Åß„Åç„Åæ„Åõ„Çì„ÄÇ") });
        return;
      }
      await setRoleAbilitySelectionState({ roleId: myRoleId, actorUid: state.userId, justRevealed:true, privateToActor: (myRoleId === "RAI_E3" || myRoleId === "SHA_U2") });
    }
    if (myRoleId === "CIT_A1"){
      await markAliceAbilityUsed();
      setTimeout(() => {
        setDamageToPlayer(state.userId, 0);
      }, 1500);
    }
    hideRevealPop();
    if (myRoleId === "CIT_A3" && isAgathaAbilityUsed() && isMyTurn()){
      await doEndTurn();
    }
  });

  btnAttackNo.addEventListener("click", (e) => {
    e.stopPropagation();
    hideAttackPop();
  });
  btnRoomActionNo?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const closeZoomOnNo = !!pendingRoomAction?.closeZoomOnNo;
    const onNo = pendingRoomAction?.onNo;
    hideRoomActionPop();
    if (typeof onNo === "function") await onNo();
    if (closeZoomOnNo) closeZoom();
  });
  btnRoomActionYes?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const handler = pendingRoomAction?.onYes;
    hideRoomActionPop();
    if (handler) await handler();
  });
  btnAttackYes.addEventListener("click", async (e) => {
    e.stopPropagation();
    if (!canUseAttackDice()) {
      hideAttackPop();
      return;
    }
    const uid = pendingAttackTargetUid;
    const target = markerCache?.[uid] || null;
    if (!uid || !target){
      hideAttackPop();
      return;
    }
    const x = Number(target.x);
    const y = Number(target.y);
    const point = roomSvg && Number.isFinite(x) && Number.isFinite(y)
      ? (() => {
          const ctm = roomSvg.getScreenCTM();
          if (!ctm) return null;
          const pt = roomSvg.createSVGPoint();
          pt.x = x;
          pt.y = y;
          return pt.matrixTransform(ctm);
        })()
      : null;

    hideAttackPop();
    attackTurnEndChoicePending = true;
    attackFlowUiLockActive = true;
    renderTurnEndButton();
    const selectedSum = chooseSumForTestPlayer("ÊîªÊíÉ");
    if (isTestPlayer() && selectedSum == null){
      attackTurnEndChoicePending = false;
      attackFlowUiLockActive = false;
      renderTurnEndButton();
      return;
    }
    const masamuneMode = hasMyEquipmentByName("Â¶ñÂàÄ„Éû„Çµ„É†„Éç");
    const vendettaMode = isMyRevealedVendetta();
    const gatlingMode = hasMyEquipmentByName("„Ç¨„Éà„É™„É≥„Ç∞");
    const gatlingTargetUids = gatlingMode ? [...highlightedMarkerUids()] : [];
    const attackTargetUids = gatlingMode ? gatlingTargetUids : [uid];
    await recordLastAttackToMe(attackTargetUids);
    lastAttackWatch = {
      uid: state.userId,
      targetUids: attackTargetUids,
      hasRosary: hasMyEquipmentByName("ÈäÄ„ÅÆ„É≠„Ç∂„É™„Ç™"),
      at: Date.now()
    };
    const selectedPair = selectedSum != null ? pickDiceBySum(selectedSum) : null;
    const d6 = (masamuneMode || vendettaMode) ? 0 : (selectedPair?.d6 ?? (1 + Math.floor(Math.random() * 6)));
    const d4 = selectedPair?.d4 ?? (1 + Math.floor(Math.random() * 4));
    const width = window.innerWidth;
    const height = window.innerHeight;
    const landing = randomCenterLandingPoint(width, height);
    const endX = Number(landing.x || (point?.x || width/2));
    const endY = Number(landing.y || (point?.y || height/2));
    const motion = createDiceMotion(width, height, endX, endY);
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/attack`), {
      uid: state.userId,
      targetUid: uid,
      gatlingTargetUids,
      x: endX,
      y: endY,
      d6,
      d4,
      masamuneMode,
      vendettaMode,
      motion,
      at: Date.now()
    });
    if (state.roomCode && isMyTurn()){
      await update(ref(db, `rooms/${state.roomCode}/turn`), {
        attackDone: true,
        attackAt: Date.now()
      });
    }
  });


  btnAttackResultKeep?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const pending = pendingAttackResolution;
    const spec = attackAbilitySpecFromRows(pending?.rows || []);
    if (!spec){
      await finalizePendingAttackResolution(false);
      return;
    }

    const runKeepAbility = async () => {
      const role = myRoleInfo();
      const roleId = safeText(role?.id || "");
      const followupTargetUid = primaryAttackTargetUidFromRows(pending?.rows || []);
      await finalizePendingAttackResolution(false);
      await resolveAttackAbilityReveal(role);

      if (roleId === "CIT_C1"){
        markAttackAbilityUsedThisTurn(roleId);
        await addDamageToPlayer(state.userId, 2);
        await runFollowupAttackToTarget(followupTargetUid, 1500);
        return;
      }
      if (roleId === "RAI_G2"){
        await runFollowupAttackToTarget(followupTargetUid, 0);
        return;
      }
      if (roleId === "SHA_U3"){
        markAttackAbilityUsedThisTurn(roleId);
        await startUlsterExtraAttackSelection();
        return;
      }
    };

    if (attackResultChoiceBusy) return;
    showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "", async () => {
      if (attackResultChoiceBusy) return;
      attackResultChoiceBusy = true;
      try {
        await runKeepAbility();
      } finally {
        attackResultChoiceBusy = false;
      }
    }, {
      messageHtml: `<span class="ability-pill">${escapeHtml(formatAttackAbilityPillLabel(spec.abilityName))}</span>${escapeHtml(spec.description)}`,
      yesLabel: "„ÅØ„ÅÑ",
      noLabel: "„ÅÑ„ÅÑ„Åà",
      fixedLower:true,
      noCaret:true,
      dismissOnOutside:true
    });
  });


  btnAttackResultExcalibur?.addEventListener("click", async (e) => {
    e.stopPropagation();
    if (attackResultChoiceBusy) return;
    const pending = pendingAttackResolution;
    if (!pending || !pendingAttackResultMeta?.allowExcaliburButton) return;
    attackResultChoiceBusy = true;
    try {
      await revealMyIdentityToEquipment({ revealedBy:"excalibur_attack" });
      pendingAttackResultMeta = {
        ...(pendingAttackResultMeta || {}),
        allowExcaliburButton: false,
        showBonusLabel: false,
        zeroDamagePreview: false
      };
      pending.meta = normalizeAttackResultMeta(pendingAttackResultMeta);
      showAttackResultPop(pending.rows);

      pending.rows = excaliburExtraDamageRows(pending.rows, 2);
      cachePendingAttackResolution(pending);
      await upsertPendingAttackResolution(pending.rows, pending.turnKey || turnCycleKey(), pendingAttackResultMeta);
      showAttackResultPop(pending.rows);
    } finally {
      attackResultChoiceBusy = false;
    }
  });

  btnAttackResultEnd?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const pending = pendingAttackResolution;
    const spec = attackAbilitySpecFromRows(pending?.rows || []);
    if (spec){
      if (attackResultChoiceBusy) return;
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "Êú¨ÂΩì„Å´ÁµÇ‰∫Ü„Åó„Åæ„Åô„Åã„ÄÇ", async () => {
        if (attackResultChoiceBusy) return;
        attackResultChoiceBusy = true;
        try {
          const openedEmma = await tryOpenEmmaSelectionOnEndAttempt();
          if (openedEmma){
            await finalizePendingAttackResolution(false);
            return;
          }
          await finalizePendingAttackResolution(true);
        } finally {
          attackResultChoiceBusy = false;
        }
      }, { fixedLower:true, noCaret:true, dismissOnOutside:true });
      return;
    }
    const openedEmma = await tryOpenEmmaSelectionOnEndAttempt();
    if (openedEmma){
      await finalizePendingAttackResolution(false);
      return;
    }
    await finalizePendingAttackResolution(true);
  });

  btnIdentityPromptNo?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const handler = pendingIdentityPrompt?.onNo;
    const closeZoomOnChoice = !!pendingIdentityPrompt?.closeZoomOnChoice;
    hideIdentityPrompt();
    await setSeatIdentityPromptState(null);
    if (closeZoomOnChoice) closeZoom();
    if (handler) await handler();
  });

  btnIdentityPromptYes?.addEventListener("click", async (e) => {
    e.stopPropagation();
    if (btnIdentityPromptYes.disabled) return;
    const handler = pendingIdentityPrompt?.onYes;
    const closeZoomOnChoice = !!pendingIdentityPrompt?.closeZoomOnChoice;
    hideIdentityPrompt();
    await setSeatIdentityPromptState(null);
    if (closeZoomOnChoice) closeZoom();
    if (handler) await handler();
  });

  equipBody.addEventListener("click", (e) => {
    const card = e.target.closest(".card72.wb-front, .id72");
    const selectionAction = captureSelectionRestoreAction();
    if (!card){
      if (pendingEquipAction?.type === "david_select"){
        hideRoomActionPop();
        restoreDavidAbilitySelection();
        return;
      }
      openEquipExpand();
      return;
    }

    if (pendingEquipAction?.type === "david_select"){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      const isPulseCard = card.classList.contains("equip-defeat-pulse");
      const canPick = isPulseCard && pendingEquipAction.defeatedUids?.includes(ownerUid) && !!sourceKey;
      if (!canPick){
        restoreDavidAbilitySelection();
        return;
      }
      pendingEquipAction = {
        ...pendingEquipAction,
        selectedOwnerUid: ownerUid,
        selectedSourceKey: sourceKey
      };
      renderEquipmentDock();
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      hideDavidSelectPreview();
      zoomDismissHandler = async () => {
        restoreDavidAbilitySelection();
      };
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "„Åì„ÅÆ„Ç´„Éº„Éâ„ÇíÁç≤Âæó„Åó„Åæ„Åô„Åã„ÄÇ", async () => {
        const action = pendingEquipAction;
        if (!action || action.type !== "david_select") return;
        zoomDismissHandler = null;
        const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
        if (ok){
          await markDavidAbilityUsed();
          pendingEquipAction = null;
          hideDavidSelectPreview();
          closeZoom();
          renderEquipmentDock();
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          restoreDavidAbilitySelection();
        }
      });
      return;
    }

    if (pendingEquipAction?.type === "green_give"){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (ownerUid !== state.userId || !sourceKey) return;
      const action = { ...pendingEquipAction, sourceKey };
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "„Åì„ÅÆ„Ç´„Éº„Éâ„Çí„Çè„Åü„Åó„Åæ„Åô„Åã„ÄÇ", async () => {
        pendingEquipAction = null;
        renderTurnEndButton();
        zoomDismissHandler = null;
        const ok = await moveEquipmentCardBetweenPlayers(action.fromUid, action.toUid, sourceKey);
        if (ok){
          await sendGreenResponse(
            { from: action.toUid, requestId: action.requestId, card: action.cardObj },
            action.answerOpt,
            "Ë£ÖÂÇô„Çí„Çè„Åü„Åô"
          );
          closeZoom();
          renderEquipmentDock();
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          zoomDismissHandler = null;
          restoreGreenGiveZoomSelection(action);
        }
      });
      zoomDismissHandler = async () => {
        restoreGreenGiveZoomSelection(action);
      };
      return;
    }

    if (pendingEquipAction?.type === "banana_give"){
      const action = { ...pendingEquipAction };
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (ownerUid !== state.userId || !sourceKey){
        greenShareDock?.classList.add("hidden");
        openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
        setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
        setZoomPassthrough(false);
        zoomDismissHandler = async () => {
          restorePendingEquipSelection(action);
        };
        return;
      }
      const cardName = safeText(card.dataset.cardName || "„Åì„ÅÆË£ÖÂÇô");
      pendingEquipAction.selectedSourceKey = sourceKey;
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
      setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
      greenShareDock?.classList.add("hidden");
      const actionForRestore = { ...pendingEquipAction };
      openTargetSelectDock({
        title: `„Äå${cardName}„Äç„ÇíË™∞„Åã„Å´Ê∏°„Åó„Åæ„Åô„Åã„ÄÇ`,
        includeSelf: false,
        onlyAlive: true,
        overEquipExpand: !equipExpandBackdrop?.classList.contains('hidden'),
        onSelect: async (uid) => {
          const chosenSource = safeText(pendingEquipAction?.selectedSourceKey || "");
          pendingEquipAction = null;
          await setSeatEquipSelectionState(null);
          renderTurnEndButton();
          closeEquipExpandIfOpen();
          greenShareDock?.classList.add("hidden");
          const ok = await moveEquipmentCardBetweenPlayers(state.userId, uid, chosenSource);
          if (ok){
            closeZoom();
            renderEquipmentDock();
          }
        }
      });
      zoomDismissHandler = async () => {
        greenShareDock?.classList.remove("over-equip-expand");
        greenShareDock?.classList.add("hidden");
        cardPlayerSelectActive = false;
        updateCardInteractivity();
        renderTurnEndButton();
        restorePendingEquipSelection(actionForRestore);
      };
      return;
    }

    if (pendingEquipAction?.type === "oliver_target"){
      const action = { ...pendingEquipAction };
      if (!card.classList.contains("equip-steal-pulse")){
        greenShareDock?.classList.add("hidden");
        openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
        setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
        setZoomPassthrough(false);
        zoomDismissHandler = async () => {
          restorePendingEquipSelection(action);
        };
        return;
      }
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (!ownerUid || ownerUid === state.userId || !sourceKey) return;
      const cardObj = pendingEquipAction?.cardObj || null;
      pendingEquipAction = { type:"oliver_confirm", ownerUid, sourceKey, cardObj };
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
      renderTurnEndButton();
      zoomDismissHandler = async () => {
        restoreOliverZoomSelection();
      };
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "„Åì„Çå„ÇíÂ•™„ÅÑ„Åæ„Åô„Åã„ÄÇ", async () => {
        const action = pendingEquipAction;
        pendingEquipAction = null;
        await setSeatEquipSelectionState(null);
        renderTurnEndButton();
        closeEquipExpandIfOpen();
        zoomDismissHandler = null;
        const ok = await stealEquipmentFromPlayer(action.ownerUid, action.sourceKey);
        if (ok){
          closeZoom();
          renderEquipmentDock();
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          zoomDismissHandler = null;
          restoreOliverZoomSelection();
        }
      });
      return;
    }

    if (canUseRoom4Steal() && card.classList.contains("equip-steal-pulse")){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (!ownerUid || ownerUid === state.userId || !sourceKey) return;
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "„Åì„ÅÆË£ÖÂÇô„ÇíÂ•™„ÅÑ„Åæ„Åô„Åã„ÄÇ", async () => {
        room4StealUsed = true;
        await updateTurnRoomActionState({ room4StealUsed:true });
        const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
        if (ok){
          renderEquipmentDock();
          closeZoom();
        }
      }, { fixedLower:true, closeZoomOnNo:true });
      return;
    }

    if (selectionAction){
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
      setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
      setZoomPassthrough(false);
      zoomDismissHandler = async () => {
        await restoreSelectionAction(selectionAction);
      };
      return;
    }

    if (isDeductionZoomActive()) return;

    openZoomFromCard(card);
  });

  attackLootBody?.addEventListener("click", async (e) => {
    const card = e.target.closest(".card72.wb-front, .id72");
    if (!card || !pendingAttackLoot) return;
    if (card.dataset.noSteal === "1"){
      pendingAttackLoot = { ...pendingAttackLoot, selected:{ noSteal:true, ownerUid:"", sourceKey:"" } };
      await setAttackLootPending(pendingAttackLoot);
      renderAttackLootPanel();
      await commitAttackLootSelection({ noSteal:true });
      return;
    }

    const ownerUid = safeText(card.dataset.ownerUid || "");
    const sourceKey = safeText(card.dataset.sourceKey || "");
    if (!ownerUid || !sourceKey || card.dataset.itemKind === "identity") return;
    pendingAttackLoot = { ...pendingAttackLoot, selected:{ ownerUid, sourceKey, noSteal:false } };
    await setAttackLootPending(pendingAttackLoot);
    renderAttackLootPanel();
    openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
    setZoomOverPanel(true);
    await new Promise(resolve => setTimeout(resolve, 180));
    showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "„Åì„ÅÆË£ÖÂÇô„ÇíÂ•™„ÅÑ„Åæ„Åô„Åã„ÄÇ", async () => {
      await commitAttackLootSelection({ ownerUid, sourceKey });
    }, { fixedLower:true, closeZoomOnNo:true });
  });

  attackLootBackdrop?.addEventListener("click", (e) => {
    if (e.target === attackLootBackdrop){
      e.stopPropagation();
    }
  });

  const hpBoard = document.getElementById("hpBoard");
  const positionLine = document.getElementById("positionLine");
  const turnEndWrap = document.getElementById("turnEndWrap");
  const btnEndTurn = document.getElementById("btnEndTurn");
  const endTurnConfirm = document.getElementById("endTurnConfirm");
  const endTurnConfirmMsg = document.getElementById("endTurnConfirmMsg");
  const btnEndTurnYes = document.getElementById("btnEndTurnYes");
  const btnEndTurnNo = document.getElementById("btnEndTurnNo");
  let damageCache = {};

  function clampDamage(v){
    const n = Number(v);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.min(15, Math.floor(n)));
  }

  function buildHpCells(){
    hpBoard.innerHTML = "";
    for (let row=15; row>=0; row--){
      const cell = document.createElement("div");
      cell.className = "hp-cell";
      cell.dataset.damage = String(row);
      hpBoard.appendChild(cell);
    }
  }

  function playerById(uid){
    return latestPlayers.find(p => p.id === uid) || null;
  }

  function isPlayerEliminated(uid){
    if (!uid) return false;
    const hand = state.hands?.[uid];
    const role = hand?.roleId ? ROLE_BY_ID[hand.roleId] : null;
    const hp = Number(role?.hp || 0);
    if (!hp) return false;
    const dmg = clampDamage(damageCache?.[uid]);
    return dmg >= hp;
  }

  function hasGuardianAngelShield(uid){
    const targetUid = safeText(uid);
    if (!targetUid) return false;
    return !!state.room?.guardianAngelShield?.[targetUid];
  }

  function isAttackTargetProtected(uid){
    return hasGuardianAngelShield(uid);
  }

  function buildChipFor(uid){
    const p = playerById(uid);
    const color = p?.color || "#ddd";
    const initial = firstChar(p?.name || "");
    const d = document.createElement("div");
    d.className = "chip16";
    d.style.background = color;
    d.style.color = textColorFor(color);
    d.textContent = initial || "";
    d.title = p ? p.name : "";
    if (canControlHpBoard()){
      d.style.cursor = "pointer";
      const longPressMs = 500;
      let longPressTimer = null;
      let longPressDone = false;
      const clearLongPressTimer = () => {
        if (!longPressTimer) return;
        clearTimeout(longPressTimer);
        longPressTimer = null;
      };

      d.addEventListener("pointerdown", (e) => {
        if (!e.target.closest("#hpBoard")) return;
        longPressDone = false;
        clearLongPressTimer();
        longPressTimer = setTimeout(async () => {
          longPressDone = true;
          if (!uid) return;
          await healDamageToPlayer(uid, 1);
        }, longPressMs);
      });
      d.addEventListener("pointerup", clearLongPressTimer);
      d.addEventListener("pointerleave", clearLongPressTimer);
      d.addEventListener("pointercancel", clearLongPressTimer);

      d.addEventListener("click", async (e) => {
        e.stopPropagation();
        clearLongPressTimer();
        if (longPressDone || !e.target.closest("#hpBoard")){
          longPressDone = false;
          return;
        }
        if (!uid) return;
        await addDamageToPlayer(uid, 1);
      });
    }
    return d;
  }

  function bindEliminatedChipRoomUp(chipEl, uid){
    if (!chipEl || !uid) return;
    chipEl.classList.add("eliminated-clickable");
    chipEl.title = `${chipEl.title ? chipEl.title + "\n" : ""}„ÇØ„É™„ÉÉ„ÇØ„Åß+1‰∏ä„ÅÆÈÉ®Â±ã„Å∏ÁßªÂãï`;
    chipEl.addEventListener("click", async (e) => {
      if (cardPlayerSelectActive || isEquipSelectionLockActive()) return;
      e.stopPropagation();
      await moveEliminatedPlayerToUpperRoom(uid);
    });
  }

  function turnState(){
    return state.room?.turn || null;
  }

  function currentTurnPlayerId(){
    return safeText(turnState()?.currentPlayerId || "");
  }

  function isMyTurn(){
    const cur = currentTurnPlayerId();
    return !!cur && cur === state.userId;
  }

  function isTestPlayer(){
    return safeText(state.userName).trim().toLowerCase() === "test";
  }

  function canControlHpBoard(){
    return isTestPlayer() || !!state.isHost;
  }

  function chooseSumForTestPlayer(label){
    if (!isTestPlayer()) return null;
    const input = window.prompt(`${label}„ÅÆÂêàË®àÁõÆ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑÔºà2„Äú10Ôºâ`, "7");
    if (input == null) return null;
    const sum = Number(input);
    if (!Number.isFinite(sum)) return null;
    return Math.max(2, Math.min(10, Math.floor(sum)));
  }

  function pickDiceBySum(sum){
    const pairs = [];
    for (let d6 = 1; d6 <= 6; d6++){
      const d4 = sum - d6;
      if (d4 >= 1 && d4 <= 4) pairs.push({ d6, d4 });
    }
    if (!pairs.length) return null;
    return pairs[Math.floor(Math.random() * pairs.length)];
  }

  function canUseMoveDice(){
    if (!isMyTurn()) return false;
    if (isDavidAbilityPending()) return false;
    if (mustResolveUranusMeteorStrike()) return false;
    return !turnState()?.moveDone;
  }

  function canUseAttackDice(){
    if (!isMyTurn()) return false;
    return !!turnState()?.moveDone && !turnState()?.attackDone;
  }

  function syncRoomAbilityTurnState(){
    const key = turnCycleKey();
    const turnOwnerUid = currentTurnPlayerId();
    if (!turnOwnerUid || turnOwnerUid !== attackAbilityUsageTurnOwnerUid){
      resetAttackAbilityUsageTurnState();
    }
    const roomActionState = turnRoomActionState();
    room4StealUsed = roomActionState.room4StealUsed;
    room3ActionUsed = roomActionState.room3ActionUsed;
    movedByDiceRoomId = roomActionState.movedByDiceRoomId;
    const hasMatchingPending = !!pendingAttackResolution
      && safeText(pendingAttackResolution.turnKey || "") === key
      && currentTurnPlayerId() === state.userId;
    if (roomAbilityTurnKey === key) return;
    roomAbilityTurnKey = key;
    walpurgisSwapUsed = false;
    uranusMeteorResolved = false;
    vampireHiddenAttackSuccess = false;
    vampireHealScheduled = false;
    hideRoomActionPop();
    if (!hasMatchingPending){
      hideAttackResultPop();
      pendingAttackResolution = null;
      pendingAttackResultMeta = null;
      attackTurnEndChoicePending = false;
      attackFlowUiLockActive = false;
      cachePendingAttackResolution(null);
    }
    showTurnHint("");
    clearCarolTurnHealTimer();
    scheduleCarolTurnStartHeal();
    if (isMyTurn() && isMyIdentityRevealed() && isMyRole("SHA_U2") && !isRoleAbilityUsed("SHA_U2")){
      const check = uranusAbilityAvailability();
      if (check.ok){
        setRoleAbilitySelectionState({ roleId:"SHA_U2", actorUid: state.userId, privateToActor:true }).catch(() => {});
      }
    }
  }

  function canUseRoom4Steal(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    const roomActionState = turnRoomActionState();
    if (roomActionState.room4StealUsed) return false;
    if (roomActionState.movedByDiceRoomId !== 4) return false;
    const others = latestPlayers.filter(p => p.id !== state.userId && !isPlayerEliminated(p.id));
    return others.some(p => hasAnyEquipment(p.id));
  }

  function canUseRoom3Action(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    const roomActionState = turnRoomActionState();
    if (roomActionState.room3ActionUsed) return false;
    return roomActionState.movedByDiceRoomId === 3;
  }


  function canUseWalpurgisSwap(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    if (!isMyRole("SHA_W2")) return false;
    if (!isMyIdentityRevealed()) return false;
    if (walpurgisSwapUsed) return false;
    return true;
  }

  async function animateMarkerSwapVisual(uidA, uidB, durationMs = 560){
    const markerA = markerCache?.[uidA] || null;
    const markerB = markerCache?.[uidB] || null;
    if (!markerA || !markerB) return;
    const ax = Number(markerA.x), ay = Number(markerA.y);
    const bx = Number(markerB.x), by = Number(markerB.y);
    if (![ax, ay, bx, by].every(Number.isFinite)) return;

    const ctm = roomSvg?.getScreenCTM();
    if (!roomSvg || !ctm) return;
    const aPt = roomSvg.createSVGPoint();
    aPt.x = ax; aPt.y = ay;
    const bPt = roomSvg.createSVGPoint();
    bPt.x = bx; bPt.y = by;
    const aScr = aPt.matrixTransform(ctm);
    const bScr = bPt.matrixTransform(ctm);

    const makeChip = (m) => {
      const chip = document.createElement("div");
      chip.className = "chip16";
      chip.style.position = "fixed";
      chip.style.left = "0";
      chip.style.top = "0";
      chip.style.zIndex = "11200";
      chip.style.pointerEvents = "none";
      chip.style.background = String(m.color || "#ddd");
      chip.style.color = textColorFor(String(m.color || "#ddd"));
      chip.style.transform = "translate(-50%,-50%)";
      chip.style.transition = `transform ${durationMs}ms cubic-bezier(.22,.78,.24,1)`;
      chip.textContent = String(m.initial || "").slice(0,1);
      document.body.appendChild(chip);
      return chip;
    };

    const setChipPos = (chip, x, y) => {
      chip.style.transform = `translate(${x}px, ${y}px) translate(-50%,-50%)`;
    };

    const bezierPoint = (p0, p1, p2, t) => {
      const it = 1 - t;
      return {
        x: it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x,
        y: it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y
      };
    };

    const chipA = makeChip(markerA);
    const chipB = makeChip(markerB);
    setChipPos(chipA, aScr.x, aScr.y);
    setChipPos(chipB, bScr.x, bScr.y);

    markerLayer?.classList.add("swap-animating");

    const mid = { x: (aScr.x + bScr.x) / 2, y: (aScr.y + bScr.y) / 2 };
    const dx = bScr.x - aScr.x;
    const dy = bScr.y - aScr.y;
    const dist = Math.hypot(dx, dy) || 1;
    const nx = -dy / dist;
    const ny = dx / dist;
    const arc = Math.max(26, Math.min(96, dist * 0.34));

    const pA0 = { x: aScr.x, y: aScr.y };
    const pA1 = { x: mid.x + nx * arc, y: mid.y + ny * arc };
    const pA2 = { x: bScr.x, y: bScr.y };
    const pB0 = { x: bScr.x, y: bScr.y };
    const pB1 = { x: mid.x - nx * arc, y: mid.y - ny * arc };
    const pB2 = { x: aScr.x, y: aScr.y };

    await new Promise(resolve => {
      const startedAt = performance.now();
      const step = (now) => {
        const elapsed = now - startedAt;
        const raw = Math.max(0, Math.min(1, elapsed / durationMs));
        const eased = 1 - Math.pow(1 - raw, 3);
        const pa = bezierPoint(pA0, pA1, pA2, eased);
        const pb = bezierPoint(pB0, pB1, pB2, eased);
        setChipPos(chipA, pa.x, pa.y);
        setChipPos(chipB, pb.x, pb.y);
        if (raw < 1){
          requestAnimationFrame(step);
          return;
        }
        resolve();
      };
      requestAnimationFrame(step);
    });

    chipA.remove();
    chipB.remove();
    markerLayer?.classList.remove("swap-animating");
  }

  async function swapMarkerPositionWithPlayer(targetUid){
    const myUid = safeText(state.userId || "");
    const otherUid = safeText(targetUid || "");
    if (!state.roomCode || !myUid || !otherUid || myUid === otherUid) return false;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const tx = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      cur.markers = cur.markers || {};
      const mine = cur.markers[myUid];
      const other = cur.markers[otherUid];
      if (!mine || !other) return cur;
      const nextMine = { ...mine };
      const nextOther = { ...other };

      nextMine.x = Number(other.x);
      nextMine.y = Number(other.y);
      nextMine.roomId = Number(other.roomId || mine.roomId || 7);
      nextMine.updatedAt = Date.now();

      nextOther.x = Number(mine.x);
      nextOther.y = Number(mine.y);
      nextOther.roomId = Number(mine.roomId || other.roomId || 7);
      nextOther.updatedAt = Date.now();

      cur.markers[myUid] = nextMine;
      cur.markers[otherUid] = nextOther;
      return cur;
    });
    return !!tx?.committed;
  }

  function showWalpurgisSwapConfirm(clientX, clientY, targetUid){
    const uid = safeText(targetUid || "");
    if (!uid || !canUseWalpurgisSwap()) return;
    const player = playerById(uid);
    const name = safeText(player?.name || "„Åì„ÅÆ„Éó„É¨„Ç§„É§„Éº");
    suppressOutsidePopCloseUntil = Date.now() + 700;
    showRoomActionPopAt(clientX, clientY, "", async () => {
      if (!canUseWalpurgisSwap()) return;
      walpurgisSwapUsed = true;
      await emitRoleFlashEvent("SHA_W2", "walpurgis_swap");
      await new Promise(resolve => setTimeout(resolve, 1200));
      try {
        await emitWalpurgisSwapEvent(state.userId, uid, 620);
        await new Promise(resolve => setTimeout(resolve, 620));
        await swapMarkerPositionWithPlayer(uid);
      } finally {
        markerLayer?.classList.remove("swap-animating");
        renderMarkers();
      }
    }, {
      messageHtml: `${escapeHtml(name)}„Å®‰ΩçÁΩÆ„Çí‰∫§Êèõ„Åó„Åæ„Åô„Åã„ÄÇ`,
      yesLabel: "„ÅØ„ÅÑ",
      noLabel: "„ÅÑ„ÅÑ„Åà",
      yesBtnClass: "pop-purple",
      noBtnClass: "pop-white"
    });
  }

  function refreshRoomAbilityHint(){
    if (canUseRoom4Steal()){
      showTurnHint("‰ªñ„Éó„É¨„Ç§„É§„Éº„ÅÆË£ÖÂÇô„ÇíÂ•™„ÅÜ„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ");
      return;
    }
    if (canUseRoom3Action()){
      showTurnHint({
        text: "‰ªªÊÑè„ÅÆ„Éó„É¨„Ç§„É§„Éº„Å∏2„ÉÄ„É°„Éº„Ç∏/1ÂõûÂæ©„Åß„Åç„Åæ„Åô„ÄÇ",
        showRoom3Skip: true
      });
      return;
    }
    if (canUseWalpurgisSwap()){
      showTurnHint("„Éó„É¨„Ç§„É§„Éº„ÇíÈï∑Êäº„Åó„Åß‰ΩçÁΩÆ„Çí‰∫§Êèõ");
      return;
    }
    showTurnHint("");
  }

  async function stealEquipmentFromPlayer(targetUid, sourceKey){
    if (!state.roomCode || !targetUid || !sourceKey) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const targetRow = cur.equipment?.[targetUid];
      if (!targetRow) return cur;
      const item = targetRow[sourceKey];
      if (!item || item.kind === "identity") return cur;

      const oldCount = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
      if (oldCount > 1){
        const next = { ...item, count: oldCount - 1 };
        delete next.qty;
        delete next.quantity;
        targetRow[sourceKey] = next;
      } else {
        delete targetRow[sourceKey];
      }

      const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
      cur.equipment[state.userId] = cur.equipment[state.userId] || {};
      cur.equipment[state.userId][addKey] = {
        theme: safeText(item.theme || "white"),
        name: safeText(item.name || ""),
        effect: safeText(item.effect || ""),
        at: Date.now()
      };
      return cur;
    });
    return !!result.committed;
  }


  async function stealAllEquipmentFromPlayer(targetUid){
    const uid = safeText(targetUid);
    if (!state.roomCode || !uid || uid === state.userId) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const targetRow = cur.equipment?.[uid];
      if (!targetRow) return cur;
      const stealItems = Object.entries(targetRow)
        .filter(([, item]) => item && item.kind !== "identity")
        .map(([, item]) => item);
      if (!stealItems.length) return cur;
      cur.equipment = cur.equipment || {};
      cur.equipment[state.userId] = cur.equipment[state.userId] || {};
      for (const item of stealItems){
        const copies = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
        for (let i = 0; i < copies; i++){
          const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
          cur.equipment[state.userId][addKey] = {
            theme: safeText(item.theme || "white"),
            name: safeText(item.name || ""),
            effect: safeText(item.effect || ""),
            at: Date.now()
          };
        }
      }
      for (const [key, item] of Object.entries(targetRow)){
        if (!item || item.kind === "identity") continue;
        delete targetRow[key];
      }
      return cur;
    });
    return !!result.committed;
  }


  async function runRosaryAutoLootFlow(defeatedUids = []){
    const targets = [...new Set((defeatedUids || []).map(uid => safeText(uid)).filter(uid => uid && uid !== state.userId))]
      .filter(uid => listEquipForUid(uid).some(it => !isIdentityEquipItem(it)));
    if (!targets.length) return;

    await waitUntilZoomClosed({ maxWaitMs:16000, pollMs:80 });
    openZoomFromDeckCard({ name:"ÈäÄ„ÅÆ„É≠„Ç∂„É™„Ç™", effect:"Ë£ÖÂÇô„ÄÅ„ÉÄ„Ç§„Çπ„ÅÆÊîªÊíÉ„Å´„Çà„Å£„Å¶ÂÄí„Åó„ÅüPL„ÅÆÂÖ®„Å¶„ÅÆË£ÖÂÇô„ÇíÂ•™„ÅÜ„ÄÇ" }, "white", {
      closeOnBackdrop:false,
      showCloseButton:false
    });
    setZoomOverPanel(true);

    await new Promise(resolve => setTimeout(resolve, 1000));
    for (const uid of targets){
      await stealAllEquipmentFromPlayer(uid);
    }
    closeZoom();
    renderEquipmentDock();
  }

  async function moveEquipmentCardBetweenPlayers(fromUid, toUid, sourceKey){
    if (!state.roomCode || !fromUid || !toUid || !sourceKey) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const fromRow = cur.equipment?.[fromUid];
      if (!fromRow) return cur;
      const item = fromRow[sourceKey];
      if (!item || item.kind === "identity") return cur;

      const oldCount = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
      if (oldCount > 1){
        const next = { ...item, count: oldCount - 1 };
        delete next.qty;
        delete next.quantity;
        fromRow[sourceKey] = next;
      } else {
        delete fromRow[sourceKey];
      }

      cur.equipment = cur.equipment || {};
      cur.equipment[toUid] = cur.equipment[toUid] || {};
      const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
      cur.equipment[toUid][addKey] = {
        theme: safeText(item.theme || "white"),
        name: safeText(item.name || ""),
        effect: safeText(item.effect || ""),
        at: Date.now()
      };
      return cur;
    });
    return !!result.committed;
  }

  function restoreOliverZoomSelection(){
    const cardObj = pendingEquipAction?.cardObj || null;
    if (!cardObj) return;
    openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
    setZoomOverPanel(false);
    setZoomPassthrough(true);
    pendingEquipAction = { type:"oliver_target", cardObj };
    renderEquipmentDock();
    renderTurnEndButton();
  }

  function isEquipSelectionLockActive(){
    return pendingEquipAction?.type === "oliver_target" || pendingEquipAction?.type === "banana_give";
  }

  function captureSelectionRestoreAction(){
    if (isEquipSelectionLockActive()) return { kind:"equip", ...pendingEquipAction };
    if (activeRoleAbilitySelection){
      return { kind:"role_ability", entry: activeRoleAbilitySelection };
    }
    if (cardPlayerSelectActive && pendingCardTargetSelection?.cardObj){
      return { kind:"card_target", cardObj: pendingCardTargetSelection.cardObj };
    }
    if (isIdentityPromptInteractionLockActive()){
      return {
        kind:"identity_prompt",
        cardObj: pendingIdentityPrompt?.cardObj || null,
        cardTheme: safeText(pendingIdentityPrompt?.cardTheme || "white") || "white",
        message: safeText(pendingIdentityPrompt?.message || ""),
        canReveal: !!pendingIdentityPrompt?.canReveal
      };
    }
    return null;
  }

  async function restoreSelectionAction(action){
    if (!action) return;
    if (action.kind === "equip"){
      restorePendingEquipSelection(action);
      return;
    }
    if (action.kind === "role_ability"){
      openRoleAbilitySelectionUI(action.entry || null);
      return;
    }
    if (action.kind === "card_target"){
      await openPersistentCardTargetSelection(action.cardObj, { restore:true });
      return;
    }
    if (action.kind === "identity_prompt") restoreIdentityPromptSelection(action);
  }

  function restorePendingEquipSelection(action = null){
    const next = action || pendingEquipAction;
    const type = safeText(next?.type || "");
    if (!next || (type !== "oliver_target" && type !== "banana_give")) return;
    const cardObj = next.cardObj || null;
    if (!cardObj) return;
    openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(true);
    if (type === "banana_give"){
      pendingEquipAction = { type:"banana_give", selectedSourceKey:"", cardObj };
    } else {
      pendingEquipAction = { type:"oliver_target", cardObj };
    }
    renderEquipmentDock();
    renderTurnEndButton();
  }

  function restoreSeatEquipSelection(entry){
    const type = safeText(entry?.type || "");
    const cardObj = entry?.cardObj || null;
    if (!cardObj || (type !== "banana_give" && type !== "oliver_target")){
      pendingEquipAction = null;
      renderTurnEndButton();
      return;
    }
    restoringSeatEquipSelection = true;
    try {
      restorePendingEquipSelection({ type, cardObj });
    } finally {
      restoringSeatEquipSelection = false;
    }
  }

  function canShowEndTurnButton(){
    if (!isMyTurn()) return false;
    if (!identityPromptPop?.classList.contains("hidden")) return false;
    if (cardPlayerSelectActive) return false;
    if (isEquipSelectionLockActive()) return false;
    if (pendingEquipAction?.type === "oliver_confirm") return false;
    if (mustAttackWithMasamune()) return false;
    if (attackTurnEndChoicePending) return false;
    if (attackFlowUiLockActive) return false;
    if (suppressEndTurnButton) return false;
    if (hpBoardAnimationActive) return false;
    return !!turnState()?.moveDone;
  }

  function mustAttackWithMasamune(){
    if (!isMyTurn()) return false;
    if (!hasMyEquipmentByName("Â¶ñÂàÄ„Éû„Çµ„É†„Éç")) return false;
    if (!!turnState()?.attackDone) return false;
    return highlightedMarkerUids().size > 0;
  }

  function hideEndTurnConfirm(){
    endTurnConfirm?.classList.add("hidden");
  }

  function showEndTurnConfirm(options = {}){
    if (endTurnConfirmMsg){
      endTurnConfirmMsg.textContent = safeText(options.message || "Êú¨ÂΩì„Å´ÁµÇ‰∫Ü„Åó„Åæ„Åô„Åã„ÄÇ");
    }
    endTurnConfirm?.classList.remove("hidden");
  }

  function repeatTurnPending(){
    return Number(turnState()?.repeatTurnRemaining || 0) > 0;
  }

  function repeatTurnLabel(){
    const rest = Math.max(0, Number(turnState()?.repeatTurnRemaining || 0));
    const total = Math.max(0, Number(turnState()?.repeatTurnTotal || 0));
    if (rest <= 0 || total <= 0) return "„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊâãÁï™„ÇíË°å„ÅÜ";
    return `„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊâãÁï™„ÇíË°å„ÅÜ(${rest}/${total})`;
  }

  function hasSealWisdomBonusThisTurn(){
    return !!turnState()?.sealWisdomBonus;
  }

  function renderTurnEndButton(){
    syncRoomAbilityTurnState();
    if (!turnEndWrap) return;
    const visible = isGameStarted() && canShowEndTurnButton();
    turnEndWrap.classList.toggle("hidden", !visible);
    if (btnEndTurn){
      if (hasSealWisdomBonusThisTurn()){
        btnEndTurn.textContent = "ÊâãÁï™„ÇíÁµÇ„Çè„Çã(+1)";
      } else {
        btnEndTurn.textContent = repeatTurnPending() ? repeatTurnLabel() : "ÊâãÁï™„ÇíÁµÇ„Çè„Çã";
      }
    }
    if (!visible) hideEndTurnConfirm();
  }

  function turnCycleKey(){
    const t = turnState() || {};
    const cur = safeText(t.currentPlayerId || "");
    const updatedAt = Number(t.updatedAt || 0);
    return `${cur}:${updatedAt}`;
  }

  function maybeAutoRollMoveDiceOnTurnStart(){
    if (!isGameStarted()) return;
    if (!canUseMoveDice()) return;
    if (!state.userId) return;

    const myMarker = markerCache?.[state.userId] || null;
    if (myMarker) return;

    const key = turnCycleKey();
    if (!key || key === autoMoveTriggeredTurnKey) return;

    autoMoveTriggeredTurnKey = key;
    hideAttackPop();
    setTimeout(() => triggerMoveDiceForAll(), 80);
  }

  async function triggerMoveDiceForAll(){
    if (!state.roomCode || !canUseMoveDice()) return;
    const selectedSum = chooseSumForTestPlayer("ÁßªÂãï");
    if (isTestPlayer() && selectedSum == null) return;
    const selectedPair = selectedSum != null ? pickDiceBySum(selectedSum) : null;
    const d6 = selectedPair?.d6 ?? (1 + Math.floor(Math.random() * 6));
    const d4 = selectedPair?.d4 ?? (1 + Math.floor(Math.random() * 4));
    const compass = hasMyEquipmentByName('Á•ûÁßò„ÅÆ„Ç≥„É≥„Éë„Çπ');
    const secondD6 = 1 + Math.floor(Math.random() * 6);
    const secondD4 = 1 + Math.floor(Math.random() * 4);
    const width = window.innerWidth;
    const height = window.innerHeight;
    const motion = createDiceMotion(width, height, width/2, height/2);
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/move`), {
      uid: state.userId,
      d6,
      d4,
      compass,
      secondD6,
      secondD4,
      motion,
      at: Date.now()
    });
  }

  function nameFromSecondChar(name){
    const chars = Array.from(safeText(name || "").trim());
    return chars.slice(1).join("");
  }

  function hideAttackResultPop(){
    attackResultPop?.classList.add("hidden");
    attackResultChoiceBusy = false;
  }

  function normalizeAttackResultMeta(meta){
    if (!meta || typeof meta !== "object") return null;
    return {
      showBonusLabel: !!meta.showBonusLabel,
      allowExcaliburButton: !!meta.allowExcaliburButton,
      freddieSpecial: !!meta.freddieSpecial,
      zeroDamagePreview: !!meta.zeroDamagePreview
    };
  }

  function cachePendingAttackResolution(pending){
    if (!state.roomCode || !state.userId) return;
    const key = attackResolutionKey(state.roomCode);
    if (!pending || typeof pending !== "object"){
      sessionStorage.removeItem(key);
      return;
    }
    const rows = Array.isArray(pending.rows)
      ? pending.rows.map(item => ({
          uid: safeText(item?.uid || ""),
          damage: Math.max(0, Number(item?.damage || 0))
        })).filter(item => item.uid)
      : [];
    if (!rows.length){
      sessionStorage.removeItem(key);
      return;
    }
    const meta = normalizeAttackResultMeta(pending.meta);
    sessionStorage.setItem(key, JSON.stringify({ rows, turnKey: safeText(pending.turnKey || ""), meta }));
  }

  async function upsertPendingAttackResolution(rows = [], turnKey = "", meta = null){
    const uid = safeText(state.userId || "");
    const roomCode = safeText(state.roomCode || "");
    if (!uid || !roomCode) return;
    const normalizedRows = (rows || [])
      .map(item => ({ uid: safeText(item?.uid || ""), damage: Math.max(0, Number(item?.damage || 0)) }))
      .filter(item => item.uid);
    const normalizedTurnKey = safeText(turnKey || "");
    const payload = normalizedRows.length ? {
      uid,
      rows: normalizedRows,
      turnKey: normalizedTurnKey,
      meta: normalizeAttackResultMeta(meta),
      at: Date.now()
    } : null;
    await set(ref(db, `rooms/${roomCode}/attackResolutionPending/${uid}`), payload);
  }

  function restorePendingAttackResolutionFromRoom(){
    const roomPending = state.room?.attackResolutionPending || {};
    const mine = roomPending?.[state.userId] || null;
    const rows = Array.isArray(mine?.rows)
      ? mine.rows.map(item => ({ uid: safeText(item?.uid || ""), damage: Math.max(0, Number(item?.damage || 0)) })).filter(item => item.uid)
      : [];
    const meta = normalizeAttackResultMeta(mine?.meta);
    const pendingTurnKey = safeText(mine?.turnKey || "");
    const canRestore = !!rows.length && currentTurnPlayerId() === state.userId && pendingTurnKey === turnCycleKey();
    if (!canRestore){
      pendingAttackResolution = null;
      pendingAttackResultMeta = null;
      attackTurnEndChoicePending = false;
      cachePendingAttackResolution(null);
      hideAttackResultPop();
      renderTurnEndButton();
      return false;
    }
    pendingAttackResolution = { rows, applied:false, turnKey: pendingTurnKey, meta };
    pendingAttackResultMeta = meta;
    cachePendingAttackResolution(pendingAttackResolution);
    showAttackResultPop(rows);
    attackTurnEndChoicePending = true;
    attackFlowUiLockActive = true;
    renderTurnEndButton();
    return true;
  }

  function restoreAttackLootPendingFromRoom(){
    const roomPending = state.room?.attackLootPending || {};
    const mine = normalizeAttackLootPayload(roomPending?.[state.userId] || null);
    pendingAttackLoot = mine;
    renderAttackLootPanel();
  }

  function restorePendingAttackResolutionFromSession(){
    if (!state.roomCode || !state.userId) return false;
    const raw = sessionStorage.getItem(attackResolutionKey(state.roomCode));
    if (!raw) return false;
    let parsed = null;
    try {
      parsed = JSON.parse(raw);
    } catch {
      sessionStorage.removeItem(attackResolutionKey(state.roomCode));
      return false;
    }
    const rows = Array.isArray(parsed?.rows)
      ? parsed.rows.map(item => ({ uid: safeText(item?.uid || ""), damage: Math.max(0, Number(item?.damage || 0)) })).filter(item => item.uid)
      : [];
    const meta = normalizeAttackResultMeta(parsed?.meta);
    const pendingTurnKey = safeText(parsed?.turnKey || "");
    if (!rows.length || !pendingTurnKey){
      sessionStorage.removeItem(attackResolutionKey(state.roomCode));
      return false;
    }
    pendingAttackResolution = { rows, applied:false, turnKey: pendingTurnKey, meta };
    pendingAttackResultMeta = meta;
    showAttackResultPop(rows);
    attackTurnEndChoicePending = true;
    attackFlowUiLockActive = true;
    renderTurnEndButton();
    return true;
  }

  function makeAttackResultNameNode(uid){
    const wrap = document.createElement("span");
    wrap.className = "green-share-btn attack-result-pop-name";
    const p = playerById(uid);
    const chip = document.createElement("span");
    chip.className = "chip16";
    const color = p?.color || "#ddd";
    chip.style.background = color;
    chip.style.color = textColorFor(color);
    chip.textContent = firstChar(p?.name || "");
    const text = document.createElement("span");
    text.className = "attack-result-pop-name-text";
    const rest = nameFromSecondChar(p?.name || "");
    text.textContent = rest || safeText(p?.name || "-");
    wrap.appendChild(chip);
    wrap.appendChild(text);
    return wrap;
  }

  function showAttackResultPop(rows = []){
    if (!attackResultPop || !attackResultRows) return;
    attackResultRows.innerHTML = "";
    const exMeta = pendingAttackResultMeta || {};
    if (!rows.length){
      const row = document.createElement("div");
      row.className = "attack-result-pop-row";
      row.textContent = "„ÉÄ„É°„Éº„Ç∏ÂØæË±°„ÅØ„ÅÑ„Åæ„Åõ„Çì„ÄÇ";
      attackResultRows.appendChild(row);
    }
    for (const item of rows){
      const uid = safeText(item?.uid || "");
      if (!uid) continue;
      const row = document.createElement("div");
      row.className = "attack-result-pop-row";
      const amount = document.createElement("span");
      const damageValue = Math.max(0, Number(item?.damage || 0));
      const treatZeroAsPreview = !!(exMeta.zeroDamagePreview && damageValue === 0);
      amount.textContent = (damageValue > 0 || treatZeroAsPreview) ? `${damageValue} Damege >` : "ÊîªÊíÉÂ§±Êïó >";
      row.appendChild(amount);
      if (exMeta.showBonusLabel){
        const plus = document.createElement("span");
        plus.className = "attack-result-plus-two";
        plus.textContent = "(+2)";
        row.appendChild(plus);
      }
      row.appendChild(makeAttackResultNameNode(uid));
      attackResultRows.appendChild(row);
    }
    const spec = attackAbilitySpecFromRows(rows);
    if (btnAttackResultEnd){
      btnAttackResultEnd.textContent = hasSealWisdomBonusThisTurn() ? "OK„Åä„Çè„Çã(+1)" : "OK„Åä„Çè„Çã";
    }
    if (btnAttackResultKeep){
      if (spec){
        btnAttackResultKeep.innerHTML = `OK <span class="ability-pill">${escapeHtml(formatAttackAbilityPillLabel(spec.abilityName))}</span>`;
      } else {
        btnAttackResultKeep.textContent = "OK„Åä„Çè„Çâ„Å™„ÅÑ";
      }
    }
    const roleId = safeText(myRoleInfo()?.id || "");
    const shouldHideKeepAsSecondAttack = !spec
      && (roleId === "CIT_C1" || roleId === "SHA_U3")
      && isAttackAbilityUsedThisTurn(roleId);
    btnAttackResultExcalibur?.classList.toggle("hidden", !exMeta.allowExcaliburButton);
    btnAttackResultEnd?.classList.remove("hidden");
    btnAttackResultKeep?.classList.toggle("hidden", shouldHideKeepAsSecondAttack);
    attackResultChoiceBusy = false;
    attackResultPop.classList.remove("hidden");
  }

  async function addResolvedDamageToPlayers(rows = []){
    const entries = (rows || [])
      .map(item => ({ uid: safeText(item?.uid || ""), damage: Math.max(0, Number(item?.damage || 0)) }))
      .filter(item => item.uid && item.damage > 0);
    if (!state.roomCode || !entries.length) return;

    const expected = new Set();
    for (const item of entries){
      const roleId = safeText(state.hands?.[item.uid]?.roleId || "");
      const hp = Number(ROLE_BY_ID?.[roleId]?.hp || 0);
      if (hp <= 0) continue;
      const before = clampDamage(damageCache?.[item.uid]);
      const after = clampDamage(before + item.damage);
      if (before < hp && after >= hp){
        expected.add(item.uid);
      }
    }
    attackExpectedEliminationUids = expected;
    attackExpectedEliminationAt = Date.now();

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      cur.damage = cur.damage || {};
      for (const item of entries){
        cur.damage[item.uid] = clampDamage(Number(cur.damage[item.uid] || 0) + item.damage);
      }
      return cur;
    });
  }

  async function waitForHpBoardSwapAnimationEnd(maxWaitMs = 1800){
    const startedAt = Date.now();
    while (hpBoardAnimationActive && (Date.now() - startedAt) < maxWaitMs){
      await new Promise(resolve => setTimeout(resolve, 40));
    }
  }

  async function finalizePendingAttackResolution(endTurnAfterApply){
    const pending = pendingAttackResolution;
    pendingAttackResolution = null;
    pendingAttackResultMeta = null;
    attackTurnEndChoicePending = false;
    suppressEndTurnButton = true;
    cachePendingAttackResolution(null);
    await upsertPendingAttackResolution([], "");
    renderTurnEndButton();
    hideAttackResultPop();
    clearAttackResultDice();
    if (!pending || pending.applied){
      if (!endTurnAfterApply){
        attackFlowUiLockActive = false;
        suppressEndTurnButton = ulsterExtraAttackPending > 0;
        renderTurnEndButton();
      }
      return;
    }
    pending.applied = true;
    await addResolvedDamageToPlayers(pending.rows || []);
    if (endTurnAfterApply){
      ulsterExtraAttackPending = 0;
      await new Promise(resolve => setTimeout(resolve, 2000));
      await doEndTurn();
      attackFlowUiLockActive = false;
      suppressEndTurnButton = false;
      renderTurnEndButton();
      return;
    }

    await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
    await waitForHpBoardSwapAnimationEnd();
    if (ulsterExtraAttackPending > 0){
      ulsterExtraAttackPending = Math.max(0, ulsterExtraAttackPending - 1);
    }
    attackFlowUiLockActive = false;
    suppressEndTurnButton = ulsterExtraAttackPending > 0;
    renderTurnEndButton();
  }

  function animateHpBoardSwapIfNeeded(){
    const swap = pendingHpSwapAnimation;
    if (!swap || !hpBoard) return;
    pendingHpSwapAnimation = null;
    const fromA = hpBoard.querySelector(`.hp-cell .chip16[data-uid="${swap.aUid}"]`);
    const fromB = hpBoard.querySelector(`.hp-cell .chip16[data-uid="${swap.bUid}"]`);
    if (!fromA || !fromB) return;

    const rectA = fromA.getBoundingClientRect();
    const rectB = fromB.getBoundingClientRect();
    if (!rectA.width || !rectB.width) return;

    const floatA = fromA.cloneNode(true);
    const floatB = fromB.cloneNode(true);
    for (const node of [floatA, floatB]){
      node.style.position = 'fixed';
      node.style.margin = '0';
      node.style.zIndex = '360';
      node.style.pointerEvents = 'none';
    }

    floatA.style.left = `${rectA.left}px`;
    floatA.style.top = `${rectA.top}px`;
    floatB.style.left = `${rectB.left}px`;
    floatB.style.top = `${rectB.top}px`;

    document.body.appendChild(floatA);
    document.body.appendChild(floatB);

    fromA.style.opacity = '0';
    fromB.style.opacity = '0';

    const dxAB = rectB.left - rectA.left;
    const dyAB = rectB.top - rectA.top;
    const dxBA = rectA.left - rectB.left;
    const dyBA = rectA.top - rectB.top;
    const curveY = Math.max(28, Math.min(84, Math.abs(dxAB) * 0.28));

    const animationMs = 520;
    const easing = 'cubic-bezier(.22,.75,.2,1)';
    const endA = floatA.animate([
      { transform:'translate(0px, 0px) scale(1)' },
      { transform:`translate(${dxAB*0.5}px, ${dyAB*0.5-curveY}px) scale(1.05)` },
      { transform:`translate(${dxAB}px, ${dyAB}px) scale(1)` }
    ], { duration:animationMs, easing, fill:'forwards' });

    const endB = floatB.animate([
      { transform:'translate(0px, 0px) scale(1)' },
      { transform:`translate(${dxBA*0.5}px, ${dyBA*0.5+curveY}px) scale(1.05)` },
      { transform:`translate(${dxBA}px, ${dyBA}px) scale(1)` }
    ], { duration:animationMs, easing, fill:'forwards' });

    hpBoardAnimationActive = true;
    renderTurnEndButton();

    Promise.allSettled([endA.finished, endB.finished]).finally(() => {
      floatA.remove();
      floatB.remove();
      fromA.style.opacity = '';
      fromB.style.opacity = '';
      hpBoardAnimationActive = false;
      renderTurnEndButton();
    });
  }

  function renderHpBoard(){
    if (!hpBoard) return;
    if (!state.roomCode) return;

    if (!hpBoard.firstChild) buildHpCells();

    const cells = Array.from(hpBoard.querySelectorAll(".hp-cell"));
    for (const c of cells){
      c.querySelectorAll(".chip16").forEach(x => x.remove());
    }

    const entries = Object.entries(damageCache || {}).map(([uid, lvl]) => ({
      uid, lvl: clampDamage(lvl)
    }));

    const started = isGameStarted();
    if (started && entries.length === 0 && latestPlayers.length > 0){
      for (const p of latestPlayers){
        entries.push({ uid: p.id, lvl: 0 });
      }
    }

    const byLvl = new Map();
    for (const e of entries){
      const arr = byLvl.get(e.lvl) || [];
      arr.push(e.uid);
      byLvl.set(e.lvl, arr);
    }

    for (const [lvl, uids] of byLvl.entries()){
      uids.sort((a,b) => {
        const pa = playerById(a);
        const pb = playerById(b);
        return Number(pa?.seatIndex||999) - Number(pb?.seatIndex||999);
      });
      byLvl.set(lvl, uids);
    }

    for (const cell of cells){
      const lvl = Number(cell.dataset.damage);
      const uids = byLvl.get(lvl) || [];
      for (const uid of uids){
        const chip = buildChipFor(uid);
        if (isPlayerEliminated(uid)){
          bindEliminatedChipRoomUp(chip, uid);
        }
        cell.appendChild(chip);
      }
    }
    animateHpBoardSwapIfNeeded();
  }

  function renderPositionLine(){
    if (!positionLine) return;

    const started = isGameStarted();
    const order = Array.isArray(state.room?.positionOrder) ? state.room.positionOrder : [];
    const turnPlayerId = currentTurnPlayerId();

    let players = [];
    if (started && order.length > 0){
      players = order
        .map(uid => latestPlayers.find(p => p.id === uid) || null)
        .filter(Boolean);
      const rest = latestPlayers
        .filter(p => !order.includes(p.id))
        .sort((a,b) => Number(a.seatIndex || 999) - Number(b.seatIndex || 999));
      players.push(...rest);
    } else {
      players = latestPlayers
        .slice()
        .sort((a,b) => Number(a.seatIndex || 999) - Number(b.seatIndex || 999));
    }

    positionLine.innerHTML = "";
    if (!started || players.length === 0){
      positionLine.classList.add("hidden");
      renderTurnEndButton();
      return;
    }

    players.forEach((p, idx) => {
      if (idx > 0){
        const arrow = document.createElement("span");
        arrow.className = "position-arrow";
        arrow.textContent = "‚ñ∂";
        positionLine.appendChild(arrow);
      }
      const item = document.createElement("div");
      item.className = "position-item";

      const eliminated = isPlayerEliminated(p.id);
      const chipWrap = document.createElement("div");
      chipWrap.className = "position-chip-wrap";
      const chip = buildChipFor(p.id);
      if (started && p.id === turnPlayerId && !eliminated){
        chip.classList.add("turn-pulse");
      }
      if (eliminated) bindEliminatedChipRoomUp(chip, p.id);
      chipWrap.appendChild(chip);

      const marker = document.createElement("div");
      marker.className = "starter-mark";
      marker.textContent = (started && p.id === turnPlayerId) ? "‚ñ≥" : "";

      const tempRole = temporaryRoleTagByUid?.[p.id];
      if (tempRole && Number(tempRole.until || 0) <= Date.now()){
        delete temporaryRoleTagByUid[p.id];
      }
      const bubbleText = safeText((temporaryRoleTagByUid?.[p.id]?.text) || (activeGreenReplies?.[p.id] || ""));
      if (bubbleText){
        const bubble = document.createElement("div");
        bubble.className = "position-bubble";
        bubble.textContent = bubbleText;
        chipWrap.appendChild(bubble);
      }

      item.appendChild(chipWrap);
      item.appendChild(marker);

      positionLine.appendChild(item);
    });

    positionLine.classList.remove("hidden");
    updateRoomChoiceUi();
    renderTurnEndButton();
  }


  async function ensureCurrentTurnPlayerAlive(){
    const curId = currentTurnPlayerId();
    if (!curId) return;
    if (!isPlayerEliminated(curId)) return;
    await advanceTurnToNextPlayer();
  }

  function subscribeDamage(){
    const dRef = ref(db, `rooms/${state.roomCode}/damage`);
    onValue(dRef, snap => {
      damageCache = snap.val() || {};

      const eliminatedNow = {};
      for (const p of latestPlayers){
        eliminatedNow[p.id] = isPlayerEliminated(p.id);
      }
      const watchActive = lastAttackWatch
        && lastAttackWatch.uid === state.userId
        && (Date.now() - Number(lastAttackWatch.at || 0) < 12000);
      const expectedAttackWindowActive = (Date.now() - Number(attackExpectedEliminationAt || 0) < 12000);
      const attackDefeatedUids = [];
      if (watchActive && expectedAttackWindowActive){
        for (const uid of (lastAttackWatch.targetUids || [])){
          if (!uid || !attackExpectedEliminationUids.has(uid)) continue;
          const becameEliminated = !!eliminatedNow[uid] && !previousEliminatedMap[uid];
          if (!becameEliminated) continue;
          attackDefeatedUids.push(uid);
          attackExpectedEliminationUids.delete(uid);
        }
      }

      const myRoleId = safeText(state.hands?.[state.userId]?.roleId || "");
      if (myRoleId === "CIT_D1" && !isMyIdentityRevealed()){
        const othersEliminatedNow = latestPlayers.some(p => p.id !== state.userId && !!eliminatedNow[p.id]);
        const othersEliminatedBefore = latestPlayers.some(p => p.id !== state.userId && !!previousEliminatedMap[p.id]);
        if (othersEliminatedNow && !othersEliminatedBefore && !danielAutoRevealTimer){
          danielAutoRevealTimer = setTimeout(async () => {
            danielAutoRevealTimer = null;
            await waitUntilZoomClosed();
            await revealMyIdentityToEquipment({ revealedBy:"daniel_forced" });
          }, 2000);
        }
      }

      const justEliminatedUids = latestPlayers
        .map(p => p.id)
        .filter(uid => !!eliminatedNow[uid] && !previousEliminatedMap[uid]);

      if (myRoleId === "CIT_B3" && attackDefeatedUids.length && !isMyIdentityRevealed() && !bruceAutoRevealTimer){
        const hadHiddenRevealTarget = attackDefeatedUids.some(uid => justEliminatedUids.includes(uid) && !isIdentityRevealedFor(uid));
        const revealDelayMs = hadHiddenRevealTarget ? 2200 : 0;
        bruceAutoRevealTimer = setTimeout(async () => {
          bruceAutoRevealTimer = null;
          if (isMyIdentityRevealed()) return;
          if (!isMyRole("CIT_B3")) return;
          await waitUntilZoomClosed();
          await revealMyIdentityToEquipment({ revealedBy:"bruce_ability" });
          const role = myRoleInfo();
          if (role) openIdentityRevealZoom(role, state.userId);
        }, revealDelayMs);
      }

      if (justEliminatedUids.includes(state.userId) && isMyRole("RAI_G3") && !isRoleAbilityUsed("RAI_G3")){
        setRoleAbilitySelectionState({ roleId:"RAI_G3", actorUid: state.userId }).catch(() => {});
      }

      previousEliminatedMap = eliminatedNow;

      renderHpBoard();
      ensureCurrentTurnPlayerAlive();

      const justEliminatedUnrevealed = [];

      for (const [uid, dmgRaw] of Object.entries(damageCache)){
        const myHand = state.hands?.[uid];
        const role = myHand?.roleId ? ROLE_BY_ID[myHand.roleId] : null;
        const hp = Number(role?.hp || 0);
        const dmg = clampDamage(dmgRaw);
        if (!uid || !hp || dmg < hp){
          autoDamageRevealLock[uid] = false;
          continue;
        }
        if (autoDamageRevealLock[uid]) continue;
        autoDamageRevealLock[uid] = true;
        const alreadyRevealed = isIdentityRevealedFor(uid);
        if (!alreadyRevealed && justEliminatedUids.includes(uid)){
          justEliminatedUnrevealed.push({ uid, role });
        }
        revealIdentityByDamage(uid).catch(() => {});
      }

      if (justEliminatedUnrevealed.length >= 2){
        openMultiIdentityRevealZoom(justEliminatedUnrevealed);
      } else if (justEliminatedUnrevealed.length === 1){
        const entry = justEliminatedUnrevealed[0];
        openIdentityRevealZoom(entry.role, entry.uid);
      }

      if (attackDefeatedUids.length){
        const shouldUseRosaryLoot = !!lastAttackWatch?.hasRosary;
        setTimeout(() => {
          if (shouldUseRosaryLoot){
            runRosaryAutoLootFlow(attackDefeatedUids).catch(() => {});
          } else {
            createOrMergeAttackLootPending(attackDefeatedUids).catch(() => {});
          }
        }, 2200);
      }

      renderEquipmentDock();
      const myRoleBack = myRoleCard?.querySelector('.role-back');
      if (myRoleBack){
        myRoleBack.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));
      }
    });
  }


  function subscribeDiceEvents(){
    const moveRef = ref(db, `rooms/${state.roomCode}/diceEvents/move`);
    onValue(moveRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!moveDiceEventInitialized){
        moveDiceEventInitialized = true;
        moveDiceEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= moveDiceEventSeenAt) return;
      moveDiceEventSeenAt = at;
      runDiceRollAnimation({
        force:true,
        finalD6:Number(ev.d6 || 1),
        finalD4:Number(ev.d4 || 1),
        secondD6:Number(ev.secondD6 || 1),
        secondD4:Number(ev.secondD4 || 1),
        compass: !!ev.compass,
        applyMove: safeText(ev.uid || "") === state.userId,
        motion: ev.motion || null
      });
    });

    const attackRef = ref(db, `rooms/${state.roomCode}/diceEvents/attack`);
    onValue(attackRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!attackDiceEventInitialized){
        attackDiceEventInitialized = true;
        attackDiceEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= attackDiceEventSeenAt) return;
      attackDiceEventSeenAt = at;
      runAttackDiceAnimation(safeText(ev.targetUid || ""), Number(ev.x || 0), Number(ev.y || 0), {
        force:true,
        finalD6:Number(ev.d6 || 1),
        finalD4:Number(ev.d4 || 1),
        masamuneMode: !!ev.masamuneMode,
        vendettaMode: !!ev.vendettaMode,
        gatlingTargetUids: Array.isArray(ev.gatlingTargetUids) ? ev.gatlingTargetUids : [],
        applyDamage: safeText(ev.uid || "") === state.userId,
        motion: ev.motion || null
      });
    });

    const cardRef = ref(db, `rooms/${state.roomCode}/diceEvents/card`);
    onValue(cardRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!cardDiceEventInitialized){
        cardDiceEventInitialized = true;
        cardDiceEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= cardDiceEventSeenAt) return;
      cardDiceEventSeenAt = at;
      const kind = safeText(ev.kind || "");
      if (kind === "curse_doll"){
        runCornerD6Roll(Number(ev.d6 || 1));
      } else if (kind === "blessing"){
        if (safeText(ev.uid || "") === state.userId) return;
        runCornerD6Roll(Number(ev.d6 || 1));
      } else if (kind === "riot"){
        runCornerD6D4Roll({
          d6: Number(ev.d6 || 1),
          d4: Number(ev.d4 || 1)
        });
      } else if (kind === "role_agatha"){
        showAgathaRevealCardOverlay(safeText(ev.uid || ""), {
          closeAt: Number(ev.closeAt || 0),
          duration: 1200
        });
        runCornerD6D4Roll({
          d6: Number(ev.d6 || 1),
          d4: Number(ev.d4 || 1)
        });
      } else if (kind === "role_felix"){
        runCornerD6Roll(Number(ev.d6 || 1));
      } else if (kind === "role_emma"){
        runCornerD4Roll(Number(ev.d4 || 1));
      }
    });
  }

  function subscribeRoleFlashEvents(){
    const flashRef = ref(db, `rooms/${state.roomCode}/effectEvents/roleFlash`);
    onValue(flashRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!roleFlashEventInitialized){
        roleFlashEventInitialized = true;
        roleFlashEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= roleFlashEventSeenAt) return;
      roleFlashEventSeenAt = at;
      showRoleFlashOverlay(safeText(ev.roleId || ""), Number(ev.durationMs || 1200));
    });
  }

  
  function subscribeHpSwapEvents(){
    const hpSwapRef = ref(db, `rooms/${state.roomCode}/effectEvents/hpSwap`);
    onValue(hpSwapRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!hpSwapEventInitialized){
        hpSwapEventInitialized = true;
        hpSwapEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= hpSwapEventSeenAt) return;
      hpSwapEventSeenAt = at;
      const aUid = safeText(ev.aUid || "");
      const bUid = safeText(ev.bUid || "");
      if (!aUid || !bUid) return;
      pendingHpSwapAnimation = { aUid, bUid, at };
      renderHpBoard();
      setTimeout(() => {
        if (!pendingHpSwapAnimation){
          pendingHpSwapAnimation = { aUid, bUid, at };
        }
        renderHpBoard();
      }, 120);
    });
  }

  function subscribeWalpurgisSwapEvents(){
    const swapRef = ref(db, `rooms/${state.roomCode}/effectEvents/walpurgisSwap`);
    onValue(swapRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!walpurgisSwapEventInitialized){
        walpurgisSwapEventInitialized = true;
        walpurgisSwapEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= walpurgisSwapEventSeenAt) return;
      walpurgisSwapEventSeenAt = at;
      const uidA = safeText(ev.uidA || "");
      const uidB = safeText(ev.uidB || "");
      const durationMs = Math.max(240, Number(ev.durationMs) || 620);
      if (!uidA || !uidB || uidA === uidB) return;
      animateMarkerSwapVisual(uidA, uidB, durationMs);
    });
  }

  function subscribeGreenReplyBubbles(){
    const bRef = ref(db, `rooms/${state.roomCode}/greenReplyBubbles`);
    onValue(bRef, snap => {
      const raw = snap.val() || {};
      const next = {};
      for (const row of Object.values(raw)){
        const uid = safeText(row?.responderId || "");
        const label = safeText(row?.answerLabel || "");
        if (!uid || !label) continue;
        next[uid] = label;
      }
      activeGreenReplies = next;
      renderPositionLine();
    });
  }

  async function initDamageAllToZero(players){
    if (!state.roomCode) return;
    const baseRef = ref(db, `rooms/${state.roomCode}/damage`);
    const obj = {};
    for (const p of players){
      obj[p.id] = 0;
    }
    await set(baseRef, obj);
  }

  async function ensureTurnInitialized(){
    if (!state.roomCode || !isGameStarted()) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !(cur.gameStarted || cur.startedAt)) return cur;
      if (cur.turn && cur.turn.currentPlayerId) return cur;
      const startPlayerId = safeText(cur.startPlayerId || "");
      if (!startPlayerId) return cur;
      cur.turn = {
        currentPlayerId: startPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        drawnTypes: { green:false, white:false, black:false },
        movedByDiceRoomId: null,
        room3ActionUsed: false,
        room4StealUsed: false,
        repeatTurnRemaining: 0,
        repeatTurnTotal: 0,
        sealWisdomBonus: false,
        updatedAt: Date.now()
      };
      if (cur.guardianAngelShield && cur.guardianAngelShield[startPlayerId]){
        delete cur.guardianAngelShield[startPlayerId];
      }
      return cur;
    });
  }

  async function advanceTurnToNextPlayer(){
    if (!state.roomCode) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !(cur.gameStarted || cur.startedAt)) return cur;
      const order = Array.isArray(cur.positionOrder) ? cur.positionOrder : [];
      if (order.length === 0) return cur;

      const isEliminatedInRoom = (uid) => {
        if (!uid) return false;
        const hand = cur.hands?.[uid];
        const role = hand?.roleId ? ROLE_BY_ID[hand.roleId] : null;
        const hp = Number(role?.hp || 0);
        if (!hp) return false;
        const dmg = clampDamage(cur.damage?.[uid]);
        return dmg >= hp;
      };
      const aliveOrder = order.filter(uid => !isEliminatedInRoom(uid));
      if (aliveOrder.length === 0) return cur;

      const curTurn = cur.turn || {};
      const curId = safeText(curTurn.currentPlayerId || cur.startPlayerId || aliveOrder[0] || "");
      const rest = Math.max(0, Number(curTurn.repeatTurnRemaining || 0));
      const total = Math.max(0, Number(curTurn.repeatTurnTotal || 0));
      const repeat = rest > 0 && !isEliminatedInRoom(curId);
      const nextRepeatRemaining = repeat ? Math.max(0, rest - 1) : 0;
      const nextRepeatTotal = repeat ? Math.max(total, rest) : 0;
      let nextPlayerId = curId;
      if (!repeat){
        let nextIdx = aliveOrder.indexOf(curId);
        if (nextIdx < 0) nextIdx = 0;
        nextPlayerId = safeText(aliveOrder[(nextIdx + 1) % aliveOrder.length] || aliveOrder[0] || "");
      }
      if (!nextPlayerId || isEliminatedInRoom(nextPlayerId)){
        nextPlayerId = safeText(aliveOrder[0] || "");
      }
      if (!nextPlayerId) return cur;

      cur.turn = {
        currentPlayerId: nextPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        drawnTypes: { green:false, white:false, black:false },
        movedByDiceRoomId: null,
        room3ActionUsed: false,
        room4StealUsed: false,
        repeatTurnRemaining: nextRepeatRemaining,
        repeatTurnTotal: nextRepeatTotal,
        sealWisdomBonus: false,
        updatedAt: Date.now()
      };
      if (cur.guardianAngelShield && cur.guardianAngelShield[nextPlayerId]){
        delete cur.guardianAngelShield[nextPlayerId];
      }
      return cur;
    });
  }

  function toGreenOrder(){
    return GREEN_DECK.map(x => {
      const text = safeText(x?.text||"").replace(/^Êé®ÁêÜ„Ç´„Éº„ÉâÔºö/,"").trim();
      return { name:"Êé®ÁêÜ„Ç´„Éº„Éâ", effect:text };
    });
  }
  function toWhiteOrder(){ return WHITE_DECK.map(x => ({ name:safeText(x.name), effect:safeText(x.effect) })); }
  function toBlackOrder(){ return BLACK_DECK.map(x => ({ name:safeText(x.name), effect:safeText(x.effect) })); }
  function remainingCount(d){
    const o = Array.isArray(d?.order) ? d.order.length : 0;
    const i = Number(d?.idx||0);
    return Math.max(0, o - i);
  }

  let deckCache = null;
  function subscribeDeckState(){
    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    onValue(dsRef, snap => {
      deckCache = snap.val() || null;
      renderDeckRowFromRoom();
      updateEquipDockTop();
    });
  }

  async function ensureRoomDeckState(){
    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    await runTransaction(dsRef, (cur) => {
      if (cur && cur.green && cur.white && cur.black) return cur;

      const green = { order: shuffle(toGreenOrder()), idx: 0 };
      const white = { order: shuffle(toWhiteOrder()), idx: 0 };
      const black = { order: shuffle(toBlackOrder()), idx: 0 };

      return {
        green, white, black,
        reveal: { slot3: null, slot5: null },
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };
    });
  }

  async function drawFromSharedDeck(type, { viaParasol=false } = {}){
    if (!state.roomCode) return;
    if (viaParasol){
      if (type !== "green" || !canUseParasolGreenDraw()) return;
    } else if (!canDrawTypeNormally(type)){
      return;
    }

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let drawn = null;

    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      if (!cur.turn || safeText(cur.turn.currentPlayerId || "") !== state.userId) return cur;

      const turn = cur.turn;
      const allowUnlimitedDraw = isTestPlayer();
      if (!turn.moveDone || turn.attackDone) return cur;
      if (!viaParasol && !allowUnlimitedDraw && turn.deckDrawDone) return cur;

      const ds = cur.deckState;
      if (!ds || !ds[type] || !Array.isArray(ds[type].order)) return cur;

      const d = ds[type];
      const idx = Number(d.idx || 0);
      if (idx >= d.order.length) return cur;

      drawn = d.order[idx];
      d.idx = idx + 1;

      ds.reveal = ds.reveal || { slot3:null, slot5:null };
      if (type === "black"){
        ds.reveal.slot5 = { theme:"black", card: drawn, at: Date.now() };
      } else if (type === "white"){
        ds.reveal.slot3 = { theme:"white", card: drawn, at: Date.now() };
      }

      if (viaParasol){
        turn.attackDone = true;
        turn.attackAt = Date.now();
      } else if (!allowUnlimitedDraw) {
        turn.deckDrawDone = true;
      }
      turn.drawnTypes = {
        green: !!(turn?.drawnTypes?.green || type === "green"),
        white: !!(turn?.drawnTypes?.white || type === "white"),
        black: !!(turn?.drawnTypes?.black || type === "black")
      };
      turn.updatedAt = Date.now();
      ds.updatedAt = Date.now();
      return cur;
    });

    if (drawn && (type === "white" || type === "black")){
      clearDiceRollTimers();
      if (diceRollOverlay) diceRollOverlay.innerHTML = '';
      await grantEquipmentToMe(drawn, type);
      await applyImmediateDeckCardEffect(drawn);
    } else if (drawn && type === "green"){
      clearDiceRollTimers();
      if (diceRollOverlay) diceRollOverlay.innerHTML = '';
      openZoomFromDeckCard(drawn, "green", { closeOnBackdrop:false, showCloseButton:false });
      openGreenShareDock(drawn, { attackRangeOnly: viaParasol });
    }

    scheduleDeckRebuildIfEmpty(type).catch(() => {});
  }

  function baseOrderWithoutEquip(type){
    if (type === "green") return toGreenOrder();
    if (type === "white") return toWhiteOrder().filter(card => !isEquipCard(card));
    if (type === "black") return toBlackOrder().filter(card => !isEquipCard(card));
    return [];
  }

  function isEliminatedInRoomState(cur, uid){
    if (!cur || !uid) return false;
    const roleId = safeText(cur?.hands?.[uid]?.roleId || "");
    const hp = Number(ROLE_BY_ID?.[roleId]?.hp || 0);
    if (!hp) return false;
    const dmg = clampDamage(Number(cur?.damage?.[uid] || 0));
    return dmg >= hp;
  }

  function collectEliminatedEquipCardsForDeck(cur, type){
    const recycled = [];
    if (!cur?.equipment || !type) return recycled;
    for (const [uid, row] of Object.entries(cur.equipment || {})){
      if (!isEliminatedInRoomState(cur, uid) || !row || typeof row !== "object") continue;
      for (const [key, item] of Object.entries(row)){
        if (!item || item.kind === "identity") continue;
        if (!isEquipCard(item)) continue;
        if (safeText(item.theme || "") !== type) continue;
        recycled.push({
          name: safeText(item.name || ""),
          effect: safeText(item.effect || "")
        });
        delete row[key];
      }
      if (Object.keys(row).length === 0){
        delete cur.equipment[uid];
      }
    }
    return recycled;
  }

  async function scheduleDeckRebuildIfEmpty(type){
    if (!state.roomCode || !["green","white","black"].includes(type)) return;
    if (deckRebuildTimers[type]) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let pendingAt = 0;
    const tx = await runTransaction(roomRef, (cur) => {
      if (!cur?.deckState?.[type]) return cur;
      const deck = cur.deckState[type];
      const idx = Number(deck.idx || 0);
      const total = Array.isArray(deck.order) ? deck.order.length : 0;
      if (idx < total) return cur;
      const prevPending = Number(deck.rebuildPendingAt || 0);
      if (prevPending > 0) return cur;
      pendingAt = Date.now();
      deck.rebuildPendingAt = pendingAt;
      cur.deckState.updatedAt = Date.now();
      return cur;
    });
    if (!tx?.committed || !pendingAt) return;

    deckRebuildTimers[type] = setTimeout(async () => {
      deckRebuildTimers[type] = null;
      await runTransaction(roomRef, (cur) => {
        if (!cur?.deckState?.[type]) return cur;
        const deck = cur.deckState[type];
        if (Number(deck.rebuildPendingAt || 0) !== pendingAt) return cur;
        const idx = Number(deck.idx || 0);
        const total = Array.isArray(deck.order) ? deck.order.length : 0;
        if (idx < total){
          delete deck.rebuildPendingAt;
          return cur;
        }
        const base = baseOrderWithoutEquip(type);
        const recycled = collectEliminatedEquipCardsForDeck(cur, type);
        deck.order = shuffle([...base, ...recycled]);
        deck.idx = 0;
        cur.deckState.reveal = cur.deckState.reveal || { slot3:null, slot5:null };
        if (type === "white") cur.deckState.reveal.slot3 = null;
        if (type === "black") cur.deckState.reveal.slot5 = null;
        delete deck.rebuildPendingAt;
        cur.deckState.updatedAt = Date.now();
        return cur;
      });
    }, 2000);
  }

  function renderDeckRowFromRoom(){
    if (!deckCache || !deckCache.green || !deckCache.white || !deckCache.black){
      setSlotAsDeck(slot1, 'greendeck.jpg', 0, { disabled:true, type:"green" });
      setSlotAsDeck(slot2, 'whitedeck.jpg', 0, { disabled:true, type:"white" });
      setSlotEmptyNoFrame(slot3);
      setSlotAsDeck(slot4, 'blackdeck.jpg', 0, { disabled:true, type:"black" });
      setSlotEmptyNoFrame(slot5);
      bindDeckClicksShared();
      updateCardInteractivity();
      return;
    }

    const gLeft = remainingCount(deckCache.green);
    const wLeft = remainingCount(deckCache.white);
    const bLeft = remainingCount(deckCache.black);

    setSlotAsDeck(slot1, 'greendeck.jpg', gLeft, { disabled: gLeft===0, type:"green" });
    setSlotAsDeck(slot2, 'whitedeck.jpg', wLeft, { disabled: wLeft===0, type:"white" });
    setSlotAsDeck(slot4, 'blackdeck.jpg', bLeft, { disabled: bLeft===0, type:"black" });

    const r3 = deckCache?.reveal?.slot3;
    const r5 = deckCache?.reveal?.slot5;

    if (r3 && r3.card){
      setSlotAsWbFront(slot3, r3.card, r3.theme || "white");
    } else {
      setSlotEmptyNoFrame(slot3);
    }

    if (r5 && r5.card){
      setSlotAsWbFront(slot5, r5.card, "black");
    } else {
      setSlotEmptyNoFrame(slot5);
    }

    bindDeckClicksShared();
    updateCardInteractivity();
  }

  function bindDeckClicksShared(){
    const s1 = slot1.cloneNode(true);
    slot1.parentNode.replaceChild(s1, slot1);
    slot1 = s1;
    slot1.dataset.cardType = "green";
    slot1.style.backgroundImage = remainingCount(deckCache?.green) <= 0 ? 'none' : `url('greendeck.jpg')`;
    slot1.style.backgroundColor = remainingCount(deckCache?.green) <= 0 ? '#f3f4f6' : '';
    ensureCountTag(slot1);

    const s2 = slot2.cloneNode(true);
    slot2.parentNode.replaceChild(s2, slot2);
    slot2 = s2;
    slot2.dataset.cardType = "white";
    slot2.style.backgroundImage = remainingCount(deckCache?.white) <= 0 ? 'none' : `url('whitedeck.jpg')`;
    slot2.style.backgroundColor = remainingCount(deckCache?.white) <= 0 ? '#f3f4f6' : '';
    ensureCountTag(slot2);

    const s4 = slot4.cloneNode(true);
    slot4.parentNode.replaceChild(s4, slot4);
    slot4 = s4;
    slot4.dataset.cardType = "black";
    slot4.style.backgroundImage = remainingCount(deckCache?.black) <= 0 ? 'none' : `url('blackdeck.jpg')`;
    slot4.style.backgroundColor = remainingCount(deckCache?.black) <= 0 ? '#f3f4f6' : '';
    ensureCountTag(slot4);

    slot1.addEventListener('click', async (e) => {
      const left = remainingCount(deckCache?.green);
      if (!canClickType("green")) return;
      if (left <= 0) return;
      if (canDrawTypeNormally("green")){
        await drawFromSharedDeck("green");
        return;
      }
      if (!canUseParasolGreenDraw()) return;
      const clickX = Number(e?.clientX || (window.innerWidth / 2));
      const clickY = Number(e?.clientY || (window.innerHeight / 2));
      showRoomActionPopAt(
        clickX,
        clickY,
        "ÊîªÊíÉ„ÅÆ‰ª£„Çè„Çä„Å´„Ç´„Éº„Éâ„ÇíÂºï„Åç„Åæ„Åô„Åã„ÄÇÔºàËôπËâ≤„ÅÆ„Éë„É©„ÇΩ„É´Ôºâ",
        async () => {
          const warningMessage = parasolBlockedDrawWarningMessage();
          if (!warningMessage){
            await drawFromSharedDeck("green", { viaParasol:true });
            return;
          }
          showRoomActionPopAt(
            clickX,
            clickY,
            warningMessage,
            async () => {
              await drawFromSharedDeck("green", { viaParasol:true });
            },
            { noCaret:true, yesLabel:"OK", noLabel:"„ÇÑ„ÇÅ„Çã" }
          );
        },
        { noCaret:true }
      );
    });
    slot2.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.white);
      if (!canClickType("white")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("white");
    });
    slot4.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.black);
      if (!canClickType("black")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("black");
    });
  }

  const cardsPanelEl = document.getElementById("cardsPanel");
  cardsPanelEl.addEventListener("click", (e) => {
    if (isEquipSelectionLockActive()) return;
    const card = e.target.closest(".card72.wb-front");
    if (!card) return;
    if (card.classList.contains("locked") || card.classList.contains("blocked")) return;
    const selectionAction = captureSelectionRestoreAction();
    if (selectionAction){
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
      setZoomPassthrough(false);
      zoomDismissHandler = async () => {
        await restoreSelectionAction(selectionAction);
      };
      return;
    }
    openZoomFromCard(card);
  });

  const roomSvg = document.getElementById('roomSvg');
  const roomG   = document.getElementById('roomG');

  function svgEl(name, attrs={}, parent=roomG){
    const n = document.createElementNS('http://www.w3.org/2000/svg', name);
    for(const k in attrs) n.setAttribute(k, attrs[k]);
    parent.appendChild(n);
    return n;
  }
  function ptsToStr(pts){ return pts.map(p=>`${p[0]},${p[1]}`).join(' '); }
  function poly(pts, cls, parent=roomG){ return svgEl('polygon', {points: ptsToStr(pts), class: cls}, parent); }

  function ensureRoomPatterns(){
    let defs = roomSvg.querySelector('#roomPatternDefs');
    if (defs) return defs;
    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.setAttribute('id', 'roomPatternDefs');
    roomSvg.insertBefore(defs, roomSvg.firstChild);

    const roomImageScaleMap = {
      1: 2.7,
      2: 1.90,
      3: 2.80,
      4: 2.80,
      5: 1.90,
      6: 2.20,
      7: 1.05,
    };

    for (let roomId = 1; roomId <= 7; roomId++){
      const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
      pattern.setAttribute('id', `roomPattern${roomId}`);
      pattern.setAttribute('patternUnits', 'objectBoundingBox');
      pattern.setAttribute('patternContentUnits', 'userSpaceOnUse');
      pattern.setAttribute('viewBox', '0 0 100 100');
      pattern.setAttribute('width', '1');
      pattern.setAttribute('height', '1');

      const scale = roomImageScaleMap[roomId] || 1;
      const imageSize = 100 * scale;
      const imageOffset = (100 - imageSize) / 2;
      const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      image.setAttribute('href', `room${roomId}.jpg`);
      image.setAttribute('x', String(imageOffset));
      image.setAttribute('y', String(imageOffset));
      image.setAttribute('width', String(imageSize));
      image.setAttribute('height', String(imageSize));
      image.setAttribute('preserveAspectRatio', 'xMidYMid slice');

      pattern.appendChild(image);
      defs.appendChild(pattern);
    }
    return defs;
  }

  function hexFlat(cx, cy, s){
    const rt3 = Math.sqrt(3);
    const h = (rt3/2)*s;
    return [
      [cx+s,   cy],
      [cx+s/2, cy+h],
      [cx-s/2, cy+h],
      [cx-s,   cy],
      [cx-s/2, cy-h],
      [cx+s/2, cy-h],
    ];
  }
  function buildStarRooms(cx, cy, s0, t, tip){
    const P = hexFlat(cx, cy, s0);

    const add=(a,b)=>[a[0]+b[0],a[1]+b[1]];
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
    const mul=(a,k)=>[a[0]*k,a[1]*k];
    const norm=(v)=>{ const L=Math.hypot(v[0],v[1])||1; return [v[0]/L,v[1]/L]; };

    function intersectRayRay(p,u,q,v){
      const det = u[0]*(-v[1]) - u[1]*(-v[0]);
      const b = sub(q,p);
      const s = ( b[0]*(-v[1]) - b[1]*(-v[0]) ) / det;
      return add(p, mul(u, s));
    }
    function outwardNormal(a,b){
      const u = norm(sub(b,a));
      return [u[1], -u[0]];
    }

    const lines = [];
    for(let i=0;i<6;i++){
      const a = P[i], b = P[(i+1)%6];
      const d = norm(sub(b,a));
      const n = outwardNormal(a,b);
      const p0 = add(a, mul(n, t));
      lines.push({ p:p0, d, n });
    }

    const Q = [];
    for(let i=0;i<6;i++){
      const L0 = lines[(i+5)%6];
      const L1 = lines[i];
      Q.push(intersectRayRay(L0.p, L0.d, L1.p, L1.d));
    }

    const T = [];
    for(let i=0;i<6;i++){
      const a = P[i], b = P[(i+1)%6];
      const mid = mul(add(a,b), 0.5);
      const n = lines[i].n;
      T.push(add(mid, mul(n, tip)));
    }

    const rooms = [];
    for(let i=0;i<6;i++){
      const i2 = (i+1)%6;
      rooms.push([ P[i], P[i2], Q[i2], T[i], Q[i] ]);
    }

    return { centerHex:P, rooms };
  }

  const cx  = 0,  cy  = 0;
  const s0  = 48;
  const t   = 26;
  const tip = 90;

  function fitRoomViewBox(margin = 2){
    const bb = roomG.getBBox();
    const x = bb.x - margin;
    const y = bb.y - margin;
    const w = bb.width + margin*2;
    const h = bb.height + margin*2;
    roomSvg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
  }

  let markerLayer = null;
  let attackRangeLayer = null;
  let roomGuideLayer = null;
  let markerCache = {};
  const roomShapeEls = {};
  const roomHitEls = {};
  let autoMoveTriggeredTurnKey = "";
  const roomPolygons = {};
  let roomGuideVisible = false;
  const ROOM_GUIDE_LINES = {
    1: ["ÁôΩ„Ç´„Éº„Éâ„Åå", "„Å≤„Åë„Çã„ÄÇ"],
    2: ["Èªí„Ç´„Éº„Éâ„Åå", "„Å≤„Åë„Çã„ÄÇ"],
    3: ["‰ªªÊÑè„ÅÆ„Éó„É¨„Ç§„É§„Éº„Å∏", "2„ÉÄ„É°„Éº„Ç∏ / 1ÂõûÂæ©"],
    4: ["‰ªªÊÑè„ÅÆ„Éó„É¨„Ç§„É§„Éº„Åã„Çâ", "Ë£ÖÂÇô„Çí„ÅÜ„Å∞„ÅÜ"],
    5: ["Êé®ÁêÜ„Ç´„Éº„Éâ„Åå", "„Å≤„Åë„Çã"],
    6: ["Êé®ÁêÜ / ÁôΩ / Èªí„Ç´„Éº„Éâ", "„Åå„Å≤„Åë„Çã"],
    7: ["Ê¨°„ÅÆÊâãÁï™„Å´Ëá™Áî±„Å´", "ÁßªÂãï„Åß„Åç„Çã"]
  };
  const ROOM_GUIDE_OFFSET = {
    1:[0,-5],2:[0,-5],3:[0,-5],4:[0,-5],5:[0,-5],6:[0,-5],7:[0,0]
  };
  const agathaRevealOverlay = document.getElementById('agathaRevealOverlay');
  const diceRollOverlay = document.getElementById('diceRollOverlay');
  let diceRollTimers = [];
  let agathaRevealHideTimer = null;
  let agathaRevealVisibleUntil = 0;
  let pendingMoveChoice = null;

  function clearDiceRollTimers(){
    for (const id of diceRollTimers) clearTimeout(id);
    diceRollTimers = [];
  }

  function hideAgathaRevealCardOverlay(){
    if (agathaRevealHideTimer){
      clearTimeout(agathaRevealHideTimer);
      agathaRevealHideTimer = null;
    }
    agathaRevealVisibleUntil = 0;
    if (agathaRevealOverlay){
      agathaRevealOverlay.innerHTML = '';
      agathaRevealOverlay.classList.add('hidden');
    }
  }

  function showAgathaRevealCardOverlay(uid, options = {}){
    if (!agathaRevealOverlay) return;
    const roleId = safeText(state.hands?.[uid]?.roleId || "CIT_A3");
    const role = ROLE_BY_ID[roleId] || ROLE_BY_ID.CIT_A3;
    if (!role) return;

    const duration = Math.max(0, Number(options.duration || 1200));
    const requestedCloseAt = Number(options.closeAt || 0);
    const closeAt = requestedCloseAt > 0 ? requestedCloseAt : (Date.now() + duration);
    if (closeAt <= agathaRevealVisibleUntil) return;

    agathaRevealVisibleUntil = closeAt;
    agathaRevealOverlay.innerHTML = '';
    agathaRevealOverlay.appendChild(createIdentityCard(role));
    agathaRevealOverlay.classList.remove('hidden');

    if (agathaRevealHideTimer) clearTimeout(agathaRevealHideTimer);
    const remainMs = Math.max(0, closeAt - Date.now());
    agathaRevealHideTimer = setTimeout(() => {
      hideAgathaRevealCardOverlay();
    }, remainMs);
  }

  function myEquipmentNames(){
    return listEquipForUid(state.userId)
      .filter(v => !isIdentityEquipItem(v))
      .map(v => safeText(v?.name))
      .filter(Boolean);
  }

  function hasMyEquipmentByName(name){
    const n = safeText(name);
    if (!n) return false;
    return myEquipmentNames().includes(n);
  }

  function hasEquipmentByName(uid, name){
    const targetUid = safeText(uid);
    const targetName = safeText(name);
    if (!targetUid || !targetName) return false;
    return listEquipForUid(targetUid)
      .filter(v => !isIdentityEquipItem(v))
      .map(v => safeText(v?.name))
      .includes(targetName);
  }

  function countEquipmentByNames(uid, names){
    const targetUid = safeText(uid);
    const nameSet = new Set((names || []).map(v => safeText(v)).filter(Boolean));
    if (!targetUid || nameSet.size === 0) return 0;
    return listEquipForUid(targetUid)
      .filter(v => !isIdentityEquipItem(v))
      .reduce((sum, item) => sum + (nameSet.has(safeText(item?.name)) ? 1 : 0), 0);
  }

  function calcAttackDamageFromRoll(attackerUid, d6, d4, options = {}){
    const uid = safeText(attackerUid);
    const a = Number(d6) || 0;
    const b = Number(d4) || 0;
    if (!uid) return 0;

    if (options.masamuneMode){
      return Math.max(0, b);
    }

    if (options.vendettaMode){
      return Math.max(0, b);
    }

    if (!didAttackRollSucceed(a, b, options)) return 0;

    let damage = Math.abs(a - b);
    damage += countEquipmentByNames(uid, ["„Çµ„Éº„Éô„É´", "Êã≥ÈäÉR", "Êã≥ÈäÉL", "„ÇØ„É≠„Çπ„Éú„Ç¶„Ç¨„É≥"]);

    const role = myRoleInfo();
    if (uid === state.userId && role && hasEquipmentByName(uid, "„Ç®„ÇØ„Çπ„Ç´„É™„Éê„Éº") && isMyIdentityRevealed() && role.faction === "„É¨„Ç§„ÉÄ„Éº"){
      damage += 2;
    }

    if (hasEquipmentByName(uid, "Ë≥¢ËÄÖ„ÅÆ„É≠„Éº„Éñ")){
      damage -= 1;
    }

    if (options.excaliburRevealBoost){
      damage += 2;
    }

    return Math.max(0, damage);
  }

  function excaliburExtraDamageRows(rows = [], amount = 2){
    const plus = Math.max(0, Number(amount) || 0);
    if (plus <= 0) return rows;
    return (rows || []).map(item => {
      const uid = safeText(item?.uid || "");
      const base = Math.max(0, Number(item?.damage || 0));
      if (!uid) return { ...item, damage: base };
      const add = applyIncomingDamageModifiers(uid, plus, { source:"attack" });
      return { ...item, uid, damage: Math.max(0, base + add) };
    });
  }

  function buildExcaliburAttackMeta({ attackerUid, targetUid, attackSucceeded, d6, d4 }){
    const uid = safeText(attackerUid);
    if (uid !== state.userId) return null;
    const role = myRoleInfo();
    if (!role || role.faction !== "„É¨„Ç§„ÉÄ„Éº") return null;
    if (!hasEquipmentByName(uid, "„Ç®„ÇØ„Çπ„Ç´„É™„Éê„Éº")) return null;
    if (isMyIdentityRevealed()) return null;

    const roleId = safeText(role.id || "");
    const success = !!attackSucceeded;
    const sameDice = (Number(d6) || 0) === (Number(d4) || 0);
    const targetRevealed = isIdentityRevealedFor(targetUid);
    const galahadAuto = roleId === "RAI_G2" && !success;
    const freddieAuto = roleId === "RAI_F3" && success && targetRevealed;

    return {
      showBonusLabel: success || galahadAuto || freddieAuto,
      allowExcaliburButton: success && !freddieAuto && !sameDice,
      autoBoost: galahadAuto || freddieAuto,
      freddieSpecial: freddieAuto
    };
  }

  function applyIncomingDamageModifiers(uid, amount, options = {}){
    const targetUid = safeText(uid);
    let add = Math.max(0, Number(amount) || 0);
    if (!targetUid || add <= 0) return 0;
    if (options.source === "attack" && hasGuardianAngelShield(targetUid)){
      return 0;
    }
    if (hasEquipmentByName(targetUid, "Ë≥¢ËÄÖ„ÅÆ„É≠„Éº„Éñ")){
      add -= 1;
    }
    return Math.max(0, add);
  }

  function clearPendingMoveChoiceUi(){
    for (let roomId = 1; roomId <= 7; roomId++){
      roomShapeEls[roomId]?.classList.remove('room-choice-once');
      roomHitEls[roomId]?.classList.remove('room-choice-once');
    }
  }

  function bringRoomPulseToFront(roomId){
    const shape = roomShapeEls[roomId];
    const hit = roomHitEls[roomId];
    if (!shape || !roomG) return;
    const anchor =
      (attackRangeLayer && attackRangeLayer.parentNode === roomG && attackRangeLayer) ||
      (markerLayer && markerLayer.parentNode === roomG && markerLayer) ||
      (roomGuideLayer && roomGuideLayer.parentNode === roomG && roomGuideLayer) ||
      null;
    if (anchor){
      roomG.insertBefore(shape, anchor);
      if (hit) roomG.insertBefore(hit, anchor);
      return;
    }
    roomG.appendChild(shape);
    if (hit) roomG.appendChild(hit);
  }

  function setPendingMoveChoice(roomIds){
    clearPendingMoveChoiceUi();
    const unique = [...new Set((roomIds || []).filter(v => Number.isFinite(v) && v >= 1 && v <= 7))];
    pendingMoveChoice = unique.length ? { roomIds: unique, consumed: false } : null;
    for (const rid of unique){
      roomShapeEls[rid]?.classList.add('room-choice-once');
      roomHitEls[rid]?.classList.add('room-choice-once');
    }
    updateRoomChoiceUi();
    updateAttackRangeUi();
    refreshRoomAbilityHint();
  }

  function mySeatMoveChoiceFromRoom(){
    const seatIndex = Number(state.seatedTable || 0);
    if (!seatIndex) return null;
    const table = state.room?.tables?.[String(seatIndex)] || null;
    if (!table || safeText(table.playerId || "") !== safeText(state.userId || "")) return null;
    const node = table.moveDiceChoice || null;
    if (!node || typeof node !== "object") return null;
    const roomIds = Array.isArray(node.roomIds)
      ? [...new Set(node.roomIds.map(v => Number(v)).filter(v => Number.isFinite(v) && v >= 1 && v <= 7))]
      : [];
    if (!roomIds.length) return null;
    return {
      roomIds,
      d6: Number(node.d6 || 0),
      d4: Number(node.d4 || 0),
      secondD6: Number(node.secondD6 || 0),
      secondD4: Number(node.secondD4 || 0),
      at: Number(node.at || 0)
    };
  }

  async function saveMySeatMoveChoice(payload = null){
    if (!state.roomCode || !state.seatedTable) return;
    await set(ref(db, `rooms/${state.roomCode}/tables/${state.seatedTable}/moveDiceChoice`), payload);
  }

  function clearPendingMoveChoiceState(){
    if (!pendingMoveChoice) return;
    pendingMoveChoice = null;
    clearPendingMoveChoiceUi();
    updateRoomChoiceUi();
    refreshRoomAbilityHint();
  }

  function syncPendingMoveChoiceOwnership(){
    const seatIndex = Number(state.seatedTable || 0);
    if (!seatIndex){
      clearPendingMoveChoiceState();
      return;
    }
    const table = state.room?.tables?.[String(seatIndex)] || null;
    const isSeatOwner = !!table && safeText(table.playerId || "") === safeText(state.userId || "");
    if (!isSeatOwner){
      clearPendingMoveChoiceState();
      return;
    }
    if (!isMyTurn() || !!turnState()?.moveDone){
      clearPendingMoveChoiceState();
    }
  }

  function restorePendingMoveChoiceFromSeat(){
    if (!isMyTurn()) return;
    if (!!turnState()?.moveDone) return;
    const saved = mySeatMoveChoiceFromRoom();
    if (!saved) return;
    const now = pendingMoveChoice || null;
    const sameChoice = !!now
      && !now.consumed
      && Array.isArray(now.roomIds)
      && now.roomIds.length === saved.roomIds.length
      && now.roomIds.every((rid, idx) => rid === saved.roomIds[idx]);
    if (sameChoice) return;
    setPendingMoveChoice(saved.roomIds);
  }

  async function resolvePendingMoveChoice(roomId){
    if (!pendingMoveChoice || pendingMoveChoice.consumed) return false;
    if (!pendingMoveChoice.roomIds.includes(roomId)) return false;
    pendingMoveChoice.consumed = true;
    clearPendingMoveChoiceUi();
    pendingMoveChoice = null;
    await placeMarkerInRoom(roomId);
    await saveMySeatMoveChoice(null);
    if (state.roomCode && isMyTurn()){
      await update(ref(db, `rooms/${state.roomCode}/turn`), {
        moveDone: true,
        moveAt: Date.now()
      });
    }
    const cleanupTimer = setTimeout(() => {
      diceRollOverlay.innerHTML = '';
      clearDiceRollTimers();
    }, 1000);
    updateRoomChoiceUi();
    diceRollTimers.push(cleanupTimer);
    return true;
  }

  function dicePipsD6(face){
    const map = {
      1:["mc"],
      2:["tl","br"],
      3:["tl","mc","br"],
      4:["tl","tr","bl","br"],
      5:["tl","tr","mc","bl","br"],
      6:["tl","ml","bl","tr","mr","br"]
    };
    return map[face] || map[1];
  }

  function renderD6Face(el, face){
    el.innerHTML = '';
    for (const klass of dicePipsD6(face)){
      const pip = document.createElement('span');
      pip.className = `pip ${klass}`;
      el.appendChild(pip);
    }
  }

  function renderD4Face(el, face){
    el.innerHTML = '';
    const num = document.createElement('span');
    num.className = 'd4-num';
    num.textContent = String(Math.max(1, Math.min(4, Number(face) || 1)));
    el.appendChild(num);
  }

  function randomCornerStart(width, height){
    const corner = Math.floor(Math.random() * 4);
    const pad = 40;
    if (corner === 0) return { x: width - pad, y: pad };      // Âè≥‰∏ä
    if (corner === 1) return { x: width - pad, y: height - pad }; // Âè≥‰∏ã
    if (corner === 2) return { x: pad, y: height - pad };      // Â∑¶‰∏ã
    return { x: pad, y: pad };                                  // Â∑¶‰∏ä
  }

  function randomCenterOffsets(){
    let a = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
    let b = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
    let guard = 0;
    while (Math.hypot(a.x-b.x, a.y-b.y) < 62 && guard < 40){
      b = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
      guard++;
    }
    if (Math.hypot(a.x-b.x, a.y-b.y) < 62){
      b = { x:a.x + 64, y:a.y + 10 };
    }
    return [a,b];
  }

  function randomCenterLandingPoint(width, height){
    const cx = width / 2;
    const cy = height / 2;
    const rangeX = Math.max(40, width * 0.12);
    const rangeY = Math.max(36, height * 0.10);
    const x = cx + (Math.random() * 2 - 1) * rangeX;
    const y = cy + (Math.random() * 2 - 1) * rangeY;
    return {
      x: Math.max(50, Math.min(width - 50, x)),
      y: Math.max(50, Math.min(height - 50, y))
    };
  }

  function createDiceMotion(width, height, endX, endY){
    const startBase = randomCornerStart(width, height);
    const [offsetA, offsetB] = randomCenterOffsets();
    const startDegA = Math.random() * 90;
    const startDegB = Math.random() * 90;
    const endDegA = startDegA + 720 + Math.random() * 360;
    const endDegB = startDegB + 720 + Math.random() * 360;
    return { startBase, offsetA, offsetB, startDegA, startDegB, endDegA, endDegB, endX, endY };
  }

  function setFlyerTransform(el, x, y, deg){
    el.style.transform = `translate(${x}px, ${y}px) rotate(${deg}deg)`;
  }

  function diceTotalToRoomId(total){
    if (total === 2 || total === 3) return 5;
    if (total === 4 || total === 5) return 6;
    if (total === 6) return 1;
    if (total === 7) return 2;
    if (total === 8) return 3;
    if (total === 9) return 4;
    if (total === 10) return 7;
    return null;
  }

  function pointInPolygon(x, y, pts){
    let inside = false;
    for (let i = 0, j = pts.length - 1; i < pts.length; j = i++){
      const xi = pts[i][0], yi = pts[i][1];
      const xj = pts[j][0], yj = pts[j][1];
      const intersects = ((yi > y) !== (yj > y))
        && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
      if (intersects) inside = !inside;
    }
    return inside;
  }

  function previousRoomId(roomId){
    if (roomId === 1) return 6;
    if (roomId >= 2 && roomId <= 6) return roomId - 1;
    return null;
  }

  function attackTargetRoomIdsFromRoom(roomId, extraScope = 0){
    const current = Number(roomId);
    if (!Number.isFinite(current) || current < 1 || current > 7) return new Set();
    if (current === 7) return new Set([1,2,3,4,5,6,7]);

    const bonus = Math.max(0, Number(extraScope) || 0);
    const rooms = new Set([current, 7]);
    let cursor = current;

    for (let i = 0; i < 1 + bonus; i++){
      cursor = previousRoomId(cursor);
      if (!cursor) break;
      rooms.add(cursor);
    }
    return rooms;
  }

  function attackRangeTargetUidsFor(uid = state.userId){
    const attackerUid = safeText(uid);
    if (!attackerUid) return new Set();
    const myMarker = markerCache?.[attackerUid] || null;
    const myRoomId = markerRoomId(myMarker);
    if (!myRoomId) return new Set();

    const deadScopeCount = countEquipmentByNames(attackerUid, ["Ê≠ªÁ•û„Çπ„Ç≥„Éº„Éó"]);
    const attackRooms = attackTargetRoomIdsFromRoom(myRoomId, deadScopeCount);
    const targets = new Set();
    for (const [targetUid, marker] of Object.entries(markerCache || {})){
      if (!marker || targetUid === attackerUid) continue;
      if (isPlayerEliminated(targetUid)) continue;
      const rid = markerRoomId(marker);
      if (!rid || !attackRooms.has(rid)) continue;
      if (isAttackTargetProtected(targetUid)) continue;
      targets.add(targetUid);
    }
    return targets;
  }

  function inferRoomIdFromPoint(x, y){
    for (const [ridText, pts] of Object.entries(roomPolygons)){
      const rid = Number(ridText);
      if (!Number.isFinite(rid)) continue;
      if (pointInPolygon(x, y, pts)) return rid;
    }
    return null;
  }

  function markerRoomId(marker){
    if (!marker) return null;
    const roomId = Number(marker.roomId);
    if (Number.isFinite(roomId) && roomId >= 1 && roomId <= 7) return roomId;

    const x = Number(marker.x);
    const y = Number(marker.y);
    if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
    return inferRoomIdFromPoint(x, y);
  }

  function canChooseOuterRoomDirectly(){
    if (!canUseMoveDice()) return false;
    if (hasMovedByDiceInCurrentTurn()) return false;
    const myMarker = markerCache?.[state.userId] || null;
    return markerRoomId(myMarker) === 7;
  }

  function hasMovedByDiceInCurrentTurn(){
    return !!turnRoomActionState()?.movedByDiceRoomId;
  }

  function highlightedMarkerUids(){
    if (mustResolveUranusMeteorStrike()){
      return new Set(uranusMeteorTargetUids());
    }
    if (canUseRoom3Action()){
      return new Set(
        Object.keys(markerCache || {}).filter(uid => !!uid && !isPlayerEliminated(uid) && !hasEquipmentByName(uid, "Âπ∏ÈÅã„ÅÆ„Éñ„É≠„Éº„ÉÅ"))
      );
    }
    if (!canUseAttackDice()) return new Set();
    return attackRangeTargetUidsFor(state.userId);
  }

  function randomPointInRoom(roomId, padding = 12){
    const pts = roomPolygons[roomId];
    if (!Array.isArray(pts) || !pts.length) return null;
    const xs = pts.map(p => p[0]);
    const ys = pts.map(p => p[1]);
    const minX = Math.min(...xs) + padding;
    const maxX = Math.max(...xs) - padding;
    const minY = Math.min(...ys) + padding;
    const maxY = Math.max(...ys) - padding;
    if (!(minX < maxX && minY < maxY)) return null;

    for (let i = 0; i < 180; i++){
      const x = minX + Math.random() * (maxX - minX);
      const y = minY + Math.random() * (maxY - minY);
      if (pointInPolygon(x, y, pts)) return { x, y };
    }
    return { x:(minX + maxX) / 2, y:(minY + maxY) / 2 };
  }

  function hasMarkerCollision(x, y, exceptUid = null, minDistance = 20){
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!marker || uid === exceptUid) continue;
      const mx = Number(marker.x);
      const my = Number(marker.y);
      if (!Number.isFinite(mx) || !Number.isFinite(my)) continue;
      if (Math.hypot(mx - x, my - y) < minDistance) return true;
    }
    return false;
  }

  async function placeMarkerInRoom(roomId){
    if (!roomId || !state.roomCode || !state.userId) return;

    movedByDiceRoomId = roomId;
    updateTurnRoomActionState({ movedByDiceRoomId:roomId, room3ActionUsed:false, room4StealUsed:false });

    let target = null;
    for (let i = 0; i < 120; i++){
      const p = randomPointInRoom(roomId);
      if (!p) break;
      if (!hasMarkerCollision(p.x, p.y, state.userId, 22)){
        target = p;
        break;
      }
      if (!target) target = p;
    }
    if (!target) return;

    setCurrentRoom(roomId);

    if (!hasMarkerCollision(target.x, target.y, state.userId, 22)){
      await writeMyMarker(target.x, target.y);
      return;
    }

    const updates = {};
    const pushLen = 14;
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!marker || uid === state.userId) continue;
      const mx = Number(marker.x);
      const my = Number(marker.y);
      if (!Number.isFinite(mx) || !Number.isFinite(my)) continue;
      const dx = mx - target.x;
      const dy = my - target.y;
      const dist = Math.hypot(dx, dy);
      if (dist >= 22) continue;
      const ux = dist > 0.001 ? dx / dist : Math.cos(Math.random() * Math.PI * 2);
      const uy = dist > 0.001 ? dy / dist : Math.sin(Math.random() * Math.PI * 2);
      updates[`markers/${uid}/x`] = mx + ux * pushLen;
      updates[`markers/${uid}/y`] = my + uy * pushLen;
      updates[`markers/${uid}/updatedAt`] = Date.now();
    }

    const myColor = getMyColor();
    const myInitial = getMyInitial();
    if (!myColor || !myInitial) return;
    updates[`markers/${state.userId}`] = {
      x: target.x,
      y: target.y,
      color: myColor,
      initial: myInitial,
      updatedAt: Date.now(),
      viaDice: true,
      roomId
    };
    await update(ref(db, `rooms/${state.roomCode}`), updates);
  }

  function upperRoomId(roomId){
    const rid = Number(roomId);
    if (!Number.isFinite(rid) || rid < 1 || rid > 7) return null;
    return Math.min(7, rid + 1);
  }

  async function placePlayerMarkerInRoom(uid, roomId){
    if (!uid || !roomId || !state.roomCode) return false;
    let target = null;
    for (let i = 0; i < 120; i++){
      const p = randomPointInRoom(roomId);
      if (!p) break;
      if (!hasMarkerCollision(p.x, p.y, uid, 22)){
        target = p;
        break;
      }
      if (!target) target = p;
    }
    if (!target) return false;

    await update(ref(db, `rooms/${state.roomCode}/markers/${uid}`), {
      x: target.x,
      y: target.y,
      roomId,
      updatedAt: Date.now()
    });
    return true;
  }

  async function moveEliminatedPlayerToUpperRoom(uid){
    if (!uid || !state.roomCode) return;
    if (!isPlayerEliminated(uid)) return;
    const marker = markerCache?.[uid] || null;
    const nowRoomId = markerRoomId(marker);
    const targetRoomId = upperRoomId(nowRoomId);
    if (!targetRoomId) return;
    await placePlayerMarkerInRoom(uid, targetRoomId);
  }

  async function placeMarkerByDice(total){
    const roomId = diceTotalToRoomId(total);
    await placeMarkerInRoom(roomId);
    await saveMySeatMoveChoice(null);
    renderEquipmentDock();
    renderMarkers();
  }

  function clearAttackResultDice(){
    if (!diceRollOverlay) return;
    diceRollOverlay.querySelectorAll('.attack-result-pin').forEach(el => el.remove());
  }

  async function addDamageToPlayer(uid, amount, options = {}){
    const add = applyIncomingDamageModifiers(uid, amount, options);
    if (!uid || !state.roomCode || add <= 0) return;
    const dRef = ref(db, `rooms/${state.roomCode}/damage/${uid}`);
    await runTransaction(dRef, (cur) => clampDamage(Number(cur || 0) + add));
  }

  async function healDamageToPlayer(uid, amount){
    const heal = Math.max(0, Number(amount) || 0);
    if (!uid || !state.roomCode || heal <= 0) return;
    const dRef = ref(db, `rooms/${state.roomCode}/damage/${uid}`);
    await runTransaction(dRef, (cur) => clampDamage(Number(cur || 0) - heal));
  }

  async function fullRecoverPlayer(uid){
    if (!uid || !state.roomCode) return;
    await set(ref(db, `rooms/${state.roomCode}/damage/${uid}`), 0);
  }

  async function enableGuardianAngelShieldForPlayer(uid){
    const targetUid = safeText(uid);
    if (!state.roomCode || !targetUid) return;
    await set(ref(db, `rooms/${state.roomCode}/guardianAngelShield/${targetUid}`), true);
  }


  async function setDamageToPlayer(uid, damage){
    if (!uid || !state.roomCode) return;
    await set(ref(db, `rooms/${state.roomCode}/damage/${uid}`), clampDamage(damage));
  }

  async function enableRepeatTurnOnce(){
    if (!state.roomCode || !isMyTurn()) return;
    await update(ref(db, `rooms/${state.roomCode}/turn`), {
      repeatTurnRemaining: 1,
      repeatTurnTotal: 1,
      sealWisdomBonus: true,
      updatedAt: Date.now()
    });
  }

  async function runCornerD6Roll(fixedFace = null){
    if (!diceRollOverlay) return Number(fixedFace || (1 + Math.floor(Math.random() * 6)));
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const wrap = document.createElement('div');
    wrap.className = 'dice-flyer rolling';
    const d6 = document.createElement('div');
    d6.className = 'die';
    wrap.appendChild(d6);
    diceRollOverlay.appendChild(wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const corners = [
      { x: 60, y: 60 },
      { x: Math.max(60, width - 60), y: 60 },
      { x: 60, y: Math.max(60, height - 60) },
      { x: Math.max(60, width - 60), y: Math.max(60, height - 60) }
    ];
    const start = corners[Math.floor(Math.random() * corners.length)];
    const end = { x: width / 2, y: height / 2 };
    setFlyerTransform(wrap, start.x, start.y, Math.floor(Math.random() * 360));

    const animDuration = 900;
    const rollStartAt = Date.now();
    const tick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      const id = setTimeout(tick, 70 + Math.floor(Math.random() * 80));
      diceRollTimers.push(id);
    };
    tick();

    const launch = setTimeout(() => {
      setFlyerTransform(wrap, end.x, end.y, 720 + Math.floor(Math.random() * 360));
    }, 20);
    diceRollTimers.push(launch);

    const finalFace = Number(fixedFace || (1 + Math.floor(Math.random() * 6)));
    await new Promise(resolve => {
      const stop = setTimeout(() => {
        wrap.classList.remove('rolling');
        renderD6Face(d6, finalFace);
        resolve();
      }, 980);
      diceRollTimers.push(stop);
    });
    return finalFace;
  }

  async function runCornerD4Roll(fixedFace = null){
    if (!diceRollOverlay) return Number(fixedFace || (1 + Math.floor(Math.random() * 4)));
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const wrap = document.createElement('div');
    wrap.className = 'dice-flyer rolling';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    wrap.appendChild(d4);
    diceRollOverlay.appendChild(wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const corners = [
      { x: 60, y: 60 },
      { x: Math.max(60, width - 60), y: 60 },
      { x: 60, y: Math.max(60, height - 60) },
      { x: Math.max(60, width - 60), y: Math.max(60, height - 60) }
    ];
    const start = corners[Math.floor(Math.random() * corners.length)];
    const end = { x: width / 2, y: height / 2 };
    setFlyerTransform(wrap, start.x, start.y, Math.floor(Math.random() * 360));

    const animDuration = 900;
    const rollStartAt = Date.now();
    const tick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      renderD4Face(d4, 1 + Math.floor(Math.random() * 4));
      const id = setTimeout(tick, 70 + Math.floor(Math.random() * 80));
      diceRollTimers.push(id);
    };
    tick();

    const launch = setTimeout(() => {
      setFlyerTransform(wrap, end.x, end.y, 720 + Math.floor(Math.random() * 360));
    }, 20);
    diceRollTimers.push(launch);

    const finalFace = Number(fixedFace || (1 + Math.floor(Math.random() * 4)));
    await new Promise(resolve => {
      const stop = setTimeout(() => {
        wrap.classList.remove('rolling');
        renderD4Face(d4, finalFace);
        resolve();
      }, 980);
      diceRollTimers.push(stop);
    });
    return finalFace;
  }

  async function emitCardDiceEvent(payload = {}){
    if (!state.roomCode) return;
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/card`), {
      ...payload,
      at: Date.now()
    });
  }



  async function runCornerD6D4Roll(fixed = null){
    if (!diceRollOverlay) return { d6: Number(fixed?.d6 || (1 + Math.floor(Math.random() * 6))), d4: Number(fixed?.d4 || (1 + Math.floor(Math.random() * 4))) };
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer rolling';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer rolling';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    diceRollOverlay.appendChild(d6Wrap);
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const corners = [
      { x: 60, y: 60 },
      { x: Math.max(60, width - 60), y: 60 },
      { x: 60, y: Math.max(60, height - 60) },
      { x: Math.max(60, width - 60), y: Math.max(60, height - 60) }
    ];
    const startA = corners[Math.floor(Math.random() * corners.length)] || corners[0];
    const startB = startA;
    const end = { x: width / 2, y: height / 2 };

    setFlyerTransform(d6Wrap, startA.x, startA.y, Math.floor(Math.random() * 360));
    setFlyerTransform(d4Wrap, startB.x, startB.y, Math.floor(Math.random() * 360));

    const animDuration = 900;
    const rollStartAt = Date.now();
    const tick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      renderD4Face(d4, 1 + Math.floor(Math.random() * 4));
      const id = setTimeout(tick, 70 + Math.floor(Math.random() * 80));
      diceRollTimers.push(id);
    };
    tick();

    const launch = setTimeout(() => {
      setFlyerTransform(d6Wrap, end.x - 18, end.y - 6, 720 + Math.floor(Math.random() * 360));
      setFlyerTransform(d4Wrap, end.x + 18, end.y + 6, 720 + Math.floor(Math.random() * 360));
    }, 20);
    diceRollTimers.push(launch);

    const finalD6 = Number(fixed?.d6 || (1 + Math.floor(Math.random() * 6)));
    const finalD4 = Number(fixed?.d4 || (1 + Math.floor(Math.random() * 4)));
    await new Promise(resolve => {
      const stop = setTimeout(() => {
        d6Wrap.classList.remove('rolling');
        d4Wrap.classList.remove('rolling');
        renderD6Face(d6, finalD6);
        renderD4Face(d4, finalD4);
        resolve();
      }, 980);
      diceRollTimers.push(stop);
    });

    return { d6: finalD6, d4: finalD4 };
  }

  async function addDamageToAllOtherPlayers(uid, amount){
    const baseAdd = Math.max(0, Number(amount) || 0);
    if (!state.roomCode || baseAdd <= 0) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const order = Array.isArray(cur.positionOrder) ? cur.positionOrder : [];
      if (order.length === 0) return cur;
      cur.damage = cur.damage || {};
      for (const pid of order){
        if (!pid || pid === uid) continue;
        const add = applyIncomingDamageModifiers(pid, baseAdd);
        if (add <= 0) continue;
        cur.damage[pid] = clampDamage(Number(cur.damage[pid] || 0) + add);
      }
      return cur;
    });
  }

  function alivePlayerIds(){
    return latestPlayers
      .map(p => safeText(p?.id || ""))
      .filter(Boolean)
      .filter(uid => !isPlayerEliminated(uid));
  }

  function maxDamageAlivePlayerIds(){
    const alive = alivePlayerIds();
    if (!alive.length) return [];
    let maxDamage = -1;
    for (const uid of alive){
      const dmg = clampDamage(damageCache?.[uid]);
      if (dmg > maxDamage) maxDamage = dmg;
    }
    if (maxDamage < 0) return [];
    return alive.filter(uid => clampDamage(damageCache?.[uid]) === maxDamage);
  }

  function playerIdsInRoom(roomId){
    const rid = Number(roomId);
    if (!Number.isFinite(rid) || rid < 1 || rid > 7) return [];
    const uids = [];
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!uid || !marker) continue;
      if (markerRoomId(marker) === rid) uids.push(uid);
    }
    return uids;
  }

  async function addDamageToPlayers(uids, amount, options = {}){
    const baseAdd = Math.max(0, Number(amount) || 0);
    if (!state.roomCode || baseAdd <= 0) return;
    const targets = [...new Set((uids || []).map(uid => safeText(uid)).filter(Boolean))];
    if (!targets.length) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      cur.damage = cur.damage || {};
      for (const uid of targets){
        const add = applyIncomingDamageModifiers(uid, baseAdd, options);
        if (add <= 0) continue;
        cur.damage[uid] = clampDamage(Number(cur.damage[uid] || 0) + add);
      }
      return cur;
    });
  }

  async function applyImmediateDeckCardEffect(cardObj){
    const name = safeText(cardObj?.name || "");
    if (!name || !state.userId) return;
    const role = myRoleInfo();
    if (!role) return;
    const lockKey = `${name}:${state.userId}`;
    if (isEffectResolutionLocked(lockKey)) return;
    setEffectResolutionLock(lockKey, true);
    try {
    if (name === "„ÅÑ„ÇÑ„Åó„ÅÆËÅñÊ∞¥"){
      await waitMs(1500);
      await healDamageToPlayer(state.userId, 2);
      return;
    }

    if (name === "Ë£Å„Åç„ÅÆÈñÉÂÖâ"){
      await waitMs(1500);
      await addDamageToAllOtherPlayers(state.userId, 2);
      return;
    }

    if (name === "Êà¶ÊÖÑ„ÅÆÈóáÂÑÄÂºè" || name === "ÂÖâËá®"){
      const targetFaction = (name === "Êà¶ÊÖÑ„ÅÆÈóáÂÑÄÂºè") ? "„Ç∑„É£„Éâ„Ç¶" : "„É¨„Ç§„ÉÄ„Éº";
      const message = (name === "Êà¶ÊÖÑ„ÅÆÈóáÂÑÄÂºè")
        ? "„Ç∑„É£„Éâ„Ç¶„Å®„Åó„Å¶Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Åæ„Åô„Åã„ÄÇ"
        : "„É¨„Ç§„ÉÄ„Éº„Å®„Åó„Å¶Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Åæ„Åô„Åã„ÄÇ";
      const canReveal = role.faction === targetFaction;
      showIdentityPromptPop({
        message,
        canReveal,
        cardObj,
        cardTheme: name === "Êà¶ÊÖÑ„ÅÆÈóáÂÑÄÂºè" ? "black" : "white",
        openZoom: true,
        onYes: async () => {
          await revealMyIdentityToEquipment();
          openIdentityRevealZoom(role, state.userId);
          await fullRecoverPlayer(state.userId);
        }
      });
      return;
    }

    if (name === "Âπ∏„Åõ„ÅÆ„ÇØ„ÉÉ„Ç≠„Éº"){
      const canReveal = role.initial === "A" || role.initial === "U";
      showIdentityPromptPop({
        message: "A„Åæ„Åü„ÅØU„Å®„Åó„Å¶Ê≠£‰Ωì„ÇíÂÖ¨Èñã„Åó„Åæ„Åô„Åã„ÄÇ",
        canReveal,
        cardObj,
        cardTheme: "white",
        openZoom: true,
        onYes: async () => {
          await revealMyIdentityToEquipment(identityPromptRevealOptions(name));
          openIdentityRevealZoom(role, state.userId);
          await fullRecoverPlayer(state.userId);
        }
      });
      return;
    }

    if (name === "Èóá„ÇíÁ•ì„ÅÜÈè°"){
      const shouldReveal = role.faction === "„Ç∑„É£„Éâ„Ç¶" && role.name !== "„Ç¶„É´„É™„ÉÉ„Éí" && !isMyIdentityRevealed();
      if (!shouldReveal) return;
      await revealMyIdentityToEquipment();
      openIdentityRevealZoom(role, state.userId);
      return;
    }

    if (name === "Â∞ÅÂç∞„ÅÆÁü•ÊÅµ"){
      await enableRepeatTurnOnce();
      return;
    }

    if (name === "ÂÆàË≠∑Â§©‰Ωø"){
      await enableGuardianAngelShieldForPlayer(state.userId);
      return;
    }

    if (name === "ÂøúÊÄ•ÊâãÂΩì"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "ÊÅ©ÊÅµ"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "Âê∏Ë°Ä„Ç≥„Ç¶„É¢„É™"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "‰∏â„Å§ÁõÆ„ÅÆÈªíÁä¨"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "„Éê„Éä„Éä„ÅÆÁöÆ"){
      const myItems = listEquipForUid(state.userId).filter(it => !isIdentityEquipItem(it));
      if (myItems.length === 0){
        await waitMs(1000);
        await addDamageToPlayer(state.userId, 1);
        return;
      }
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      setZoomPassthrough(true);
      pendingEquipAction = { type:"banana_give", selectedSourceKey:"", cardObj };
      await setSeatEquipSelectionState({ type:"banana_give", cardObj });
      renderEquipmentDock();
      renderTurnEndButton();
      return;
    }

    if (name === "„Ç™„É™„Éê„Éº„ÅÆÂ≠êÂàÜ"){
      const hasStealableEquip = latestPlayers
        .filter(p => p.id !== state.userId && !isPlayerEliminated(p.id))
        .some(p => hasAnyEquipment(p.id));
      if (!hasStealableEquip){
        return;
      }
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      setZoomPassthrough(true);
      pendingEquipAction = { type:"oliver_target", cardObj };
      await setSeatEquipSelectionState({ type:"oliver_target", cardObj });
      renderEquipmentDock();
      renderTurnEndButton();
      return;
    }

    if (name === "‰∫∫È≠ö„ÅÆÊ∂ô"){
      await waitMs(1500);
      const topUids = maxDamageAlivePlayerIds();
      for (const uid of topUids){
        await healDamageToPlayer(uid, 3);
      }
      return;
    }

    if (name === "Âë™„ÅÑ„ÅÆ‰∫∫ÂΩ¢"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "Êö¥Âãï"){
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      await waitMs(2000);
      const rolled = { d6: 1 + Math.floor(Math.random() * 6), d4: 1 + Math.floor(Math.random() * 4) };
      await emitCardDiceEvent({ kind:"riot", uid: state.userId, d6: rolled.d6, d4: rolled.d4 });
      await waitMs(1000);
      const targetRoomId = diceTotalToRoomId(Number(rolled?.d6 || 0) + Number(rolled?.d4 || 0));
      await waitMs(1500);
      await addDamageToPlayers(playerIdsInRoom(targetRoomId), 3);
      closeZoom();
      return;
    }
    } finally {
      setEffectResolutionLock(lockKey, false);
    }
  }

  async function runAttackDiceAnimation(targetUid, clickClientX, clickClientY, options = {}){
    if (!diceRollOverlay || !targetUid) return;
    const applyDamage = options.applyDamage !== false;
    const masamuneMode = !!options.masamuneMode;
    const vendettaMode = !!options.vendettaMode;
    const d4OnlyMode = masamuneMode || vendettaMode;

    if (vendettaMode){
      showRoleFlashOverlay("SHA_V3", 1200);
      await new Promise(resolve => setTimeout(resolve, 1200));
    }

    clearDiceRollTimers();
    clearAttackResultDice();

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    if (!d4OnlyMode){
      diceRollOverlay.appendChild(d6Wrap);
    }
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const fallbackEndX = Math.max(50, Math.min(width - 50, Number(clickClientX) || width / 2));
    const fallbackEndY = Math.max(50, Math.min(height - 50, Number(clickClientY) || height / 2));
    const motion = options.motion || createDiceMotion(width, height, fallbackEndX, fallbackEndY);

    const startA = { x:Number(motion.startBase?.x || 0) - 16, y:Number(motion.startBase?.y || 0) - 6 };
    const startB = { x:Number(motion.startBase?.x || 0) + 16, y:Number(motion.startBase?.y || 0) + 6 };
    const endX = Number(motion.endX || fallbackEndX);
    const endY = Number(motion.endY || fallbackEndY);
    const offsetA = { x:Number(motion.offsetA?.x || 0), y:Number(motion.offsetA?.y || 0) };
    const offsetB = { x:Number(motion.offsetB?.x || 0), y:Number(motion.offsetB?.y || 0) };

    const startDegA = Number(motion.startDegA || 0);
    const startDegB = Number(motion.startDegB || 0);
    if (!d4OnlyMode){
      setFlyerTransform(d6Wrap, startA.x, startA.y, startDegA);
    }
    setFlyerTransform(d4Wrap, startB.x, startB.y, startDegB);

    const animDuration = 950;
    const rollStartAt = Date.now();
    const rollFaceTick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      if (!d4OnlyMode){
        renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      }
      renderD4Face(d4, 1 + Math.floor(Math.random() * 4));

      const t = elapsed / animDuration;
      const nextInterval = 55 + Math.floor(185 * t);
      const id = setTimeout(rollFaceTick, nextInterval);
      diceRollTimers.push(id);
    };
    rollFaceTick();

    const launchDelayMs = 30;
    const moveDurationMs = 950;
    const settleBufferMs = 80;

    const moveTimer = setTimeout(() => {
      if (!d4OnlyMode){
        d6Wrap.classList.add('rolling');
      }
      d4Wrap.classList.add('rolling');
      const endDegA = Number(motion.endDegA || (startDegA + 720));
      const endDegB = Number(motion.endDegB || (startDegB + 720));
      if (!d4OnlyMode){
        setFlyerTransform(d6Wrap, endX + offsetA.x, endY + offsetA.y, endDegA);
      }
      setFlyerTransform(d4Wrap, endX + offsetB.x, endY + offsetB.y, endDegB);
    }, launchDelayMs);
    diceRollTimers.push(moveTimer);

    const finalD6 = Number(options.finalD6 || (1 + Math.floor(Math.random() * 6)));
    const finalD4 = Number(options.finalD4 || (1 + Math.floor(Math.random() * 4)));

    const stopDelayMs = launchDelayMs + moveDurationMs + settleBufferMs;
    const stopTimer = setTimeout(() => {
      if (!d4OnlyMode){
        d6Wrap.classList.remove('rolling');
      }
      d4Wrap.classList.remove('rolling');
      if (!d4OnlyMode){
        renderD6Face(d6, finalD6);
      }
      renderD4Face(d4, finalD4);

      if (!d4OnlyMode){
        d6Wrap.classList.add('attack-result-pin');
      }
      d4Wrap.classList.add('attack-result-pin');

      Promise.resolve().then(async () => {
        const attackSucceeded = didAttackRollSucceed(finalD6, finalD4, { masamuneMode, vendettaMode });
        setAttackRollResultLabel(attackSucceeded);
        if (!applyDamage) return;
        const damage = calcAttackDamageFromRoll(state.userId, finalD6, finalD4, { masamuneMode, vendettaMode, excaliburRevealBoost: false });
        const gatlingTargets = Array.isArray(options.gatlingTargetUids)
          ? options.gatlingTargetUids.map(uid => safeText(uid)).filter(Boolean)
          : [];
        const targetUids = (gatlingTargets.length > 0) ? gatlingTargets : [targetUid];
        const exMeta = d4OnlyMode
          ? null
          : buildExcaliburAttackMeta({ attackerUid:state.userId, targetUid, attackSucceeded, d6:finalD6, d4:finalD4 });
        let resolvedRows = targetUids.map(uid => ({
          uid,
          damage: (attackSucceeded && damage > 0)
            ? applyIncomingDamageModifiers(uid, damage, { source:"attack" })
            : 0
        }));
        if (exMeta?.autoBoost){
          resolvedRows = excaliburExtraDamageRows(resolvedRows, 2);
        }
        pendingAttackResultMeta = {
          showBonusLabel: !!exMeta?.showBonusLabel,
          allowExcaliburButton: !!exMeta?.allowExcaliburButton,
          freddieSpecial: !!exMeta?.freddieSpecial,
          zeroDamagePreview: false
        };
        const hasExcaliburPreviewZero = !!pendingAttackResultMeta.allowExcaliburButton
          && hasEquipmentByName(state.userId, "Ë≥¢ËÄÖ„ÅÆ„É≠„Éº„Éñ")
          && Math.abs((Number(finalD6) || 0) - (Number(finalD4) || 0)) === 1
          && resolvedRows.some(row => Number(row.damage || 0) === 0);
        if (hasExcaliburPreviewZero){
          pendingAttackResultMeta.zeroDamagePreview = true;
          pendingAttackResultMeta.showBonusLabel = true;
        }
        const dealtDamage = resolvedRows.some(row => Number(row.damage || 0) > 0);
        const pendingTurnKey = turnCycleKey();
        pendingAttackResolution = { rows: resolvedRows, applied:false, turnKey: pendingTurnKey, meta: normalizeAttackResultMeta(pendingAttackResultMeta) };
        cachePendingAttackResolution(pendingAttackResolution);
        await upsertPendingAttackResolution(resolvedRows, pendingTurnKey, pendingAttackResultMeta);
        showAttackResultPop(resolvedRows);
        if (dealtDamage && isMyRole("SHA_V2")){
          if (isMyIdentityRevealed()){
            scheduleVampireHeal();
          } else {
            vampireHiddenAttackSuccess = true;
          }
        }
      });
    }, stopDelayMs);
    diceRollTimers.push(stopTimer);
  }


  function runDiceRollAnimation(options = {}){
    const force = !!options.force;
    if (!force && !canUseMoveDice()) return;
    const applyMove = options.applyMove !== false;
    const compass = !!options.compass;
    if (!diceRollOverlay) return;
    pendingMoveChoice = null;
    clearPendingMoveChoiceUi();
    updateRoomChoiceUi();
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    diceRollOverlay.appendChild(d6Wrap);
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const center = { x: width / 2, y: height / 2 };
    const animDuration = 950;

    const runSingleRoll = ({ motion, finalD6, finalD4, startAfterMs = 0, onStop = null }) => {
      const m = motion || createDiceMotion(width, height, center.x, center.y);
      const startA = { x:Number(m.startBase?.x || 0) - 16, y:Number(m.startBase?.y || 0) - 6 };
      const startB = { x:Number(m.startBase?.x || 0) + 16, y:Number(m.startBase?.y || 0) + 6 };
      const offsetA = { x:Number(m.offsetA?.x || 0), y:Number(m.offsetA?.y || 0) };
      const offsetB = { x:Number(m.offsetB?.x || 0), y:Number(m.offsetB?.y || 0) };
      const startDegA = Number(m.startDegA || 0);
      const startDegB = Number(m.startDegB || 0);

      const launchTimer = setTimeout(() => {
        setFlyerTransform(d6Wrap, startA.x, startA.y, startDegA);
        setFlyerTransform(d4Wrap, startB.x, startB.y, startDegB);

        const rollStartAt = Date.now();
        const rollFaceTick = () => {
          const elapsed = Date.now() - rollStartAt;
          if (elapsed >= animDuration) return;
          renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
          renderD4Face(d4, 1 + Math.floor(Math.random() * 4));
          const t = elapsed / animDuration;
          const nextInterval = 55 + Math.floor(185 * t);
          const id = setTimeout(rollFaceTick, nextInterval);
          diceRollTimers.push(id);
        };
        rollFaceTick();

        const moveTimer = setTimeout(() => {
          d6Wrap.classList.add('rolling');
          d4Wrap.classList.add('rolling');
          const endDegA = Number(m.endDegA || (startDegA + 720));
          const endDegB = Number(m.endDegB || (startDegB + 720));
          const endX = Number(m.endX || center.x);
          const endY = Number(m.endY || center.y);
          setFlyerTransform(d6Wrap, endX + offsetA.x, endY + offsetA.y, endDegA);
          setFlyerTransform(d4Wrap, endX + offsetB.x, endY + offsetB.y, endDegB);
        }, 30);
        diceRollTimers.push(moveTimer);

        const stopTimer = setTimeout(() => {
          d6Wrap.classList.remove('rolling');
          d4Wrap.classList.remove('rolling');
          renderD6Face(d6, finalD6);
          renderD4Face(d4, finalD4);
          if (typeof onStop === 'function') onStop();
        }, 980);
        diceRollTimers.push(stopTimer);
      }, startAfterMs);
      diceRollTimers.push(launchTimer);
    };

    const finalD6 = Number(options.finalD6 || (1 + Math.floor(Math.random() * 6)));
    const finalD4 = Number(options.finalD4 || (1 + Math.floor(Math.random() * 4)));
    const secondD6 = Number(options.secondD6 || (1 + Math.floor(Math.random() * 6)));
    const secondD4 = Number(options.secondD4 || (1 + Math.floor(Math.random() * 4)));

    if (!compass){
      runSingleRoll({ motion: options.motion || null, finalD6, finalD4 });

      const placeMarkerTimer = setTimeout(async () => {
        if (applyMove) await placeMarkerByDice(finalD6 + finalD4);
        if (applyMove && state.roomCode && isMyTurn()){
          await update(ref(db, `rooms/${state.roomCode}/turn`), {
            moveDone: true,
            moveAt: Date.now()
          });
        }
      }, 1900);
      diceRollTimers.push(placeMarkerTimer);

      const cleanupTimer = setTimeout(() => {
        diceRollOverlay.innerHTML = '';
        clearDiceRollTimers();
      }, 3200);
      diceRollTimers.push(cleanupTimer);
      return;
    }

    runSingleRoll({ motion: options.motion || null, finalD6, finalD4 });
    runSingleRoll({
      motion: options.secondMotion || null,
      finalD6: secondD6,
      finalD4: secondD4,
      startAfterMs: 2980,
      onStop: () => {
        if (!applyMove) return;
        const roomA = diceTotalToRoomId(finalD6 + finalD4);
        const roomB = diceTotalToRoomId(secondD6 + secondD4);
        saveMySeatMoveChoice({
          roomIds: [roomA, roomB],
          d6: finalD6,
          d4: finalD4,
          secondD6,
          secondD4,
          at: Date.now()
        }).catch(() => {});
        setPendingMoveChoice([roomA, roomB]);
      }
    });
  }

  function getMyColor(){
    if (state.seatedTable != null){
      return SEAT_COLORS[state.seatedTable-1] || "#ddd";
    }
    return null;
  }
  function getMyInitial(){
    return firstChar(state.userName || "");
  }

  function ensureMarkerLayer(){
    if (markerLayer && markerLayer.isConnected){
      roomG.appendChild(markerLayer);
      return markerLayer;
    }
    markerLayer = svgEl('g', { id:"markerLayer" }, roomG);
    return markerLayer;
  }
  function clearMarkerLayer(){
    if (!markerLayer) return;
    while(markerLayer.firstChild) markerLayer.removeChild(markerLayer.firstChild);
  }

  function ensureAttackRangeLayer(){
    if (attackRangeLayer && attackRangeLayer.isConnected){
      if (markerLayer && markerLayer.parentNode === roomG){
        roomG.insertBefore(attackRangeLayer, markerLayer);
      }
      return attackRangeLayer;
    }
    attackRangeLayer = svgEl('g', { class:'attack-range-layer' }, roomG);
    if (markerLayer && markerLayer.parentNode === roomG){
      roomG.insertBefore(attackRangeLayer, markerLayer);
    }
    return attackRangeLayer;
  }

  function clearAttackRangeLayer(){
    if (!attackRangeLayer) return;
    while (attackRangeLayer.firstChild) attackRangeLayer.removeChild(attackRangeLayer.firstChild);
  }

  function normalizedEdgeKey(ax, ay, bx, by){
    const pa = `${Number(ax).toFixed(3)},${Number(ay).toFixed(3)}`;
    const pb = `${Number(bx).toFixed(3)},${Number(by).toFixed(3)}`;
    return pa < pb ? `${pa}|${pb}` : `${pb}|${pa}`;
  }

  function polygonCentroid(pts){
    if (!Array.isArray(pts) || !pts.length) return { x:0, y:0 };
    let sx = 0;
    let sy = 0;
    for (const [x, y] of pts){
      sx += Number(x) || 0;
      sy += Number(y) || 0;
    }
    return { x: sx / pts.length, y: sy / pts.length };
  }

  function offsetEdgeOutward(edge){
    const ax = Number(edge.ax) || 0;
    const ay = Number(edge.ay) || 0;
    const bx = Number(edge.bx) || 0;
    const by = Number(edge.by) || 0;

    const dx = bx - ax;
    const dy = by - ay;
    const len = Math.hypot(dx, dy) || 1;

    let nx = -dy / len;
    let ny = dx / len;

    const mx = (ax + bx) / 2;
    const my = (ay + by) / 2;
    const pts = roomPolygons[edge.roomId];
    const c = polygonCentroid(pts);

    const plusDist = Math.hypot((mx + nx) - c.x, (my + ny) - c.y);
    const minusDist = Math.hypot((mx - nx) - c.x, (my - ny) - c.y);
    if (plusDist < minusDist){
      nx *= -1;
      ny *= -1;
    }

    const offset = 1.25;
    return {
      x1: ax + nx * offset,
      y1: ay + ny * offset,
      x2: bx + nx * offset,
      y2: by + ny * offset
    };
  }

  function updateAttackRangeUi(){
    ensureAttackRangeLayer();
    clearAttackRangeLayer();

    if (!canUseAttackDice()) return;

    const myMarker = markerCache?.[state.userId] || null;
    const myRoomId = markerRoomId(myMarker);
    if (!myRoomId) return;

    const deadScopeCount = countEquipmentByNames(state.userId, ["Ê≠ªÁ•û„Çπ„Ç≥„Éº„Éó"]);
    const attackRooms = attackTargetRoomIdsFromRoom(myRoomId, deadScopeCount);
    if (!attackRooms.size) return;

    const edges = new Map();
    for (const rid of attackRooms){
      const pts = roomPolygons[rid];
      if (!Array.isArray(pts) || pts.length < 2) continue;
      for (let i = 0; i < pts.length; i++){
        const a = pts[i];
        const b = pts[(i + 1) % pts.length];
        const key = normalizedEdgeKey(a[0], a[1], b[0], b[1]);
        const cur = edges.get(key);
        if (cur){
          cur.count += 1;
        } else {
          edges.set(key, { ax:a[0], ay:a[1], bx:b[0], by:b[1], count:1, roomId: rid });
        }
      }
    }

    for (const edge of edges.values()){
      if (edge.count !== 1) continue;
      const outlinePos = offsetEdgeOutward(edge);
      const outline = svgEl('line', {
        class:'attack-range-edge-outline',
        x1: outlinePos.x1,
        y1: outlinePos.y1,
        x2: outlinePos.x2,
        y2: outlinePos.y2
      });
      const line = svgEl('line', {
        class:'attack-range-edge',
        x1: edge.ax,
        y1: edge.ay,
        x2: edge.bx,
        y2: edge.by
      });
      attackRangeLayer.appendChild(outline);
      attackRangeLayer.appendChild(line);
    }
  }


  function showUranusSkipPop(clientX, clientY){
    const ability = '<span class="ability-pill">„É°„ÉÜ„Ç™„Çπ„Éà„É©„Ç§„ÇØ</span>';
    showRoomActionPopAt(clientX, clientY, "", async () => {
      uranusMeteorResolved = true;
      if (canChooseOuterRoomDirectly()){
        renderMarkers();
        return;
      }
      hideAttackPop();
      setTimeout(() => {
        triggerMoveDiceForAll();
      }, 40);
    }, {
      messageHtml: `${ability}„Çí‰ΩøÁî®„Åõ„Åö„Å´ÁßªÂãï„Åó„Åæ„Åô„Åã„ÄÇ`,
      yesLabel: "„ÅØ„ÅÑ",
      noLabel: "„ÅÑ„ÅÑ„Åà"
    });
  }

  function showUranusMeteorConfirmPop(clientX, clientY, targetUid){
    const uid = safeText(targetUid || "");
    if (!uid) return;
    const player = playerById(uid);
    const name = safeText(player?.name || "„Åì„ÅÆ„Éó„É¨„Ç§„É§„Éº");
    const ability = '<span class="ability-pill">„É°„ÉÜ„Ç™„Çπ„Éà„É©„Ç§„ÇØ</span>';
    showRoomActionPopAt(clientX, clientY, "", async () => {
      await emitRoleFlashEvent("SHA_U2", "meteor_strike");
      await new Promise(resolve => setTimeout(resolve, 1200));
      await addDamageToPlayer(uid, 3);
      uranusMeteorResolved = true;
      renderMarkers();
    }, {
      messageHtml: `${ability}${escapeHtml(name)}„Å´3„ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Åæ„Åô„Åã„ÄÇ`,
      yesLabel: "„ÅØ„ÅÑ",
      noLabel: "„ÅÑ„ÅÑ„Åà"
    });
  }
 function drawMarker({x,y,color,initial,uid,pulse=false,eliminated=false}){
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  g.setAttribute("data-uid", uid || "");
  if (pulse) g.classList.add("mark-pulse-target");
  if (eliminated) g.classList.add("marker-eliminated");

  const size = (uid && uid === state.userId) ? 17 : 16;
  const rx = 3;

  if (!eliminated && uid && uid === state.userId){
    g.style.cursor = canInteractWithMapPlayerIcons() ? 'pointer' : 'default';
    g.addEventListener('click', (e) => {
      if (!canInteractWithMapPlayerIcons()) return;
      if (cardPlayerSelectActive) return;
      if (canUseRoom3Action()){
        if (hasEquipmentByName(uid, "Âπ∏ÈÅã„ÅÆ„Éñ„É≠„Éº„ÉÅ")) return;
        e.stopPropagation();
        const p = playerById(uid);
        const nm = safeText(p?.name || "„Åì„ÅÆ„Éó„É¨„Ç§„É§„Éº");
        showRoomActionPopAt(e.clientX, e.clientY, `„Äå${nm}„Äç„Å´ÂÆüË°å„Åô„ÇãÂäπÊûú„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ`, async () => {
          room3ActionUsed = true;
          await updateTurnRoomActionState({ room3ActionUsed:true });
          showTurnHint("");
          await new Promise(resolve => setTimeout(resolve, 1000));
          await healDamageToPlayer(uid, 1);
          renderMarkers();
        }, {
          yesLabel: "1ÂõûÂæ©„Åô„Çã",
          noLabel: "2„ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Çã",
          compactButtons: true,
          yOffset: -14,
          onNo: async () => {
            room3ActionUsed = true;
            await updateTurnRoomActionState({ room3ActionUsed:true });
            showTurnHint("");
            await new Promise(resolve => setTimeout(resolve, 1000));
            await addDamageToPlayer(uid, 2);
            renderMarkers();
          }
        });
        return;
      }
      if (mustResolveUranusMeteorStrike()){
        e.stopPropagation();
        showUranusSkipPop(e.clientX, e.clientY);
        return;
      }
      if (!canUseMoveDice()) return;
      if (canChooseOuterRoomDirectly()) return;
      e.stopPropagation();
      hideAttackPop();
      triggerMoveDiceForAll();
    });
  } else if (!eliminated && uid){
    if (pulse) g.style.cursor = canInteractWithMapPlayerIcons() ? 'pointer' : 'default';
    const longPressMs = 500;
    let markerLongPressTimer = null;
    let markerLongPressDone = false;
    const clearMarkerLongPress = () => {
      if (!markerLongPressTimer) return;
      clearTimeout(markerLongPressTimer);
      markerLongPressTimer = null;
    };

    g.addEventListener('pointerdown', (e) => {
      if (!canInteractWithMapPlayerIcons()) return;
      if (cardPlayerSelectActive) return;
      if (isEquipSelectionLockActive()) return;
      markerLongPressDone = false;
      clearMarkerLongPress();
      if (!canUseWalpurgisSwap()) return;
      if (uid === state.userId) return;
      markerLongPressTimer = setTimeout(() => {
        markerLongPressDone = true;
        showWalpurgisSwapConfirm(e.clientX, e.clientY, uid);
      }, longPressMs);
    });
    g.addEventListener('pointerup', clearMarkerLongPress);
    g.addEventListener('pointerleave', clearMarkerLongPress);
    g.addEventListener('pointercancel', clearMarkerLongPress);

    g.addEventListener('click', (e) => {
      if (!canInteractWithMapPlayerIcons()) return;
      if (cardPlayerSelectActive) return;
      if (isEquipSelectionLockActive()) return;
      clearMarkerLongPress();
      if (markerLongPressDone){
        e.preventDefault();
        e.stopPropagation();
        markerLongPressDone = false;
        return;
      }
      if (!pulse) return;
      e.stopPropagation();
      if (canUseRoom3Action()){
        if (hasEquipmentByName(uid, "Âπ∏ÈÅã„ÅÆ„Éñ„É≠„Éº„ÉÅ")) return;
        const p = playerById(uid);
        const nm = safeText(p?.name || "„Åì„ÅÆ„Éó„É¨„Ç§„É§„Éº");
        showRoomActionPopAt(e.clientX, e.clientY, `„Äå${nm}„Äç„Å´ÂÆüË°å„Åô„ÇãÂäπÊûú„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ`, async () => {
          room3ActionUsed = true;
          await updateTurnRoomActionState({ room3ActionUsed:true });
          showTurnHint("");
          await new Promise(resolve => setTimeout(resolve, 1000));
          await healDamageToPlayer(uid, 1);
          renderMarkers();
        }, {
          yesLabel: "1ÂõûÂæ©„Åô„Çã",
          noLabel: "2„ÉÄ„É°„Éº„Ç∏‰∏é„Åà„Çã",
          compactButtons: true,
          yOffset: -14,
          onNo: async () => {
            room3ActionUsed = true;
            await updateTurnRoomActionState({ room3ActionUsed:true });
            showTurnHint("");
            await new Promise(resolve => setTimeout(resolve, 1000));
            await addDamageToPlayer(uid, 2);
            renderMarkers();
          }
        });
        return;
      }
      if (mustResolveUranusMeteorStrike()){
        showUranusMeteorConfirmPop(e.clientX, e.clientY, uid);
        return;
      }
      if (!canUseAttackDice()) return;
      const p = playerById(uid);
      pendingAttackTargetUid = uid;
      showAttackPopAt(e.clientX, e.clientY, p?.name || '„Åì„ÅÆ„Éó„É¨„Ç§„É§„Éº');
    });
  }

  const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
  rect.setAttribute("x", String(x - size/2));
  rect.setAttribute("y", String(y - size/2));
  rect.setAttribute("width", String(size));
  rect.setAttribute("height", String(size));
  rect.setAttribute("rx", String(rx));
  rect.setAttribute("class", "mark-rect");
  if (uid && hasGuardianAngelShield(uid)) rect.classList.add("guardian-shield");
  rect.setAttribute("fill", String(color || "#ddd"));

  const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
  txt.setAttribute("x", String(x));
  txt.setAttribute("y", String(y+0.5));
  txt.setAttribute("class","mark-text");
  txt.setAttribute("fill", textColorFor(color || "#ddd"));
  txt.textContent = String(initial || "").slice(0,1);

  g.appendChild(rect);
  g.appendChild(txt);
  markerLayer.appendChild(g);
}

  function updateRoomChoiceUi(){
    const choiceMode = canChooseOuterRoomDirectly();
    for (let roomId = 1; roomId <= 6; roomId++){
      const pending = !!pendingMoveChoice && !pendingMoveChoice.consumed && pendingMoveChoice.roomIds.includes(roomId);
      roomShapeEls[roomId]?.classList.toggle('room-choice-pulse', choiceMode);
      roomHitEls[roomId]?.classList.toggle('room-choice-pulse', choiceMode);
      if (roomHitEls[roomId]){
        roomHitEls[roomId].style.cursor = (choiceMode || pending) ? 'pointer' : (isGameStarted() ? 'default' : 'pointer');
      }
    }

    const centerPending = !!pendingMoveChoice && !pendingMoveChoice.consumed && pendingMoveChoice.roomIds.includes(7);
    roomShapeEls[7]?.classList.toggle('room-choice-once', centerPending);
    roomHitEls[7]?.classList.toggle('room-choice-once', centerPending);
    if (roomHitEls[7]){
      roomHitEls[7].style.cursor = centerPending ? 'pointer' : (isGameStarted() ? 'default' : 'pointer');
    }

    for (let roomId = 1; roomId <= 7; roomId++){
      const pulsing =
        roomShapeEls[roomId]?.classList.contains('room-choice-pulse') ||
        roomShapeEls[roomId]?.classList.contains('room-choice-once');
      if (pulsing) bringRoomPulseToFront(roomId);
    }
  }


  function renderMarkers(){
    syncRoomAbilityTurnState();
    ensureMarkerLayer();
    clearMarkerLayer();
    const pulseTargets = highlightedMarkerUids();
    if (canUseMoveDice() && !mustResolveUranusMeteorStrike() && !hasMovedByDiceInCurrentTurn()) pulseTargets.add(state.userId);
    const entries = Object.entries(markerCache || {});
    for (const [uid, m] of entries){
      if (!m) continue;
      const x = Number(m.x);
      const y = Number(m.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
      const eliminated = isPlayerEliminated(uid);
      if (eliminated) continue;
      const player = playerById(uid);
      const markerColor = safeText(player?.color || "") || String(m.color || "#ddd");
      const markerInitial = firstChar(player?.name || "") || String(m.initial || "");
      drawMarker({
        uid,
        x, y,
        color: markerColor,
        initial: markerInitial,
        pulse: pulseTargets.has(uid),
        eliminated
      });
    }
    updateRoomChoiceUi();
    updateAttackRangeUi();
    if (roomGuideVisible && roomGuideLayer && roomGuideLayer.parentNode === roomG){
      roomG.appendChild(roomGuideLayer);
    }
    refreshRoomAbilityHint();
  }

  function clientToSvgPoint(svg, clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) return {x:0,y:0};
    const p = pt.matrixTransform(ctm.inverse());
    return { x: p.x, y: p.y };
  }

  async function writeMyMarker(x, y){
    if (!state.roomCode) return;
    const color = getMyColor();
    const initial = getMyInitial();
    if (!color || !initial) return;

    const mRef = ref(db, `rooms/${state.roomCode}/markers/${state.userId}`);
    const roomId = inferRoomIdFromPoint(x, y) || state.currentRoomId || null;
    await set(mRef, { x, y, color, initial, roomId, updatedAt: Date.now() });
  }

  function subscribeMarkers(){
    const mRef = ref(db, `rooms/${state.roomCode}/markers`);
    onValue(mRef, snap => {
      markerCache = snap.val() || {};
      const myMarker = markerCache?.[state.userId] || null;
      const myRoomId = markerRoomId(myMarker);
      if (myRoomId && state.currentRoomId !== myRoomId){
        setCurrentRoom(myRoomId);
      }
      renderMarkers();
      maybeAutoRollMoveDiceOnTurnStart();
    });
  }

  function setCurrentRoom(roomId){
    state.currentRoomId = roomId;
    updateCardInteractivity();
  }

  function polygonCenter(pts){
    if (!Array.isArray(pts) || !pts.length) return { x:0, y:0 };
    const sum = pts.reduce((acc, [x,y]) => ({ x: acc.x + Number(x || 0), y: acc.y + Number(y || 0) }), { x:0, y:0 });
    return { x: sum.x / pts.length, y: sum.y / pts.length };
  }

  function clearRoomGuideLayer(){
    if (!roomGuideLayer) return;
    while (roomGuideLayer.firstChild) roomGuideLayer.removeChild(roomGuideLayer.firstChild);
  }

  function ensureRoomGuideLayer(){
    if (roomGuideLayer && roomGuideLayer.parentNode === roomG){
      roomG.appendChild(roomGuideLayer);
      return;
    }
    roomGuideLayer = svgEl('g', { class:'room-guide-layer', id:'roomGuideLayer' }, roomG);
    roomG.appendChild(roomGuideLayer);
  }

  function renderRoomGuideLayer(){
    if (!roomGuideVisible){
      clearRoomGuideLayer();
      return;
    }
    ensureRoomGuideLayer();
    clearRoomGuideLayer();
    for (let roomId = 1; roomId <= 7; roomId++){
      const pts = roomPolygons[roomId];
      const lines = ROOM_GUIDE_LINES[roomId];
      if (!pts || !lines) continue;
      const center = polygonCenter(pts);
      const [dx, dy] = ROOM_GUIDE_OFFSET[roomId] || [0,0];
      const noteG = svgEl('g', {
        transform: `translate(${(center.x + dx).toFixed(2)}, ${(center.y + dy).toFixed(2)})`
      }, roomGuideLayer);
      const lineHeight = 8;
      const paddingX = 5;
      const paddingY = 3;
      const contentHeight = lines.length * lineHeight;
      const topY = -contentHeight / 2;
      const textNodes = [];

      lines.forEach((line, idx) => {
        const txt = svgEl('text', {
          class:'room-guide-note-text',
          x: '0',
          y: (topY + (idx + 0.5) * lineHeight).toFixed(2),
          'dominant-baseline': 'middle'
        }, noteG);
        txt.textContent = String(line);
        textNodes.push(txt);
      });

      const contentWidth = textNodes.reduce((maxWidth, node) => {
        try {
          const w = Number(node.getBBox().width) || 0;
          return Math.max(maxWidth, w);
        } catch {
          return maxWidth;
        }
      }, 0);
      const width = Math.max(34, contentWidth + paddingX * 2);
      const height = contentHeight + paddingY * 2;
      const rect = svgEl('rect', {
        class:'room-guide-note',
        x: (-width / 2).toFixed(2),
        y: (-height / 2).toFixed(2),
        width: width.toFixed(2),
        height: height.toFixed(2),
        rx: 4,
        ry: 4
      }, noteG);
      noteG.insertBefore(rect, noteG.firstChild);
    }
  }

  function renderRoomShape(){
    ensureRoomPatterns();
    while(roomG.firstChild) roomG.removeChild(roomG.firstChild);
    roomGuideLayer = null;
    Object.keys(roomPolygons).forEach(k => delete roomPolygons[k]);
    for (const k of Object.keys(roomShapeEls)) delete roomShapeEls[k];
    for (const k of Object.keys(roomHitEls)) delete roomHitEls[k];

    const { centerHex, rooms } = buildStarRooms(cx, cy, s0, t, tip);
    roomPolygons[7] = centerHex.map(([x,y]) => [x,y]);

    const centerShape = poly(centerHex, 'shape');
    centerShape.dataset.roomId = "7";
    centerShape.setAttribute('fill', "url('#roomPattern7')");
    roomShapeEls[7] = centerShape;

    rooms.forEach((pts, idx)=>{
      const shapeEl = poly(pts, 'shape');
      const hit = poly(pts, 'roomhit');
      const roomId = idx + 1;
      shapeEl.setAttribute('fill', `url('#roomPattern${roomId}')`);
      shapeEl.dataset.roomId = String(roomId);
      roomPolygons[roomId] = pts.map(([x,y]) => [x,y]);
      hit.dataset.roomId = String(roomId);
      roomShapeEls[roomId] = shapeEl;
      roomHitEls[roomId] = hit;

      hit.addEventListener('click', async (ev) => {
        if (cardPlayerSelectActive) return;
        if (isEquipSelectionLockActive()) return;
        if (isGameStarted()){
          if (await resolvePendingMoveChoice(roomId)) return;
          if (!canChooseOuterRoomDirectly()) return;
          await placeMarkerInRoom(roomId);
          if (state.roomCode && isMyTurn()){
            await update(ref(db, `rooms/${state.roomCode}/turn`), {
              moveDone: true,
              moveAt: Date.now()
            });
          }
          return;
        }
        setCurrentRoom(roomId);
        const p = clientToSvgPoint(roomSvg, ev.clientX, ev.clientY);
        await writeMyMarker(p.x, p.y);
      });
    });

    const centerHit = poly(centerHex, 'roomhit');
    centerHit.dataset.roomId = "7";
    roomHitEls[7] = centerHit;
    centerHit.addEventListener('click', async (ev) => {
      if (cardPlayerSelectActive) return;
      if (isEquipSelectionLockActive()) return;
      if (isGameStarted()){
        if (await resolvePendingMoveChoice(7)) return;
        return;
      }
      setCurrentRoom(7);
      const p = clientToSvgPoint(roomSvg, ev.clientX, ev.clientY);
      await writeMyMarker(p.x, p.y);
    });

    ensureMarkerLayer();
    ensureAttackRangeLayer();
    ensureMarkerLayer();
    renderRoomGuideLayer();
    updateRoomChoiceUi();
    updateAttackRangeUi();
    fitRoomViewBox(2);
  }

  const ROLES = [
    { id:"CIT_A1", name:"„Ç¢„É™„Çπ",    en:"ALICE",    initial:"A", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:8,  win:"ÁîüÂ≠ò„Åó„Å¶„ÅÑ„Çã", effect:"„ÅÜ„Åï„Åé„Åï„Çì„Éí„Éº„É´ÔºöÊâãÁï™Âàù„ÇÅ„Å´‰ΩøÁî®„ÄÇ„ÉÄ„É°„Éº„Ç∏„ÇíÂÖ®ÂõûÂæ©Ôºà1ÂõûÔºâ" },
    { id:"CIT_A2", name:"„Ç¢„É≥„Ç∏„Çß„É©", en:"ANGELA",  initial:"A", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:8,  win:"Âè≥Èö£„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅåÂãùÂà©„Åô„Çã", effect:"Áßª„ÇäÊ∞óÔºöÂãùÂà©Êù°‰ª∂„Çí„ÄåÂ∑¶Èö£„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅåÂãùÂà©„Åô„Çã„Äç„Å´Â§âÊõ¥Ôºà1ÂõûÔºâ" },
    { id:"CIT_A3", name:"„Ç¢„Ç¨„Çµ",    en:"AGATHA",   initial:"A", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:8,  win:"Ëá™ÂàÜ„ÅÆÊâãÁï™„Åß„Ç≤„Éº„É†ÁµÇ‰∫Ü", effect:"ÂÆåÂÖ®ÁäØÁΩ™ÔºöÊ≠£‰ΩìÂÖ¨ÈñãÊôÇ„Å´„ÉÄ„Ç§„Çπ2ÂÄã„ÇíÂêåÊôÇ„Å´ÊåØ„Çä„ÄÅÂá∫ÁõÆ„Ç®„É™„Ç¢„ÅÆPLÂÖ®Âì°„Å´3„ÉÄ„É°„Éº„Ç∏Ôºà1ÂõûÔºâ" },
    { id:"CIT_B1", name:"„Éê„Ç§„É≠„É≥",  en:"BYRON",    initial:"B", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:10, win:"Ë£ÖÂÇô„Ç´„Éº„Éâ„Çí5Êûö‰ª•‰∏äÊâÄÊåÅ", effect:"ÂøµÂäõ„ÅÆÊáê‰∏≠ÊôÇË®àÔºö2‰ª•‰∏ä„ÅÆÊîªÊíÉ„ÉÄ„É°„Éº„Ç∏ÊôÇ„ÄÅ‰ª£„Çè„Çä„Å´Ë£ÖÂÇô„Çí1„Å§Â•™„ÅÜ" },
    { id:"CIT_B2", name:"„Éô„É≥„Ç∏„É£„Éü„É≥", en:"BENJAMIN", initial:"B", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:10, win:"‰ªñPL„ÅåË£ÖÂÇô„Çí5„Å§‰ª•‰∏äÊâÄÊåÅ", effect:"Â§™ÈºìÊåÅ„Å°ÔºöÊâãÁï™ÊúÄÂæå„Å´Âêå„Åò„Ç®„É™„Ç¢„ÅÆPL„Å∏Ë£ÖÂÇô„Çí1„Å§Ê∏°„Åõ„Çã" },
    { id:"CIT_B3", name:"„Éñ„É´„Éº„Çπ",  en:"BRUCE",    initial:"B", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:10, win:"ÊîªÊíÉ„ÅßHP12‰ª•‰∏ä„ÅÆPL„ÇíËÑ±ËêΩ„Åï„Åõ„Çã„ÄÅ„Åæ„Åü„ÅØÁµÇ‰∫ÜÊôÇ„Å´„Éû„Çπ9„Å´„ÅÑ„Çã", effect:"ÂõΩÂ£´ÁÑ°ÂèåÔºöÊîªÊíÉ„ÅßPL„ÇíËÑ±ËêΩ„Åï„Åõ„ÅüÊôÇ„ÄÅËá™ÂàÜ„ÅÆÊ≠£‰Ωì„ÇíÂÖ¨Èñã" },
    { id:"CIT_C1", name:"„ÇØ„É¨„Ç§„Ç∞",  en:"CRAIG",    initial:"C", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:11, win:"2‰∫∫ËÑ±ËêΩÂæå„Å´‰ªñPL„ÇíÊîªÊíÉ„Åó„Å¶ËÑ±ËêΩ„Åï„Åõ„Çã", effect:"Ê≠ª„ÅÆÈ•óÂÆ¥ÔºöÊîªÊíÉÂæå„ÄÅËá™ÂàÜ„Å´2„ÉÄ„É°„Éº„Ç∏‰∏é„ÅàÂÜçÊîªÊíÉÂèØ" },
    { id:"CIT_C2", name:"„Ç≠„É£„É≠„É´",  en:"CAROL",    initial:"C", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:11, win:"ÊúÄÂàù„Å´ËÑ±ËêΩ„Åô„Çã„ÄÅ„Åæ„Åü„ÅØËá™ÂàÜ„Å®„ÇÇ„ÅÜ1‰∫∫„Å†„ÅëÁîüÂ≠ò", effect:"ËÅñÁóïÔºöÊ≠£‰ΩìÂÖ¨ÈñãÂæå„Å´2ÂõûÂæ©„ÄÇÂÖ¨ÈñãÊ∏à„Åø„Å™„ÇâÊâãÁï™Âàù„ÇÅ„Å´2ÂõûÂæ©" },
    { id:"CIT_C3", name:"„ÇØ„É¨„Ç¢",    en:"CLAIRE",   initial:"C", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:11, win:"„Ç≤„Éº„É†ÁµÇ‰∫ÜÊôÇ„ÄÅËá™ÂàÜ„ÅÆ„ÉÄ„É°„Éº„Ç∏„Åå6ÔΩû8", effect:"„Ç≠„É£„Çπ„É™„É≥„Ç∞ÔºöÊâãÁï™Âàù„ÇÅ„Å´Ëá™ÂàÜ„Å®‰ªñPL„ÅÆHP„ÇíÂÖ•„ÇåÊõø„Åà„ÇãÔºà1ÂõûÔºâ" },
    { id:"CIT_D1", name:"„ÉÄ„Éã„Ç®„É´",  en:"DANIEL",   initial:"D", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:13, win:"ÊúÄÂàù„Å´ËÑ±ËêΩ„Åô„Çã„ÄÅ„Åæ„Åü„ÅØ„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°ËÑ±ËêΩ„Åã„Å§ÁîüÂ≠ò", effect:"Áµ∂Âè´ÔºöÊúÄÂàù„Å´‰ªñPL„ÅåËÑ±ËêΩ„Åó„ÅüÊôÇ„ÄÅÊ≠£‰Ωì„Ç´„Éº„Éâ„ÇíÂÖ¨Èñã" },
    { id:"CIT_D2", name:"„Éá„Éº„É¥„Ç£„ÉÉ„Éâ", en:"DAVID",  initial:"D", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:13, win:"„Äå„ÅÑ„Å´„Åó„Åà„ÅÆËÅñÊùØ„Äç„ÄåÁ•ûÁßò„ÅÆ„Ç≥„É≥„Éë„Çπ„Äç„ÄåÂπ∏ÈÅã„ÅÆ„Éñ„É≠„Éº„ÉÅ„Äç„ÄåÈäÄ„ÅÆ„É≠„Ç∂„É™„Ç™„Äç„ÅÆ„ÅÜ„Å°3Á®Æ„ÇíÊâÄÊåÅ", effect:"„Ç∞„É¨„Ç§„Éñ„Éá„Ç£„Ç¨„ÉºÔºöÊâãÁï™Âàù„ÇÅ„Å´ËÑ±ËêΩËÄÖ„ÅÆË£ÖÂÇô„Ç´„Éº„Éâ„Åã„Çâ‰ªªÊÑè1ÊûöÁç≤Âæó" },
    { id:"CIT_D3", name:"„Éá„Éú„É©",    en:"DEBORAH",  initial:"D", faction:"„Ç∑„ÉÅ„Ç∫„É≥", hp:13, win:"5‰∫∫Êà¶ÔºöÁµÇ‰∫ÜÊôÇ„Å´ÊúÄ„ÇÇ„ÉÄ„É°„Éº„Ç∏„ÅåÂ§ö„ÅÑÔºè6‰∫∫Êà¶ÔºöËá™ÂàÜ‰ª•Â§ñ„ÅÆ„Ç∑„ÉÅ„Ç∫„É≥„ÅåÂãùÂà©", effect:"ÁåÆË∫´ÁöÑ„Å™ÊÑõÔºöÊâãÁï™Âàù„ÇÅ„Å´ÂãùÂà©Êù°‰ª∂„Çí„ÄåËÑ±ËêΩ„Åô„Çã„Äç„Å´Â§âÊõ¥" },
    { id:"RAI_E1", name:"„Ç®„Éü",      en:"EMI",      initial:"E", faction:"„É¨„Ç§„ÉÄ„Éº", hp:10, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"„ÉÜ„É¨„Éù„Éº„ÉàÔºöÁßªÂãïÊôÇ„ÄÅÂá∫ÁõÆ„Ç®„É™„Ç¢„Åæ„Åü„ÅØ‰∏°Èö£„Ç®„É™„Ç¢„Å´ÁßªÂãïÂèØ" },
    { id:"RAI_E2", name:"„Ç®„É™„Ç´",    en:"ERIKA",    initial:"E", faction:"„É¨„Ç§„ÉÄ„Éº", hp:10, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"Áôí„Åó„ÅÆÂÖâÔºöÊâãÁï™ÁµÇ‰∫ÜÊôÇ„Å´4Èù¢„ÉÄ„Ç§„Çπ„ÇíÊåØ„Çä„ÄÅÂá∫ÁõÆÂàÜ‰ªñPL„ÇíÂõûÂæ©" },
    { id:"RAI_E3", name:"„Ç®„Éû",      en:"EMMA",     initial:"E", faction:"„É¨„Ç§„ÉÄ„Éº", hp:10, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"Â∞ÅÂç∞„ÅÆÈéñÔºöÊâãÁï™Âàù„ÇÅ„Å´‰ªñPL1‰∫∫„ÅÆÁâπÊÆäËÉΩÂäõ„Çí„Ç≤„Éº„É†ÁµÇ‰∫Ü„Åæ„ÅßÂ∞ÅÂç∞Ôºà1ÂõûÔºâ" },
    { id:"RAI_F1", name:"„Éï„Çß„É™„ÉÉ„ÇØ„Çπ", en:"FELIX", initial:"F", faction:"„É¨„Ç§„ÉÄ„Éº", hp:12, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"„Ç¢„Çπ„Éà„É©„É´„Éª„É°„Ç§„ÇπÔºöÊâãÁï™Âàù„ÇÅ„Å´‰ªñPL1‰∫∫„Å∏6Èù¢„ÉÄ„Ç§„ÇπÊîªÊíÉÔºà1ÂõûÔºâ" },
    { id:"RAI_F2", name:"„Éï„Çß„É™„Ç∑„Ç¢", en:"FELICIA", initial:"F", faction:"„É¨„Ç§„ÉÄ„Éº", hp:12, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"„Çπ„É©„É†Ë°ó„ÅÆÂ§©‰ΩøÔºöÊâãÁï™Âàù„ÇÅ„Å´‰ªªÊÑè„ÅÆPL„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí7„Å´„Åô„ÇãÔºà1ÂõûÔºâ" },
    { id:"RAI_F3", name:"„Éï„É¨„Éá„Ç£",  en:"FREDDIE",  initial:"F", faction:"„É¨„Ç§„ÉÄ„Éº", hp:12, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"„Éâ„É©„Ç¥„É≥„Ç¢„Çø„ÉÉ„ÇØÔºöÊ≠£‰ΩìÂÖ¨Èñã‰∏≠„ÅÆPL„Å∏„ÅÆÊîªÊíÉÊàêÂäüÊôÇ +2„ÉÄ„É°„Éº„Ç∏" },
    { id:"RAI_G1", name:"„Ç¥„Éº„Éâ„É≥",  en:"GORDON",   initial:"G", faction:"„É¨„Ç§„ÉÄ„Éº", hp:14, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"Áµ∂ÂØæÁÑ°Êïµ„Éê„É™„Ç¢ÔºöÊâãÁï™ÁµÇ‰∫ÜÊôÇ„Å´‰ΩøÁî®„ÄÇÊ¨°„ÅÆËá™ÂàÜ„ÅÆÊâãÁï™Âàù„ÇÅ„Åæ„ÅßÂÖ®„ÉÄ„É°„Éº„Ç∏ÁÑ°ÂäπÔºà1ÂõûÔºâ" },
    { id:"RAI_G2", name:"„Ç¨„É©„Éè„Éâ",  en:"GALAHAD",  initial:"G", faction:"„É¨„Ç§„ÉÄ„Éº", hp:14, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"È≠îÂâ£„ÅÆ‰ºùÊâøËÄÖÔºö„Ç®„ÇØ„Çπ„Ç´„É™„Éê„ÉºÊâÄÊåÅÊôÇ„Å´ÊîªÊíÉÂ§±Êïó„Å™„Çâ„ÉÄ„Ç§„ÇπÊåØ„ÇäÁõ¥„Åó" },
    { id:"RAI_G3", name:"„Ç¥„Éâ„Ç¶„Ç£„É≥", en:"GODWIN",  initial:"G", faction:"„É¨„Ç§„ÉÄ„Éº", hp:14, win:"„Ç∑„É£„Éâ„Ç¶ÂÖ®Âì°„ÅÆËÑ±ËêΩ", effect:"ËòáÁîüË£ÖÁΩÆTYPE-GÔºöËá™ÂàÜËÑ±ËêΩÊôÇ„ÄÅÊó¢„Å´ËÑ±ËêΩ„Åó„Å¶„ÅÑ„ÇãPL1‰∫∫„Çí„ÉÄ„É°„Éº„Ç∏7„ÅßÂæ©Ê¥ª" },
    { id:"SHA_U1", name:"„Ç¶„É´„É™„ÉÉ„Éí", en:"ULRICH",  initial:"U", faction:"„Ç∑„É£„Éâ„Ç¶", hp:11, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"Êé®ÁêÜ„Ç´„Éº„Éâ„ÇíÂèó„ÅëÂèñ„Å£„ÅüÊôÇ„ÄÅ„Ç¶„ÇΩ„Çí„Å§„ÅÑ„Å¶„Çà„ÅÑ" },
    { id:"SHA_U2", name:"„Ç¶„É©„Éå„Çπ",   en:"URANUS",  initial:"U", faction:"„Ç∑„É£„Éâ„Ç¶", hp:11, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"„É°„ÉÜ„Ç™„Çπ„Éà„É©„Ç§„ÇØÔºöÊ≠£‰ΩìÂÖ¨ÈñãÊ∏à„Åø„ÅßÁßªÂãïÂâç„Å™„Çâ„ÄÅ„Ç®„É™„Ç¢6-7„ÅÆPL1‰∫∫„Å´3„ÉÄ„É°„Éº„Ç∏" },
    { id:"SHA_U3", name:"„Ç¢„É´„Çπ„Çø„Éº", en:"ULSTER",  initial:"U", faction:"„Ç∑„É£„Éâ„Ç¶", hp:11, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"„Éá„É´„Éª„Éï„É™„ÇπÔºö2ÂõûÊîªÊíÉ„Åß„Åç„Çã" },
    { id:"SHA_V1", name:"„É¥„Çß„Éé„É†",    en:"VENOM",   initial:"V", faction:"„Ç∑„É£„Éâ„Ç¶", hp:13, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"ÂèçÈßÅ„ÅÆÁåõÊØíÔºöÊîªÊíÉËÄÖ„ÅØ1„ÉÄ„É°„Éº„Ç∏Âèó„Åë„Çã„ÅãË£ÖÂÇô„ÇíÊ∏°„Åô„ÅãÈÅ∏Êäû" },
    { id:"SHA_V2", name:"„É¥„Ç°„É≥„Éë„Ç§„Ç¢", en:"VAMPIRE", initial:"V", faction:"„Ç∑„É£„Éâ„Ç¶", hp:13, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"Âê∏Ë°ÄÔºöÊîªÊíÉÊàêÂäüÊôÇ„ÄÅ„ÉÄ„É°„Éº„Ç∏„Çí2ÂõûÂæ©" },
    { id:"SHA_V3", name:"„É¥„Çß„É≥„Éá„ÉÉ„Çø", en:"VENDETTA", initial:"V", faction:"„Ç∑„É£„Éâ„Ç¶", hp:13, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"ÂÜ•Â∫ú„ÅÆÂ§ßÈéåÔºöÊîªÊíÉ„ÅØ4Èù¢„ÉÄ„Ç§„Çπ„ÅÆ„Åø‰ΩøÁî®" },
    { id:"SHA_W1", name:"„ÉØ„Ç§„Éà",      en:"WIGHT",    initial:"W", faction:"„Ç∑„É£„Éâ„Ç¶", hp:14, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"‰∫°ËÄÖ„ÅÆÁéãÔºöÁßªÂãïÂæå„Å´ÂÖ¨Èñã„Åó„Å¶‰ΩøÁî®„ÄÇÊâãÁï™„ÇíÁµÇ‰∫Ü„Åó„Å¶„ÄÅËÑ±ËêΩËÄÖÊï∞„Å∂„ÇìËøΩÂä†ÊâãÁï™Ôºà1ÂõûÔºâ" },
    { id:"SHA_W2", name:"„ÉØ„É´„Éó„É´„ÇÆ„Çπ", en:"WALPURGIS", initial:"W", faction:"„Ç∑„É£„Éâ„Ç¶", hp:14, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"ÈáçÂäõ„ÅÆËôπÔºöÊîªÊíÉÊôÇ„ÄÅ‰ªªÊÑè„ÅÆPL1‰∫∫„Å®‰ΩçÁΩÆ„Çí‰∫§ÊèõÂèØ" },
    { id:"SHA_W3", name:"„ÉØ„Éº„Ç¶„É´„Éï",   en:"WEREWOLF", initial:"W", faction:"„Ç∑„É£„Éâ„Ç¶", hp:14, win:"„É¨„Ç§„ÉÄ„ÉºÂÖ®Âì°„Åæ„Åü„ÅØ„Ç∑„ÉÅ„Ç∫„É≥3‰∫∫„ÅÆËÑ±ËêΩ", effect:"ÂèçÊíÉÔºöÊîªÊíÉ„ÇíÂèó„Åë„ÅüÊôÇ„ÄÅ„Åù„ÅÆPL„Çí„Åü„Å†„Å°„Å´ÊîªÊíÉ" },
  ];

  const ROLE_BY_ID = Object.fromEntries(ROLES.map(r => [r.id, r]));
  const POOL = {
    "„Ç∑„ÉÅ„Ç∫„É≥": ROLES.filter(r => r.faction === "„Ç∑„ÉÅ„Ç∫„É≥"),
    "„É¨„Ç§„ÉÄ„Éº": ROLES.filter(r => r.faction === "„É¨„Ç§„ÉÄ„Éº"),
    "„Ç∑„É£„Éâ„Ç¶": ROLES.filter(r => r.faction === "„Ç∑„É£„Éâ„Ç¶"),
  };

  const DEAL_RULE = {
    1: { "„É¨„Ç§„ÉÄ„Éº": 1, "„Ç∑„É£„Éâ„Ç¶": 0, "„Ç∑„ÉÅ„Ç∫„É≥": 0 },
    2: { "„É¨„Ç§„ÉÄ„Éº": 1, "„Ç∑„É£„Éâ„Ç¶": 1, "„Ç∑„ÉÅ„Ç∫„É≥": 0 },
    3: { "„É¨„Ç§„ÉÄ„Éº": 1, "„Ç∑„É£„Éâ„Ç¶": 1, "„Ç∑„ÉÅ„Ç∫„É≥": 1 },
    4: { "„É¨„Ç§„ÉÄ„Éº": 2, "„Ç∑„É£„Éâ„Ç¶": 2, "„Ç∑„ÉÅ„Ç∫„É≥": 0 },
    5: { "„É¨„Ç§„ÉÄ„Éº": 2, "„Ç∑„É£„Éâ„Ç¶": 2, "„Ç∑„ÉÅ„Ç∫„É≥": 1 },
    6: { "„É¨„Ç§„ÉÄ„Éº": 2, "„Ç∑„É£„Éâ„Ç¶": 2, "„Ç∑„ÉÅ„Ç∫„É≥": 2 },
    7: { "„É¨„Ç§„ÉÄ„Éº": 2, "„Ç∑„É£„Éâ„Ç¶": 2, "„Ç∑„ÉÅ„Ç∫„É≥": 3 },
    8: { "„É¨„Ç§„ÉÄ„Éº": 3, "„Ç∑„É£„Éâ„Ç¶": 3, "„Ç∑„ÉÅ„Ç∫„É≥": 2 },
    9: { "„É¨„Ç§„ÉÄ„Éº": 3, "„Ç∑„É£„Éâ„Ç¶": 3, "„Ç∑„ÉÅ„Ç∫„É≥": 3 },
    10:{ "„É¨„Ç§„ÉÄ„Éº": 3, "„Ç∑„É£„Éâ„Ç¶": 3, "„Ç∑„ÉÅ„Ç∫„É≥": 4 },
  };

  const state = {
    userId: savedUserId,
    userName: null,
    roomCode: null,
    seatedTable: null,
    isHost: false,
    hands: {},
    room: {},
    spectating: false,
    currentRoomId: 0,
  };

  const mainEl = document.getElementById('main');
  const joinBox = document.getElementById('joinBox');
  const inputName = document.getElementById('userName');
  const inputCode = document.getElementById('roomCode');
  const btnJoin = document.getElementById('btnJoin');
  const lobby = document.getElementById('lobby');
  const roomInfo = document.getElementById('roomInfo');
  const lastAttackToMeHeader = document.getElementById('lastAttackToMeHeader');
  const attackRollResult = document.getElementById('attackRollResult');
  const roomInfoLobby = document.getElementById('roomInfoLobby');
  const copyLinkBtn = document.getElementById('copyLinkBtn');

  const seatPopBackdrop = document.getElementById('seatPopBackdrop');
  const seatCountBadge = document.getElementById('seatCountBadge');
  const tileGrid = document.getElementById('tileGrid');
  const startWarn = document.getElementById('startWarn');
  const btnSpectate = document.getElementById('btnSpectate');

  const gameArea = document.getElementById('gameArea');


  let preloadImagesStarted = false;
  function collectImageAssetsForPreload(){
    const fromDeck = [...WHITE_DECK, ...BLACK_DECK]
      .map(card => cardImageFileFromName(card?.name || ""))
      .filter(Boolean);
    const fromRole = ROLES
      .map(role => `${encodeURI(`${safeText(role?.initial || "").trim()}${safeText(role?.name || "").trim()}`)}.jpg`)
      .filter(v => v && v !== '.jpg');
    return [...new Set([
      ...fromDeck,
      ...fromRole,
      'maemain.jpg','back.jpg','gear.jpg','hp.png','endgear.png',
      'greendeck.jpg','whitedeck.jpg','blackdeck.jpg','browncard.jpg','suiri.jpg',
      ...Array.from({length:7}, (_,i) => `room${i+1}.jpg`),
      '4d1.png','4d2.png','4d3.png','4d4.png','4da1.png','4da2.png','4da3.png',
      '6d1.png','6d2.png','6d3.png','6d4.png','6d5.png','6d6.png','6da1.png','6da2.png','6da3.png','6da4.png',
      'map.png'
    ])];
  }
  function startImagePreload(){
    if (preloadImagesStarted) return;
    preloadImagesStarted = true;
    const files = collectImageAssetsForPreload();
    files.forEach((file) => {
      const img = new Image();
      img.decoding = 'async';
      img.src = file;
    });
  }

  const myRoleDock = document.getElementById('myRoleDock');
  const myRoleCard = document.getElementById('myRoleCard');

  const kickDialog = document.getElementById('kickDialog');
  const kickMessage = document.getElementById('kickMessage');
  const btnKickYes = document.getElementById('btnKickYes');
  const btnKickNo = document.getElementById('btnKickNo');

  const hostSettingsBtn = document.getElementById('hostSettingsBtn');
  const startPop = document.getElementById('startPop');
  const btnStartPopClose = document.getElementById('btnStartPopClose');
  const btnGameStart = document.getElementById('btnGameStart');
  const btnHostDice = document.getElementById('btnHostDice');
  const btnResetRoom = document.getElementById('btnResetRoom');
  const startBadge = document.getElementById('startBadge');

  const helpBtn = document.getElementById('helpBtn');
  const roomGuideBtn = document.getElementById('roomGuideBtn');
  const helpBackdrop = document.getElementById('helpBackdrop');
  const equipExpandBackdrop = document.getElementById('equipExpandBackdrop');
  const equipExpandBody = document.getElementById('equipExpandBody');
  const helpBody = document.getElementById('helpBody');

  function teamColor(f){
    if (f === "„É¨„Ç§„ÉÄ„Éº")  return "#c21d1d";
    if (f === "„Ç∑„É£„Éâ„Ç¶")  return "#0b2a6a";
    if (f === "„Ç∑„ÉÅ„Ç∫„É≥") return "#eab308";
    return "#111";
  }
  function cardImageUrl(role){
    const initial = safeText(role?.initial || "").trim();
    const roleName = safeText(role?.name || "").trim();
    const safe = encodeURI(`${initial}${roleName}`.trim());
    return safe ? `url('${safe}.jpg')` : "none";
  }
  function createIdentityCard(role){
    const team = teamColor(role.faction);
    const en = (role.en || "").trim() || (role.name || "").trim();
    const chars = Array.from(en);
    const ini = (role.initial && String(role.initial)) || (chars[0] || "");
    const enSub = chars.length >= 2 ? chars.slice(1).join("") : "";

    const teamLabel = (role.faction === "„É¨„Ç§„ÉÄ„Éº") ? "RAIDER"
                  : (role.faction === "„Ç∑„É£„Éâ„Ç¶") ? "SHADOW"
                  : (role.faction === "„Ç∑„ÉÅ„Ç∫„É≥") ? "CITIZEN"
                  : String(role.faction || "");

    const card = document.createElement('div');
    card.className = 'id72';
    card.style.setProperty('--team', team);
    card.style.backgroundImage = cardImageUrl(role);

    card.innerHTML = `
      <div class="initial"><span>${ini}</span></div>
      <svg class="team-arc" viewBox="0 0 22 10" aria-hidden="true">
        <path id="teamPath" d="M0,3 Q11,9 22,3" fill="none"></path>
        <text>
          <textPath href="#teamPath" startOffset="50%" text-anchor="middle">${teamLabel}</textPath>
        </text>
      </svg>
      <div class="eng-sub">${enSub}</div>
      <div class="name">${role.name || ""}</div>
      <div class="hp-badge" aria-label="HP ${role.hp ?? ""}">
        <div class="label">HP</div>
        <div class="val">${role.hp ?? ""}</div>
      </div>
      <div class="effect">
        <p class="row"><span class="tag">ÂãùÂà©Êù°‰ª∂</span>${role.win || ""}</p>
        <p class="row"><span class="tag">${(String(role.effect||"").split("Ôºö")[0] || "ÊäÄÂêç")}</span>${(String(role.effect||"").split("Ôºö").slice(1).join("Ôºö") || "").trim() || String(role.effect||"")}</p>
      </div>
    `;
    return card;
  }

  function renderHelpList(){
    helpBody.innerHTML = '';
    const sortedRoles = [...ROLES].sort((a,b) => {
      const order = { "„É¨„Ç§„ÉÄ„Éº": 0, "„Ç∑„É£„Éâ„Ç¶": 1, "„Ç∑„ÉÅ„Ç∫„É≥": 2 };
      const ao = order[a.faction] ?? 9;
      const bo = order[b.faction] ?? 9;
      if (ao !== bo) return ao - bo;
      if (a.initial !== b.initial) return safeText(a.initial).localeCompare(safeText(b.initial), 'ja');
      return safeText(a.name).localeCompare(safeText(b.name), 'ja');
    });

    const byInitial = new Map();
    sortedRoles.forEach((r) => {
      const key = safeText(r.initial || "?");
      if (!byInitial.has(key)) byInitial.set(key, []);
      byInitial.get(key).push(r);
    });

    function isEquipCard(cardObj){
      const txt = safeText(cardObj?.effect || "").trim();
      return txt.startsWith("Ë£ÖÂÇô");
    }
    function sortDeckForHelp(deck){
      return [...(deck || [])].sort((a,b) => {
        const ae = isEquipCard(a) ? 0 : 1;
        const be = isEquipCard(b) ? 0 : 1;
        if (ae !== be) return ae - be;
        return safeText(a?.name || a?.text || "").localeCompare(safeText(b?.name || b?.text || ""), 'ja');
      });
    }

    function makeSection(title){
      const sec = document.createElement('section');
      sec.className = 'help-section';
      const h = document.createElement('h3');
      h.className = 'help-section-title';
      h.textContent = title;
      sec.appendChild(h);
      return sec;
    }

    const roleSec = makeSection('Ê≠£‰Ωì„Ç´„Éº„Éâ„É™„Çπ„Éà');
    for (const group of byInitial.values()){
      const row = document.createElement('div');
      row.className = 'help-role-row';
      group.forEach((r) => {
        const cardWrap = document.createElement('div');
        cardWrap.className = 'role-card-wrap';
        const roleCard = createIdentityCard(r);
        roleCard.style.cursor = 'pointer';
        if (isTestPlayer()){
          roleCard.addEventListener('click', async (e) => {
            e.stopPropagation();
            await replaceMyRoleCardForTest(r);
          });
        } else {
          roleCard.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = captureSelectionRestoreAction();
            openZoomFromCard(roleCard, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
            setZoomOverPanel(true);
            if (action){
              setZoomPassthrough(false);
              zoomDismissHandler = async () => {
                await restoreSelectionAction(action);
              };
            }
          });
        }
        cardWrap.appendChild(roleCard);
        if (isTestPlayer()){
          cardWrap.title = '„ÇØ„É™„ÉÉ„ÇØ„ÅßËá™ÂàÜ„ÅÆÊ≠£‰Ωì„Ç´„Éº„Éâ„Çí„Åì„ÅÆ„Ç´„Éº„Éâ„Å´Â§âÊõ¥ÔºàËÉΩÂäõ‰ΩøÁî®Áä∂Ê≥Å„ÅØ„É™„Çª„ÉÉ„ÉàÔºâ';
        }
        row.appendChild(cardWrap);
      });
      roleSec.appendChild(row);
    }
    helpBody.appendChild(roleSec);

    function appendDeckSection(title, deck, theme, toCardObj){
      const sec = makeSection(title);
      const grid = document.createElement('div');
      grid.className = 'help-card-grid';
      sortDeckForHelp(deck).forEach((cardData) => {
        const card = document.createElement('div');
        card.className = `card72 wb-front ${theme === 'black' ? 'wb-black' : theme === 'green' ? 'wb-green' : 'wb-white'}`;
        card.innerHTML = buildWbFrontHTML(toCardObj(cardData), theme);
        adjustCardNameFont(card);
        card.style.cursor = 'pointer';
        card.addEventListener('click', (e) => {
          e.stopPropagation();
          const action = captureSelectionRestoreAction();
          openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
          setZoomOverPanel(true);
          if (action){
            setZoomPassthrough(false);
            zoomDismissHandler = async () => {
              await restoreSelectionAction(action);
            };
          }
        });
        grid.appendChild(card);
      });
      sec.appendChild(grid);
      helpBody.appendChild(sec);
    }

    appendDeckSection('ÁôΩ„Ç´„Éº„Éâ„É™„Çπ„Éà', WHITE_DECK, 'white', (c) => c);
    appendDeckSection('Èªí„Ç´„Éº„Éâ„É™„Çπ„Éà', BLACK_DECK, 'black', (c) => c);
    appendDeckSection('Êé®ÁêÜ„Ç´„Éº„Éâ„É™„Çπ„Éà', GREEN_DECK, 'green', (c) => {
      const text = safeText(c?.text || '').replace(/^Êé®ÁêÜ„Ç´„Éº„ÉâÔºö/, '').trim();
      return { name:'Êé®ÁêÜ„Ç´„Éº„Éâ', effect:text };
    });
  }
  function openHelp(){
    renderHelpList();
    helpBackdrop.classList.remove('hidden');
  }
  async function replaceMyRoleCardForTest(role){
    if (!isTestPlayer()) return;
    if (!state.roomCode || !state.userId || !role?.id) return;
    const prev = state.hands?.[state.userId] || {};
    await update(ref(db, `rooms/${state.roomCode}`), {
      [`hands/${state.userId}`]: {
        ...prev,
        roleId: role.id,
        testReplacedAt: Date.now()
      },
      [`equipment/${state.userId}/identity`]: null
    });
    await resetAllAbilityUsageForUids([state.userId]);
  }
  function closeHelp(){ helpBackdrop.classList.add('hidden'); }
  function renderEquipExpandBody(){
    if (!equipExpandBody || !equipBody) return;
    equipExpandBody.innerHTML = equipBody.innerHTML;
  }
  function findEquipBodyCardFromDataset(cardEl){
    if (!cardEl || !equipBody) return null;
    const ownerUid = safeText(cardEl.dataset.ownerUid || "");
    const sourceKey = safeText(cardEl.dataset.sourceKey || "");
    const roleId = safeText(cardEl.dataset.roleId || "");
    if (ownerUid && sourceKey){
      return equipBody.querySelector(`.card72.wb-front[data-owner-uid="${ownerUid}"][data-source-key="${sourceKey}"], .id72[data-owner-uid="${ownerUid}"][data-source-key="${sourceKey}"]`);
    }
    if (ownerUid && roleId){
      return equipBody.querySelector(`.id72[data-owner-uid="${ownerUid}"][data-role-id="${roleId}"]`);
    }
    return null;
  }
  function openEquipSelectionTempZoom(cardEl, action){
    if (!cardEl || !action) return;
    greenShareDock?.classList.add("hidden");
    openZoomFromCard(cardEl, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
    setZoomOverPanel(true);
    setZoomPassthrough(false);
    zoomDismissHandler = async () => {
      restorePendingEquipSelection(action);
    };
  }
  function openEquipExpand(){
    if (!equipDock?.classList.contains('visible')) return;
    renderEquipExpandBody();
    equipExpandBackdrop?.classList.remove('hidden');
  }
  function closeEquipExpand(){
    equipExpandBackdrop?.classList.add('hidden');
    if (isEquipSelectionLockActive() && zoomBackdrop?.classList.contains('hidden')){
      restorePendingEquipSelection();
    }
  }
  function closeEquipExpandIfOpen(){
    if (!equipExpandBackdrop || equipExpandBackdrop.classList.contains('hidden')) return;
    closeEquipExpand();
  }
  function toggleRoomGuideOverlay(){
    roomGuideVisible = !roomGuideVisible;
    roomGuideBtn.classList.toggle('active', roomGuideVisible);
    renderRoomGuideLayer();
  }
  helpBtn.addEventListener('click', () => {
    if (!joinBox.classList.contains('hidden')) return;
    if (helpBackdrop.classList.contains('hidden')) openHelp();
    else closeHelp();
  });
  roomGuideBtn.addEventListener('click', () => {
    if (isIdentityPromptInteractionLockActive()) return;
    if (joinBox.classList.contains('hidden')) toggleRoomGuideOverlay();
  });
  helpBackdrop.addEventListener('click', (e) => {
    if (!helpBackdrop.classList.contains('hidden') && !e.target.closest('.help-pop')) closeHelp();
  });
  equipExpandBackdrop?.addEventListener('click', (e) => {
    if (!equipExpandBackdrop.classList.contains('hidden') && !e.target.closest('.equip-expand-pop')) closeEquipExpand();
  });
  equipExpandBody?.addEventListener('click', (e) => {
    const card = e.target.closest('.card72.wb-front, .id72');
    if (!card) return;
    e.stopPropagation();

    const action = captureSelectionRestoreAction();
    const ownerUid = safeText(card.dataset.ownerUid || "");
    const sourceKey = safeText(card.dataset.sourceKey || "");

    if (action?.kind === 'equip' && action?.type === 'oliver_target' && (!card.classList.contains('equip-steal-pulse') || !ownerUid || ownerUid === state.userId || !sourceKey)){
      openEquipSelectionTempZoom(card, action);
      return;
    }
    if (action?.kind === 'equip' && action?.type === 'banana_give' && (ownerUid !== state.userId || !sourceKey)){
      openEquipSelectionTempZoom(card, action);
      return;
    }

    const linked = findEquipBodyCardFromDataset(card);
    if (linked){
      linked.click();
      return;
    }
    if (action){
      greenShareDock?.classList.add("hidden");
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
      setZoomOverPanel(true);
      setZoomPassthrough(false);
      zoomDismissHandler = async () => {
        await restoreSelectionAction(action);
      };
      return;
    }
    openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
    setZoomOverPanel(true);
    setZoomPassthrough(false);
  });

  const SEAT_COLORS = [
    "#ef4444", "#f97316", "#f59e0b", "#eab308",
    "#22c55e", "#10b981", "#06b6d4", "#3b82f6",
    "#6366f1", "#8b5cf6", "#ec4899", "#f43f5e"
  ];

  const seatKey = (room)=>`bbSeat_${room}_${state.userId}`;
  const attackResolutionKey = (room)=>`bbAttackResolution_${room}_${state.userId}`;

  function isGameStarted(){
    return !!(state.room && (state.room.gameStarted || state.room.startedAt));
  }


  async function resetAllAbilityUsageForUids(uids){
    if (!state.roomCode) return;
    const targets = [...new Set((uids || []).map(uid => safeText(uid)).filter(Boolean))];
    if (!targets.length) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !cur.abilityUsage) return cur;
      for (const usageMap of Object.values(cur.abilityUsage || {})){
        if (!usageMap || typeof usageMap !== 'object') continue;
        for (const uid of targets){
          if (Object.prototype.hasOwnProperty.call(usageMap, uid)){
            delete usageMap[uid];
          }
        }
      }
      return cur;
    });
  }

  function moveAbilityUsageUid(cur, fromUid, toUid){
    if (!cur || typeof cur !== 'object') return;
    for (const value of Object.values(cur)){
      if (!value || typeof value !== 'object') continue;
      if (Object.prototype.hasOwnProperty.call(value, fromUid)){
        value[toUid] = value[fromUid];
        delete value[fromUid];
      }
      moveAbilityUsageUid(value, fromUid, toUid);
    }
  }

  async function syncMySeatNameIfNeeded(){
    if (!state.roomCode || !state.userId || !state.userName) return;
    const seat = Number(state.seatedTable || 0);
    if (!seat) return;

    const seatRef = ref(db, `rooms/${state.roomCode}/tables/${seat}`);
    const snap = await get(seatRef);
    const row = snap.val() || null;
    if (!row || row.playerId !== state.userId) return;

    const nextName = safeText(state.userName || 'ÂêçÁÑ°„Åó') || 'ÂêçÁÑ°„Åó';
    const nextColor = SEAT_COLORS[seat - 1] || null;
    if (safeText(row.playerName || '') === nextName && (row.color || null) === nextColor) return;

    await update(seatRef, {
      playerName: nextName,
      color: nextColor,
      renamedAt: Date.now()
    });

    const markerRef = ref(db, `rooms/${state.roomCode}/markers/${state.userId}`);
    const markerSnap = await get(markerRef);
    const marker = markerSnap.val() || null;
    if (marker){
      await update(markerRef, {
        initial: firstChar(nextName || "") || safeText(marker.initial || ""),
        color: nextColor || safeText(marker.color || "#ddd"),
        updatedAt: Date.now()
      });
    }
  }
  function isSeated(){ return state.seatedTable != null; }

  function showSeatPop(){ seatPopBackdrop.classList.remove('hidden'); }
  function hideSeatPop(){
    if (!isGameStarted()) return;
    seatPopBackdrop.classList.add('hidden');
  }
  function updateSeatBoardVisibility(){
    const started = isGameStarted();
    const seated = isSeated();
    let shouldShow = false;

    if (!state.roomCode) shouldShow = false;
    else if (!started) shouldShow = !state.spectating;
    else shouldShow = (!seated) && (!state.spectating);

    if (shouldShow) showSeatPop(); else hideSeatPop();
  }

  btnSpectate.addEventListener('click', () => {
    state.spectating = true;
    if (isGameStarted()) hideSeatPop();
  });

  function generateRoomCode(length = 6){
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
    return code;
  }

  function refreshRoomLabels(){
    if (!state.roomCode || !state.userName) return;
    const label = state.isHost ? 'Ôºà„Éõ„Çπ„ÉàÔºâ' : '';
    const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
    roomInfo.textContent = infoText;
    roomInfoLobby.textContent = infoText;
  }

  function didAttackRollSucceed(d6, d4, options = {}){
    if (options.masamuneMode || options.vendettaMode) return true;
    return (Number(d6) || 0) !== (Number(d4) || 0);
  }

  // TODO: „Éá„Éê„ÉÉ„Ç∞Áî®Ë°®Á§∫„ÄÇÂæå„ÅßÊ∂à„Åô„Å®„Åç„ÅØ #attackRollResult / .attack-roll-result-debug „ÇíÈùûË°®Á§∫„Å´„Åô„Çã„ÄÇ
  function setAttackRollResultLabel(isSuccess){
    if (!attackRollResult) return;
    attackRollResult.textContent = isSuccess ? 'ÊîªÊíÉÊàêÂäü' : 'ÊîªÊíÉÂ§±Êïó';
  }

  function renderLastAttackToMeHeader(){
    if (!lastAttackToMeHeader) return;
    const me = latestPlayers.find(p => p.id === state.userId);
    const seat = Number(me?.lastattacktome || 0);
    if (!seat){
      lastAttackToMeHeader.textContent = '';
      return;
    }
    const names = latestPlayers
      .filter(p => p.seatIndex === seat)
      .map(p => safeText(p.name || ''))
      .filter(Boolean);
    const nameLabel = names.length ? names.join(' / ') : 'ÔºàÁ©∫Â∏≠Ôºâ';
    lastAttackToMeHeader.textContent = `lastattacktome: ${nameLabel}`;
  }

  async function recordLastAttackToMe(targetUids){
    if (!state.roomCode) return;
    const attackerSeat = Number(latestPlayers.find(p => p.id === state.userId)?.seatIndex || state.seatedTable || 0);
    if (!attackerSeat) return;
    const updates = {};
    for (const uid of [...new Set(targetUids || [])]){
      const targetSeat = Number(latestPlayers.find(p => p.id === safeText(uid))?.seatIndex || 0);
      if (!targetSeat) continue;
      updates[`tables/${targetSeat}/lastattacktome`] = attackerSeat;
    }
    if (!Object.keys(updates).length) return;
    await update(ref(db, `rooms/${state.roomCode}`), updates);
  }

  function updateHostUI(){
    refreshRoomLabels();
    if (state.isHost){
      hostSettingsBtn.classList.add('visible');
      roomGuideBtn.classList.remove('visible');
      roomGuideBtn.classList.remove('host-position');
    } else {
      hostSettingsBtn.classList.remove('visible');
      startPop.classList.add('hidden');
      roomGuideBtn.classList.add('visible');
      roomGuideBtn.classList.remove('host-position');
    }
    helpBtn.classList.add('visible');
  }

  function subscribeRoom(){
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    onValue(roomRef, snap => {
      state.room = snap.val() || {};
      restorePendingAttackResolutionFromRoom();
      restoreAttackLootPendingFromRoom();
      if (isGameStarted() && !currentTurnPlayerId() && state.isHost){
        ensureTurnInitialized();
      }
      renderSeatTiles();
      refreshStartBadge();
      renderHands();
      updateSeatBoardVisibility();
      renderEquipmentDock();
      renderHpBoard();
      renderPositionLine();
      renderTurnEndButton();
      renderMarkers();
      syncPendingMoveChoiceOwnership();
      restorePendingMoveChoiceFromSeat();
      updateCardInteractivity();
      maybeAutoRollMoveDiceOnTurnStart();
    });
  }

  function subscribeHostState(){
    const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
    onValue(hostRef, snap => {
      const hostId = snap.val();
      state.isHost = (hostId === state.userId);
      updateHostUI();
    });
  }

  function subscribeHands(){
    const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
    onValue(handsRef, snap => {
      state.hands = snap.val() || {};
      renderHands();
      tryRestorePendingGreenSession();
      tryRestorePendingCardTargetSession().catch(() => {});
    });
  }


  function subscribeGreenInbox(){
    const inboxRef = ref(db, `rooms/${state.roomCode}/greenInbox/${state.userId}`);
    onValue(inboxRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!greenInboxInitialized){
        greenInboxInitialized = true;
        greenInboxSeenAt = at || 0;
        return;
      }

      if (!msg || !msg.card || !at) return;
      if (at <= greenInboxSeenAt) return;
      greenInboxSeenAt = at;
      openZoomFromDeckCard(msg.card, "green", { closeOnBackdrop:false, showCloseButton:false });
      openGreenAnswerDock(msg);
    });
  }

  function applyGreenResponseToWaitingSession(msg){
    const at = Number(msg?.at || 0);
    if (!msg || !at) return false;
    const requestId = safeText(msg.requestId || "");
    if (!pendingGreenRequestId || requestId !== pendingGreenRequestId) return false;
    greenReplySeenAt = Math.max(greenReplySeenAt, at);
    setGreenDockMeta({ title:"ÂõûÁ≠î„ÅåÂ±ä„Åç„Åæ„Åó„Åü", subtitle:safeText(msg.answerLabel || "") });
    const reveal = greenRevealByRequestId[requestId];
    if (reveal?.roleId){
      showGreenRevealPanel(reveal.roleId, reveal.responderId);
    }
    greenShareActions?.classList.remove("hidden");
    const responder = playerById(safeText(msg.to || ""));
    setGreenSessionState({
      phase:"confirm",
      card: greenShareCard || msg.card || null,
      requestId,
      toUid: safeText(msg.to || ""),
      toName: safeText(responder?.name || ""),
      toInitial: firstChar(responder?.name || ""),
      toColor: safeText(responder?.color || ""),
      answerLabel: safeText(msg.answerLabel || "")
    }).catch(() => {});
    return true;
  }

  function subscribeGreenResponses(){
    const resRef = ref(db, `rooms/${state.roomCode}/greenResponses/${state.userId}`);
    onValue(resRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!greenReplyInitialized){
        greenReplyInitialized = true;
        const handledOnInit = applyGreenResponseToWaitingSession(msg);
        greenReplySeenAt = handledOnInit ? Math.max(greenReplySeenAt, at || 0) : (at || 0);
        return;
      }

      if (!msg || !at) return;
      if (at <= greenReplySeenAt) return;
      applyGreenResponseToWaitingSession(msg);
    });
  }

  function tryRestorePendingGreenSession(){
    const entry = pendingGreenSessionEntry;
    if (!entry) return;
    const phase = safeText(entry?.phase || "");
    if (!phase){
      pendingGreenSessionEntry = null;
      return;
    }
    const needsPlayers = phase !== "answering";
    if (phase === "answering" && !myRoleInfo()) return;
    if (needsPlayers){
      if (latestPlayers.length === 0) return;
      const mySeatReady = latestPlayers.some(p => p.id === state.userId);
      if (!mySeatReady) return;
    }
    restoreGreenSessionUI(entry);
    pendingGreenSessionEntry = null;
  }

  function subscribeGreenSessionState(){
    const gsRef = ref(db, `rooms/${state.roomCode}/greenSessions/${state.userId}`);
    onValue(gsRef, snap => {
      const data = snap.val() || null;
      const at = Number(data?.at || 0);

      if (!greenSessionInitialized){
        greenSessionInitialized = true;
        greenSessionSeenAt = at || 0;
        if (data){
          pendingGreenSessionEntry = data;
          tryRestorePendingGreenSession();
        }
        return;
      }

      if (!data){
        pendingGreenSessionEntry = null;
        if (pendingGreenAnswerMsg || pendingGreenRequestId || (greenShareCard && !greenShareDock?.classList.contains("hidden"))){
          hideGreenShareDock();
          closeZoom();
        }
        return;
      }
      if (!at) return;
      if (at <= greenSessionSeenAt) return;
      greenSessionSeenAt = at;
      pendingGreenSessionEntry = data;
      tryRestorePendingGreenSession();
    });
  }


  async function tryRestorePendingCardTargetSession(){
    const entry = pendingCardTargetSessionEntry;
    if (!entry) return;
    const phase = safeText(entry?.phase || "");
    if (!phase){
      pendingCardTargetSessionEntry = null;
      await setCardTargetSessionState(null);
      return;
    }
    if (latestPlayers.length === 0) return;
    const mySeatReady = latestPlayers.some(p => p.id === state.userId);
    if (!mySeatReady) return;

    pendingCardTargetSessionEntry = null;
    cardTargetSessionRestoring = true;
    try {
      if (phase === "resolving"){
        await resolveCardTargetSessionEntry(entry);
      } else {
        await openPersistentCardTargetSelection(entry.card || null, { restore:true });
      }
    } finally {
      cardTargetSessionRestoring = false;
    }
  }

  function subscribeRoleAbilitySelectionState(){
    const selectionRef = ref(db, `rooms/${state.roomCode}/roleAbilitySelection`);
    onValue(selectionRef, snap => {
      const data = snap.val() || null;
      const at = Number(data?.at || 0);
      if (!roleAbilitySelectionInitialized){
        roleAbilitySelectionInitialized = true;
        roleAbilitySelectionSeenAt = at || 0;
        if (data) openRoleAbilitySelectionUI(data);
        return;
      }
      if (!data){
        activeRoleAbilitySelection = null;
        cardPlayerSelectActive = false;
        greenShareDock?.classList.add("hidden");
        renderTurnEndButton();
        updateCardInteractivity();
        if (!zoomBackdrop?.classList.contains("hidden")) closeZoom();
        return;
      }
      if (!at || at <= roleAbilitySelectionSeenAt) return;
      roleAbilitySelectionSeenAt = at;
      openRoleAbilitySelectionUI(data);
    });
  }

  function subscribeCardTargetSessionState(){
    const sessionRef = ref(db, `rooms/${state.roomCode}/cardTargetSessions/${state.userId}`);
    onValue(sessionRef, snap => {
      const data = snap.val() || null;
      const at = Number(data?.at || 0);

      if (!cardTargetSessionInitialized){
        cardTargetSessionInitialized = true;
        cardTargetSessionSeenAt = at || 0;
        if (data){
          pendingCardTargetSessionEntry = data;
          tryRestorePendingCardTargetSession().catch(() => {});
        }
        return;
      }

      if (!data){
        pendingCardTargetSessionEntry = null;
        pendingCardTargetSelection = null;
        cardPlayerSelectActive = false;
        updateCardInteractivity();
        greenShareDock?.classList.add("hidden");
        closeZoom();
        renderTurnEndButton();
        return;
      }
      if (!at) return;
      if (at <= cardTargetSessionSeenAt) return;
      cardTargetSessionSeenAt = at;
      pendingCardTargetSessionEntry = data;
      tryRestorePendingCardTargetSession().catch(() => {});
    });
  }

  function subscribeSeatEquipSelectionState(){
    const seat = Number(state.seatedTable || 0);
    if (seatEquipSelectionUnsubscribe && subscribedSeatEquipSelectionIndex !== seat){
      seatEquipSelectionUnsubscribe();
      seatEquipSelectionUnsubscribe = null;
      subscribedSeatEquipSelectionIndex = null;
    }
    if (!state.roomCode || !seat){
      if (isEquipSelectionLockActive()){
        pendingEquipAction = null;
        greenShareDock?.classList.add("hidden");
        closeZoom();
        renderEquipmentDock();
        renderTurnEndButton();
      }
      return;
    }
    if (seatEquipSelectionUnsubscribe && subscribedSeatEquipSelectionIndex === seat) return;

    subscribedSeatEquipSelectionIndex = seat;
    const selectionRef = ref(db, `rooms/${state.roomCode}/seatEquipSelectionState/${seat}`);
    seatEquipSelectionUnsubscribe = onValue(selectionRef, (snap) => {
      const data = snap.val() || null;
      if (!data){
        if (isEquipSelectionLockActive()){
          pendingEquipAction = null;
          greenShareDock?.classList.add("hidden");
          closeZoom();
          renderEquipmentDock();
          renderTurnEndButton();
        }
        return;
      }
      restoreSeatEquipSelection(data);
    });
  }

  function subscribeSeatPromptState(){
    const seat = Number(state.seatedTable || 0);
    if (seatPromptUnsubscribe && subscribedSeatPromptIndex !== seat){
      seatPromptUnsubscribe();
      seatPromptUnsubscribe = null;
      subscribedSeatPromptIndex = null;
    }
    if (!state.roomCode || !seat){
      const wasOpen = !identityPromptPop?.classList.contains("hidden");
      hideIdentityPrompt();
      if (wasOpen) closeZoom();
      return;
    }
    if (seatPromptUnsubscribe && subscribedSeatPromptIndex === seat) return;

    subscribedSeatPromptIndex = seat;
    const seatPromptRef = ref(db, `rooms/${state.roomCode}/seatPromptState/${seat}`);
    seatPromptUnsubscribe = onValue(seatPromptRef, (snap) => {
      const data = snap.val() || null;
      if (!data || safeText(data.type || "") !== "identity_prompt"){
        const wasOpen = !identityPromptPop?.classList.contains("hidden");
        hideIdentityPrompt();
        if (wasOpen) closeZoom();
        return;
      }
      const cardName = safeText(data.cardName || "");
      const resolver = buildIdentityPromptResolver(cardName);
      const payload = identityPromptPayloadFromCard(cardName);
      if (!resolver || !payload) return;
      restoringSeatIdentityPrompt = true;
      try {
        showIdentityPromptPop({
          message: safeText(data.message || payload.message),
          canReveal: !!data.canReveal,
          cardObj: cardByName(cardName) || { name: cardName },
          cardTheme: safeText(data.cardTheme || payload.cardTheme || "white") || "white",
          openZoom: true,
          onYes: resolver
        });
      } finally {
        restoringSeatIdentityPrompt = false;
      }
    });
  }
  function subscribeGreenReveals(){
    const revealRef = ref(db, `rooms/${state.roomCode}/greenReveals`);
    onValue(revealRef, snap => {
      greenRevealByRequestId = snap.val() || {};
      const pendingReveal = greenRevealByRequestId[safeText(pendingGreenRequestId || "")];
      if (pendingReveal?.roleId){
        showGreenRevealPanel(pendingReveal.roleId, pendingReveal.responderId);
        return;
      }
      const answerReveal = greenRevealByRequestId[safeText(pendingGreenAnswerMsg?.requestId || "")];
      if (answerReveal?.roleId){
        showGreenRevealPanel(answerReveal.roleId, answerReveal.responderId);
        return;
      }
      hideGreenRevealPanel();
    });
  }


  function subscribeGreenCloseSignals(){
    const closeRef = ref(db, `rooms/${state.roomCode}/greenCloseSignals/${state.userId}`);
    onValue(closeRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!pendingGreenCloseInitialized){
        pendingGreenCloseInitialized = true;
        pendingGreenCloseSeenAt = at || 0;
        return;
      }

      if (!msg || !at) return;
      if (at <= pendingGreenCloseSeenAt) return;
      pendingGreenCloseSeenAt = at;

      const requestId = safeText(msg.requestId || "");
      if (!requestId) return;
      const pendingAnswerRequest = safeText(pendingGreenAnswerMsg?.requestId || "");
      const pendingShareRequest = safeText(pendingGreenRequestId || "");
      if (requestId !== pendingAnswerRequest && requestId !== pendingShareRequest) return;

      pendingGreenAnswerMsg = null;
      remove(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${requestId}`)).catch(() => {});
      hideGreenShareDock();
      closeZoom();
      setGreenSessionState(null).catch(() => {});
    });
  }

  function subscribePlayers(){
    const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
    onValue(tablesRef, snap => {
      const wasSeated = state.seatedTable != null;
      const data = snap.val() || {};
      const players = Object.entries(data)
        .map(([seatIndex, t]) => (t && t.playerId ? {
          id: t.playerId,
          name: t.playerName || 'ÂêçÁÑ°„Åó',
          seatIndex: Number(seatIndex),
          color: t.color || null,
          lastattacktome: Number(t.lastattacktome || 0)
        } : null))
        .filter(Boolean)
        .sort((a,b) => a.seatIndex - b.seatIndex);

      latestPlayers = players;
      tryRestorePendingGreenSession();
      tryRestorePendingCardTargetSession().catch(() => {});
      if (activeRoleAbilitySelection){
        openRoleAbilitySelectionUI(activeRoleAbilitySelection);
      }

      const mySeat = players.find(p => p.id === state.userId);
      if (mySeat) {
        state.seatedTable = mySeat.seatIndex;
        sessionStorage.setItem(seatKey(state.roomCode), String(mySeat.seatIndex));
      } else {
        state.seatedTable = null;
        if (wasSeated){
          state.spectating = false;
          hideGreenShareDock();
          hideIdentityPrompt();
          closeZoom();
        }
        sessionStorage.removeItem(seatKey(state.roomCode));
      }

      subscribeSeatPromptState();
      subscribeSeatEquipSelectionState();
      renderSeatTiles();
      refreshStartBadge();
      updateSeatBoardVisibility();
      renderEquipmentDock();
      renderHpBoard();
      renderPositionLine();
      renderLastAttackToMeHeader();
    });
  }

  function effectiveSeatCount(){
    const mp = Number(state.room.maxPlayers || 0);
    return (mp >= 2) ? mp : SEAT_COLORS.length;
  }
  function occupiedCount(){ return latestPlayers.length; }

  let pendingSeatIndexToSteal = null;
  let pendingSeatPlayerIdToSteal = null;
  let pendingMode = "prestart";

  function renderSeatTiles(){
    if (!state.roomCode) return;

    const started = isGameStarted();
    const N = effectiveSeatCount();
    seatCountBadge.textContent = `${occupiedCount()} / ${N}`;

    tileGrid.innerHTML = '';

    for(let i=1;i<=N;i++){
      const color = SEAT_COLORS[i-1] || "#ddd";
      const seatIndex = i;

      const tile = document.createElement('button');
      tile.type = 'button';
      tile.className = 'seat-tile empty';
      tile.style.background = color;
      tile.setAttribute('aria-label', `Â∏≠ ${seatIndex}`);

      const taken = latestPlayers.find(p => p.seatIndex === seatIndex);
      if (taken){
        tile.classList.remove('empty');
        tile.classList.add('taken');
        const initial = document.createElement('div');
        initial.className = 'seat-initial';
        initial.textContent = firstChar(taken.name);
        tile.appendChild(initial);
      }

      const num = document.createElement('div');
      num.className = 'seat-num';
      num.textContent = seatIndex;
      tile.appendChild(num);

      if (state.seatedTable === seatIndex) tile.classList.add('me');

      tile.addEventListener('click', async () => {
        if (!state.roomCode) return;

        const startedNow = isGameStarted();

        if (startedNow){
          if (isSeated()) return;
          if (!taken){
            alert("„Ç≤„Éº„É†ÈñãÂßãÂæå„ÅØÁ©∫Â∏≠„Å´Â∫ß„Çå„Åæ„Åõ„Çì„ÄÇÂ∏≠„ÇíÂ•™Âèñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
            return;
          }
          pendingMode = "started";
          pendingSeatIndexToSteal = seatIndex;
          pendingSeatPlayerIdToSteal = taken.id;

          kickMessage.textContent = `„Äå${taken.name}„Äç„ÇíËøΩ„ÅÑÂá∫„Åó„Åæ„Åô„ÅãÔºü`;
          kickDialog.classList.remove('hidden');
          return;
        }

        if (state.seatedTable !== null){
          if (seatIndex === state.seatedTable) return;
          if (taken) return;
          await moveSeatToEmpty(seatIndex);
          return;
        }

        if (!taken){
          await sitToSeat(seatIndex);
          state.spectating = true;
          return;
        }

        pendingMode = "prestart";
        pendingSeatIndexToSteal = seatIndex;
        pendingSeatPlayerIdToSteal = taken.id;

        kickMessage.textContent = `„Äå${taken.name}„Äç„ÇíËøΩ„ÅÑÂá∫„Åó„Å¶„ÄÅ„Åì„ÅÆËâ≤„ÅÆÂ∏≠„ÇíÂ•™Âèñ„Åó„Åæ„Åô„ÅãÔºü`;
        kickDialog.classList.remove('hidden');
      });

      tileGrid.appendChild(tile);
    }

    startWarn.textContent = started
      ? "‚Äª„Ç≤„Éº„É†ÈñãÂßãÊ∏à„ÅøÔºàÂÜçÂÖ•ÂÆ§„Å´„ÅØÂ∫ßÂ∏≠„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ËøΩ„ÅÑÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÔºâ"
      : "‚Äª„Éõ„Çπ„Éà„Åå„Äå„Çπ„Çø„Éº„Éà„Äç„ÇíÊäº„Åô„Å®ÈÖçÂ∏É„Åï„Çå„Åæ„Åô";
  }

  async function sitToSeat(seatIndex){
    const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
    await set(tRef, {
      playerId: state.userId,
      playerName: state.userName || 'ÂêçÁÑ°„Åó',
      color: SEAT_COLORS[seatIndex-1] || null,
      seatedAt: Date.now()
    });
    state.seatedTable = seatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(seatIndex));
  }

  async function moveSeatToEmpty(newSeatIndex){
    if (!state.roomCode) return;
    const oldSeatIndex = state.seatedTable;
    if (oldSeatIndex == null) return;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap = await get(roomRef);
    const roomData = snap.val() || {};
    if (roomData.gameStarted || roomData.startedAt) return;

    const tables = roomData.tables || {};
    const oldSeat = tables[String(oldSeatIndex)];
    const newSeat = tables[String(newSeatIndex)];

    if (!oldSeat || oldSeat.playerId !== state.userId) return;
    if (newSeat && newSeat.playerId) return;

    const updates = {};
    updates[`tables/${oldSeatIndex}`] = null;
    updates[`tables/${newSeatIndex}`] = {
      playerId: state.userId,
      playerName: state.userName || 'ÂêçÁÑ°„Åó',
      color: SEAT_COLORS[newSeatIndex-1] || null,
      seatedAt: Date.now(),
      movedFrom: oldSeatIndex,
      movedAt: Date.now()
    };

    await update(roomRef, updates);

    state.seatedTable = newSeatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(newSeatIndex));
  }

  async function stealSeatPrestart(seatIndex, previousPlayerId){
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    if (roomData.gameStarted || roomData.startedAt) return;

    await sitToSeat(seatIndex);

    const updates = {};
    const markers = roomData.markers || {};
    const prevMarker = previousPlayerId ? markers[previousPlayerId] : null;
    if (prevMarker){
      updates[`markers/${state.userId}`] = {
        ...prevMarker,
        color: SEAT_COLORS[seatIndex-1] || null,
        initial: firstChar(state.userName || "") || safeText(prevMarker.initial || ""),
        updatedAt: Date.now(),
        inheritedFrom: previousPlayerId
      };
      updates[`markers/${previousPlayerId}`] = null;
    }

    if (Object.keys(updates).length){
      await update(roomRef, updates);
      await resetAllAbilityUsageForUids([state.userId, previousPlayerId]);
    }

    if (roomData.hostId && previousPlayerId && roomData.hostId === previousPlayerId) {
      await update(roomRef, { hostId: state.userId });
    }

    state.spectating = true;
  }

  async function stealSeatStarted(seatIndex, previousPlayerId){
    if (!state.roomCode) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap = await get(roomRef);
    const roomData = snap.val() || {};

    if (!(roomData.gameStarted || roomData.startedAt)) return;

    const tables = roomData.tables || {};
    const alreadySeated = Object.values(tables).some(t => t && t.playerId === state.userId);
    if (alreadySeated) return;

    const cur = tables[String(seatIndex)];
    if (!cur || cur.playerId !== previousPlayerId) return;

    const updates = {};
    updates[`tables/${seatIndex}`] = {
      ...(cur || {}),
      playerId: state.userId,
      playerName: state.userName || 'ÂêçÁÑ°„Åó',
      color: SEAT_COLORS[seatIndex-1] || null,
      seatedAt: Date.now(),
      stolenFrom: previousPlayerId,
      stolenAt: Date.now()
    };

    const hands = roomData.hands || {};
    const prevHand = hands[previousPlayerId] || null;
    if (prevHand){
      updates[`hands/${state.userId}`] = { ...prevHand, inheritedAt: Date.now(), inheritedFrom: previousPlayerId };
      updates[`hands/${previousPlayerId}`] = null;
    }

    const markers = roomData.markers || {};
    const prevMarker = markers[previousPlayerId] || null;
    if (prevMarker){
      updates[`markers/${state.userId}`] = {
        ...prevMarker,
        color: SEAT_COLORS[seatIndex-1] || null,
        initial: firstChar(state.userName || "") || safeText(prevMarker.initial || ""),
        updatedAt: Date.now(),
        inheritedFrom: previousPlayerId
      };
      updates[`markers/${previousPlayerId}`] = null;
    }

    const equipment = roomData.equipment || {};
    const prevEquipment = equipment[previousPlayerId] || null;
    if (prevEquipment){
      const nextEquipment = JSON.parse(JSON.stringify(prevEquipment));
      if (nextEquipment.identity && nextEquipment.identity.kind === "identity" && nextEquipment.identity.roleId){
        nextEquipment.identity.inheritedAt = Date.now();
        nextEquipment.identity.inheritedFrom = previousPlayerId;
      }
      updates[`equipment/${state.userId}`] = nextEquipment;
      updates[`equipment/${previousPlayerId}`] = null;
    }

    const turn = roomData.turn || null;
    const isTurnOwnerStolen = !!turn && safeText(turn.currentPlayerId || "") === safeText(previousPlayerId || "");
    const nextTurnUpdatedAt = isTurnOwnerStolen ? Date.now() : Number(turn?.updatedAt || 0);
    if (isTurnOwnerStolen) {
      updates[`turn/currentPlayerId`] = state.userId;
      updates[`turn/updatedAt`] = nextTurnUpdatedAt;
    }

    const positionOrder = Array.isArray(roomData.positionOrder) ? roomData.positionOrder : null;
    if (positionOrder && previousPlayerId){
      let replaced = false;
      const nextOrder = positionOrder.map((uid) => {
        if (safeText(uid || "") === safeText(previousPlayerId || "")){
          replaced = true;
          return state.userId;
        }
        return uid;
      });
      if (replaced){
        updates[`positionOrder`] = nextOrder;
      }
    }

    if (safeText(roomData.startPlayerId || "") === safeText(previousPlayerId || "")){
      updates[`startPlayerId`] = state.userId;
    }
    if (roomData.hostId && previousPlayerId && roomData.hostId === previousPlayerId){
      updates[`hostId`] = state.userId;
    }

    const damage = roomData.damage || {};
    if (Object.prototype.hasOwnProperty.call(damage, previousPlayerId)){
      updates[`damage/${state.userId}`] = clampDamage(Number(damage[previousPlayerId] || 0));
      updates[`damage/${previousPlayerId}`] = null;
    }

    const guardShields = roomData.guardianAngelShield || {};
    if (Object.prototype.hasOwnProperty.call(guardShields, previousPlayerId)){
      updates[`guardianAngelShield/${state.userId}`] = !!guardShields[previousPlayerId];
      updates[`guardianAngelShield/${previousPlayerId}`] = null;
    }

    const migrateGreenStateBySeatSteal = (room, fromUid, toUid, outUpdates) => {
      const prevUid = safeText(fromUid || "");
      const nextUid = safeText(toUid || "");
      if (!prevUid || !nextUid || prevUid === nextUid) return;

      const migratedAt = Date.now();
      const copy = (v) => JSON.parse(JSON.stringify(v));
      const deepReplaceUid = (value) => {
        if (value == null) return value;
        if (typeof value === "string"){
          return safeText(value) === prevUid ? nextUid : value;
        }
        if (Array.isArray(value)) return value.map(deepReplaceUid);
        if (typeof value === "object"){
          const next = {};
          for (const [k, v] of Object.entries(value)){
            next[k] = deepReplaceUid(v);
          }
          return next;
        }
        return value;
      };

      const sameJson = (a, b) => JSON.stringify(a) === JSON.stringify(b);
      const touchAt = (entry) => {
        if (!entry || typeof entry !== "object") return entry;
        return { ...entry, at: migratedAt };
      };
      const answeredRequestIds = new Set(
        Object.values(room.greenResponses || {})
          .map((row) => safeText(row?.requestId || ""))
          .filter(Boolean)
      );

      const migrateUidNode = (nodeName, shouldTouchAt = false) => {
        const node = room[nodeName] || {};
        if (!node || typeof node !== "object") return;

        if (Object.prototype.hasOwnProperty.call(node, prevUid)){
          const original = node[prevUid];
          const requestId = safeText(original?.requestId || "");
          const skipAnsweredInbox = nodeName === "greenInbox" && requestId && answeredRequestIds.has(requestId);
          if (skipAnsweredInbox){
            outUpdates[`${nodeName}/${prevUid}`] = null;
          } else {
            const migrated = deepReplaceUid(copy(original));
            outUpdates[`${nodeName}/${nextUid}`] = shouldTouchAt ? touchAt(migrated) : migrated;
            outUpdates[`${nodeName}/${prevUid}`] = null;
          }
        }

        for (const [key, value] of Object.entries(node)){
          if (value == null || safeText(key || "") === prevUid) continue;
          const rewritten = deepReplaceUid(copy(value));
          if (sameJson(rewritten, value)) continue;
          outUpdates[`${nodeName}/${key}`] = shouldTouchAt ? touchAt(rewritten) : rewritten;
        }
      };

      migrateUidNode("greenInbox", true);
      migrateUidNode("greenResponses", true);
      migrateUidNode("greenCloseSignals", true);
      migrateUidNode("greenSessions", true);
      migrateUidNode("cardTargetSessions", true);

      const migrateRequestNode = (nodeName, shouldTouchAt = false) => {
        const node = room[nodeName] || {};
        if (!node || typeof node !== "object") return;
        for (const [rowId, row] of Object.entries(node)){
          if (!row || typeof row !== "object") continue;
          const rewritten = deepReplaceUid(copy(row));
          if (sameJson(rewritten, row)) continue;
          outUpdates[`${nodeName}/${rowId}`] = shouldTouchAt ? touchAt(rewritten) : rewritten;
        }
      };

      migrateRequestNode("greenRequests", true);
      migrateRequestNode("greenReplyBubbles", true);
      migrateRequestNode("greenReveals", true);
    };

    migrateGreenStateBySeatSteal(roomData, previousPlayerId, state.userId, updates);

    const roleAbilitySelection = roomData.roleAbilitySelection || null;
    if (roleAbilitySelection && safeText(roleAbilitySelection.actorUid || "") === safeText(previousPlayerId || "")){
      updates[`roleAbilitySelection`] = {
        ...roleAbilitySelection,
        actorUid: state.userId,
        at: Date.now()
      };
    }

    const attackResolutionPending = roomData.attackResolutionPending || {};
    if (Object.prototype.hasOwnProperty.call(attackResolutionPending, previousPlayerId)){
      const pending = attackResolutionPending[previousPlayerId] || {};
      const prevTurnKey = safeText(pending.turnKey || "");
      const expectedOldTurnKey = turn ? `${safeText(previousPlayerId || "")}:${Number(turn.updatedAt || 0)}` : "";
      const nextTurnKey = (isTurnOwnerStolen && prevTurnKey === expectedOldTurnKey)
        ? `${safeText(state.userId || "")}:${nextTurnUpdatedAt}`
        : prevTurnKey;
      updates[`attackResolutionPending/${state.userId}`] = {
        ...pending,
        uid: state.userId,
        turnKey: nextTurnKey
      };
      updates[`attackResolutionPending/${previousPlayerId}`] = null;
    }

    const attackLootPending = roomData.attackLootPending || {};
    if (Object.prototype.hasOwnProperty.call(attackLootPending, previousPlayerId)){
      const pending = attackLootPending[previousPlayerId] || {};
      updates[`attackLootPending/${state.userId}`] = {
        ...pending,
        uid: state.userId,
        at: Date.now()
      };
      updates[`attackLootPending/${previousPlayerId}`] = null;
    }

    if (roomData.abilityUsage){
      const abilityUsageCopy = JSON.parse(JSON.stringify(roomData.abilityUsage));
      moveAbilityUsageUid(abilityUsageCopy, previousPlayerId, state.userId);
      updates[`abilityUsage`] = abilityUsageCopy;
    }

    await update(roomRef, updates);

    state.seatedTable = seatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(seatIndex));

    state.spectating = true;
    hideSeatPop();
  }

  kickDialog.addEventListener('click', (e) => { if (e.target === kickDialog) closeKickDialog(); });
  btnKickNo.addEventListener('click', (e) => { e.stopPropagation(); closeKickDialog(); });
  btnKickYes.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (pendingSeatIndexToSteal == null || !state.roomCode) { closeKickDialog(); return; }

    if (pendingMode === "started"){
      await stealSeatStarted(pendingSeatIndexToSteal, pendingSeatPlayerIdToSteal);
    } else {
      await stealSeatPrestart(pendingSeatIndexToSteal, pendingSeatPlayerIdToSteal);
    }
    closeKickDialog();
  });
  function closeKickDialog(){
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
    pendingMode = "prestart";
  }

  /* =========================================================
     ‚òÖ‚ë£Âè≥‰∏ãÔºöÊ≠£‰Ωì„Ç´„Éº„Éâ„ÅØ„ÄåË£èÈù¢(browncard.jpg)„Äç„ÅßË°®Á§∫„Åó„ÄÅ
        „ÇØ„É™„ÉÉ„ÇØ„Åß„Äå„Ç™„É¢„ÉÜ(Êã°Â§ß)„Äç„ÇíË°®Á§∫
     ========================================================= */
  function renderMyRoleCard(role){
    myRoleCard.innerHTML = '';
    const isSeatedNow = latestPlayers.some(p => p.id === state.userId && Number(p.seatIndex || 0) > 0);
    if (!isSeatedNow || !role){
      myRoleDock.classList.remove('visible');
      renderEquipmentDock();
      return;
    }

    const identity = equipCache?.[state.userId]?.identity;
    const isIdentityRevealed = !!(identity && identity.kind === 'identity' && identity.roleId === role.id);

    if (isIdentityRevealed){
      const face = createIdentityCard(role);
      face.title = "ÂÖ¨ÈñãÊ∏à„Åø„ÅÆÊ≠£‰Ωì„Ç´„Éº„Éâ";
      face.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));
      face.addEventListener('click', (e) => {
        e.stopPropagation();
        if (activeRoleAbilitySelection && safeText(activeRoleAbilitySelection.actorUid || "") === safeText(state.userId || "")) return;
        const action = captureSelectionRestoreAction();
        openZoomFromRole(role, { enableRevealPop:true, showCloseButton:false });
        if (action){
          setZoomPassthrough(false);
          zoomDismissHandler = async () => {
            await restoreSelectionAction(action);
          };
        }
      });
      myRoleCard.appendChild(face);
    } else {
      const back = document.createElement('div');
      back.className = 'role-back';
      back.style.backgroundImage = `url('browncard.jpg')`;
      back.title = "„ÇØ„É™„ÉÉ„ÇØ„ÅßÊã°Â§ßË°®Á§∫";
      back.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));

      back.addEventListener('click', (e) => {
        e.stopPropagation();
        if (activeRoleAbilitySelection && safeText(activeRoleAbilitySelection.actorUid || "") === safeText(state.userId || "")) return;
        const action = captureSelectionRestoreAction();
        openZoomFromRole(role, { enableRevealPop:true, showCloseButton:false }); // Êã°Â§ß„ÅØ„Ç™„É¢„ÉÜÔºàid72Ôºâ
        if (action){
          setZoomPassthrough(false);
          zoomDismissHandler = async () => {
            await restoreSelectionAction(action);
          };
        }
      });

      myRoleCard.appendChild(back);
    }

    myRoleDock.classList.add('visible');
    renderEquipmentDock();
  }

  function renderHands(){
    const started = isGameStarted();
    updateSeatBoardVisibility();

    const my = state.hands[state.userId];
    if (my && my.roleId && ROLE_BY_ID[my.roleId]){
      renderMyRoleCard(ROLE_BY_ID[my.roleId]);
    } else {
      renderMyRoleCard(null);
    }

    startWarn.textContent = started
      ? "‚Äª„Ç≤„Éº„É†ÈñãÂßãÊ∏à„ÅøÔºàÊú™ÁùÄÂ∏≠„ÅØÂ∏≠„ÇíÂ•™Âèñ„Åó„Å¶ÂèÇÂä†„Åß„Åç„Åæ„ÅôÔºâ"
      : "‚Äª„Éõ„Çπ„Éà„Åå„Äå„Çπ„Çø„Éº„Éà„Äç„ÇíÊäº„Åô„Å®ÈÖçÂ∏É„Åï„Çå„Åæ„Åô";
  }

  function pickUnique(pool, k){
    const s = shuffle(pool);
    return s.slice(0, Math.max(0, k));
  }
  function buildDeckByPlayerCount(n){
    const rule = DEAL_RULE[n];
    if (!rule) throw new Error(`ÂØæÂøúÂ§ñ„ÅÆ‰∫∫Êï∞: ${n}`);

    const deck = [];
    deck.push(...pickUnique(POOL["„É¨„Ç§„ÉÄ„Éº"], rule["„É¨„Ç§„ÉÄ„Éº"]));
    deck.push(...pickUnique(POOL["„Ç∑„É£„Éâ„Ç¶"], rule["„Ç∑„É£„Éâ„Ç¶"]));
    deck.push(...pickUnique(POOL["„Ç∑„ÉÅ„Ç∫„É≥"], rule["„Ç∑„ÉÅ„Ç∫„É≥"]));

    if (deck.length !== n){
      throw new Error(`„Éá„ÉÉ„Ç≠ÊûöÊï∞„Åå‰∏ÄËá¥„Åó„Åæ„Åõ„ÇìÔºàn=${n}, deck=${deck.length}Ôºâ`);
    }
    return shuffle(deck);
  }

  async function dealIdentityCards(){
    if (!state.roomCode) return;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};

    if (roomData.gameStarted || roomData.startedAt) return;

    const tables = roomData.tables || {};
    const players = Object.entries(tables)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        seatIndex: Number(seatIndex),
        name: String(t.playerName || "")
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    const n = players.length;
    if (n < 1 || n > 10) return;

    const deck = buildDeckByPlayerCount(n);

    const hands = {};
    for (let i=0;i<n;i++){
      hands[players[i].id] = { roleId: deck[i].id, dealtAt: Date.now() };
    }

    const positionOrder = shuffle(players.map(p => p.id));
    const startPlayerId = positionOrder[Math.floor(Math.random()*positionOrder.length)] || null;
    const freshDeckState = {
      green: { order: shuffle(toGreenOrder()), idx: 0 },
      white: { order: shuffle(toWhiteOrder()), idx: 0 },
      black: { order: shuffle(toBlackOrder()), idx: 0 },
      reveal: { slot3: null, slot5: null },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    const markers = { ...(roomData.markers || {}) };
    for (const p of players){
      if (safeText(p.name).trim().toLowerCase() !== "test") continue;
      const pt = randomPointInRoom(4, 14);
      if (!pt) continue;
      const color = SEAT_COLORS[(Number(p.seatIndex) || 1) - 1] || "#ddd";
      const initial = firstChar(p.name || "T");
      markers[p.id] = {
        x: pt.x,
        y: pt.y,
        color,
        initial,
        roomId: 4,
        updatedAt: Date.now(),
        forcedSpawn: true
      };
    }

    await update(roomRef, {
      hands,
      deckState: freshDeckState,
      guardianAngelShield: null,
      gameStarted: true,
      startedAt: Date.now(),
      playerCountAtStart: n,
      markers,
      positionOrder,
      startPlayerId,
      turn: {
        currentPlayerId: startPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        drawnTypes: { green:false, white:false, black:false },
        movedByDiceRoomId: null,
        room3ActionUsed: false,
        room4StealUsed: false,
        repeatTurnRemaining: 0,
        repeatTurnTotal: 0,
        sealWisdomBonus: false,
        updatedAt: Date.now()
      }
    });

    await initDamageAllToZero(players);
  }

  function refreshStartBadge(){
    const n = latestPlayers.length;
    startBadge.textContent = `ÂèÇÂä†‰∫∫Êï∞Ôºö${n}`;
    if (state.isHost){
      const rule = DEAL_RULE[n];
      if (rule){
        startBadge.textContent = `ÂèÇÂä†‰∫∫Êï∞Ôºö${n}ÔºàR${rule["„É¨„Ç§„ÉÄ„Éº"]}/S${rule["„Ç∑„É£„Éâ„Ç¶"]}/C${rule["„Ç∑„ÉÅ„Ç∫„É≥"]}Ôºâ`;
      }
    }
  }

  hostSettingsBtn.addEventListener('click', () => {
    if (!state.isHost) return;
    startPop.classList.toggle('hidden');
  });
  btnStartPopClose.addEventListener('click', () => startPop.classList.add('hidden'));
  btnHostDice?.addEventListener('click', async () => {
    if (!state.isHost) return;
    await runCornerD6D4Roll();
    const cleanupTimer = setTimeout(() => {
      diceRollOverlay.innerHTML = '';
      clearDiceRollTimers();
    }, 2000);
    diceRollTimers.push(cleanupTimer);
  });

  btnGameStart.addEventListener('click', async () => {
    if (!state.isHost) return;
    await dealIdentityCards();
    startPop.classList.add('hidden');
  });

  btnResetRoom.addEventListener('click', async () => {
    if (!state.isHost || !state.roomCode) return;

    const base = `rooms/${state.roomCode}`;
    await Promise.all([
      remove(ref(db, `${base}/tables`)),
      remove(ref(db, `${base}/hands`)),
      remove(ref(db, `${base}/maxPlayers`)),
      remove(ref(db, `${base}/gameStarted`)),
      remove(ref(db, `${base}/startedAt`)),
      remove(ref(db, `${base}/playerCountAtStart`)),
      remove(ref(db, `${base}/markers`)),
      remove(ref(db, `${base}/deckState`)),
      remove(ref(db, `${base}/equipment`)),
      remove(ref(db, `${base}/guardianAngelShield`)),
      remove(ref(db, `${base}/damage`)),
      remove(ref(db, `${base}/positionOrder`)),
      remove(ref(db, `${base}/startPlayerId`)),
      remove(ref(db, `${base}/greenInbox`)),
      remove(ref(db, `${base}/greenResponses`)),
      remove(ref(db, `${base}/greenReplyBubbles`)),
      remove(ref(db, `${base}/greenReveals`)),
      remove(ref(db, `${base}/greenRequests`)),
      remove(ref(db, `${base}/roleAbilitySelection`)),
      remove(ref(db, `${base}/turn`)),
      remove(ref(db, `${base}/attackResolutionPending`)),
      remove(ref(db, `${base}/attackLootPending`)),
    ]);

    deckCache = null;
    equipCache = {};
    damageCache = {};

    state.seatedTable = null;
    state.spectating = false;
    sessionStorage.removeItem(seatKey(state.roomCode));
    sessionStorage.removeItem(attackResolutionKey(state.roomCode));
    startPop.classList.add('hidden');

    renderSeatTiles();
    renderHands();
    updateSeatBoardVisibility();

    renderDeckRowFromRoom();
    renderEquipmentDock();
    buildHpCells();
    renderHpBoard();

    updateEquipDockTop();
  });

  async function tryOpenEmmaSelectionOnEndAttempt(){
    if (!isMyRole("RAI_E3") || !isMyIdentityRevealed()) return false;
    const check = emmaAbilityAvailability();
    if (!check.ok) return false;
    await setRoleAbilitySelectionState({ roleId:"RAI_E3", actorUid: state.userId, privateToActor:true, endTurnAfterResolve:true });
    return true;
  }

  async function doEndTurn(){
    lastAttackWatch = null;
    attackTurnEndChoicePending = false;
    pendingAttackResolution = null;
    pendingAttackResultMeta = null;
    ulsterExtraAttackPending = 0;
    attackFlowUiLockActive = false;
    suppressEndTurnButton = false;
    resetAttackAbilityUsageTurnState();
    cachePendingAttackResolution(null);
    await advanceTurnToNextPlayer();
    hideAttackPop();
    hideAttackResultPop();
    clearAttackResultDice();
    hideEndTurnConfirm();
    renderTurnEndButton();
  }

  btnEndTurn?.addEventListener('click', async () => {
    if (!canShowEndTurnButton()) return;
    const openedEmma = await tryOpenEmmaSelectionOnEndAttempt();
    if (openedEmma) return;
    if (!turnState()?.attackDone){
      showEndTurnConfirm({ message:"Êú¨ÂΩì„Å´ÁµÇ‰∫Ü„Åó„Åæ„Åô„Åã„ÄÇ" });
      return;
    }
    await doEndTurn();
  });

  btnEndTurnNo?.addEventListener('click', () => {
    hideEndTurnConfirm();
  });

  btnEndTurnYes?.addEventListener('click', async () => {
    if (!canShowEndTurnButton()){
      hideEndTurnConfirm();
      return;
    }
    hideEndTurnConfirm();
    const openedEmma = await tryOpenEmmaSelectionOnEndAttempt();
    if (openedEmma) return;
    await doEndTurn();
  });

  const urlParams = new URLSearchParams(window.location.search);
  const roomFromUrl = urlParams.get('room');
  if(roomFromUrl) inputCode.value = roomFromUrl;

  const cachedUserName = localStorage.getItem(USER_NAME_CACHE_KEY);
  if (cachedUserName != null) inputName.value = cachedUserName;

  inputName.addEventListener("input", () => {
    localStorage.setItem(USER_NAME_CACHE_KEY, inputName.value || "");
  });

  btnJoin.addEventListener('click', async () => {
    startImagePreload();
    state.userName = (inputName.value || 'ÂêçÁÑ°„Åó').slice(0,4);
    localStorage.setItem(USER_NAME_CACHE_KEY, state.userName);
    state.roomCode = inputCode.value.trim() || generateRoomCode();
    state.spectating = false;
    state.currentRoomId = 0;

    await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
      name: state.userName,
      joinedAt: Date.now()
    });

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val();

    if(!roomData || !roomData.hostId){
      await update(roomRef, { hostId: state.userId });
      state.isHost = true;
    } else {
      state.isHost = (roomData.hostId === state.userId);
    }

    updateHostUI();

    mainEl.classList.remove('prejoin');
    mainEl.classList.add('joined');

    joinBox.classList.add('hidden');
    lobby.classList.remove('hidden');
    lobby.classList.add('entered');

    gameArea.classList.remove('hidden');

    renderRoomShape();
    buildHpCells();

    await ensureRoomDeckState();
    subscribeDeckState();
    renderDeckRowFromRoom();

    const cachedSeat = sessionStorage.getItem(seatKey(state.roomCode));
    if (cachedSeat) state.seatedTable = Number(cachedSeat) || null;
    restorePendingAttackResolutionFromSession();
    await syncMySeatNameIfNeeded();

    subscribeRoom();
    subscribeHostState();
    subscribePlayers();
    subscribeHands();
    subscribeGreenInbox();
    subscribeGreenResponses();
    subscribeGreenSessionState();
    subscribeCardTargetSessionState();
    subscribeRoleAbilitySelectionState();
    subscribeGreenReveals();
    subscribeGreenCloseSignals();
    subscribeGreenReplyBubbles();
    subscribeMarkers();
    subscribeEquipment();
    subscribeDamage();
    subscribeDiceEvents();
    subscribeRoleFlashEvents();
    subscribeHpSwapEvents();
    subscribeWalpurgisSwapEvents();

    renderSeatTiles();
    refreshStartBadge();
    renderHands();
    updateSeatBoardVisibility();

    updateCardInteractivity();
    renderEquipmentDock();
    renderHpBoard();

    requestAnimationFrame(() => {
      updateEquipDockTop();
      applyEquipCols();
    });
  });

  copyLinkBtn.addEventListener('click', async () => {
    const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
    try {
      await navigator.clipboard.writeText(url);
      copyLinkBtn.classList.add('copied');
      copyLinkBtn.textContent = 'COPIED';
      inputCode.value = state.roomCode;
      setTimeout(()=>{
        copyLinkBtn.classList.remove('copied');
        copyLinkBtn.textContent='COPY';
      },1500);
    } catch {
      prompt('„Ç≥„Éî„Éº„Åß„Åç„Åæ„Åõ„Çì„ÄÇÊâãÂãï„Åß„Ç≥„Éî„Éº„Åó„Å¶„Åè„Å†„Åï„ÅÑ', url);
    }
  });
</script>

</body>
</html>
