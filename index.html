<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>シャドウ・レイダーズ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  :root{
    --z-dice-roll-overlay: 12050;
    --z-role-flash-overlay: 12040;
    --equip-dock-height: 220px;
  }
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:272; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .attack-roll-result-debug{font-weight:700;min-width:52px;text-align:left;display:none;}
  #lastAttackToMeHeader{display:none;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn.danger{background:#ef4444;color:#fff;border-color:#ef4444;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:hidden;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('shadowpre.jpg'); }
  main.joined{ background-image:url('back.jpg'); }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;
    z-index:271;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}

  /* 公開確認ポップ */
  .confirm-pop{
    position:fixed;
    left:0; top:0;
    transform:translate(-50%,-10px);
    background:#fff;
    border:1px solid rgba(0,0,0,.18);
    border-radius:12px;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    padding:10px 10px 10px;
    z-index:284;
    min-width:210px;
  }
  .confirm-pop.hidden{display:none;}
  .confirm-pop .msg{font-size:13px;line-height:1.45;margin:0 0 10px;}
  .confirm-pop .msg .ability-pill{display:inline-block;padding:1px 6px;border-radius:999px;background:#111;color:#fff;font-weight:700;}
  .ability-pill{display:inline-block;padding:1px 6px;border-radius:999px;background:#111;color:#fff;font-weight:700;}
  .confirm-pop .actions{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}
  .confirm-pop.hide-actions .actions{display:none;}
  .confirm-pop.hide-actions .msg{margin-bottom:0;}
  .confirm-pop.no-wrap .msg{white-space:nowrap;}
  .confirm-pop .caret{
    position:absolute;
    left:50%; top:-7px;
    width:12px; height:12px;
    background:#fff;
    border-left:1px solid rgba(0,0,0,.18);
    border-top:1px solid rgba(0,0,0,.18);
    transform:translateX(-50%) rotate(45deg);
  }
  .confirm-pop.bottom-fixed{
    left:50%;
    top:auto;
    bottom:16px;
    transform:translateX(-50%);
    min-width:280px;
    max-width:min(92vw, 420px);
  }
  .confirm-pop.bottom-fixed .caret{display:none;}
  #counterAbilityPop{
    min-width:0;
    width:fit-content;
  }
  #counterAbilityPop .actions{
    justify-content:center;
    flex-wrap:nowrap;
  }
  .btn.pop-dark{background:#111;color:#fff;border-color:#111;}
  .btn.pop-disabled{background:#bcbcbc;color:#fff;border-color:#bcbcbc;cursor:not-allowed;}
  .btn.pop-light-gray{background:#d1d5db;color:#fff;border-color:#d1d5db;cursor:not-allowed;}
  .btn.pop-light-gray .ability-pill{background:rgba(255,255,255,.45);color:#f8fafc;border:1px solid rgba(255,255,255,.65);}
  .btn.pop-purple{background:#6d28d9;color:#fff;border-color:#6d28d9;}
  .btn.pop-white{background:#fff;color:#111;border-color:#d1d5db;}

  .attack-result-pop-rows{display:flex;flex-direction:column;gap:8px;margin:0 0 10px;max-height:220px;overflow:auto;}
.attack-result-pop-row{display:flex;align-items:center;justify-content:center;gap:6px;font-size:14px;line-height:1.4;text-align:center;}
.attack-result-plus-two{font-size:12px;color:#d97878;}
.attack-result-pop-name{display:inline-flex;align-items:center;justify-content:flex-start;gap:6px;min-width:0;width:70px;max-width:70px;cursor:default;padding:4px 6px;}
.attack-result-pop-name-text{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:left;}
.attack-result-pop-row .chip16{flex:0 0 auto;}
.btn-excalibur{background:#FF3655;color:#fff;border-color:#c21d1d;padding:2px 2px;}
.btn-excalibur:hover{filter:brightness(1.05);}
.btn-excalibur img{display:block;height:24px;width:auto;}

  #attackResultPop{
    min-width:min(92vw, 250px);
    width:fit-content;
    max-width:min(92vw, 320px);
  }
  #attackResultPop .actions{justify-content:center;flex-wrap:nowrap;}

  .help-btn{
    position:fixed;left:16px;bottom:24px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:1000;cursor:pointer;
    z-index:274;
  }
  .help-btn.visible{display:flex;}

  .room-guide-btn{
    position:fixed;left:16px;bottom:74px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:20px;font-weight:1000;cursor:pointer;
    z-index:274;
  }
  .room-guide-btn.host-position{bottom:124px;}
  .room-guide-btn.visible{display:flex;}
 .room-guide-btn.active{background:#111;color:#fff;box-shadow:0 0 0 2px rgba(255,255,255,.35), 0 8px 20px rgba(0,0,0,.25);}
  body.green-interaction-active .help-btn.visible,
  body.green-interaction-active .room-guide-btn.visible{
    z-index:295;
  }
  body.david-overlay-active .help-btn.visible,
  body.david-overlay-active .room-guide-btn.visible{
    z-index:295;
  }
  .room-guide-btn img{width:22px;height:22px;display:block;object-fit:contain;pointer-events:none;}


  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:291;
    padding:16px 16px 64px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(560px, calc(100% - 0px));
    max-height:min(82vh, 780px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:1000;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(82vh - 48px);}

  .equip-expand-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:290;
    padding:16px 16px 64px;
  }
  .equip-expand-backdrop.hidden{display:none;}
  .equip-expand-pop{
    width:min(560px, calc(100% - 0px));
    max-height:min(82vh, 780px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  .equip-expand-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .equip-expand-title{font-weight:1000;font-size:14px;}
  .equip-expand-body{
    padding:12px;
    overflow:auto;
    max-height:calc(82vh - 48px);
    background-color:#ffffff;
    background-image:url('gear.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }

  .attack-loot-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.48);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:288;
    padding:16px;
  }
  .attack-loot-backdrop.hidden{display:none;}
  .attack-loot-pop{
    width:min(760px, calc(100% - 20px));
    max-height:min(86vh, 820px);
    background:#fff;
    border-radius:16px;
    border:1px solid rgba(0,0,0,.14);
    box-shadow:0 22px 44px rgba(0,0,0,.4);
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  .attack-loot-header{padding:10px 12px;border-bottom:1px solid #eee;font-weight:1000;font-size:14px;}
  .attack-loot-body{padding:12px;overflow:auto;display:flex;flex-direction:column;gap:10px;background:url('gear.jpg') center/cover no-repeat;}
  .attack-loot-row{display:flex;gap:8px;align-items:flex-start;}
  .attack-loot-row.byron-row{padding-top:8px;border-top:1px dashed rgba(0,0,0,.28);}
  .attack-loot-row.byron-row:first-child{padding-top:0;border-top:none;}
  .attack-loot-row.byron-row.selected .card72.wb-front,
  .attack-loot-row.byron-row.selected .id72{opacity:.35;animation:none !important;}
  .attack-loot-row.byron-row .byron-selected-card{opacity:1 !important;}
  .attack-loot-cards{display:flex;gap:8px;flex-wrap:wrap;}
  .attack-loot-no-steal{border:2px solid #111 !important;color:#111 !important;background:#fff !important;display:flex;align-items:center;justify-content:center;font-weight:1000;flex:0 0 auto;}

  .help-section{padding:6px 0 10px;}
  .help-section + .help-section{border-top:1px solid rgba(0,0,0,.16);}
  .help-section-title{font-weight:900;font-size:13px;margin:0 0 8px;}
  .help-card-grid{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:12px;justify-items:center;}
  .help-card-slot{
    width:calc(var(--card-w) * 1.5);
    height:calc(var(--card-h) * 1.5);
    position:relative;
  }
  .help-card-slot .card72,.help-card-slot .id72,
  .help-role-row .role-card-wrap .id72{
    position:absolute;
    top:0;
    left:0;
    transform:scale(1.5);
    transform-origin:top left;
    margin:0;
  }
  .help-section .card72,.help-section .id72{width:var(--card-w);height:var(--card-h);}
  .help-role-row{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:8px;}
  .help-role-row .role-card-wrap{
    width:calc(var(--card-w) * 1.5);
    height:calc(var(--card-h) * 1.5);
    flex:0 0 auto;
    position:relative;
  }
  .help-role-row:last-child{margin-bottom:0;}

  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;border-bottom:1px solid rgba(0,0,0,.06);
  }
  .role-row:last-child{border-bottom:none;}
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:1000;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}
  .role-desc .meta{font-size:12px;opacity:.8;margin-top:6px;white-space:pre-wrap;}

  .seat-pop-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:270;
    padding:16px;
  }
  .seat-pop-backdrop.hidden{display:none;}

  .seat-board{
    width:min(400px, calc(100% - 32px));
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.22);
    padding:12px 12px 14px;
    position:relative;
    margin:0;
  }
  .seat-board-title{
    font-weight:1000;
    font-size:13px;
    opacity:.9;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin:0 0 10px;
  }
  .seat-count-badge{
    font-size:12px;
    font-weight:900;
    background:#111;
    color:#fff;
    padding:4px 8px;
    border-radius:999px;
    white-space:nowrap;
  }
  .tile-grid{
    display:grid;
    grid-template-columns:repeat(4, 54px);
    grid-auto-rows:54px;
    gap:10px;
    justify-content:center;
    padding:4px 0 2px;
  }
  .seat-tile{
    width:54px;height:54px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.12);
    box-shadow:0 6px 16px rgba(0,0,0,.16);
    cursor:pointer;
    position:relative;
    overflow:hidden;
    outline:none;
  }
  .seat-tile:focus{box-shadow:0 0 0 3px rgba(37,99,235,.25), 0 6px 16px rgba(0,0,0,.16);}
  .seat-tile.me::after{ display:none; }
  .seat-initial{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    font-weight:1000;
    font-size:16px;
    line-height:1;
    color:#111;
    pointer-events:none;
    user-select:none;
  }
  .seat-tile.empty{opacity:.95;}
  .seat-tile.taken{opacity:1;}
  .warn{
    font-size:12px;
    opacity:.75;
    text-align:center;
    margin-top:10px;
  }

  .seat-board-actions{
    display:flex;
    justify-content:flex-end;
    margin-top:10px;
    gap:8px;
    flex-wrap:wrap;
  }

  :root{
    --outer:#0b3b2e;
    --gold:#d6b35a;
    --brown:#5a4032;
    --team:#c21d1d;
    --black:#111;
    --paper:#f7f4ee;
    --effect:#ffd9a3;
    --inner-gap:-0.5px;
    --inner-w:1px;
    --inner-r:9px;
    --ini-stroke:0.3px;
    --ini-stroke-shadow:0.3px;
    --ini-y:-0.4px;

    /* =========================================================
       ★HPボード：各ルーム（damage 15→0）の比率を固定
       （frを使って、ボード全体のサイズ変更時にも区切り位置を維持）
       ========================================================= */
    --hp-r15: 25fr;
    --hp-r14: 26fr;
    --hp-r13: 23fr;
    --hp-r12: 23fr;
    --hp-r11: 24fr;
    --hp-r10: 24fr;
    --hp-r9:  24fr;
    --hp-r8:  23fr;
    --hp-r7:  23fr;
    --hp-r6:  23fr;
    --hp-r5:  23fr;
    --hp-r4:  24fr;
    --hp-r3:  23fr;
    --hp-r2:  23fr;
    --hp-r1:  23fr;
    --hp-r0:  24fr;

    /* HPセルの左右余白（高さを変えたくない場合は縦paddingを0推奨） */
    --hp-cell-pad-x: 6px;
    --hp-cell-pad-y: 0px;
  }

  .my-role-dock{
    position:fixed;
    right:16px;
    bottom:16px;
    z-index:260;
    display:none;
  }
  .my-role-dock.visible{ display:block; }
  body.green-interaction-active .my-role-dock.visible{
    z-index:297;
  }

  /* =========================
     装備枠（★カードパネル直下まで上に伸ばす）
     ========================= */
  .equip-dock{
    position:fixed;
    left:16px;
    right:calc(2px + 72px + 12px);
    top:var(--equip-top, auto);
    bottom:10px;
    min-height:120px;
    z-index:259;
    display:none;
  }
  .equip-dock.visible{ display:block; }
  .equip-dock.david-select-front{ z-index:283; }
  .equip-dock.deduction-front{ z-index:286; }

  .equip-board{
    background-color:#ffffff;
    background-image:url('gear.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    border:1px solid rgba(0,0,0,.10);
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.18);
    padding:10px;
    height:100%;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    overflow:visible;
  }

  .equip-body{
    flex:1 1 auto;
    display:flex;
    flex-wrap:wrap;
    align-content:flex-start;
    align-items:flex-start;
    gap:6px;
    min-height:0;
    overflow-y:auto;
    overflow-x:visible;
    padding:8px 4px 8px 0;
    margin:-8px -4px -8px 0;
    -ms-overflow-style:none;
    scrollbar-width:none;
  }
  .equip-body::-webkit-scrollbar{
    width:0;
    height:0;
    display:none;
  }

  .equip-row{
    display:inline-flex;
    align-items:flex-start;
    gap:5px;
    padding:2px 0;
    overflow:visible;
  }

  .equip-tag{
    width:18px;height:18px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.35);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:12px;
    line-height:1;
    user-select:none;
    flex:0 0 auto;
  }
  .equip-cards{
    display:flex;
    flex-wrap:wrap;
    gap:5px;
    align-items:flex-start;
    justify-content:flex-start;
    overflow:visible;
    padding-bottom:2px;
    flex:0 1 auto;
  }

  .id72{
    width:var(--card-w);height:var(--card-h);
    background-color: var(--paper);
    background-image: none;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border:1.4px solid var(--outer);
    border-radius:10px;
    box-sizing:border-box;
    position:relative;
    overflow:hidden;
    cursor:pointer;
  }
  .id72::before{
    content:"";
    position:absolute;
    left:var(--inner-gap);right:var(--inner-gap);
    top:var(--inner-gap);bottom:var(--inner-gap);
    border:var(--inner-w) solid var(--gold);
    border-radius:var(--inner-r);
    pointer-events:none;
    z-index:1;
    opacity:1;
  }
  .id72 .initial{
    position:absolute;top:1px;left:1px;
    width:16px;height:16px;
    border:1px solid var(--black);
    border-radius:999px;
    display:grid;place-items:center;
    font-weight:900;font-size:13px;
    background:var(--team);
    line-height:1;z-index:5;
  }
  .id72 .initial span{
    display:inline-block;line-height:1;
    color:var(--black);
    transform: translateY(var(--ini-y));
    -webkit-text-stroke: var(--ini-stroke) var(--gold);
    text-stroke: var(--ini-stroke) var(--gold);
    text-shadow:
      0 0 0 var(--gold),
      0 var(--ini-stroke-shadow) 0 var(--gold),
      0 calc(var(--ini-stroke-shadow) * -1) 0 var(--gold),
      var(--ini-stroke-shadow) 0 0 var(--gold),
      calc(var(--ini-stroke-shadow) * -1) 0 0 var(--gold);
  }
  .id72 .team-arc{
    position:absolute;left:2px;top:18px;
    width:16px;height:10px;
    z-index:6;pointer-events:none;overflow:visible;
  }
  .id72 .team-arc text{
    font-weight:600;font-size:6px;letter-spacing:.40px;
    fill:var(--team);
  }
  .id72 .eng-sub{
    position:absolute;top:3px;left:15px;
    padding:1px 3px 1px 3px;
    background:var(--black);color:var(--gold);
    border:1px solid var(--gold);
    border-radius:0 6px 6px 0;
    font-weight:900;letter-spacing:.2px;
    font-size:10px;line-height:1;
    box-sizing:border-box;z-index:4;
  }
  .id72 .name{
    position:absolute;top:45px;left:2px;right:4px;
    text-align:left;padding:0px 4px;
    background:var(--black);color:var(--gold);
    border:1px solid var(--gold);
    border-radius:6px;
    font-weight:900;font-size:9px;
    letter-spacing:.3px;
    box-sizing:border-box;z-index:2;
  }
  .id72 .hp-badge{
    position:absolute;top:43px;right:1px;
    width:18px;height:18px;border-radius:999px;
    background:var(--brown);
    border:1px solid var(--gold);
    box-sizing:border-box;z-index:3;
    display:flex;flex-direction:column;
    align-items:center;justify-content:center;
    gap:0;padding-top:1px;
  }
  .id72 .hp-badge .label{
    font-size:5px;font-weight:900;line-height:0.5;
    color:var(--gold);letter-spacing:.2px;opacity:.98;
  }
  .id72 .hp-badge .val{
    font-size:12px;font-weight:1000;line-height:1;
    color:var(--gold);
    transform:translateY(-1px);
  }
  .id72 .effect{
    position:absolute;left:3px;right:3px;bottom:1.4px;top:61px;
    background:var(--effect);
    border-radius:4px;
    padding:1px 1px;
    box-sizing:border-box;
    font-size:5.4px;line-height:1.25;
    color:var(--black);
    overflow:hidden;z-index:2;
  }
  .id72 .tag{
    display:inline-block;
    background:var(--black);
    color:#fff;
    font-weight:900;
    padding:1px 2px;
    border-radius:3px;
    margin-right:1px;
    font-size:5.5px;
    letter-spacing:.2px;
    line-height:1;
    vertical-align:baseline;
  }
  .id72 .row{ margin:0 0 1px 0; }
  .id72 .row:last-child{ margin-bottom:0; }
  .id72 .effect.david-all-text{
    font-size:4.7px;
    line-height:1.2;
  }
  .id72 .effect.david-all-text .tag{
    font-size:4.7px;
  }
  .id72 .ulrich-effect-row{
    color:#0b2a6a;
  }
  .role-card-wrap{ flex:0 0 auto; }

  .host-settings-btn{
    position:fixed;
    left:16px;
    bottom:74px;
    width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;
    z-index:274;
  }
  .host-settings-btn.visible{display:flex;}

  .action-chat-btn{
    position:fixed;
    left:16px;
    bottom:124px;
    width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:18px;cursor:pointer;
    z-index:274;
  }
  .action-chat-btn.visible{display:flex;}

  .action-chat-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.45);z-index:320;
    display:flex;align-items:flex-end;justify-content:center;padding:14px;
  }
  .action-chat-backdrop.hidden{display:none;}
  .action-chat-pop{
    width:min(900px, 100%); max-height:min(78vh, 720px);
    background:#fff;border-radius:14px;border:1px solid #ddd;overflow:hidden;
    display:flex;flex-direction:column;
  }
  .action-chat-header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee;font-weight:900;}
  .action-chat-body{padding:10px 12px;overflow:auto;display:flex;flex-direction:column;gap:8px;background:#fafafa;}
  .action-chat-row{font-size:12px;line-height:1.5;background:#fff;border:1px solid #eee;border-radius:8px;padding:6px 8px;white-space:pre-wrap;word-break:break-word;}

  .start-pop{
    position:fixed;
    left:16px;
    bottom:120px;
    background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:273;min-width:280px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:900;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}
  .start-badge{
    display:inline-flex;align-items:center;gap:6px;
    font-size:12px;font-weight:900;
    padding:4px 10px;border-radius:999px;
    border:1px solid rgba(0,0,0,.12);
    background:#f8f8f8;
  }

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    min-height:calc(100vh - 60px);
    padding-top:12px;
    gap:12px;
  }

  .game-area{
    width:min(980px, calc(100% - 24px));
    display:flex;
    flex-direction:column;
    gap:1px;
    align-items:center;
    justify-content:flex-start;
    padding-bottom:18px;  

  }
  .top-row{
    width:100%;
    display:flex;
    gap:14px;
    align-items:flex-start;
    justify-content:center;
    margin-top:-10px;
  }

  /* パネル共通 */
  .panel{
    background:rgba(255,255,255,.78);
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    box-shadow:0 12px 28px rgba(0,0,0,.10);
    padding:12px;
    box-sizing:border-box;
  }

  .left-panel{
    width:170px; 
    padding:0px;
    display:flex;
    align-items:stretch;
    justify-content:stretch;
    background:transparent !important;
    border:none !important;
    box-shadow:none !important;

    aspect-ratio: 2 / 4.5;
    height:auto;
    min-height:0;
  }

  /* =========================================================
     ★①左図形：枠/セル線/背景を透明（画像だけ表示）
     ========================================================= */
  .hp-board{
    width:100%;
    height:100%;
    min-height:0;

    border:none;                 /* 枠なし */
    border-radius:12px;

    overflow:hidden;
    position:relative;
    display:grid;

    grid-template-rows:
      var(--hp-r15) var(--hp-r14) var(--hp-r13) var(--hp-r12)
      var(--hp-r11) var(--hp-r10) var(--hp-r9)  var(--hp-r8)
      var(--hp-r7)  var(--hp-r6)  var(--hp-r5)  var(--hp-r4)
      var(--hp-r3)  var(--hp-r2)  var(--hp-r1)  var(--hp-r0);

    background-image:url('hp.png'); /* 画像だけ */
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    transform:none;
  }
  .hp-cell{
    position:relative;
    min-height:0;
    overflow:hidden;

    display:flex;
    align-items:center;
    justify-content:center;
    flex-wrap:nowrap;
    gap:6px;

    padding:var(--hp-cell-pad-y) var(--hp-cell-pad-x);
    box-sizing:border-box;

    background:transparent; /* セル背景も透明 */
  }
  .hp-cell.hp-cell-room4plus{
    padding-right:calc(var(--hp-cell-pad-x) + 50px);
  }
  .hp-cell::after{ display:none; } /* セル線を消す */

.chip16{
    width:18px;height:18px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.42);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:11px;
    line-height:1;
    user-select:none;
    box-shadow:0 4px 10px rgba(0,0,0,.16);
    flex:0 0 auto;
  }

  .right-panel{
    width:min(520px, 52vw);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
  }
/* 自分のマーカーだけ、丸い点線リング */
  .mark-me-ring{
  fill: transparent;
  stroke: rgba(17,17,17,.95);
  stroke-width: 2;
  stroke-dasharray: 3.5 3.5;
  stroke-linecap: round;
  vector-effect: non-scaling-stroke;
  cursor:pointer;
  pointer-events:all;
}

.marker-swap-hidden{
  opacity:0;
  pointer-events:none;
}

.chip16.turn-pulse{
  animation:markerPulse 1.2s ease-in-out infinite;
}


.dice-roll-overlay{
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:var(--z-dice-roll-overlay);
}
.agatha-reveal-overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
  z-index:286;
}
.agatha-reveal-overlay.hidden{ display:none; }
.agatha-reveal-overlay .id72{
  transform:scale(2.0);
  transform-origin:center center;
  box-shadow:0 18px 50px rgba(0,0,0,.45);
  animation:none !important;
  transition:none !important;
}
.dice-flyer{
  position:absolute;
  left:0;
  top:0;
  transform:translate(-9999px,-9999px);
  will-change:transform;
}
.dice-flyer.rolling{
  transition:transform .95s cubic-bezier(.08,.62,.18,1);
}

.dice-flyer,
.dice-flyer *{
  box-sizing:border-box;
}

.dice-flyer{
  --die: 48px;
  --pip: 8px;
  --pad: 6px;
  --d4-2-gap: 13%;
}

.attack-result-pin{
  position:absolute;
  left:0;
  top:0;
  pointer-events:none;
}

.die{
  width:var(--die); height:var(--die);
  background:#e53935;
  border:1px solid #b71c1c;
  border-radius:5px;
  position:relative;
}
.pip{
  width:var(--pip); height:var(--pip);
  background:#fff; border-radius:50%;
  position:absolute;
}
.tl{left:var(--pad); top:var(--pad);}
.tr{right:var(--pad); top:var(--pad);}
.ml{left:var(--pad); top:50%; transform:translateY(-50%);}
.mc{left:50%; top:50%; transform:translate(-50%,-50%);}
.mr{right:var(--pad); top:50%; transform:translateY(-50%);}
.bl{left:var(--pad); bottom:var(--pad);}
.br{right:var(--pad); bottom:var(--pad);}

.d4{
  width:var(--die);
  height:calc(var(--die) * 0.8660254038);
  position:relative;
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
  background:#1e88e5;
  border:none;
  --vTopX: 50%;  --vTopY: 0%;
  --vLftX: 0%;   --vLftY: 100%;
  --vRgtX: 100%; --vRgtY: 100%;
  --cx: 50%;
  --cy: calc(100% * 2 / 3);
  --k: 0.45;
}
.d4-num{
  position:absolute;
  left:50%;
  top:60%;
  transform:translate(-50%,-50%);
  color:#fff;
  font-size:18px;
  font-weight:1000;
  line-height:1;
}

  /* =========================================================
     ★②右図形：図形外の背景を透明（パネルの白背景/枠/影を消す）
     ========================================================= */
  .map-panel{
    width:110%;
    height:min(62vh, 340px);
    display:flex;
    justify-content:center;
    align-items:center;
    padding:0;
    overflow:hidden;

    background:transparent !important;
    border:none !important;
    box-shadow:none !important;
  }

  .position-line{
    position:absolute;
    right:12px;
    bottom:calc(100% + 6px);
    min-height:16px;
    display:flex;
    flex-wrap:wrap;
    align-items:flex-start;
    justify-content:flex-end;
    gap:4px;
    max-width:min(280px, calc(100vw - 28px));
    z-index:3;
  }
  .position-item{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
    position:relative;
  }
  .position-chip-wrap{
    position:relative;
    display:flex;
    justify-content:center;
    align-items:center;
  }
  .position-bubble{
    position:absolute;
    bottom:calc(100% + 10px);
    left:50%;
    transform:translateX(-50%);
    width:max-content;
    max-width:min(260px, calc(100vw - 36px));
    padding:4px 8px;
    border-radius:8px;
    background:#111;
    border:1px solid #fff;
    color:#fff;
    font-size:10px;
    font-weight:900;
    white-space:normal;
    word-break:break-word;
    overflow:visible;
    text-overflow:clip;
    line-height:1.2;
    pointer-events:none;
    z-index:2;
  }
  .position-bubble::after{
    content:"";
    position:absolute;
    left:50%;
    top:100%;
    transform:translateX(-50%);
    border:7px solid transparent;
    border-top-color:#111;
  }
  .position-bubble.white-text{
    background:#fff;
    border:1px solid #111;
    color:#111;
  }
  .position-bubble.white-text::after{ border-top-color:#fff; }
  .position-bubble.white-text::before{ border-top-color:#111; }
  .position-bubble.faction-raider{
    background:#d13636;
    border:1px solid #fff;
    color:#fff;
  }
  .position-bubble.faction-raider::after{ border-top-color:#d13636; }
  .position-bubble.faction-raider::before{ border-top-color:#fff; }
  .position-bubble.faction-shadow{
    background:#1f2f6b;
    border:1px solid #fff;
    color:#fff;
  }
  .position-bubble.faction-shadow::after{ border-top-color:#1f2f6b; }
  .position-bubble.faction-shadow::before{ border-top-color:#fff; }
  .position-bubble::before{
    content:"";
    position:absolute;
    left:50%;
    top:100%;
    transform:translateX(-50%);
    border:8px solid transparent;
    border-top-color:#fff;
    z-index:-1;
  }
  .starter-mark{
    min-height:10px;
    font-size:10px;
    font-weight:900;
    line-height:1;
    color:#111;
  }
  .position-line.hidden{ display:none; }
  .turn-end-wrap{
    position:fixed;
    right:24px;
    bottom:135px;
    z-index:261;
    display:flex;
    justify-content:center;
  }
  .turn-end-wrap.hidden{display:none;}
  #btnEndTurn{
    width:60px;
    height:60px;
    border-radius:50%;
    padding:0 6px;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    line-height:1.15;
    font-size:8px;
    font-weight:1000;
    border:none;
    background:url('endgear.png') center/cover no-repeat;
    color:#fff;
    text-shadow:0 1px 2px rgba(0,0,0,.65);
    box-shadow:0 8px 18px rgba(0,0,0,.24);
  }

  .endturn-confirm{
    position:fixed;
    left:50%;
    bottom:16px;
    transform:translateX(-50%);
    background:#fff;
    border:1px solid rgba(0,0,0,.18);
    border-radius:12px;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    padding:10px;
    z-index:285;
    min-width:240px;
  }
  .endturn-confirm.hidden{display:none;}
  .endturn-confirm .msg{font-size:13px;line-height:1.45;margin:0 0 10px;}
  .endturn-confirm .actions{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}
  .position-arrow{
    font-size:12px;
    font-weight:900;
    line-height:1;
    color:#111;
    user-select:none;
    margin-top:2px;
  }

  :root{
    --card-w:72px;
    --card-h:108px;
    --card-gap:6px;

    --wb-black:#111;
    --wb-gold:#caa44a;
    --wb-gold2:#f3dc8a;
    --wb-gray:#e5e5e5;

    --green-dark:#0b3b2e;
    --green-soft:#e9fff4;
  }

  /* =========================================================
     ★③カードテーブル：背景をgear.jpgに
     ========================================================= */
  .cards-panel{
    width:calc(100% + 50px);
    max-width:calc(100% + 50px);
    margin-left:-30px;    
    margin-right:-30px;    
    display:flex;
    justify-content:center;
    align-items:flex-start;
    padding:6px 5px 6px 5px;
    overflow-x:auto;
    overflow-y:hidden;
    -webkit-overflow-scrolling:touch;

    background-color:#ffffff;
    background-image:url('gear.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    border:1px solid rgba(0,0,0,.08);
    box-shadow:0 12px 28px rgba(0,0,0,.10);
    border-radius:16px;
  }

  .cards-zone{
    width:100%;
    position:relative;
    display:flex;
    justify-content:center;
    margin-top:3px;
  }

  .empty-cards-row{
    display:flex;
    gap:var(--card-gap);
    justify-content:flex-start;
    align-items:flex-start;
    flex-wrap:nowrap;
    width:max-content;
    padding:0;
  }

  .room-svg{width:100%;height:100%;display:block;}
  .shape{stroke:#111;stroke-width:1;vector-effect:non-scaling-stroke;}
  .attack-range-layer{pointer-events:none;}
  .attack-range-edge-outline{stroke:var(--brown);stroke-width:1.6;stroke-linecap:round;vector-effect:non-scaling-stroke;}
  .attack-range-edge{stroke:var(--gold);stroke-width:2.5;stroke-linecap:round;vector-effect:non-scaling-stroke;}
  .roomhit{fill:transparent;cursor:pointer;}
  .roomhit:hover{fill:rgba(0,0,0,.06);}
  .room-choice-pulse{
    transform-box:fill-box;
    transform-origin:center;
    animation:roomChoicePulse 1.2s ease-in-out infinite;
  }
  .room-choice-once{
    transform-box:fill-box;
    transform-origin:center;
    animation:roomChoicePulse 1.2s ease-in-out infinite;
  }
  .shape.room-choice-pulse,
  .shape.room-choice-once{
    stroke:#a855f7;
    stroke-width:2;
  }
  .shape.emi-room-choice-pulse{
    stroke:#ef4444;
    stroke-width:4;
  }
  .emi-room-choice-pulse{
    transform-box:fill-box;
    transform-origin:center;
    animation:roomChoicePulse 1.2s ease-in-out infinite;
  }
  .roomhit.emi-room-choice-pulse{cursor:pointer;}
  @keyframes roomChoicePulse{
    0%,100%{ transform:scale(1); }
    50%{ transform:scale(1.05); }
  }

  .room-guide-layer{pointer-events:none;}
  .room-guide-note{
    fill:rgba(229,229,229,.84);
    stroke:rgba(0,0,0,.22);
    stroke-width:0.6;
    vector-effect:non-scaling-stroke;
  }
  .room-guide-note-text{
    fill:#111;
    font-size:8px;
    font-weight:800;
    text-anchor:middle;
    user-select:none;
  }

.mark-rect{stroke:#111;stroke-width:1;vector-effect:non-scaling-stroke;}
.mark-rect.guardian-shield{stroke:#d4af37;stroke-width:2;}
.mark-rect.gordon-barrier{stroke:#dc2626;stroke-width:2;}
.mark-text{font-weight:1000;font-size:10px;dominant-baseline:middle;text-anchor:middle;user-select:none;pointer-events:none;}
.mark-pulse-target{
  transform-box:fill-box;
  transform-origin:center;
  animation:markerPulse 1.2s ease-in-out infinite;
}
.mark-pulse-self-turn-start{
  animation:markerPulseSelfTurn 1.2s ease-in-out infinite;
}
.equip-steal-pulse{
  animation:equipStealPulse 1.1s ease-in-out infinite;
  cursor:pointer;
}
.equip-defeat-pulse{
  animation:equipDefeatPulse .9s ease-in-out infinite;
  cursor:pointer;
}
@keyframes equipStealPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.06); }
}
@keyframes equipDefeatPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.14); }
}
@keyframes markerPulse{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.2); }
}
@keyframes markerPulseSelfTurn{
  0%,100%{ transform:scale(1); }
  50%{ transform:scale(1.6); }
}
.turn-hint-pop{
  position:fixed;
  top:55px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:nowrap;
  background:#111;
  color:#fff;
  border-radius:10px;
  padding:8px 12px;
  font-size:12px;
  font-weight:800;
  white-space:nowrap;
  z-index:286;
  box-shadow:0 8px 18px rgba(0,0,0,.28);
}
.turn-hint-pop.multiline{
  white-space:pre;
  width:max-content;
  max-width:calc(100vw - 20px);
}
.turn-hint-pop.hidden{ display:none; }
.turn-hint-action{
  display:inline-block;
  margin:0;
  width:max-content;
  white-space:nowrap;
  font-size:13px;
  color:#fff !important;
  border-color:rgba(255,255,255,.78) !important;
  background:rgba(255,255,255,.08);
}
.turn-start-board{
  position:fixed;
  left:50%;
  top:50%;
  width:180px;
  height:120px;
  transform:translate(-50%,-50%);
  z-index:286;
  pointer-events:none;
}
.turn-start-board.hidden{display:none;}
.turn-start-board img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
  border-radius:8px;
}
.turn-start-board-label{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  color:#fff;
  font-size:28px;
  font-weight:900;
  letter-spacing:.02em;
  text-shadow:0 1px 1px rgba(0,0,0,.45);
  display:flex;
  white-space:nowrap;
}
.turn-start-board-label .char-odd{animation:turn-label-bob-odd .9s ease-in-out infinite;}
.turn-start-board-label .char-even{animation:turn-label-bob-even .9s ease-in-out infinite;}
@keyframes turn-label-bob-odd{
  0%,100%{transform:translateY(-1px);}
  50%{transform:translateY(1px);}
}
@keyframes turn-label-bob-even{
  0%,100%{transform:translateY(1px);}
  50%{transform:translateY(-1px);}
}
#roomActionPop{
  z-index:293;
}
#roomActionPop.lower-mode{
  left:50% !important;
  top:auto !important;
  bottom:160px;
  transform:translateX(-50%);
}
#roomActionPop.lower-mode .caret{ display:none; }
#roomActionPop.no-caret .caret{ display:none; }
#roomActionPop.text-fit{
  min-width:0;
  width:fit-content;
  max-width:min(92vw, 420px);
}
#roomActionPop.room3-mode .actions{
  flex-wrap:nowrap;
  justify-content:center;
}
#roomActionPop.room3-mode .actions .btn{
  white-space:nowrap;
}

  .card72{
    width:var(--card-w);
    height:var(--card-h);
    border-radius:10px;
    box-sizing:border-box;
    background:rgba(255,255,255,.92);
    border:1.4px solid rgba(17,17,17,.55);
    position:relative;
    overflow:hidden;
    flex:0 0 auto;
    user-select:none;
  }
  .card72.deck{
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    cursor:pointer;
  }

  /* 既存の「薄くする」ロック */
  .card72.locked{
    opacity:.35;
    filter:grayscale(.55);
    cursor:default !important;
    pointer-events:none;
  }

  /* ★追加：薄くしないがクリック不可（白表 / 黒オモテ用） */
  .card72.blocked{
    opacity:1;
    filter:none;
    cursor:default !important;
    pointer-events:none;
  }

  .count-tag{
    position:absolute;
    top:4px;
    right:4px;
    background:rgba(235,235,235,.95);
    color:#111;
    font-weight:1000;
    font-size:12px;
    line-height:1;
    padding:4px 7px;
    border-radius:999px;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 6px 16px rgba(0,0,0,.12);
    z-index:5;
    pointer-events:none;
  }

  .card72.wb-front{
    border:1px solid var(--wb-black);
    border-radius:10px;
    background:#fff;
    cursor:pointer;
  }
  .card72.wb-front.wb-white{ background:#fff; }
  .card72.wb-front.wb-black{ background:#000; }
  .card72.wb-front.wb-green{ background:#74745a; border-color:#0b3b2e; }

  .card72.wb-front .wb-name{
    position:absolute;
    left:2px; right:2px; top:2px;
    height:18px;
    border:2px solid var(--wb-gold);
    border-radius:8px;
    background:#000;
    display:flex;align-items:center;justify-content:center;
    box-sizing:border-box;
    padding:0 4px;
    z-index:3;
  }
  .card72.wb-front.wb-green .wb-name{
    background:var(--green-dark);
    border-color:#d6b35a;
  }
  .card72.wb-front .wb-name span{
    display:block;
    font-size:8px;
    line-height:1;
    font-weight:900;
    letter-spacing:.04em;
    color:var(--wb-gold);
    text-shadow:0 1px 0 rgba(255,255,255,.08);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:clip;
    width:100%;
    text-align:center;
    transform-origin:center center;
  }
  .card72.wb-front .wb-circle{
    position:absolute;
    top:14px;
    left:50%;
    transform:translateX(-50%);
    width:60px;height:60px;
    border-radius:50%;
    border:transparent;
    background: radial-gradient(circle at 30% 30%, rgba(243,220,138,.45), rgba(0,0,0,0) 55%);
    box-sizing:border-box;
    overflow:hidden;
    z-index:1;
  }
  .card72.wb-front.wb-green .wb-circle{
    background: radial-gradient(circle at 30% 30%, rgba(34,197,94,.25), rgba(0,0,0,0) 60%);
  }
  .card72.wb-front .wb-circle img{
    width:100%;
    height:100%;
    display:block;
    object-fit:cover;
  }
  .card72.wb-front .wb-effect{
    position:absolute;
    left:2px; right:2px; bottom:2px;
    top:69px;
    background:var(--wb-gray);
    border-radius:6px;
    padding:2px;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    gap:4px;
    overflow:hidden;
    z-index:2;
  }
  .card72.wb-front.wb-green .wb-effect{
    background:rgba(238,223,200,.92);
    border:1px solid rgba(11,59,46,.28);
  }
  .card72.wb-front .wb-desc{
    position:relative;
    z-index:6;
    font-size:6px;
    line-height:1.25;
    font-weight:700;
    color:#111;
    overflow:hidden;
    white-space:pre-wrap;
  }
  .card72.wb-front.wb-black .wb-desc{ color:#111; }
  .card72.wb-front .wb-desc .inline-tag{
    display:inline-block;
    background:#000;
    color:#fff;
    font-weight:900;
    font-size:6px;
    line-height:1;
    padding:2px 4px;
    border-radius:4px;
    margin-right:2px;
    vertical-align:baseline;
  }

  /* ★追加：0枚（空）のときは枠なし */
  .card72.noframe{
    background:transparent;
    border:none !important;
  }

  /* ★④ 正体カード（右下）：裏面表示用 */
  .role-back{
    width:72px;height:108px;
    border-radius:10px;
    border:1.4px solid rgba(17,17,17,.55);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    cursor:pointer;
    box-shadow:0 10px 26px rgba(0,0,0,.18);
  }

  .zoom-backdrop{
    position:fixed;
    inset:0;
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:280;
    padding:18px;
  }
  .zoom-backdrop.hidden{ display:none; }
  .zoom-backdrop.over-panel{ z-index:292; }
  .zoom-backdrop.passthrough{
    pointer-events:none;
    background:transparent;
  }
  .zoom-backdrop.passthrough .zoom-stage{
    pointer-events:none;
  }
  .zoom-stage{
    position:relative;
    width:72px;
    height:108px;
    transform:scale(var(--zoom, 4));
    transform-origin:center;
    transition:transform .35s ease;
  }
  .zoom-stage.zoom-stage-multi{
    width:min(98vw, 1400px);
    height:auto;
    transform:none;
    transition:none;
  }
  .zoom-backdrop.green-reveal-active .zoom-stage{
    transform:translateX(-90px) scale(var(--zoom, 4));
  }
  .zoom-backdrop.david-select-active .zoom-stage{
    transform:translateX(-90px) scale(var(--zoom, 4));
  }
  .zoom-stage .card72,
  .zoom-stage .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
  }
  .zoom-stage .equip-steal-pulse{
    animation:none;
  }
  .zoom-stage .equip-defeat-pulse{
    animation:none;
  }
  .zoom-identity-owner{
    position:absolute;
    left:50%;
    top:-22px;
    transform:translateX(-50%);
    display:flex;
    align-items:center;
    gap:4px;
    background:#fff;
    border:1px solid rgba(0,0,0,.15);
    border-radius:999px;
    padding:3px 6px;
    font-size:8px;
    font-weight:700;
    color:#111;
    white-space:nowrap;
    line-height:1;
  }
  .zoom-identity-owner .chip16{
    width:9px;
    height:9px;
    min-width:9px;
    min-height:9px;
    font-size:8px;
    border-width:1px;
    border-radius:3px;
    box-shadow:none;
  }
  .zoom-identity-multi{
    display:flex;
    align-items:flex-start;
    justify-content:center;
    gap:18px;
    flex-wrap:nowrap;
    max-width:min(98vw, 1500px);
    overflow-x:auto;
    padding:14px 16px 14px;
  }
  .zoom-identity-multi-item{
    position:relative;
    flex:0 0 auto;
    width:144px;
    height:286px;
  }
  .zoom-identity-multi-item-inner{
    position:relative;
    width:72px;
    height:108px;
    margin-top:44px;
    transform:scale(2);
    transform-origin:top left;
  }
  .role-hold-preview{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%) scale(1.9);
    transform-origin:center center;
    z-index:296;
    pointer-events:none;
  }
  .role-hold-preview.hidden{display:none;}
  .eliminated-dim{
    opacity:.7;
  }
  .marker-eliminated{
    opacity:.45;
  }
  .chip16.eliminated-clickable{
    opacity:.45;
    cursor:pointer;
  }
  .green-share-dock{
    position:fixed;
    left:50%;
    top:500px;
    transform:translateX(-50%);
    z-index:289;
    width:min(380px, calc(100vw - 40px));
    background:rgba(255,255,255,.96);
    border:1px solid rgba(0,0,0,.12);
    border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.26);
    padding:10px;
  }
  .green-share-dock.hidden{ display:none; }
  .green-share-dock.over-equip-expand{ z-index:294; }
  .green-share-title{
    font-size:13px;
    font-weight:900;
    margin:0 0 8px;
  }
  .green-share-subtitle{
    font-size:12px;
    margin:0 0 8px;
    color:#333;
    line-height:1.4;
  }
  .green-share-list{
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:8px;
  }
  .green-share-actions{
    display:flex;
    justify-content:flex-end;
    margin-top:-30px;
  }
  .green-share-actions.hidden{ display:none; }
  .green-share-btn{
    border:1px solid rgba(0,0,0,.15);
    border-radius:999px;
    background:#fff;
    width:100%;
    padding:4px 8px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    font-weight:700;
  }
  .green-share-btn.answer{
    justify-content:center;
    border-radius:8px;
    border-color:#111;
    background:#111;
    color:#fff;
  }
  .green-share-btn.answer:disabled{
    opacity:1;
    background:#b8b8b8;
    border-color:#b8b8b8;
    color:#fff;
  }
  .green-share-btn:disabled{
    opacity:.45;
    cursor:default;
  }
  .green-share-btn.skip-disabled,
  .green-share-btn.skip-disabled:disabled{
    opacity:1;
    background:#d1d5db;
    border-color:#d1d5db;
    color:#fff;
    cursor:not-allowed;
  }
  .green-share-btn.waiting-selected{
    opacity:1;
  }

  .green-reveal-panel{
    position:fixed;
    left:50%;
    top:50%;
    width:72px;
    height:108px;
    transform:translate(-50%,-50%) translateX(60px);
    z-index:281;
    pointer-events:none;
    opacity:0;
    transition:transform .35s ease, opacity .35s ease;
  }
  .zoom-backdrop.green-reveal-active .green-reveal-panel{
    transform:translate(-50%,-50%) translateX(95px);
    opacity:1;
  }
  .green-reveal-panel.hidden{ display:none; }
  .green-reveal-panel.reveal-slide-in .green-reveal-card-wrap .id72{
    animation:greenRevealSlideIn .42s cubic-bezier(.16,.84,.28,1);
  }
  @keyframes greenRevealSlideIn{
    from{ transform:translateX(220px) scale(2); opacity:0; }
    to{ transform:translateX(0) scale(2); opacity:1; }
  }
  .green-reveal-label{
    position:absolute;
    left:50%;
    top:calc(100% + 8px);
    transform:translateX(-50%);
    font-size:12px;
    font-weight:900;
    color:#fff;
    text-shadow:0 2px 8px rgba(0,0,0,.55);
    white-space:nowrap;
  }
  .green-reveal-card-wrap{
    position:absolute;
    inset:0;
  }
  .green-reveal-card-wrap .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    transform:scale(2);
    transform-origin:center;
  }

  .david-select-preview{
    position:fixed;
    left:50%;
    top:50%;
    width:72px;
    height:108px;
    transform:translate(-50%,-50%) translateX(95px);
    z-index:282;
    pointer-events:none;
    opacity:0;
    transition:transform .2s ease, opacity .2s ease;
  }
  .zoom-backdrop.david-select-active .david-select-preview{
    opacity:1;
  }
  .david-select-preview.hidden{ display:none; }
  .david-select-preview .card72,
  .david-select-preview .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    transform:scale(2);
    transform-origin:center;
  }

  /* ユーザー要望: すべてのボックスシャドウを無効化 */
  *, *::before, *::after{
    box-shadow:none !important;
  }
</style>
</head>
<body>

<header>
  <h1>シャドウ・レイダーズ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <div class="small" id="lastAttackToMeHeader" aria-live="polite"></div>
    <div class="small attack-roll-result-debug" id="attackRollResult" aria-live="polite"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="gameArea" class="game-area hidden" aria-label="ゲーム面">
      <div class="top-row">
        <div class="panel left-panel">
          <div id="hpBoard" class="hp-board" aria-label="HPボード"></div>
        </div>

        <div class="right-panel">
          <div class="panel map-panel">
            <svg id="roomSvg" class="room-svg" viewBox="-170 -170 340 340" preserveAspectRatio="xMidYMid meet" aria-label="部屋マップ">
              <g id="roomG"></g>
            </svg>
          </div>
          <div id="turnEndWrap" class="turn-end-wrap hidden">
            <button id="btnEndTurn" class="btn primary">手番を終わる</button>
          </div>
        </div>
      </div>

      <div class="cards-zone">
        <div id="positionLine" class="position-line hidden" aria-label="位置列"></div>
        <div class="panel cards-panel" id="cardsPanel" aria-label="デッキ">
          <div class="empty-cards-row">
            <div id="slot1" class="card72"></div>
            <div id="slot2" class="card72"></div>
            <div id="slot3" class="card72"></div>
            <div id="slot4" class="card72"></div>
            <div id="slot5" class="card72"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</main>

<!-- 拡大表示 -->
<div id="zoomBackdrop" class="zoom-backdrop hidden" aria-label="拡大表示">
  <div id="zoomStage" class="zoom-stage" style="--zoom:2"></div>
  <div id="greenRevealPanel" class="green-reveal-panel hidden" aria-live="polite">
    <div id="greenRevealLabel" class="green-reveal-label"></div>
    <div id="greenRevealCardWrap" class="green-reveal-card-wrap"></div>
  </div>
  <div id="davidSelectPreview" class="david-select-preview hidden" aria-hidden="true"></div>
  <div id="greenShareDock" class="green-share-dock hidden" aria-label="緑カード共有">
    <p class="green-share-title">誰に渡しますか。</p>
    <p id="greenShareSubtitle" class="green-share-subtitle hidden"></p>
    <div id="greenShareList" class="green-share-list"></div>
    <div id="greenShareActions" class="green-share-actions hidden">
      <button id="greenShareCloseBtn" class="btn ghost" type="button">閉じる</button>
    </div>
  </div>
</div>

<!-- 公開確認ポップ -->
<div id="revealPop" class="confirm-pop hidden" role="dialog" aria-label="公開確認">
  <p class="msg" id="revealMsg">公開しますか？</p>
  <div class="actions">
    <button class="btn primary" id="btnRevealYes">はい</button>
    <button class="btn ghost" id="btnRevealNo">いいえ</button>
  </div>
</div>

<div id="attackPop" class="confirm-pop hidden" role="dialog" aria-label="攻撃確認">
  <div class="caret" aria-hidden="true"></div>
  <p class="msg" id="attackMsg">攻撃しますか。</p>
  <div class="actions">
    <button class="btn primary" id="btnAttackYes">はい</button>
    <button class="btn ghost" id="btnAttackNo">いいえ</button>
  </div>
</div>

<div id="attackResultPop" class="confirm-pop bottom-fixed hidden" role="dialog" aria-label="攻撃結果確認">
  <div id="attackResultRows" class="attack-result-pop-rows"></div>
  <div class="actions">
    <button class="btn btn-excalibur hidden" id="btnAttackResultExcalibur" aria-label="エクスカリバー効果">
      <img src="exkariba.png" alt="エクスカリバー">
    </button>
    <button class="btn primary" id="btnAttackResultEnd">OKおわる</button>
    <button class="btn ghost" id="btnAttackResultKeep">OKおわらない</button>
  </div>
</div>

<div id="identityPromptPop" class="confirm-pop bottom-fixed hidden" role="dialog" aria-label="陣営公開確認">
  <p class="msg" id="identityPromptMsg"></p>
  <div class="actions">
    <button class="btn" id="btnIdentityPromptYes">はい</button>
    <button class="btn" id="btnIdentityPromptNo">いいえ</button>
  </div>
</div>

<div id="counterAbilityPop" class="confirm-pop bottom-fixed hidden" role="dialog" aria-label="反撃能力確認">
  <p class="msg" id="counterAbilityMsg"></p>
  <div class="actions">
    <button class="btn pop-dark" id="btnCounterAbilityUse">能力名(8)</button>
    <button class="btn ghost" id="btnCounterAbilitySkip">使わない</button>
  </div>
</div>

<div id="roomActionPop" class="confirm-pop hidden" role="dialog" aria-label="部屋効果確認">
  <div class="caret" aria-hidden="true"></div>
  <p class="msg" id="roomActionMsg"></p>
  <div class="actions">
    <button class="btn primary" id="btnRoomActionYes">はい</button>
    <button class="btn ghost" id="btnRoomActionNo">いいえ</button>
  </div>
</div>

<div id="turnHintPop" class="turn-hint-pop hidden" aria-live="polite"></div>

<div id="turnStartBoard" class="turn-start-board hidden" aria-hidden="true">
  <img src="turnboard.jpg" alt="手番開始ボード">
  <div id="turnStartBoardLabel" class="turn-start-board-label"></div>
</div>

<div id="endTurnConfirm" class="endturn-confirm hidden" role="dialog" aria-label="手番終了確認">
  <p class="msg" id="endTurnConfirmMsg">本当に終了しますか。</p>
  <div class="actions">
    <button class="btn primary" id="btnEndTurnYes">はい</button>
    <button class="btn ghost" id="btnEndTurnNo">いいえ</button>
  </div>
</div>


<div id="seatPopBackdrop" class="seat-pop-backdrop hidden" aria-label="座席カラータイル">
  <div class="seat-board" id="seatBoard">
    <div class="seat-board-title">
      <span>プレイヤーカラーを選択してください。</span>
      <span class="seat-count-badge" id="seatCountBadge">0 / 12</span>
    </div>
    <div id="tileGrid" class="tile-grid"></div>
    <div class="warn" id="startWarn">※ホストが「スタート」を押すと配布されます</div>

    <div class="seat-board-actions">
      <button id="btnSpectate" class="btn ghost">観戦</button>
    </div>
  </div>
</div>

<!-- 装備枠 -->
<div id="equipDock" class="equip-dock" aria-label="装備枠">
  <div class="equip-board">
    <div class="equip-body" id="equipBody"></div>
  </div>
</div>

<div id="myRoleDock" class="my-role-dock" aria-label="自分の正体カード">
  <div id="myRoleCard"></div>
</div>

<div id="agathaRevealOverlay" class="agatha-reveal-overlay hidden" aria-hidden="true"></div>
<div id="diceRollOverlay" class="dice-roll-overlay" aria-hidden="true"></div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn danger" id="btnKickYes">はい</button>
      <button class="btn ghost" id="btnKickNo">キャンセル</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="actionChatBtn" class="action-chat-btn" title="行動ログ" aria-label="行動ログ">💬</button>
<button id="roomGuideBtn" class="room-guide-btn" title="ルーム効果" aria-label="ルーム効果"><img src="map.png" alt="map"></button>
<button id="helpBtn" class="help-btn" title="カードリスト">？</button>

<div id="actionChatBackdrop" class="action-chat-backdrop hidden">
  <div class="action-chat-pop" role="dialog" aria-modal="true" aria-label="行動ログ">
    <div class="action-chat-header">
      <div>行動ログ</div>
      <button id="actionChatCloseBtn" class="btn ghost" type="button">閉じる</button>
    </div>
    <div id="actionChatBody" class="action-chat-body"></div>
  </div>
</div>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="カードリスト">
    <div class="help-pop-header">
      <div class="help-pop-title">カードリスト</div>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="equipExpandBackdrop" class="equip-expand-backdrop hidden">
  <div class="equip-expand-pop" role="dialog" aria-modal="true" aria-label="装備カードリスト">
    <div class="equip-expand-header">
      <div class="equip-expand-title">装備カードリスト</div>
    </div>
    <div class="equip-expand-body" id="equipExpandBody"></div>
  </div>
</div>

<div id="attackLootBackdrop" class="attack-loot-backdrop hidden">
  <div class="attack-loot-pop" role="dialog" aria-modal="true" aria-label="攻撃脱落後の装備奪取">
    <div class="attack-loot-header" id="attackLootHeader">脱落者の装備カード</div>
    <div class="attack-loot-body" id="attackLootBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    <span class="start-badge" id="startBadge">参加人数：0</span><br>
    「スタート」で参加人数に応じた構成で、全員に正体カードを1枚配布。<br>
    「リセット」で席・正体をリセットします。<br>
    <span class="small">開始後は座席変更できません。</span>
  </div>
  <div class="start-pop-actions">
    <button id="btnHostDice" class="btn ghost">ダイス</button>
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, set, get, update, onValue, remove, runTransaction } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
    authDomain: "timebomb-3b0c7.firebaseapp.com",
    databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
    projectId: "timebomb-3b0c7",
    storageBucket: "timebomb-3b0c7.firebasestorage.app",
    messagingSenderId: "532935786630",
    appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
    measurementId: "G-K8NRR8K64Y"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);
  const USER_NAME_CACHE_KEY = "bbCachedUserName";

  const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
  sessionStorage.setItem('bbUserId', savedUserId);

  function setHpRowHeights(map){
    const root = document.documentElement;
    for (let i=0;i<=15;i++){
      const key = `--hp-r${i}`;
      if (map && Object.prototype.hasOwnProperty.call(map, i)) {
        root.style.setProperty(key, String(map[i]));
      }
    }
  }

  const equipDock = document.getElementById("equipDock");
  const cardsPanel = document.getElementById("cardsPanel");

  function updateEquipDockTop(){
    if (!equipDock || !cardsPanel) return;
    const rect = cardsPanel.getBoundingClientRect();
    if (!Number.isFinite(rect.bottom) || rect.bottom <= 0) return;
    const gap = 6;
    const top = Math.round(rect.bottom + gap);
    const minTop = 80;
    equipDock.style.setProperty('--equip-top', `${Math.max(minTop, top)}px`);
  }
  window.addEventListener('resize', () => { updateEquipDockTop(); });

  const GREEN_DECK = [
    { text:"推理カード：正体カードを見せよ。" },
    { text:"推理カード：あなたは D / F / G / V / W ?（HP12以上）だったら2ダメージ受けよ。" },
    { text:"推理カード：あなたは A / B / C / E / U ?（HP11以下）だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら2ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か レイダー？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か レイダー？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
  ];

  const WHITE_DECK = [
    { name:"銀のロザリオ", effect:"装備、ダイスの攻撃によって倒したPLの全ての装備を奪う。" },
    { name:"銀のロザリオ", effect:"装備、ダイスの攻撃によって倒したPLの全ての装備を奪う。" },
    { name:"虹色のパラソル", effect:"装備、攻撃する代わりに攻撃レンジのPLに推理カードを渡す。" },
    { name:"エクスカリバー", effect:"装備、あなたがレイダーなら、攻撃ダメージが 2 上がる。" },
    { name:"神秘のコンパス", effect:"装備、移動の時にダイスを二回振って、選ぶことができる。" },
    { name:"幸運のブローチ", effect:"装備、市庁舎(8)の効果ダメージを受けない。" },
    { name:"賢者のローブ", effect:"装備、与える攻撃ダメージ、受ける攻撃ダメージが 1 減少する。" },
    { name:"いにしえの聖杯", effect:"装備、三つ目の黒犬,吸血コウモリ,呪いの人形の効果を受けない。" },
    { name:"光臨", effect:"あなたがレイダーなら、全ダメージを回復する。" },
    { name:"守護天使", effect:"次の自分の手番の始めまで、攻撃ダメージを受けない。" },
    { name:"封印の知恵", effect:"この手番の終了後、もう1手番を行う。" },
    { name:"応急手当", effect:"任意のPL（自分も可）を選び、そのPLのダメージを7にする。" },
    { name:"人魚の涙", effect:"最もダメージが多い人を 3 回復する。" },
    { name:"幸せのクッキー", effect:"あなたが A または U なら、HPを全回復する。" },
    { name:"闇を祓う鏡", effect:"あなたがシャドウ陣営でウルリッヒでないなら、必ず正体カードを公開する。" },
    { name:"いやしの聖水", effect:"自分のダメージを 2 回復する。" },
    { name:"いやしの聖水", effect:"自分のダメージを 2 回復する。" },
    { name:"いやしの聖水", effect:"自分のダメージを 2 回復する。" },
    { name:"裁きの閃光", effect:"自分以外のPL全員に 2 ダメージ与える。" },
    { name:"恩恵", effect:"自分以外のPLを選び、6面ダイスを振る。目の数回復する。" },
  ];

  const BLACK_DECK = [
    { name:"サーベル", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"拳銃R", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"拳銃L", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"クロスボウガン", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"妖刀マサムネ", effect:"装備、攻撃レンジにPLがいれば必ず攻撃を行う。4面ダイスだけを使う。" },
    { name:"ガトリング", effect:"装備、攻撃レンジのPL全員に攻撃する。" },
    { name:"死神スコープ", effect:"装備、攻撃レンジが 1 増加する。" },
    { name:"死神スコープ", effect:"装備、攻撃レンジが 1 増加する。" },
    { name:"オリバーの子分", effect:"任意のPLを選んで、装備を1つ奪う。" },
    { name:"オリバーの子分", effect:"任意のPLを選んで、装備を1つ奪う。" },
    { name:"オリバーの子分", effect:"任意のPLを選んで、装備を1つ奪う。" },
    { name:"吸血コウモリ", effect:"自分以外のPL1人に2ダメージ与え,自分は1回復する。" },
    { name:"吸血コウモリ", effect:"自分以外のPL1人に2ダメージ与え,自分は1回復する。" },
    { name:"吸血コウモリ", effect:"自分以外のPL1人に2ダメージ与え,自分は1回復する。" },
    { name:"三つ目の黒犬", effect:"自分と選んだPL1人に2ダメージ与える。" },
    { name:"三つ目の黒犬", effect:"自分と選んだPL1人に2ダメージ与える。" },
    { name:"暴動", effect:"ダイスを2つ振り、目のエリアにいるPL全員に3ダメージ与える。" },
    { name:"バナナの皮", effect:"装備を1つ誰かに渡す。なければ 1 ダメージ受ける。" },
    { name:"呪いの人形", effect:"PLを1人選び6面ダイスを振る。1-4なら選んだPLに、5-6なら自分に3ダメージ与える。" },
    { name:"戦慄の闇儀式", effect:"あなたがシャドウで正体を公開したら、全回復する。" },
  ];

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  function safeText(s){ return String(s ?? ""); }
  function escapeHtml(s){
    return safeText(s)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }
  function escHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function cardImageFileFromName(cardName){
    const safe = encodeURI(String(cardName || "").trim());
    return safe ? `${safe}.jpg` : "";
  }
  function rgbFromHex(hex){
    const h = String(hex||"").trim();
    if(!h.startsWith("#") || (h.length!==7 && h.length!==4)) return {r:0,g:0,b:0};
    if(h.length===4){
      const r = parseInt(h[1]+h[1],16);
      const g = parseInt(h[2]+h[2],16);
      const b = parseInt(h[3]+h[3],16);
      return {r,g,b};
    }
    const r = parseInt(h.slice(1,3),16);
    const g = parseInt(h.slice(3,5),16);
    const b = parseInt(h.slice(5,7),16);
    return {r,g,b};
  }
  function textColorFor(bgHex){
    const normalized = String(bgHex || "").trim().toLowerCase();
    const forceWhiteTextColors = new Set([
      "#ef4444", // 赤
      "#3b82f6", // 青
      "#111111", // 黒
      "#ec4899", // ピンク
      "#1e3a8a", // ネイビー
      "#16a34a", // 緑
      "#630d23", // 茶
      "#9b72b0", // パープル

    ]);
    const forceBlackTextColors = new Set([
      "#facc15", // 黄
      "#67e8f9", // 水色
      "#fb923c", // オレンジ
      "#ffffff", // 白
    ]);
    if (forceWhiteTextColors.has(normalized)) return "#fff";
    if (forceBlackTextColors.has(normalized)) return "#111";

    const {r,g,b} = rgbFromHex(bgHex);
    const L = (0.2126*r + 0.7152*g + 0.0722*b)/255;
    return (L < 0.55) ? "#fff" : "#111";
  }
  function firstChar(name){
    if(!name) return '';
    return Array.from(name.trim())[0] || '';
  }
  function isEquipCard(cardObj){
    const eff = safeText(cardObj?.effect || "").trim();
    if (!eff) return false;
    if (eff === "装備") return true;
    const prefixes = ["装備、","装備,","装備：","装備:","装備 "];
    return prefixes.some(p => eff.startsWith(p));
  }

  const ROOM_ALLOW = {
    1: ["white"],
    2: ["black"],
    5: ["green"],
    6: ["green","white","black"],
  };
  function allowedTypesByRoom(roomId){ return ROOM_ALLOW[roomId] || []; }
  function hasRainbowParasolEquip(uid = state.userId){
    if (!uid) return false;
    return listEquipForUid(uid).some(item => {
      if (isIdentityEquipItem(item)) return false;
      return safeText(item?.name || "").trim() === "虹色のパラソル";
    });
  }
  function canUseParasolGreenDraw(){
    if (!isMyTurn()) return false;
    if (!hasRainbowParasolEquip(state.userId)) return false;
    const turn = turnState() || {};
    if (!turn.moveDone || turn.attackDone) return false;
    if (remainingCount(deckCache?.green) <= 0) return false;

    const targetsInRange = highlightedMarkerUids();
    if (!(targetsInRange instanceof Set) || targetsInRange.size <= 0) return false;

    const drawnTypes = turn?.drawnTypes || {};
    const drewGreenThisTurn = !!drawnTypes.green;
    const drewAnyThisTurn = !!(drawnTypes.green || drawnTypes.white || drawnTypes.black);

    const roomId = Number(state.currentRoomId || 0);
    const roomForRule = roomId === 7 ? 10 : roomId;
    if ([1, 2, 3, 4, 10].includes(roomForRule)) return true;
    if (roomForRule === 5) return drewGreenThisTurn;
    if (roomForRule === 6) return drewAnyThisTurn;
    return false;
  }
  function canDrawTypeNormally(type){
    const allowed = allowedTypesByRoom(state.currentRoomId);
    if (!allowed.includes(type)) return false;
    return canDrawSharedDeckNow();
  }
  function canDrawSharedDeckNow(){
    if (!isMyTurn()) return false;
    const t = turnState() || {};
    if (isTestPlayer()) return !!t.moveDone && !t.attackDone;
    return !!t.moveDone && !t.attackDone && !t.deckDrawDone;
  }
  function canClickType(type){
    if (isIdentityPromptInteractionLockActive()) return false;
    if (cardPlayerSelectActive) return false;
    if (isEquipSelectionLockActive()) return false;
    if (canDrawTypeNormally(type)) return true;
    if (type === "green" && canUseParasolGreenDraw()) return true;
    return false;
  }

  function parasolBlockedDrawWarningMessage(){
    const roomId = Number(state.currentRoomId || 0);
    const drawnTypes = turnState()?.drawnTypes || {};
    if (roomId === 1 && !drawnTypes.white){
      return "この後、白カードがひけません。";
    }
    if (roomId === 2 && !drawnTypes.black){
      return "この後、白カードがひけません。";
    }
    return "";
  }
  function applyLocked(el, locked, {noDim=false} = {}){
    if (!el) return;
    el.classList.toggle("locked", !!locked && !noDim);
    el.classList.toggle("blocked", !!locked && !!noDim);
    if (!locked){
      el.classList.remove("locked","blocked");
    }
  }

  function adjustCardNameFont(rootEl, retryCount = 0){
    const nameEl = rootEl?.querySelector?.('.wb-name span');
    if (!nameEl) return;

    const frameEl = nameEl.closest('.wb-name');
    if (!frameEl) return;

    const availableWidth = frameEl.clientWidth;
    if (availableWidth <= 0){
      if (retryCount < 4){
        requestAnimationFrame(() => adjustCardNameFont(rootEl, retryCount + 1));
      }
      return;
    }

    const text = (nameEl.textContent || '').trim();
    if (!text){
      nameEl.style.fontSize = '';
      nameEl.style.transform = 'scaleX(1)';
      return;
    }

    const maxFontSize = 8;
    const minFontSize = 4;
    const frameWidth = Math.max(0, frameEl.clientWidth - 2);
    if (frameWidth <= 0) return;

    const computed = getComputedStyle(nameEl);
    const canvas = adjustCardNameFont._canvas || (adjustCardNameFont._canvas = document.createElement('canvas'));
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const measureTextWidth = (fontSize) => {
      ctx.font = `${computed.fontWeight} ${fontSize}px ${computed.fontFamily}`;
      return ctx.measureText(text).width;
    };

    let low = minFontSize;
    let high = maxFontSize;
    let best = minFontSize;
    while ((high - low) > 0.1){
      const mid = (low + high) / 2;
      if (measureTextWidth(mid) <= frameWidth){
        best = mid;
        low = mid;
      } else {
        high = mid;
      }
    }

    nameEl.style.fontSize = `${best.toFixed(2)}px`;
    const finalWidth = measureTextWidth(best);
    if (finalWidth > frameWidth){
      const scaleX = Math.max(0.72, frameWidth / Math.max(finalWidth, 1));
      nameEl.style.transform = `scaleX(${scaleX.toFixed(3)})`;
    } else {
      nameEl.style.transform = 'scaleX(1)';
    }
  }

  function ensureCountTag(el){
    let tag = el.querySelector('.count-tag');
    if (!tag){
      tag = document.createElement('div');
      tag.className = 'count-tag';
      el.appendChild(tag);
    }
    return tag;
  }

  function setSlotAsDeck(slotEl, imgUrl, count, { disabled=false, type=null } = {}){
    const left = Math.max(0, Number(count) || 0);
    const hideImage = left <= 0;
    slotEl.className = 'card72 deck' + (disabled ? ' disabled' : '');
    slotEl.classList.toggle("noframe", hideImage);
    slotEl.style.backgroundImage = hideImage ? 'none' : `url('${imgUrl}')`;
    slotEl.style.backgroundColor = hideImage ? 'transparent' : '';
    slotEl.innerHTML = '';
    if (!hideImage){
      const tag = ensureCountTag(slotEl);
      tag.textContent = String(left);
    }
    slotEl.dataset.cardType = type || "";
  }

  function buildWbFrontHTML(cardObj, theme){
    const name = safeText(cardObj?.name || "（なし）").trim();
    const img  = (theme === "green") ? "suiri.jpg" : cardImageFileFromName(name);

    let eff = safeText(cardObj?.effect || "");
    let showEquip = false;

    const trimmed = eff.trim();
    const prefixes = ["装備、","装備,","装備：","装備:","装備 "];
    for (const p of prefixes){
      if (trimmed.startsWith(p)){
        showEquip = true;
        eff = trimmed.slice(p.length).trim();
        break;
      }
    }
    if (!showEquip && trimmed === "装備"){
      showEquip = true;
      eff = "";
    }

    const tagHtml = showEquip ? `<span class="inline-tag">装備</span>` : "";
    const effHtml = escHtml(eff);

    return `
      <div class="wb-name"><span>${escHtml(name)}</span></div>
      <div class="wb-circle" aria-label="card image circle">
        ${img ? `<img src="${escHtml(img)}" alt="${escHtml(name)}">` : ``}
      </div>
      <div class="wb-effect">
        <div class="wb-desc">${tagHtml}${effHtml}</div>
      </div>
    `;
  }

  function setSlotAsWbFront(slotEl, cardObj, theme){
    slotEl.className = `card72 wb-front ${theme === 'black' ? 'wb-black' : theme === 'green' ? 'wb-green' : 'wb-white'}`;
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = buildWbFrontHTML(cardObj, theme);
    adjustCardNameFont(slotEl);
    slotEl.dataset.cardType = theme || "";
  }

  function setSlotEmpty(slotEl){
    slotEl.className = 'card72';
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = '';
    slotEl.dataset.cardType = "";
  }

  function setSlotEmptyNoFrame(slotEl){
    slotEl.className = 'card72 noframe';
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = '';
    slotEl.dataset.cardType = "";
  }

  const zoomBackdrop = document.getElementById("zoomBackdrop");
  const zoomStage = document.getElementById("zoomStage");
  const greenRevealPanel = document.getElementById("greenRevealPanel");
  const greenRevealLabel = document.getElementById("greenRevealLabel");
  const greenRevealCardWrap = document.getElementById("greenRevealCardWrap");
  const davidSelectPreview = document.getElementById("davidSelectPreview");
  const greenShareDock = document.getElementById("greenShareDock");
  const greenShareList = document.getElementById("greenShareList");
  const greenShareSubtitle = document.getElementById("greenShareSubtitle");
  const greenShareActions = document.getElementById("greenShareActions");
  const greenShareCloseBtn = document.getElementById("greenShareCloseBtn");
  function updateGreenShareDockPosition(){
    if (!greenShareDock || greenShareDock.classList.contains("hidden")) return;
    const gap = 10;
    const viewportPadding = 12;
    let top = 500;
    const zoomRect = zoomStage?.getBoundingClientRect?.();
    if (zoomRect && Number.isFinite(zoomRect.bottom) && zoomRect.height > 0){
      top = Math.round(zoomRect.bottom + gap);
    }
    const dockRect = greenShareDock.getBoundingClientRect();
    const dockHeight = (Number.isFinite(dockRect.height) && dockRect.height > 0) ? dockRect.height : 0;
    const maxTop = Math.max(viewportPadding, Math.round(window.innerHeight - dockHeight - viewportPadding));
    const clampedTop = Math.max(viewportPadding, Math.min(top, maxTop));
    greenShareDock.style.top = `${clampedTop}px`;
  }
  window.addEventListener("resize", () => {
    updateGreenShareDockPosition();
  });
  if (greenShareDock && greenShareDock.parentElement === zoomBackdrop){
    document.body.appendChild(greenShareDock);
  }
  let zoomCloseOnBackdrop = true;
  let zoomCloseOnAnyClick = false;
  let greenShareCard = null;
  let greenInboxSeenAt = 0;
  let greenInboxInitialized = false;
  let greenReplySeenAt = 0;
  let greenReplyInitialized = false;
  const greenHistoryLoggedRequestIds = new Set();
  let npcSpeechInitialized = false;
  let npcSpeechSeenAt = 0;
  let activeNpcSpeechByUid = {};
  let npcGreenAutoHandledResponseAtBySender = {};
  let greenZoomLocked = false;
  let pendingGreenRequestId = "";
  let pendingGreenAnswerMsg = null;
  let pendingGreenCloseSeenAt = 0;
  let pendingGreenCloseInitialized = false;
  let greenRevealByRequestId = {};
  let greenSessionInitialized = false;
  let greenSessionRestoring = false;
  let greenSessionSeenAt = 0;
  let pendingGreenSessionEntry = null;
  let greenTurnEndButtonLockActive = false;
  let cardTargetSessionInitialized = false;
  let cardTargetSessionRestoring = false;
  let cardTargetSessionSeenAt = 0;
  let pendingCardTargetSessionEntry = null;
  let roleAbilitySelectionInitialized = false;
  let roleAbilitySelectionSeenAt = 0;
  let activeRoleAbilitySelection = null;
  const TURN_START_ONLY_REVEAL_ROLE_IDS = new Set([
    "CIT_D2", // デーヴィッド
    "CIT_D3", // デボラ
    "CIT_A1", // アリス
    "CIT_C3", // クレア
    "CIT_C2", // キャロル
    "RAI_E2", // エリカ
    "RAI_F1", // フェリックス
    "RAI_F2", // フェリシア
    "SHA_U2", // ウラヌス
  ]);
  const START_ONLY_ABILITY_ROLE_IDS = new Set(["RAI_E2", "RAI_F1", "RAI_F2"]);
  const REVEAL_ENDS_TURN_ROLE_IDS = new Set([
    "CIT_B2", // ベンジャミン
    "RAI_E3", // エマ
    "RAI_G1", // ゴードン
    "SHA_W1", // ワイト
  ]);
  let cardPlayerSelectActive = false;
  let activeGreenReplies = {};
  let moveDiceEventSeenAt = 0;
  let moveDiceEventInitialized = false;
  let attackDiceEventSeenAt = 0;
  let attackDiceEventInitialized = false;
  let cardDiceEventSeenAt = 0;
  let cardDiceEventInitialized = false;
  const deckRebuildTimers = { green:null, white:null, black:null };
  let equipSelectionStartedFromExpand = false;
  let roleFlashEventSeenAt = 0;
  let roleFlashEventInitialized = false;
  let hpSwapEventSeenAt = 0;
  let hpSwapEventInitialized = false;
  let walpurgisSwapEventSeenAt = 0;
  let walpurgisSwapEventInitialized = false;
  let identityZoomEventSeenAt = 0;
  let identityZoomEventInitialized = false;
  let roleFlashTimer = null;
  let roleFlashOverlayEl = null;
  let persistentVenomOverlayEl = null;
  let identityRevealInitialized = false;
  let identityRevealSeenByUid = {};
  let autoDamageRevealLock = {};
  let temporaryRoleTagByUid = {};
  let roomAbilityTurnKey = "";
  let room4StealUsed = false;
  let room3ActionUsed = false;
  const walpurgisSwapHiddenUids = new Set();
  let movedByDiceRoomId = null;
  let suppressSelfTurnStartPulse = false;
  let pendingRoomAction = null;
  let suppressTurnButtonUntilNextTurnStart = false;
  let uranusMeteorResolved = false;
  let vampireHiddenAttackSuccess = false;
  let pendingEquipAction = null;
  let pendingCardTargetSelection = null;
  let danielAutoRevealTimer = null;
  let bruceAutoRevealTimer = null;
  let carolTurnHealTimer = null;
  let carolTurnHealKey = "";
  let gordonBarrierClearTurnKey = "";
  let effectResolutionLocks = {};
  let zoomPassthroughMode = false;
  let zoomDismissHandler = null;
  let hpBoardAnimationActive = false;
  let suppressOutsidePopCloseUntil = 0;
  let pendingRevealAction = "";
  let attackTurnEndChoicePending = false;
  let pendingAttackResolution = null;
  let pendingAttackResultMeta = null;
  let attackResultChoiceBusy = false;
  let ulsterExtraAttackPending = 0;
  let ulsterExtraAttackGuideShown = false;
  let attackFlowUiLockActive = false;
  let suppressEndTurnButton = false;
  let pendingHpSwapAnimation = null;
  let attackAbilityUsedTurnByRole = {};
  let attackAbilityUsageTurnOwnerUid = "";
  let turnStartBoardTurnKey = "";
  let autoIdentityRevealTimer = null;
  let autoIdentityRevealTimerKey = "";
  let lastEliminationBatch = { uids: [], at: 0 };
  const lastKnownNameByUid = {};
  const lastKnownRoleNameByUid = {};
  let lastAttackRollLogContext = null;

  const AUTO_IDENTITY_REVEAL_BY = "auto_endgame_batch";
  const DAVID_WIN_GEAR_NAMES = new Set(["銀のロザリオ", "神秘のコンパス", "幸運のブローチ", "幸福のブローチ", "いにしえの聖杯"]);
  const NPC_FOREIGN_NAMES = [
    "Alex","Brian","Chris","Diana","Emma","Felix","Grace","Henry","Iris","Jason",
    "Kevin","Luna","Mia","Noah","Olivia","Parker","Quinn","Ruby","Sophia","Victor"
  ];

  const waitMs = (ms) => new Promise(resolve => setTimeout(resolve, ms));

  const revealPop = document.getElementById("revealPop");
  const revealMsg = document.getElementById("revealMsg");
  const btnRevealYes = document.getElementById("btnRevealYes");
  const btnRevealNo  = document.getElementById("btnRevealNo");
  const attackPop = document.getElementById("attackPop");
  const attackMsg = document.getElementById("attackMsg");
  const btnAttackYes = document.getElementById("btnAttackYes");
  const btnAttackNo = document.getElementById("btnAttackNo");
  const attackResultPop = document.getElementById("attackResultPop");
  const attackResultRows = document.getElementById("attackResultRows");
  const btnAttackResultEnd = document.getElementById("btnAttackResultEnd");
  const btnAttackResultKeep = document.getElementById("btnAttackResultKeep");
  const btnAttackResultExcalibur = document.getElementById("btnAttackResultExcalibur");
  const roomActionPop = document.getElementById("roomActionPop");
  const roomActionMsg = document.getElementById("roomActionMsg");
  const btnRoomActionYes = document.getElementById("btnRoomActionYes");
  const btnRoomActionNo = document.getElementById("btnRoomActionNo");
  const turnHintPop = document.getElementById("turnHintPop");
  const turnStartBoard = document.getElementById("turnStartBoard");
  const turnStartBoardLabel = document.getElementById("turnStartBoardLabel");
  const identityPromptPop = document.getElementById("identityPromptPop");
  const identityPromptMsg = document.getElementById("identityPromptMsg");
  const btnIdentityPromptYes = document.getElementById("btnIdentityPromptYes");
  const btnIdentityPromptNo = document.getElementById("btnIdentityPromptNo");
  const counterAbilityPop = document.getElementById("counterAbilityPop");
  const counterAbilityMsg = document.getElementById("counterAbilityMsg");
  const btnCounterAbilityUse = document.getElementById("btnCounterAbilityUse");
  const btnCounterAbilitySkip = document.getElementById("btnCounterAbilitySkip");
  let pendingAttackTargetUid = "";
  let pendingIdentityPrompt = null;
  let counterAbilityCountdownTimer = null;
  let activeCounterPromptAt = 0;
  let seatPromptUnsubscribe = null;
  let subscribedSeatPromptIndex = null;
  let restoringSeatIdentityPrompt = false;
  let seatEquipSelectionUnsubscribe = null;
  let subscribedSeatEquipSelectionIndex = null;
  let restoringSeatEquipSelection = false;

  const IDENTITY_PROMPT_CARD_NAMES = new Set(["幸せのクッキー", "光臨", "戦慄の闇儀式"]);
  const IDENTITY_REVEAL_POP_BLOCK_CARD_NAMES = new Set([
    "三つ目の黒犬",
    "吸血コウモリ",
    "呪いの人形",
    "戦慄の闇儀式",
    "応急手当",
    "光臨",
    "恩恵",
    "幸せのクッキー"
  ]);

  function setTurnStartBoardLabel(text){
    if (!turnStartBoardLabel) return;
    turnStartBoardLabel.innerHTML = "";
    Array.from(safeText(text || "")).forEach((ch, idx) => {
      const span = document.createElement("span");
      span.textContent = ch;
      span.className = (idx % 2 === 0) ? "char-odd" : "char-even";
      turnStartBoardLabel.appendChild(span);
    });
  }

  function hideTurnStartBoard(){
    turnStartBoard?.classList.add("hidden");
  }

  function showTurnStartBoard(){
    setTurnStartBoardLabel("あなたの手番");
    turnStartBoard?.classList.remove("hidden");
  }

  function syncTurnStartBoard(){
    if (!isGameStarted()){
      turnStartBoardTurnKey = "";
      hideTurnStartBoard();
      return;
    }
    const turn = turnState() || {};
    const key = turnCycleKey();
    if (!isMyTurn()){
      if (turnStartBoardTurnKey && turnStartBoardTurnKey !== key){
        turnStartBoardTurnKey = key;
      }
      hideTurnStartBoard();
      return;
    }
    if (!!turn.moveDone){
      hideTurnStartBoard();
      return;
    }
    if (!key || key === turnStartBoardTurnKey) return;
    turnStartBoardTurnKey = key;
    showTurnStartBoard();
  }

  document.addEventListener("pointerdown", (e) => {
    if (turnStartBoard?.classList.contains("hidden")) return;
    if (!e.isPrimary || e.button !== 0) return;
    hideTurnStartBoard();
  }, true);

  function turnRoomActionState(){
    const t = turnState() || {};
    return {
      movedByDiceRoomId: Number(t.movedByDiceRoomId || 0) || null,
      room3ActionUsed: !!t.room3ActionUsed,
      room4StealUsed: !!t.room4StealUsed
    };
  }

  async function updateTurnRoomActionState(patch = {}){
    if (!state.roomCode) return;
    const next = {};
    if (Object.prototype.hasOwnProperty.call(patch, "movedByDiceRoomId")){
      const rid = Number(patch.movedByDiceRoomId || 0) || null;
      next.movedByDiceRoomId = rid;
    }
    if (Object.prototype.hasOwnProperty.call(patch, "room3ActionUsed")){
      next.room3ActionUsed = !!patch.room3ActionUsed;
    }
    if (Object.prototype.hasOwnProperty.call(patch, "room4StealUsed")){
      next.room4StealUsed = !!patch.room4StealUsed;
    }
    if (!Object.keys(next).length) return;
    await update(ref(db, `rooms/${state.roomCode}/turn`), next);
  }

  function placeFloatingPop(popEl, clientX, clientY, { yOffset = 0 } = {}){
    if (!popEl) return;
    const pad = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const r = popEl.getBoundingClientRect();

    let x = Number(clientX);
    let y = Number(clientY);
    if (!Number.isFinite(x)) x = vw / 2;
    if (!Number.isFinite(y)) y = vh / 2;

    const halfW = r.width / 2;
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;

    let top = y + 18 + Number(yOffset || 0);
    if (top + r.height > vh - pad) top = y - r.height - 18;
    top = Math.max(pad, Math.min(top, vh - pad - r.height));

    popEl.style.left = x + "px";
    popEl.style.top = top + "px";
  }

  function getZoomPrimaryCardEl(){
    if (!zoomBackdrop || !zoomStage) return null;
    if (zoomBackdrop.classList.contains("hidden")) return null;
    return zoomStage.querySelector('.card72, .id72');
  }

  function placePopUnderAnchor(popEl, anchorEl, { gap = 10 } = {}){
    if (!popEl || !anchorEl) return false;
    const pad = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const anchorRect = anchorEl.getBoundingClientRect();
    const popRect = popEl.getBoundingClientRect();
    const halfW = popRect.width / 2;
    let x = anchorRect.left + (anchorRect.width / 2);
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;
    let top = anchorRect.bottom + Number(gap || 0);
    if (top + popRect.height > vh - pad){
      top = Math.max(pad, anchorRect.top - popRect.height - Number(gap || 0));
    }
    top = Math.max(pad, Math.min(top, vh - pad - popRect.height));
    popEl.style.left = `${x}px`;
    popEl.style.top = `${top}px`;
    return true;
  }

  function skipRoom3ActionAndStartAttack(){
    if (!canUseRoom3Action()) return;
    room3ActionUsed = true;
    updateTurnRoomActionState({ room3ActionUsed:true });
    hideRoomActionPop();
    hideAttackResultPop();
    clearAttackResultDice();
    pendingAttackResolution = null;
    pendingAttackResultMeta = null;
    attackTurnEndChoicePending = false;
    attackFlowUiLockActive = false;
    cachePendingAttackResolution(null);
    showTurnHint("");
    renderMarkers();
  }

  function roleAbilityName(role){
    const effect = safeText(role?.effect || "").trim();
    if (!effect) return "特殊能力";
    const match = effect.match(/^([^：:]+)[：:]/);
    return safeText(match?.[1] || effect).trim() || "特殊能力";
  }

  const ROLE_SELECTION_SPECS = {
    "RAI_F2": { usageKey:"felicia", abilityName:"スラム街の天使", prompt:"ダメージを7にするプレイヤーを選んでください。" },
    "RAI_F1": { usageKey:"felix", abilityName:"アストラル・メイス", prompt:"ダメージを与えるプレイヤーを選んでください。" },
    "RAI_E2": { usageKey:"erika", abilityName:"封印の鎖", prompt:"特殊能力を失わせるプレイヤーを選んでください。" },
    "RAI_E3": { usageKey:"emma", abilityName:"癒しの光", prompt:"回復させるプレイヤーを選んでください。", perTurn:true },
    "RAI_G3": { usageKey:"godwin", abilityName:"蘇生装置TYPE-G", prompt:"復活させるプレイヤーを選んでください。" },
    "CIT_C3": { usageKey:"claire", abilityName:"キャスリングTYPE-G", prompt:"ダメージを入れ替えるプレイヤーを選んでください。" },
    "CIT_B2": { usageKey:"benjamin", abilityName:"太鼓持ち", prompt:"装備を渡す相手を選んでください。", endTurnAfterResolve:true, perTurn:true },
    "SHA_U2": { usageKey:"uranus", abilityName:"メテオストライク", prompt:"ダメージを与えるプレイヤーを選んでください。", perTurn:true },
    "SHA_W2": { usageKey:"walpurgis", abilityName:"重力の虹", prompt:"位置を交換するプレイヤーを選んでください。", perTurn:true },
  };

  function roleSelectionSpec(roleId){ return ROLE_SELECTION_SPECS[safeText(roleId || "")] || null; }
  function isRoleSelectionAbility(roleId){
    const rid = safeText(roleId || "");
    if (rid === "SHA_W2") return false;
    return !!roleSelectionSpec(rid);
  }
  function isRoleAbilityUsed(roleId){
    const spec = roleSelectionSpec(roleId);
    if (!spec || !state.userId) return false;
    if (spec.perTurn){
      const usedTurn = safeText(state.room?.abilityUsage?.[spec.usageKey]?.[state.userId] || "");
      return usedTurn && usedTurn === currentTurnKey();
    }
    return !!state.room?.abilityUsage?.[spec.usageKey]?.[state.userId];
  }
  async function markRoleAbilityUsed(roleId){
    const spec = roleSelectionSpec(roleId);
    if (!spec || !state.roomCode || !state.userId) return;
    const value = spec.perTurn ? currentTurnKey() : true;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/${spec.usageKey}/${state.userId}`), value);
  }

  function currentTurnKey(){
    const turn = turnState();
    return `${safeText(turn?.currentPlayerId || "")}@${Number(turn?.updatedAt || 0)}`;
  }

  function showRevealPopAt(anchorEl, options = {}){
    const role = myRoleInfo();
    const ability = roleAbilityName(role);
    const mode = options.mode === "notice" ? "notice" : "confirm";
    const message = safeText(options.message || "").trim();
    pendingRevealAction = safeText(options.action || "");
    if (revealMsg){
      if (mode === "notice"){
        revealMsg.textContent = message || "手番の初めにだけ正体を公開できます。";
        pendingRevealAction = "";
      } else if (options.messageHtml){
        revealMsg.innerHTML = String(options.messageHtml);
      } else {
        const suffix = options.appendEndTurnNotice ? "使用後に手番が終了します。" : "";
        revealMsg.innerHTML = `正体を公開して、<span class="ability-pill">${ability}</span>を使いますか。${suffix}`;
      }
    }
    btnRevealYes?.classList.toggle("hidden", mode === "notice");
    btnRevealNo?.classList.toggle("hidden", mode === "notice");
    if (btnRevealNo){
      btnRevealNo.textContent = "いいえ";
    }
    revealPop.classList.remove("hidden");
    if (!anchorEl){
      const zoomAnchor = getZoomPrimaryCardEl();
      if (placePopUnderAnchor(revealPop, zoomAnchor, { gap:10 })) return;
      placeFloatingPop(revealPop, window.innerWidth / 2, window.innerHeight / 2);
      return;
    }
    placePopUnderAnchor(revealPop, anchorEl, { gap:10 });
  }
  function hideRevealPop(){
    revealPop.classList.add("hidden");
    pendingRevealAction = "";
  }

  function eliminatedPlayerCount(){
    return latestPlayers.filter(p => isPlayerEliminated(p.id)).length;
  }

  function isWightAbilityUsed(){
    return !!state.room?.abilityUsage?.wight?.[state.userId];
  }

  async function markWightAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/wight/${state.userId}`), true);
  }

  function isAliceAbilityUsed(){
    return !!state.room?.abilityUsage?.alice?.[state.userId];
  }

  async function markAliceAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/alice/${state.userId}`), true);
  }

  function canUseAliceAbilityNow(){
    if (!isMyRole("CIT_A1")) return { ok:false, message:"今は使えません。" };
    if (!isMyTurn()) return { ok:false, message:"今は使えません。" };
    if (isMyAbilitySealed()) return { ok:false, message:"今は使えません。" };
    if (isAliceAbilityUsed()) return { ok:false, message:"この能力はすでに使用済みです。" };
    if (!!turnState()?.moveDone) return { ok:false, message:"手番の初めにだけ使えます。" };
    return { ok:true };
  }

  function canUseWightAbilityNow(){
    if (!isMyRole("SHA_W1")) return { ok:false, message:"今は公開できません。" };
    if (isWightAbilityUsed()) return { ok:false, message:"今は公開できません。" };
    if (isMyAbilitySealed()) return { ok:false, message:"今は公開できません。" };
    if (!turnState()?.moveDone) return { ok:false, message:"今は公開できません。" };
    const eliminated = eliminatedPlayerCount();
    if (eliminated <= 0) return { ok:false, message:"今は公開できません。" };
    return { ok:true, eliminated };
  }

  async function activateWightAbilityAndEndTurn(){
    const check = canUseWightAbilityNow();
    if (!check.ok) return false;
    suppressTurnButtonUntilNextTurnStart = true;
    await markWightAbilityUsed();
    await update(ref(db, `rooms/${state.roomCode}/turn`), {
      repeatTurnRemaining: check.eliminated,
      repeatTurnTotal: check.eliminated,
      updatedAt: Date.now()
    });
    await doEndTurn();
    return true;
  }

  function showAttackPopAt(clientX, clientY, targetName){
    if (!attackPop) return;

    if (hasMyEquipmentByName("ガトリング")){
      attackMsg.textContent = "レンジ内のプレイヤー全員を攻撃します。はい、いいえ";
    } else {
      attackMsg.textContent = `${safeText(targetName || "このプレイヤー")}を攻撃しますか。`;
    }
    attackPop.classList.remove("hidden");
    placeFloatingPop(attackPop, clientX, clientY);
  }
  function hideAttackPop(){
    pendingAttackTargetUid = "";
    attackPop?.classList.add("hidden");
  }

  function showTurnHint(message, options = {}){
    if (!turnHintPop) return;
    const opts = (message && typeof message === "object") ? message : options;
    const text = (message && typeof message === "object")
      ? safeText(message.text || "")
      : safeText(message || "");
    const showSkip = !!opts.showRoom3Skip;
    const multiline = !!opts.multiline;

    turnHintPop.innerHTML = "";
    turnHintPop.classList.toggle("multiline", multiline);

    if (text){
      const textWrap = document.createElement("span");
      textWrap.textContent = text;
      turnHintPop.appendChild(textWrap);
    }
    if (showSkip){
      const btn = document.createElement("button");
      btn.className = "btn ghost turn-hint-action";
      btn.textContent = "スキップ(して攻撃)";
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        skipRoom3ActionAndStartAttack();
      });
      turnHintPop.appendChild(btn);
    }
    turnHintPop.classList.toggle("hidden", !text && !showSkip);
  }

  function hideDavidSelectPreview(){
    zoomBackdrop?.classList.remove("david-select-active");
    davidSelectPreview?.classList.add("hidden");
    if (davidSelectPreview) davidSelectPreview.innerHTML = "";
  }

  function showDavidSelectPreviewFromCard(cardEl){
    if (!davidSelectPreview || !cardEl) return;
    const clone = cardEl.cloneNode(true);
    clone.classList.remove("locked","blocked","equip-steal-pulse","equip-defeat-pulse","eliminated-dim");
    clone.style.pointerEvents = "none";
    davidSelectPreview.innerHTML = "";
    davidSelectPreview.appendChild(clone);
    davidSelectPreview.classList.remove("hidden");
    zoomBackdrop?.classList.add("david-select-active");
  }

  function hideRoomActionPop(){
    pendingRoomAction = null;
    roomActionPop?.classList.add("hidden");
    roomActionPop?.classList.remove("lower-mode", "room3-mode", "no-caret", "hide-actions", "text-fit", "no-wrap");
    if (btnRoomActionYes){
      btnRoomActionYes.textContent = "はい";
      btnRoomActionYes.disabled = false;
      btnRoomActionYes.classList.remove("pop-purple","pop-white","pop-disabled");
    }
    if (btnRoomActionNo){
      btnRoomActionNo.textContent = "いいえ";
      btnRoomActionNo.disabled = false;
      btnRoomActionNo.classList.remove("pop-purple","pop-white","pop-disabled");
    }
    if (pendingEquipAction?.type === "david_select") hideDavidSelectPreview();
  }

  function showRoomActionPopAt(clientX, clientY, message, onYes, options = {}){
    if (!roomActionPop || !roomActionMsg) return;
    const fixedLower = !!options.fixedLower;
    const compactButtons = !!options.compactButtons;
    const yOffset = Number(options.yOffset) || 0;
    const noCaret = !!options.noCaret;
    const hideActions = !!options.hideActions;
    const fitText = !!options.fitText;
    const noWrap = !!options.noWrap;
    pendingRoomAction = {
      onYes: (typeof onYes === "function") ? onYes : null,
      onNo: (typeof options.onNo === "function") ? options.onNo : null,
      closeZoomOnNo: !!options.closeZoomOnNo,
      dismissOnOutside: options.dismissOnOutside !== false
    };
    const yesBtnClass = safeText(options.yesBtnClass || "");
    const noBtnClass = safeText(options.noBtnClass || "");
    if (options.messageHtml){
      roomActionMsg.innerHTML = String(options.messageHtml);
    } else {
      roomActionMsg.textContent = safeText(message || "");
    }
    if (btnRoomActionYes){
      const yesDisabled = !!options.yesDisabled;
      btnRoomActionYes.textContent = safeText(options.yesLabel || "はい");
      btnRoomActionYes.disabled = yesDisabled;
      btnRoomActionYes.classList.remove("pop-purple","pop-white","pop-disabled");
      if (yesBtnClass) btnRoomActionYes.classList.add(yesBtnClass);
      if (yesDisabled) btnRoomActionYes.classList.add("pop-disabled");
    }
    if (btnRoomActionNo){
      const noDisabled = !!options.noDisabled;
      btnRoomActionNo.textContent = safeText(options.noLabel || "いいえ");
      btnRoomActionNo.disabled = noDisabled;
      btnRoomActionNo.classList.remove("pop-purple","pop-white","pop-disabled");
      if (noBtnClass) btnRoomActionNo.classList.add(noBtnClass);
      if (noDisabled) btnRoomActionNo.classList.add("pop-disabled");
    }
    roomActionPop.classList.remove("hidden");
    roomActionPop.classList.toggle("lower-mode", fixedLower);
    roomActionPop.classList.toggle("room3-mode", compactButtons);
    roomActionPop.classList.toggle("no-caret", noCaret);
    roomActionPop.classList.toggle("hide-actions", hideActions);
    roomActionPop.classList.toggle("text-fit", fitText);
    roomActionPop.classList.toggle("no-wrap", noWrap);

    if (fixedLower){
      roomActionPop.style.left = "";
      roomActionPop.style.top = "";
      roomActionPop.style.transform = "";
      return;
    }

    const zoomAnchor = getZoomPrimaryCardEl();
    if (placePopUnderAnchor(roomActionPop, zoomAnchor, { gap:10 })){
      roomActionPop.style.transform = "translateX(-50%)";
      return;
    }

    const pad = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const r = roomActionPop.getBoundingClientRect();
    let x = clientX;
    let y = clientY;
    const halfW = r.width / 2;
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;
    let top = y + 18 + yOffset;
    if (top + r.height > vh - pad) top = y - r.height - 18;
    top = Math.max(pad, Math.min(top, vh - pad - r.height));
    roomActionPop.style.left = x + "px";
    roomActionPop.style.top  = top + "px";
    roomActionPop.style.transform = "translate(-50%,-10px)";
  }

  function hideIdentityPrompt(){
    pendingIdentityPrompt = null;
    identityPromptPop?.classList.add("hidden");
  }

  function isIdentityPromptInteractionLockActive(){
    if (!pendingIdentityPrompt?.closeZoomOnChoice) return false;
    return !identityPromptPop?.classList.contains("hidden");
  }

  function canInteractWithMapPlayerIcons(){
    return !isIdentityPromptInteractionLockActive() && !cardPlayerSelectActive;
  }

  function isCounterRole(roleId){
    const id = safeText(roleId || "");
    return id === "SHA_W3" || id === "SHA_V1";
  }

  function counterPromptEntryForMe(){
    const uid = safeText(state.userId || "");
    if (!uid) return null;
    const entry = state.room?.counterPromptState?.[uid];
    if (!entry) return null;
    return {
      ...entry,
      uid,
      roleId: safeText(entry?.roleId || ""),
      attackerUid: safeText(entry?.attackerUid || ""),
      turnKey: safeText(entry?.turnKey || ""),
      advanceTurnOnResolve: !!entry?.advanceTurnOnResolve,
      mustChoose: !!entry?.mustChoose,
      mode: safeText(entry?.mode || ""),
      venomUid: safeText(entry?.venomUid || ""),
      expiresAt: Number(entry?.expiresAt || 0),
      at: Number(entry?.at || 0)
    };
  }

  function isVenomSelectionEntry(entry){
    return !!entry && safeText(entry.roleId || "") === "SHA_V1" && safeText(entry.mode || "") === "venom_resolution";
  }

  function isCounterPromptSilentIdentityClickWindow(){
    const entry = counterPromptEntryForMe();
    if (!entry) return false;
    if (!isCounterRole(myRoleInfo()?.id || "")) return false;
    if (isMyTurn()) return false;
    if (!entry.attackerUid || currentTurnPlayerId() !== entry.attackerUid) return false;
    return true;
  }

  function isCounterAbilityBlockedByGuardianShield(entry){
    if (!entry) return false;
    if (safeText(entry.roleId || "") !== "SHA_W3") return false;
    return hasGuardianAngelShield(entry.attackerUid);
  }

  async function clearCounterPromptForMe(expectedAt = null){
    const uid = safeText(state.userId || "");
    if (!uid || !state.roomCode) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let removedEntry = null;
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const map = cur.counterPromptState || {};
      const mine = map[uid];
      if (!mine) return cur;
      if (expectedAt != null && Number(mine.at || 0) !== Number(expectedAt || 0)) return cur;
      removedEntry = {
        roleId: safeText(mine.roleId || ""),
        attackerUid: safeText(mine.attackerUid || ""),
        turnKey: safeText(mine.turnKey || ""),
        advanceTurnOnResolve: !!mine.advanceTurnOnResolve
      };
      delete map[uid];
      if (Object.keys(map).length === 0){
        delete cur.counterPromptState;
      } else {
        cur.counterPromptState = map;
      }
      return cur;
    });
    return removedEntry;
  }

  async function tryAdvanceTurnAfterCounterChoice(resolvedEntry){
    if (!resolvedEntry?.advanceTurnOnResolve) return;
    if (!state.roomCode) return;
    const attackerUid = safeText(resolvedEntry.attackerUid || "");
    const turnKey = safeText(resolvedEntry.turnKey || "");
    if (!attackerUid || !turnKey) return;

    const stillPending = Object.values(state.room?.counterPromptState || {}).some((entry) => {
      if (!entry) return false;
      return !!entry.advanceTurnOnResolve
        && safeText(entry.attackerUid || "") === attackerUid
        && safeText(entry.turnKey || "") === turnKey;
    });
    if (stillPending) return;

    if (currentTurnPlayerId() !== attackerUid) return;
    await advanceTurnToNextPlayer();
  }

  async function resolveVenomCounterChoiceForUid(actorUid, choice, sourceKey = ""){
    if (!state.roomCode) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const resolvedActorUid = safeText(actorUid || "");
    const action = safeText(choice || "");
    const srcKey = safeText(sourceKey || "");
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur || !resolvedActorUid) return cur;
      const counterMap = cur.counterPromptState || {};
      const entry = counterMap[resolvedActorUid];
      if (!isVenomSelectionEntry(entry)) return cur;
      const venomUid = safeText(entry.venomUid || "");
      if (!venomUid) return cur;

      if (action === "give"){
        const mine = cur.equipment?.[resolvedActorUid] || {};
        const item = mine[srcKey];
        if (!item || item.kind === "identity") return cur;
        const oldCount = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
        if (oldCount > 1){
          const next = { ...item, count: oldCount - 1 };
          delete next.qty;
          delete next.quantity;
          mine[srcKey] = next;
        } else {
          delete mine[srcKey];
        }
        cur.equipment = cur.equipment || {};
        cur.equipment[venomUid] = cur.equipment[venomUid] || {};
        const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
        cur.equipment[venomUid][addKey] = {
          theme: safeText(item.theme || "white"),
          name: safeText(item.name || ""),
          effect: safeText(item.effect || ""),
          at: Date.now()
        };
      } else if (action === "damage"){
        const before = clampDamage(cur.damage?.[resolvedActorUid]);
        cur.damage = cur.damage || {};
        cur.damage[resolvedActorUid] = before + 1;
      } else {
        return cur;
      }

      delete counterMap[resolvedActorUid];
      if (Object.keys(counterMap).length === 0) delete cur.counterPromptState;
      else cur.counterPromptState = counterMap;

      if (!!entry.advanceTurnOnResolve){
        const stillPending = Object.values(counterMap).some((v) => !!v && !!v.advanceTurnOnResolve && safeText(v.attackerUid || "") === safeText(entry.attackerUid || "") && safeText(v.turnKey || "") === safeText(entry.turnKey || ""));
        if (!stillPending){
          const order = Array.isArray(cur.positionOrder) ? cur.positionOrder : [];
          const isEliminatedInRoom = (uid) => {
            const hand = cur.hands?.[uid];
            const role = hand?.roleId ? ROLE_BY_ID[hand.roleId] : null;
            const hp = Number(role?.hp || 0);
            if (!hp) return false;
            return clampDamage(cur.damage?.[uid]) >= hp;
          };
          const aliveOrder = order.filter(uid => !isEliminatedInRoom(uid));
          const curId = safeText(cur.turn?.currentPlayerId || "");
          let idx = aliveOrder.indexOf(curId);
          if (idx < 0) idx = 0;
          const nextPlayerId = safeText(aliveOrder[(idx + 1) % Math.max(1, aliveOrder.length)] || "");
          if (nextPlayerId){
            cur.turn = {
              currentPlayerId: nextPlayerId,
              moveDone: false,
              attackDone: false,
              deckDrawDone: false,
              drawnTypes: { green:false, white:false, black:false },
              movedByDiceRoomId: null,
              room3ActionUsed: false,
              room4StealUsed: false,
              repeatTurnRemaining: 0,
              repeatTurnTotal: 0,
              sealWisdomBonus: false,
              updatedAt: Date.now()
            };
          }
        }
      }
      return cur;
    });
    return !!result.committed;
  }

  async function resolveVenomCounterChoice(choice, sourceKey = ""){
    return resolveVenomCounterChoiceForUid(state.userId, choice, sourceKey);
  }

  function hideCounterAbilityPrompt(){
    if (counterAbilityCountdownTimer){
      clearInterval(counterAbilityCountdownTimer);
      counterAbilityCountdownTimer = null;
    }
    activeCounterPromptAt = 0;
    counterAbilityPop?.classList.add("hidden");
  }

  async function runWerewolfCounterAttack(attackerUid){
    const targetUid = safeText(attackerUid || "");
    if (!targetUid || !state.roomCode) return;
    const masamuneMode = hasEquipmentByName(state.userId, "妖刀マサムネ");
    const rolled = {
      d6: 1 + Math.floor(Math.random() * 6),
      d4: 1 + Math.floor(Math.random() * 4)
    };

    await emitCardDiceEvent({
      kind:"role_werewolf_counter",
      uid: state.userId,
      targetUid,
      d6: rolled.d6,
      d4: rolled.d4,
      masamuneMode
    });
    await waitMs(1000);

    const baseDamage = calcAttackDamageFromRoll(state.userId, rolled.d6, rolled.d4, {
      masamuneMode,
      targetUid
    });
    if (baseDamage <= 0) return;
    await addDamageToPlayer(targetUid, baseDamage, { source:"attack", actorUid: state.userId });
  }

  async function runWerewolfCounterAttackForUid(werewolfUid, attackerUid){
    const actorUid = safeText(werewolfUid || "");
    const targetUid = safeText(attackerUid || "");
    if (!actorUid || !targetUid || !state.roomCode) return;
    const masamuneMode = hasEquipmentByName(actorUid, "妖刀マサムネ");
    const rolled = {
      d6: 1 + Math.floor(Math.random() * 6),
      d4: 1 + Math.floor(Math.random() * 4)
    };

    await emitCardDiceEvent({
      kind:"role_werewolf_counter",
      uid: actorUid,
      targetUid,
      d6: rolled.d6,
      d4: rolled.d4,
      masamuneMode
    });
    await waitMs(1000);

    const baseDamage = calcAttackDamageFromRoll(actorUid, rolled.d6, rolled.d4, {
      masamuneMode,
      targetUid
    });
    if (baseDamage <= 0) return;
    await addDamageToPlayer(targetUid, baseDamage, { source:"attack", actorUid: actorUid });
  }

  function renderCounterAbilityPrompt(){
    const entry = counterPromptEntryForMe();
    if (!counterAbilityPop || !counterAbilityMsg || !btnCounterAbilityUse || !btnCounterAbilitySkip){
      return;
    }
    if (!entry || !isCounterRole(entry.roleId) || isAbilitySealedForPlayer(state.userId, entry.roleId)){
      hideCounterAbilityPrompt();
      return;
    }

    const role = ROLE_BY_ID[entry.roleId] || myRoleInfo();
    const ability = roleAbilityName(role || {});
    const isVenomSelection = isVenomSelectionEntry(entry);
    const blockedByGuardianShield = isCounterAbilityBlockedByGuardianShield(entry);
    const blockedByGordonBarrier = hasGordonBarrier(entry.attackerUid);
    const blocked = blockedByGuardianShield || blockedByGordonBarrier;
    counterAbilityMsg.textContent = "";
    counterAbilityMsg.classList.add("hidden");
    btnCounterAbilitySkip.textContent = isVenomSelection ? "1ダメージうける" : "使わない";
    btnCounterAbilityUse.disabled = isVenomSelection || blocked;
    btnCounterAbilityUse.classList.toggle("pop-disabled", isVenomSelection || blocked);
    btnCounterAbilityUse.classList.toggle("pop-dark", !(isVenomSelection || blocked));

    const updateLabel = () => {
      if (isVenomSelection){
        btnCounterAbilityUse.textContent = "装備を渡す（上から選ぶ）";
        return false;
      }
      if (entry.mustChoose){
        btnCounterAbilityUse.textContent = ability;
        return false;
      }
      const remainSec = Math.max(0, Math.ceil((Number(entry.expiresAt || 0) - Date.now()) / 1000));
      btnCounterAbilityUse.textContent = `${ability}(${remainSec})`;
      if (remainSec <= 0){
        clearCounterPromptForMe(entry.at).catch(() => {});
        hideCounterAbilityPrompt();
        return true;
      }
      return false;
    };

    counterAbilityPop.classList.remove("hidden");
    if (activeCounterPromptAt !== entry.at){
      if (counterAbilityCountdownTimer){
        clearInterval(counterAbilityCountdownTimer);
        counterAbilityCountdownTimer = null;
      }
      activeCounterPromptAt = entry.at;
      if (!updateLabel() && !entry.mustChoose){
        counterAbilityCountdownTimer = setInterval(updateLabel, 250);
      } else if (entry.mustChoose){
        updateLabel();
      }
    } else {
      updateLabel();
    }
  }

  function isIdentityRevealPopBlockedByEffectPop(){
    const promptCardName = safeText(pendingIdentityPrompt?.cardObj?.name || "");
    if (!identityPromptPop?.classList.contains("hidden") && IDENTITY_REVEAL_POP_BLOCK_CARD_NAMES.has(promptCardName)){
      return true;
    }

    const selectionCardName = safeText(pendingCardTargetSelection?.cardObj?.name || "");
    if (pendingCardTargetSelection && IDENTITY_REVEAL_POP_BLOCK_CARD_NAMES.has(selectionCardName)){
      return true;
    }

    return false;
  }

  function restoreIdentityPromptSelection(action = null){
    const next = action || pendingIdentityPrompt;
    const cardObj = next?.cardObj || null;
    if (!cardObj) return;
    const canReveal = !!next?.canReveal;
    openZoomFromDeckCard(cardObj, safeText(next?.cardTheme || "white") || "white", { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(true);
    identityPromptMsg.textContent = safeText(next?.message || "");
    btnIdentityPromptYes?.classList.toggle("pop-disabled", !canReveal);
    btnIdentityPromptYes?.classList.toggle("pop-dark", canReveal);
    if (btnIdentityPromptYes) btnIdentityPromptYes.disabled = !canReveal;
    identityPromptPop?.classList.remove("hidden");
  }

  function cardByName(name){
    const target = safeText(name || "");
    if (!target) return null;
    return [...WHITE_DECK, ...BLACK_DECK, ...GREEN_DECK].find((c) => safeText(c?.name || "") === target) || null;
  }

  async function setSeatIdentityPromptState(payload){
    if (restoringSeatIdentityPrompt) return;
    if (!state.roomCode) return;
    const seat = Number(state.seatedTable || 0);
    if (!seat) return;
    const promptRef = ref(db, `rooms/${state.roomCode}/seatPromptState/${seat}`);
    if (!payload){
      await remove(promptRef).catch(() => {});
      return;
    }
    await set(promptRef, {
      ...payload,
      seat,
      ownerUid: state.userId,
      at: Date.now()
    });
  }

  async function setSeatEquipSelectionState(payload){
    if (restoringSeatEquipSelection) return;
    if (!state.roomCode) return;
    const seat = Number(state.seatedTable || 0);
    if (!seat) return;
    const selectionRef = ref(db, `rooms/${state.roomCode}/seatEquipSelectionState/${seat}`);
    if (!payload){
      await remove(selectionRef).catch(() => {});
      return;
    }
    await set(selectionRef, {
      ...payload,
      seat,
      ownerUid: state.userId,
      at: Date.now()
    });
  }

  function identityPromptRevealOptions(cardName){
    const name = safeText(cardName || "");
    if (!IDENTITY_PROMPT_CARD_NAMES.has(name)) return {};
    if (name === "幸せのクッキー"){
      return {
        revealedBy: "happy_cookie",
        useAgathaAbilityOnReveal: false
      };
    }
    return {};
  }

  function buildIdentityPromptResolver(cardName){
    const name = safeText(cardName || "");
    if (!IDENTITY_PROMPT_CARD_NAMES.has(name)) return null;
    return async () => {
      const role = myRoleInfo();
      if (!role) return;
      await revealMyIdentityToEquipment(identityPromptRevealOptions(name));
      openIdentityRevealZoom(role, state.userId);
      await setDamageToPlayer(state.userId, 0, "card_kohrin_heal");
    };
  }

  function identityPromptPayloadFromCard(cardName){
    const role = myRoleInfo();
    const name = safeText(cardName || "");
    if (!role || !IDENTITY_PROMPT_CARD_NAMES.has(name)) return null;
    if (name === "戦慄の闇儀式"){
      return {
        message: "シャドウとして正体を公開しますか。",
        canReveal: role.faction === "シャドウ",
        cardTheme: "black"
      };
    }
    if (name === "光臨"){
      return {
        message: "レイダーとして正体を公開しますか。",
        canReveal: role.faction === "レイダー",
        cardTheme: "white"
      };
    }
    return {
      message: "AまたはUとして正体を公開しますか。",
      canReveal: role.initial === "A" || role.initial === "U",
      cardTheme: "white"
    };
  }

  function showIdentityPromptPop({ message, canReveal, onYes, onNo=null, cardObj=null, cardTheme="white", openZoom=false }){
    if (!identityPromptPop || !identityPromptMsg || !btnIdentityPromptYes || !btnIdentityPromptNo) return;
    if (openZoom && cardObj){
      openZoomFromDeckCard(cardObj, cardTheme, { closeOnBackdrop:false, showCloseButton:false });
    }
    pendingIdentityPrompt = {
      onYes: typeof onYes === "function" ? onYes : null,
      onNo: typeof onNo === "function" ? onNo : null,
      closeZoomOnChoice: !!openZoom,
      cardObj: cardObj || null,
      cardTheme: safeText(cardTheme || "white") || "white",
      message: safeText(message || ""),
      canReveal: !!canReveal
    };
    identityPromptMsg.textContent = safeText(message || "");

    btnIdentityPromptYes.classList.toggle("pop-disabled", !canReveal);
    btnIdentityPromptYes.classList.toggle("pop-dark", !!canReveal);
    btnIdentityPromptNo.classList.remove("pop-disabled");
    btnIdentityPromptNo.classList.add("pop-dark");
    btnIdentityPromptYes.disabled = !canReveal;
    btnIdentityPromptNo.disabled = false;

    identityPromptPop.classList.remove("hidden");
    if (openZoom) setZoomPassthrough(true);

    const cardName = safeText(cardObj?.name || "");
    if (IDENTITY_PROMPT_CARD_NAMES.has(cardName)){
      setSeatIdentityPromptState({
        type: "identity_prompt",
        cardName,
        message: safeText(message || ""),
        canReveal: !!canReveal,
        cardTheme: safeText(cardTheme || "white") || "white"
      }).catch(() => {});
    }
  }


  function myRoleInfo(){
    const my = state.hands?.[state.userId];
    return my && my.roleId ? (ROLE_BY_ID[my.roleId] || null) : null;
  }

  function erikaSealedTargets(){
    return state.room?.erikaSealedTargets || {};
  }

  function isErikaSealedPlayer(uid = state.userId){
    const targetUid = safeText(uid || "");
    if (!targetUid) return false;
    return !!erikaSealedTargets()?.[targetUid];
  }

  function isAbilitySealedForPlayer(uid = state.userId, roleId = ""){
    const targetUid = safeText(uid || "");
    if (!targetUid) return false;
    if (!isErikaSealedPlayer(targetUid)) return false;
    const rid = safeText(roleId || state.hands?.[targetUid]?.roleId || "");
    return rid !== "SHA_U1";
  }

  function isMyAbilitySealed(){
    return isAbilitySealedForPlayer(state.userId);
  }

  function isMyRole(roleId){
    return safeText(state.hands?.[state.userId]?.roleId || "") === safeText(roleId || "");
  }

  function uranusMeteorTargetUids(){
    if (!state.userId) return [];
    const targets = [];
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!uid || uid === state.userId) continue;
      if (!marker || isPlayerEliminated(uid)) continue;
      if (hasGuardianAngelShield(uid)) continue;
      const roomId = markerRoomId(marker);
      if (roomId === 6 || roomId === 7) targets.push(uid);
    }
    return targets;
  }

  function mustResolveUranusMeteorStrike(){
    return false;
  }

  async function resolveVampireHealAfterAttack(){
    if (!isMyRole("SHA_V2")) return;
    if (!vampireHiddenAttackSuccess) return;
    if (isMyAbilitySealed()) return;
    vampireHiddenAttackSuccess = false;
    await emitRoleFlashEvent("SHA_V2", "vampire_heal");
    await healDamageToPlayer(state.userId, 2, "vampire_role_heal");
  }

  function clearCarolTurnHealTimer(){
    if (!carolTurnHealTimer) return;
    clearTimeout(carolTurnHealTimer);
    carolTurnHealTimer = null;
  }

  function scheduleCarolTurnStartHeal(){
    clearCarolTurnHealTimer();
    const key = turnCycleKey();
    if (!key || key === carolTurnHealKey) return;
    if (!isMyTurn() || !isMyRole("CIT_C2") || !isMyIdentityRevealed()) return;
    if (isMyAbilitySealed()) return;
    carolTurnHealKey = key;
    carolTurnHealTimer = setTimeout(async () => {
      carolTurnHealTimer = null;
      if (!isMyTurn() || !isMyRole("CIT_C2") || !isMyIdentityRevealed()) return;
      if (isMyAbilitySealed()) return;
      await emitRoleFlashEvent("CIT_C2", "carol_turn_heal", 1800);
      await healDamageToPlayer(state.userId, 2, "carol_role_heal");
    }, 1000);
  }

  async function emitRoleFlashEvent(roleId, reason = "", durationMs = 1800){
    const rid = safeText(roleId || "");
    if (!state.roomCode || !rid) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/roleFlash`), {
      roleId: rid,
      reason: safeText(reason || ""),
      durationMs: Math.max(100, Number(durationMs) || 1800),
      at: Date.now()
    });
  }

  function attackAbilitySpecFromRows(rows = []){
    const role = myRoleInfo();
    const roleId = safeText(role?.id || "");
    if (!roleId) return null;
    if (isMyAbilitySealed()) return null;
    const normalizedRows = Array.isArray(rows)
      ? rows.map(item => ({ uid:safeText(item?.uid || ""), damage:Math.max(0, Number(item?.damage || 0)) })).filter(item => item.uid)
      : [];
    const hasSuccessDamage = normalizedRows.some(item => item.damage > 0);
    const maxDamage = normalizedRows.reduce((max, item) => Math.max(max, Number(item.damage || 0)), 0);
    const attackFailed = normalizedRows.length > 0 && !hasSuccessDamage;

    if (roleId === "CIT_C1" && !isAttackAbilityUsedThisTurn(roleId)){
      return { abilityName:"死の饗宴", description:"自分に2ダメージ与えて、もう一度攻撃しますか。" };
    }
    if (roleId === "CIT_B1" && maxDamage >= 2){
      return { abilityName:"念力の懐中時計", description:"ダメージの代わりに相手の装備カードを獲得しますか。" };
    }
    if (roleId === "RAI_F3" && !isMyIdentityRevealed() && pendingAttackResultMeta?.freddieSpecial && hasRevealedTargetInRows(normalizedRows)){
      return { abilityName:"ドラゴンアタック", description:"正体を公開している相手へのダメージが+2になります。" };
    }
    if (roleId === "RAI_G2" && hasMyEquipmentByName("エクスカリバー") && attackFailed){
      return { abilityName:"魔剣の伝承者", description:"エクスカリバーを所有している時、攻撃が成功するまで振り直す。" };
    }
    if (roleId === "SHA_U3" && !isAttackAbilityUsedThisTurn(roleId)){
      return { abilityName:"デル・フリス", description:"もう一度攻撃を行いますか。" };
    }
    if (roleId === "SHA_V2" && hasSuccessDamage){
      return { abilityName:"吸血", description:"2ダメージ回復できます。" };
    }
    return null;
  }

  function isAttackAbilityUsedThisTurn(roleId){
    const rid = safeText(roleId || "");
    if (!rid) return false;
    return !!attackAbilityUsedTurnByRole?.[rid];
  }

  function markAttackAbilityUsedThisTurn(roleId){
    const rid = safeText(roleId || "");
    if (!rid) return;
    attackAbilityUsageTurnOwnerUid = currentTurnPlayerId();
    const next = { ...(attackAbilityUsedTurnByRole || {}) };
    next[rid] = true;
    attackAbilityUsedTurnByRole = next;
  }

  function resetAttackAbilityUsageTurnState(){
    attackAbilityUsedTurnByRole = {};
    attackAbilityUsageTurnOwnerUid = "";
  }

  function formatAttackAbilityPillLabel(name){
    const raw = safeText(name || "").trim();
    if (!raw) return "";
    return Array.from(raw).length <= 2 ? ` ${raw} ` : raw;
  }

  function primaryAttackTargetUidFromRows(rows = []){
    const list = Array.isArray(rows) ? rows : [];
    for (const item of list){
      const uid = safeText(item?.uid || "");
      if (uid) return uid;
    }
    return "";
  }

  function attackEliminationPreview(rows = []){
    const entries = Array.isArray(rows)
      ? rows.map(item => ({ uid:safeText(item?.uid || ""), damage:Math.max(0, Number(item?.damage || 0)) })).filter(item => item.uid)
      : [];
    if (!entries.length) return { attackedUids:[], eliminatedUids:[], allAttackedEliminated:false };
    const attackedSet = new Set(entries.map(item => item.uid));
    const eliminatedSet = new Set();
    for (const item of entries){
      if (item.damage <= 0) continue;
      const roleId = safeText(state.hands?.[item.uid]?.roleId || "");
      const hp = Number(ROLE_BY_ID?.[roleId]?.hp || 0);
      if (hp <= 0) continue;
      const beforeDamage = clampDamage(damageCache?.[item.uid]);
      const afterDamage = clampDamage(beforeDamage + item.damage);
      if (beforeDamage < hp && afterDamage >= hp){
        eliminatedSet.add(item.uid);
      }
    }
    const attackedUids = [...attackedSet];
    const eliminatedUids = [...eliminatedSet];
    const allAttackedEliminated = attackedUids.length > 0 && attackedUids.every(uid => eliminatedSet.has(uid));
    return { attackedUids, eliminatedUids, allAttackedEliminated };
  }

  function markerClientPointByUid(uid){
    const marker = markerCache?.[safeText(uid || "")] || null;
    const x = Number(marker?.x);
    const y = Number(marker?.y);
    if (!roomSvg || !Number.isFinite(x) || !Number.isFinite(y)){
      return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    }
    const ctm = roomSvg.getScreenCTM();
    if (!ctm){
      return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    }
    const pt = roomSvg.createSVGPoint();
    pt.x = x;
    pt.y = y;
    const out = pt.matrixTransform(ctm);
    return { x: Number(out.x || (window.innerWidth / 2)), y: Number(out.y || (window.innerHeight / 2)) };
  }

  async function runFollowupAttackToTarget(uid, delayMs = 0){
    const targetUid = safeText(uid || "");
    if (!targetUid) return;
    const wait = Math.max(0, Number(delayMs) || 0);
    if (wait > 0) await waitMs(wait);
    const point = markerClientPointByUid(targetUid);
    attackTurnEndChoicePending = true;
    attackFlowUiLockActive = true;
    renderTurnEndButton();
    await runAttackDiceAnimation(targetUid, point.x, point.y, { force:true, applyDamage:true });
  }

  async function resolveAttackAbilityReveal(role){
    if (!role) return;
    if (!isMyIdentityRevealed()){
      await revealMyIdentityToEquipment({ revealedBy:"attack_ability" });
    } else {
      await emitRoleFlashEvent(role.id, "attack_ability_reveal_repeat", 1800);
    }
  }

  async function startUlsterExtraAttackSelection(){
    if (!state.roomCode) return;
    ulsterExtraAttackPending = Math.max(ulsterExtraAttackPending, 1);
    suppressEndTurnButton = false;
    attackFlowUiLockActive = false;
    await update(ref(db, `rooms/${state.roomCode}/turn`), {
      attackDone: false,
      updatedAt: Date.now()
    });
    const message = (ulsterExtraAttackGuideShown || isMyIdentityRevealed())
      ? "デル・フリス：もう一度攻撃対象を選んでください。"
      : "デル・フリス：もう一度攻撃対象を選んでください。\n※攻撃するプレイヤーを選んだ後に正体を公開します。\n公開をやめる場合は手番を終わる。";
    showTurnHint(message, { multiline:true });
    ulsterExtraAttackGuideShown = true;
    renderTurnEndButton();
  }


  async function emitHpSwapEvent(aUid, bUid){
    const a = safeText(aUid || "");
    const b = safeText(bUid || "");
    if (!state.roomCode || !a || !b || a === b) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/hpSwap`), {
      aUid: a,
      bUid: b,
      at: Date.now()
    });
  }

  async function emitWalpurgisSwapEvent(uidA, uidB, durationMs = 620){
    const a = safeText(uidA || "");
    const b = safeText(uidB || "");
    if (!state.roomCode || !a || !b || a === b) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/walpurgisSwap`), {
      uidA: a,
      uidB: b,
      durationMs: Math.max(240, Number(durationMs) || 620),
      at: Date.now()
    });
  }

  async function emitIdentityZoomEvent(roleId, uid){
    const rid = safeText(roleId || "");
    const actorUid = safeText(uid || "");
    if (!state.roomCode || !rid || !actorUid) return;
    await set(ref(db, `rooms/${state.roomCode}/effectEvents/identityZoom`), {
      roleId: rid,
      uid: actorUid,
      at: Date.now()
    });
  }

  function hideRoleFlashOverlay(){
    if (roleFlashTimer){
      clearTimeout(roleFlashTimer);
      roleFlashTimer = null;
    }
    if (roleFlashOverlayEl){
      roleFlashOverlayEl.remove();
      roleFlashOverlayEl = null;
    }
  }

  function hidePersistentVenomOverlay(){
    if (persistentVenomOverlayEl){
      persistentVenomOverlayEl.remove();
      persistentVenomOverlayEl = null;
    }
  }

  function showPersistentVenomOverlay(){
    const role = ROLE_BY_ID["SHA_V1"];
    if (!role || persistentVenomOverlayEl) return;
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.inset = "0";
    // ヴェノム常駐表示はヘルプ/装備拡大/通常拡大より背面に置く
    overlay.style.zIndex = "273";
    overlay.style.display = "flex";
    overlay.style.alignItems = "center";
    overlay.style.justifyContent = "center";
    overlay.style.background = "transparent";
    overlay.style.pointerEvents = "none";

    const card = createIdentityCard(role);
    card.style.transform = "scale(2.0)";
    card.style.transformOrigin = "center center";
    card.style.boxShadow = "0 14px 32px rgba(0,0,0,.35)";
    overlay.appendChild(card);
    document.body.appendChild(overlay);
    persistentVenomOverlayEl = overlay;
  }

  function hasPendingVenomResolution(){
    return Object.values(state.room?.counterPromptState || {}).some((entry) => safeText(entry?.mode || "") === "venom_resolution");
  }

  function syncPersistentVenomOverlay(){
    if (hasPendingVenomResolution() && zoomBackdrop?.classList.contains("hidden")){
      showPersistentVenomOverlay();
      return;
    }
    hidePersistentVenomOverlay();
  }

  function showRoleFlashOverlay(roleId, durationMs = 1800){
    const role = ROLE_BY_ID[safeText(roleId || "")];
    if (!role) return;
    hideRoleFlashOverlay();

    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.inset = "0";
    overlay.style.zIndex = "var(--z-role-flash-overlay)";
    overlay.style.display = "flex";
    overlay.style.alignItems = "center";
    overlay.style.justifyContent = "center";
    overlay.style.background = "transparent";
    overlay.style.pointerEvents = "none";

    const card = createIdentityCard(role);
    card.style.transform = "scale(2.0)";
    card.style.transformOrigin = "center center";
    card.style.boxShadow = "0 14px 32px rgba(0,0,0,.35)";
    overlay.appendChild(card);
    document.body.appendChild(overlay);
    roleFlashOverlayEl = overlay;

    roleFlashTimer = setTimeout(() => {
      hideRoleFlashOverlay();
    }, Math.max(100, Number(durationMs) || 1800));
  }

  function showTemporaryRoleTag(uid, text, durationMs = 2000){
    if (!uid || !text) return;
    const until = Date.now() + Math.max(100, Number(durationMs) || 2000);
    temporaryRoleTagByUid[uid] = { text: safeText(text), until };
    renderPositionLine();
    setTimeout(() => {
      const cur = temporaryRoleTagByUid[uid];
      if (!cur || Number(cur.until || 0) !== until) return;
      delete temporaryRoleTagByUid[uid];
      renderPositionLine();
    }, Math.max(100, Number(durationMs) || 2000));
  }


  function hasAnyEquipment(uid){
    return listEquipForUid(uid).some(v => !isIdentityEquipItem(v));
  }

  function setEffectResolutionLock(lockKey, enabled){
    const key = safeText(lockKey || "");
    if (!key) return;
    if (enabled){
      effectResolutionLocks[key] = true;
    } else {
      delete effectResolutionLocks[key];
    }
  }

  function isEffectResolutionLocked(lockKey){
    const key = safeText(lockKey || "");
    return !!(key && effectResolutionLocks[key]);
  }

  function greenCardConditionMatched(cardObj){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const compactText = text.replace(/[\s　]+/g, "");
    const role = myRoleInfo();
    if (!role) return null;

    if (text.includes("A / B / C / E / U")) return ["A","B","C","E","U"].includes(role.initial) && Number(role.hp) <= 11;
    if (text.includes("D / F / G / V / W")) return ["D","F","G","V","W"].includes(role.initial) && Number(role.hp) >= 12;
    if (compactText.includes("シチズンかシャドウ")) return role.faction === "シチズン" || role.faction === "シャドウ";
    if (compactText.includes("シチズンかレイダー")) return role.faction === "シチズン" || role.faction === "レイダー";
    if (compactText.includes("レイダーかシャドウ")) return role.faction === "レイダー" || role.faction === "シャドウ";
    if (text.includes("シャドウ？")) return role.faction === "シャドウ";
    if (text.includes("レイダー？")) return role.faction === "レイダー";
    if (text.includes("シチズン？")) return role.faction === "シチズン";

    return null;
  }

  function greenAnswerOptions(cardObj){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const matched = greenCardConditionMatched(cardObj);
    const isUlrich = isMyRole("SHA_U1");
    const canJudge = isUlrich ? false : (matched !== null);

    if (text.includes("正体カードを見せよ")){
      return [{ id:"reveal_identity", label:"私の正体です。", enabled:true }];
    }

    if (text.includes("装備を渡すか、1ダメージ受けよ")){
      const canEquip = hasAnyEquipment(state.userId);
      return [
        { id:"take_damage", label:"1ダメージうける", enabled: canJudge ? !!matched : true },
        { id:"give_equip", label:"装備をわたす", enabled: canJudge ? (!!matched && canEquip) : canEquip },
        { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
      ];
    }

    if (text.includes("❿に移動せよ")){
      const nowRoom = markerRoomId(markerCache?.[state.userId]);
      const moveLabel = (nowRoom === 7) ? "1ダメージうける" : "➓に移動する";
      return [
        { id:"yes", label:moveLabel, enabled: canJudge ? !!matched : true },
        { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
      ];
    }

    if (text.includes("1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ")){
      const nowDamage = clampDamage(damageCache?.[state.userId]);
      const healLabel = (nowDamage <= 0) ? "1ダメージうける" : "1ダメージ回復する";
      return [
        { id:"yes", label:healLabel, enabled: canJudge ? !!matched : true },
        { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
      ];
    }

    const damageMatch = text.match(/(\d+)ダメージ受けよ/);
    const damageLabel = damageMatch ? `${damageMatch[1]}ダメージうける` : "はい";
    return [
      { id:"yes", label:damageLabel, enabled: canJudge ? !!matched : true },
      { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
    ];
  }

  function isRevealIdentityGreenCard(cardObj){
    return safeText(cardObj?.effect || cardObj?.text || "").includes("正体カードを見せよ");
  }

  function hideGreenRevealPanel(){
    if (greenRevealLabel) greenRevealLabel.textContent = "";
    if (greenRevealCardWrap) greenRevealCardWrap.innerHTML = "";
    greenRevealPanel?.classList.add("hidden");
    greenRevealPanel?.classList.remove("reveal-slide-in");
    zoomBackdrop?.classList.remove("green-reveal-active");
  }

  function setGreenTurnEndButtonLock(enabled){
    const next = !!enabled;
    if (greenTurnEndButtonLockActive === next) return;
    greenTurnEndButtonLockActive = next;
    renderTurnEndButton();
  }

  function isGreenInteractionActive(){
    if (zoomBackdrop?.classList.contains("hidden")) return false;
    if (greenShareDock?.classList.contains("hidden")) return false;
    return !!(pendingGreenRequestId || pendingGreenAnswerMsg || greenShareCard);
  }

  function showGreenRevealPanel(roleId, responderId){
    const role = roleId ? ROLE_BY_ID[roleId] : null;
    if (!role || !greenRevealCardWrap || !greenRevealLabel || !greenRevealPanel) return;
    greenRevealCardWrap.innerHTML = "";
    greenRevealCardWrap.appendChild(createIdentityCard(role));
    const me = safeText(state.userId || "");
    const label = (safeText(responderId || "") === me) ? "私の正体です。" : "選択したプレイヤーの正体";
    greenRevealLabel.textContent = label;
    greenRevealPanel.classList.remove("hidden");
    zoomBackdrop?.classList.add("green-reveal-active");
    greenRevealPanel.classList.remove("reveal-slide-in");
    requestAnimationFrame(() => {
      greenRevealPanel.classList.add("reveal-slide-in");
    });
  }

  async function sendGreenResponse(msg, opt, overrideLabel=""){
    if (!state.roomCode || !msg?.from || !msg?.requestId || !opt?.id) return;
    const answerLabel = safeText(overrideLabel || opt.label || "");
    const q = safeText(msg?.card?.effect || msg?.card?.text || "");
    const greenLog = greenHistoryLogLine({
      responderUid: state.userId,
      cardText: q,
      answerLabel: answerLabel || safeText(opt?.id || ""),
      answerId: safeText(opt?.id || ""),
      useCurrentDamage: false
    });
    if (greenLog) appendActionChatLog(safeText(msg?.from || state.userId), greenLog).catch(() => {});
    const responseRoleId = (opt.id === "reveal_identity") ? safeText(state.hands?.[state.userId]?.roleId || "") : "";
    let requesterUid = safeText(msg.from || "");
    try {
      const reqSnap = await get(ref(db, `rooms/${state.roomCode}/greenRequests/${msg.requestId}`));
      const req = reqSnap.val() || null;
      if (req?.from) requesterUid = safeText(req.from || requesterUid);
    } catch (_) {}
    if (!requesterUid) return;
    await set(ref(db, `rooms/${state.roomCode}/greenResponses/${requesterUid}`), {
      from: requesterUid,
      to: state.userId,
      requestId: msg.requestId,
      answerId: opt.id,
      answerLabel,
      roleId: responseRoleId,
      card: msg.card,
      at: Date.now()
    });
    await set(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${msg.requestId}`), {
      from: msg.from,
      responderId: state.userId,
      requestId: msg.requestId,
      answerLabel,
      at: Date.now()
    });
    await remove(ref(db, `rooms/${state.roomCode}/greenInbox/${state.userId}`)).catch(() => {});
  }

  async function applyGreenAnswerEffect(msg, opt){
    const text = safeText(msg?.card?.effect || msg?.card?.text || "");

    if (opt?.id === "take_damage"){
      setTimeout(() => { addDamageToPlayer(state.userId, 1, { skipActionLog:true }); }, 1000);
      return;
    }

    const isPositive = (opt?.id === "yes" || opt?.id === "reveal_identity");
    if (!isPositive) return;

    if (text.includes("1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ")){
      setTimeout(() => {
        const cur = clampDamage(damageCache?.[state.userId]);
        if (cur <= 0) addDamageToPlayer(state.userId, 1, { skipActionLog:true });
        else healDamageToPlayer(state.userId, 1, "green_heal", { skipActionLog:true });
      }, 1000);
    } else if (!text.includes("❿に移動せよ")) {
      const damageMatch = text.match(/(\d+)ダメージ受けよ/);
      const damage = damageMatch ? Number(damageMatch[1] || 0) : 0;
      if (damage > 0){
        setTimeout(() => { addDamageToPlayer(state.userId, damage, { skipActionLog:true }); }, 1000);
      }
    }

    if (text.includes("❿に移動せよ")){
      setTimeout(() => {
        const nowRoom = markerRoomId(markerCache?.[state.userId]);
        if (nowRoom === 7) addDamageToPlayer(state.userId, 1, { skipActionLog:true });
        else placePlayerMarkerInRoom(state.userId, 7);
      }, 1000);
    }

    if (text.includes("正体カードを見せよ")){
      const roleId = safeText(state.hands?.[state.userId]?.roleId || "");
      if (roleId){
        await set(ref(db, `rooms/${state.roomCode}/greenReveals/${msg.requestId}`), {
          requestId: msg.requestId,
          from: msg.from,
          responderId: state.userId,
          roleId,
          at: Date.now()
        });
        showGreenRevealPanel(roleId, state.userId);
      }
    }
  }

  function restoreGreenGiveZoomSelection(action){
    if (!action?.cardObj) return;
    openZoomFromDeckCard(action.cardObj, "green", { closeOnBackdrop:false, showCloseButton:false });
    greenShareDock?.classList.remove("over-equip-expand");
    greenShareDock?.classList.add("hidden");
    setZoomPassthrough(true);
    pendingEquipAction = action;
    renderEquipmentDock();
  }

  function setGreenDockMeta({ title="", subtitle="" } = {}){
    const titleEl = greenShareDock?.querySelector(".green-share-title");
    if (titleEl) titleEl.innerHTML = title;
    if (greenShareSubtitle){
      greenShareSubtitle.textContent = subtitle || "";
      greenShareSubtitle.classList.toggle("hidden", !subtitle);
    }
  }

  async function setGreenSessionState(payload){
    if (greenSessionRestoring) return;
    if (!state.roomCode || !state.userId) return;
    const gsRef = ref(db, `rooms/${state.roomCode}/greenSessions/${state.userId}`);
    if (!payload){
      await remove(gsRef);
      return;
    }
    await set(gsRef, {
      ...payload,
      uid: state.userId,
      at: Date.now()
    });
  }

  async function setRoleAbilitySelectionState(payload){
    if (!state.roomCode || !state.userId) return;
    const sessionRef = ref(db, `rooms/${state.roomCode}/roleAbilitySelection`);
    if (!payload){
      await remove(sessionRef).catch(() => {});
      return;
    }
    await set(sessionRef, {
      ...payload,
      at: Date.now()
    });
  }

  function roleSelectionTargetPlayers(entry){
    const roleId = safeText(entry?.roleId || "");
    const actorUid = safeText(entry?.actorUid || "");
    const actorRoom = markerRoomId(markerCache?.[actorUid]);
    const alive = latestPlayers.filter(p => !isPlayerEliminated(p.id));
    const eliminated = latestPlayers.filter(p => isPlayerEliminated(p.id));
    if (roleId === "RAI_F2") return alive;
    if (roleId === "RAI_E3") return alive.filter(p => p.id !== actorUid && markerRoomId(markerCache?.[p.id]) === actorRoom);
    if (roleId === "RAI_G3") return eliminated.filter(p => p.id !== actorUid);
    if (roleId === "SHA_U2") return alive.filter(p => p.id !== actorUid && [6,7].includes(markerRoomId(markerCache?.[p.id])));
    if (roleId === "CIT_B2") return benjaminCandidates(actorUid);
    return alive.filter(p => p.id !== actorUid);
  }

  function buildRoleSelectionMessage(roleId){
    const spec = roleSelectionSpec(roleId);
    if (!spec) return "";
    return `<span class="ability-pill">${escapeHtml(spec.abilityName)}</span>${escapeHtml(spec.prompt)}`;
  }

  function canStartRoleSelection(roleId, actorUid){
    const entry = { roleId, actorUid };
    const candidates = roleSelectionTargetPlayers(entry);
    return candidates.length > 0;
  }

  function isCornerRoomForEmma(roomId){
    const rid = Number(roomId || 0);
    return [1,3,5,7].includes(rid);
  }

  function emmaAbilityAvailability(){
    if (!isMyRole("RAI_E3")) return { ok:false, message:"今は使えません。" };
    if (!isMyTurn()) return { ok:false, message:"今は使えません。" };
    if (isMyAbilitySealed()) return { ok:false, message:"今は使えません。" };
    if (!isMyIdentityRevealed()) return { ok:false, message:"今は使えません。" };
    if (!turnState()?.moveDone) return { ok:false, message:"今は使えません。" };
    if (isRoleAbilityUsed("RAI_E3")) return { ok:false, message:"今は使えません。" };
    if (!canStartRoleSelection("RAI_E3", state.userId)) return { ok:false, message:"今は使えません。" };
    return { ok:true };
  }

  function hasRevealedTargetInRows(rows = []){
    const normalizedRows = Array.isArray(rows)
      ? rows.map(item => safeText(item?.uid || "")).filter(Boolean)
      : [];
    return normalizedRows.some(uid => isIdentityRevealedFor(uid));
  }

  function uranusAbilityAvailability(){
    if (!isMyRole("SHA_U2")) return { ok:false, message:"今は使えません。" };
    if (!isMyTurn()) return { ok:false, message:"今は使えません。" };
    if (isMyAbilitySealed()) return { ok:false, message:"今は使えません。" };
    if (!isMyIdentityRevealed()) return { ok:false, message:"今は使えません。" };
    if (isRoleAbilityUsed("SHA_U2")) return { ok:false, message:"今は使えません。" };
    if (!canStartRoleSelection("SHA_U2", state.userId)) return { ok:false, message:"今は使えません。" };
    return { ok:true };
  }

  function benjaminCandidates(actorUid = state.userId){
    const uid = safeText(actorUid || "");
    if (!uid) return [];
    const actorRoom = markerRoomId(markerCache?.[uid]);
    if (!actorRoom) return [];
    return latestPlayers
      .filter(p => p.id !== uid)
      .filter(p => !isPlayerEliminated(p.id))
      .filter(p => markerRoomId(markerCache?.[p.id]) === actorRoom);
  }

  function benjaminAbilityAvailability(){
    if (!isMyRole("CIT_B2")) return { ok:false, message:"今は使えません。" };
    if (!isMyTurn()) return { ok:false, message:"今は使えません。" };
    if (isMyAbilitySealed()) return { ok:false, message:"今は使えません。" };
    if (!isMyIdentityRevealed()) return { ok:false, message:"今は使えません。" };
    if (!turnState()?.moveDone) return { ok:false, message:"今は使えません。" };
    if (isRoleAbilityUsed("CIT_B2")) return { ok:false, message:"今は使えません。" };
    if (!hasAnyEquipment(state.userId)) return { ok:false, message:"今は使えません。" };
    if (benjaminCandidates(state.userId).length === 0) return { ok:false, message:"今は使えません。" };
    return { ok:true };
  }

  function benjaminRevealAvailability(){
    if (!isMyRole("CIT_B2")) return { ok:false, message:"今は使えません。" };
    if (!isMyTurn()) return { ok:false, message:"今は使えません。" };
    if (isMyAbilitySealed()) return { ok:false, message:"今は使えません。" };
    if (!turnState()?.moveDone) return { ok:false, message:"今は使えません。" };
    if (!hasAnyEquipment(state.userId)) return { ok:false, message:"今は使えません。" };
    if (benjaminCandidates(state.userId).length === 0) return { ok:false, message:"今は使えません。" };
    return { ok:true };
  }

  async function completeRoleAbilitySelection(entry, targetUid){
    const actorUid = safeText(entry?.actorUid || "");
    const roleId = safeText(entry?.roleId || "");
    const selectedUid = safeText(targetUid || "");
    if (!actorUid || !roleId || actorUid !== state.userId || !selectedUid) return;

    if (roleId === "RAI_F2"){
      await setDamageToPlayer(selectedUid, 7, "felicia_set");
    } else if (roleId === "RAI_F1"){
      const eye = 1 + Math.floor(Math.random() * 6);
      await emitCardDiceEvent({ kind:"role_felix", uid: actorUid, d6: eye });
      await waitMs(1000);
      await addDamageToPlayer(selectedUid, eye);
    } else if (roleId === "RAI_E3"){
      const eye = 1 + Math.floor(Math.random() * 4);
      await emitCardDiceEvent({ kind:"role_emma", uid: actorUid, d4: eye });
      await waitMs(1000);
      await healDamageToPlayer(selectedUid, eye, "emma_ability_heal");
      await update(ref(db, `rooms/${state.roomCode}/turn`), {
        attackDone: true,
        deckDrawDone: true,
        updatedAt: Date.now()
      });
    } else if (roleId === "RAI_E2"){
      await set(ref(db, `rooms/${state.roomCode}/erikaSealedTargets/${selectedUid}`), true);
    } else if (roleId === "RAI_G3"){
      const roomRef = ref(db, `rooms/${state.roomCode}`);
      await runTransaction(roomRef, (cur) => {
        if (!cur) return cur;
        cur.damage = cur.damage || {};
        cur.damage[selectedUid] = clampDamage(7);
        recycleRevivedPlayerEquipIntoDeck(cur, selectedUid);
        cur.markers = cur.markers || {};
        delete cur.markers[selectedUid];
        cur.godwinRevivePendingMove = cur.godwinRevivePendingMove || {};
        cur.godwinRevivePendingMove[selectedUid] = true;
        if (cur.deckState && typeof cur.deckState === "object"){
          cur.deckState.updatedAt = Date.now();
        }
        return cur;
      });
    } else if (roleId === "SHA_U2"){
      await addDamageToPlayer(selectedUid, 3);
      uranusMeteorResolved = true;
    } else if (roleId === "CIT_C3"){
      const me = clampDamage(damageCache?.[actorUid]);
      const target = clampDamage(damageCache?.[selectedUid]);
      pendingHpSwapAnimation = { aUid: actorUid, bUid: selectedUid, at: Date.now() };
      const roomRef = ref(db, `rooms/${state.roomCode}`);
      await runTransaction(roomRef, (cur) => {
        if (!cur) return cur;
        cur.damage = cur.damage || {};
        const curMe = clampDamage(cur.damage?.[actorUid]);
        const curTarget = clampDamage(cur.damage?.[selectedUid]);
        cur.damage[actorUid] = curTarget;
        cur.damage[selectedUid] = curMe;
        return cur;
      });
      if (me === target){
        pendingHpSwapAnimation = null;
      }
      await emitHpSwapEvent(actorUid, selectedUid);
    }

    await markRoleAbilityUsed(roleId);
    await setRoleAbilitySelectionState(null);
    if (roleId === "RAI_E3" || !!entry?.endTurnAfterResolve){
      await doEndTurn();
    }
  }

  function openRoleAbilitySelectionUI(entry){
    const roleId = safeText(entry?.roleId || "");
    const actorUid = safeText(entry?.actorUid || "");
    let selectionBusy = false;
    const role = ROLE_BY_ID[roleId];
    if (!role) return;
    activeRoleAbilitySelection = entry;
    const isActor = actorUid === state.userId;
    if (!!entry?.privateToActor && !isActor){
      greenShareDock?.classList.add("hidden");
      return;
    }
    openIdentityRevealZoom(role, actorUid, {
      persist:true,
      showOwnerTag: !!entry?.justRevealed,
      ownerTagDurationMs: 1200
    });
    setZoomPassthrough(true);
    if (!isActor){
      greenShareDock?.classList.add("hidden");
      return;
    }
    if (isAbilitySealedForPlayer(actorUid, roleId)){
      setRoleAbilitySelectionState(null).catch(() => {});
      greenShareDock?.classList.add("hidden");
      return;
    }
    if (roleId === "CIT_B2"){
      const check = benjaminAbilityAvailability();
      if (!check.ok){
        setRoleAbilitySelectionState(null).catch(() => {});
        showRevealPopAt(null, { mode:"notice", message:check.message || "今は使えません。" });
        return;
      }
      pendingEquipAction = { type:"benjamin_give" };
      setSeatEquipSelectionState({ type:"benjamin_give" }).catch(() => {});
      setGreenDockMeta({ title:"", subtitle:"" });
      if (greenShareList) greenShareList.innerHTML = "";
      greenShareActions?.classList.add("hidden");
      greenShareDock?.classList.add("hidden");
      cardPlayerSelectActive = true;
      updateCardInteractivity();
      renderEquipmentDock();
      renderTurnEndButton();
      return;
    }
    const candidates = roleSelectionTargetPlayers(entry);
    if (candidates.length === 0){
      setRoleAbilitySelectionState(null).catch(() => {});
      showRevealPopAt(null, { mode:"notice", message:"今は公開できません。" });
      return;
    }
    setGreenDockMeta({ title:"", subtitle:"" });
    if (greenShareList) greenShareList.innerHTML = "";
    if (!greenShareList || !greenShareDock) return;
    const text = buildRoleSelectionMessage(roleId);
    setGreenDockMeta({ title:text, subtitle:"" });
    const lockRoleSelectionButtons = () => {
      if (!greenShareList) return;
      greenShareList.querySelectorAll("button").forEach((el) => {
        el.disabled = true;
        el.style.pointerEvents = "none";
      });
    };
    for (const p of candidates){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      const chip = buildChipFor(p.id);
      const label = document.createElement("span");
      label.textContent = nameFromSecondChar(p.name || "");
      btn.appendChild(chip);
      btn.appendChild(label);
      btn.addEventListener("click", () => {
        if (selectionBusy) return;
        showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, `「${safeText(p.name || "このプレイヤー")}」を選びますか。`, async () => {
          if (selectionBusy) return;
          selectionBusy = true;
          lockRoleSelectionButtons();
          await completeRoleAbilitySelection(entry, p.id);
        }, { fixedLower:true, noCaret:true });
      });
      greenShareList.appendChild(btn);
    }
    if (roleId === "RAI_E3" || roleId === "SHA_U2" || roleId === "RAI_G3"){
      const skipBtn = document.createElement("button");
      skipBtn.type = "button";
      skipBtn.className = "green-share-btn";
      skipBtn.textContent = "使わない";
      const spec = roleSelectionSpec(roleId);
      const disableSkip = !!entry?.justRevealed;
      if (disableSkip){
        skipBtn.disabled = true;
        skipBtn.classList.add("skip-disabled");
      }
      skipBtn.addEventListener("click", () => {
        if (disableSkip || selectionBusy) return;
        const abilityName = safeText(spec?.abilityName || "能力");
        showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "", async () => {
          if (selectionBusy) return;
          selectionBusy = true;
          lockRoleSelectionButtons();
          await setRoleAbilitySelectionState(null);
          if (roleId === "RAI_E3" && !!entry?.endTurnAfterResolve){
            await doEndTurn();
          }
        }, {
          messageHtml: `<span class="ability-pill">${escapeHtml(abilityName)}</span>を使いませんか。`,
          yesLabel: "はい",
          noLabel: "いいえ",
          fixedLower:true,
          noCaret:true,
          dismissOnOutside:true
        });
      });
      greenShareList.appendChild(skipBtn);
    }
    greenShareActions?.classList.add("hidden");
    greenShareDock.classList.remove("hidden");
    updateGreenShareDockPosition();
    cardPlayerSelectActive = true;
    updateCardInteractivity();
    renderTurnEndButton();
  }

  async function setCardTargetSessionState(payload){
    if (cardTargetSessionRestoring) return;
    if (!state.roomCode || !state.userId) return;
    const sessionRef = ref(db, `rooms/${state.roomCode}/cardTargetSessions/${state.userId}`);
    if (!payload){
      pendingCardTargetSessionEntry = null;
      await remove(sessionRef);
      return;
    }
    const at = Date.now();
    cardTargetSessionSeenAt = Math.max(cardTargetSessionSeenAt, at);
    await set(sessionRef, {
      ...payload,
      uid: state.userId,
      at
    });
  }

  function currentMySeatIndex(){
    const fromPlayers = latestPlayers.find(p => p.id === state.userId);
    if (fromPlayers?.seatIndex) return Number(fromPlayers.seatIndex || 0);
    const tables = state.room?.tables || {};
    for (const [seatIndex, t] of Object.entries(tables)){
      if (t && safeText(t.playerId || "") === safeText(state.userId || "")) return Number(seatIndex || 0);
    }
    return Number(state.seatedTable || 0);
  }

  function renderGreenWaitingSelection(toUid, toName="", toInitial="", toColor=""){
    if (!greenShareList) return;
    greenShareList.innerHTML = "";
    const selected = document.createElement("button");
    selected.type = "button";
    selected.className = "green-share-btn waiting-selected";
    selected.setAttribute("aria-disabled", "true");
    selected.style.pointerEvents = "none";
    const targetPlayer = toUid ? playerById(toUid) : null;
    if (targetPlayer){
      selected.appendChild(buildChipFor(toUid));
    } else if (toUid || toName){
      const fallback = document.createElement("div");
      fallback.className = "chip16";
      const chipColor = safeText(toColor || "") || "#ddd";
      const chipInitial = firstChar(safeText(toInitial || "") || safeText(toName || ""));
      fallback.style.background = chipColor;
      fallback.style.color = textColorFor(chipColor);
      fallback.textContent = chipInitial || "";
      fallback.title = safeText(toName || "");
      selected.appendChild(fallback);
    }
    const name = document.createElement("span");
    if (toUid){
      name.textContent = targetPlayer ? nameFromSecondChar(targetPlayer.name) : safeText(toName || "");
    } else {
      name.textContent = safeText(toName || "");
    }
    selected.appendChild(name);
    greenShareList.appendChild(selected);
  }

  function openTargetSelectDock({ title="対象プレイヤーを選択", includeSelf=false, onlyAlive=false, onSelect=null, nameSuffixForUid=null, lockEndTurnUntilResolved=false, overEquipExpand=false, filterPlayer=null } = {}){
    if (!greenShareDock || !greenShareList) return;
    const mySeat = currentMySeatIndex();
    const players = latestPlayers
      .filter(p => includeSelf || (p.id !== state.userId && Number(p.seatIndex || 0) !== mySeat))
      .filter(p => !isPlayerEliminated(p.id))
      .filter(p => !onlyAlive || !isPlayerEliminated(p.id))
      .filter(p => (typeof filterPlayer === "function") ? !!filterPlayer(p) : true)
      .sort((a,b) => Number(a.seatIndex||999)-Number(b.seatIndex||999));
    if (players.length === 0){
      cardPlayerSelectActive = false;
      updateCardInteractivity();
      renderTurnEndButton();
      return false;
    }

    let selected = false;
    greenShareDock?.classList.toggle("over-equip-expand", !!overEquipExpand);
    setGreenDockMeta({ title, subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";

    for (const p of players){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      const chip = buildChipFor(p.id);
      const name = document.createElement("span");
      const suffix = (typeof nameSuffixForUid === "function") ? safeText(nameSuffixForUid(p.id, p) || "") : "";
      name.textContent = `${nameFromSecondChar(p.name)}${suffix}`;
      btn.appendChild(chip);
      btn.appendChild(name);
      btn.addEventListener("click", async () => {
        if (selected) return;
        selected = true;
        if (greenShareDock) greenShareDock.classList.add("hidden");
        if (!lockEndTurnUntilResolved){
          cardPlayerSelectActive = false;
          updateCardInteractivity();
          renderTurnEndButton();
        }
        const handler = (typeof onSelect === "function") ? onSelect : null;
        try {
          if (handler) await handler(p.id, p);
        } finally {
          if (lockEndTurnUntilResolved){
            cardPlayerSelectActive = false;
            updateCardInteractivity();
            renderTurnEndButton();
          }
        }
      });
      greenShareList.appendChild(btn);
    }

    cardPlayerSelectActive = true;
    updateCardInteractivity();
    renderTurnEndButton();
    greenShareDock.classList.remove("hidden");
    updateGreenShareDockPosition();
    return true;
  }

  function cardTargetSelectionSpec(cardObj){
    const name = safeText(cardObj?.name || "");
    if (!name) return null;
    if (name === "応急手当"){
      return {
        theme:"white",
        title:"応急手当：対象プレイヤーを選択してください。",
        includeSelf:true,
        instantCloseOnSelect:true,
        resolver: async (uid) => {
          await waitMs(1000);
          await setDamageToPlayer(uid, 7, "first_aid_set", { skipActionLog:true });
          appendActionChatLog(state.userId, `白ドロー：[応急手当] 7に設定>${displayNameForUid(uid)}`).catch(() => {});
        }
      };
    }
    if (name === "恩恵"){
      return {
        theme:"white",
        title:"恩恵：回復させるプレイヤーを選択してください。",
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "いにしえの聖杯") ? "🏺" : "",
        resolver: async (uid) => {
          const eye = 1 + Math.floor(Math.random() * 6);
          await emitCardDiceEvent({ kind:"blessing", uid:state.userId, d6:eye });
          await runCornerD6Roll(eye);
          await waitMs(1000);
          await healDamageToPlayer(uid, eye, "card_blessing_heal", { skipActionLog:true });
          appendActionChatLog(state.userId, `[恩恵] (6d${eye}) ${actionDeltaText(-eye)}>${actionTargetWithDamage(uid, -eye)}`).catch(() => {});
        }
      };
    }
    if (name === "吸血コウモリ"){
      return {
        theme:"black",
        title:"吸血コウモリ：対象プレイヤーを選択してください。",
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "いにしえの聖杯") ? "🏺" : "",
        resolver: async (uid) => {
          await recordFactionRelationInferenceFromRevealedTarget(state.userId, uid, "enemy", "card_attack_target_revealed");
          await waitMs(1000);
          let dmg = 0;
          if (!hasEquipmentByName(uid, "いにしえの聖杯")){
            await addDamageToPlayer(uid, 2, { skipActionLog:true });
            dmg = 2;
          }
          await healDamageToPlayer(state.userId, 1, "card_vampire_bat_heal", { skipActionLog:true });
          appendActionChatLog(state.userId, `[吸血コウモリ] ${actionDeltaText(-1)}>${actionTargetWithDamage(state.userId, -1)}, ${actionDeltaText(dmg)}>${actionTargetWithDamage(uid, dmg)}`).catch(() => {});
        }
      };
    }
    if (name === "三つ目の黒犬"){
      return {
        theme:"black",
        title:"三つ目の黒犬：対象プレイヤーを選択してください。",
        onlyAlive:true,
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "いにしえの聖杯") ? "🏺" : "",
        resolver: async (uid) => {
          await recordFactionRelationInferenceFromRevealedTarget(state.userId, uid, "enemy", "card_attack_target_revealed");
          await waitMs(1000);
          const targetHasChalice = hasEquipmentByName(uid, "いにしえの聖杯");
          const myHasChalice = hasEquipmentByName(state.userId, "いにしえの聖杯");
          if (!targetHasChalice) await addDamageToPlayer(uid, 2);
          if (!myHasChalice) await addDamageToPlayer(state.userId, 2);
        }
      };
    }
    if (name === "呪いの人形"){
      return {
        theme:"black",
        title:"呪いの人形：対象プレイヤーを選択してください。",
        onlyAlive:true,
        nameSuffixForUid: (uid) => hasEquipmentByName(uid, "いにしえの聖杯") ? "🏺" : "",
        resolver: async (uid) => {
          await recordFactionRelationInferenceFromRevealedTarget(state.userId, uid, "enemy", "card_attack_target_revealed");
          const eye = 1 + Math.floor(Math.random() * 6);
          await emitCardDiceEvent({ kind:"curse_doll", uid: state.userId, d6: eye });
          await waitMs(1000);
          if (eye <= 4){
            if (!hasEquipmentByName(uid, "いにしえの聖杯")) await addDamageToPlayer(uid, 3, { actorUid:state.userId });
          } else if (!hasEquipmentByName(state.userId, "いにしえの聖杯")){
            await addDamageToPlayer(state.userId, 3);
          }
        }
      };
    }
    return null;
  }

  async function resolveCardTargetSessionEntry(entry){
    const card = entry?.card || null;
    const targetUid = safeText(entry?.targetUid || "");
    const spec = cardTargetSelectionSpec(card);
    if (!spec || !targetUid){
      await setCardTargetSessionState(null);
      return;
    }
    if (spec.instantCloseOnSelect){
      try {
        await spec.resolver(targetUid);
      } finally {
        pendingCardTargetSelection = null;
        cardPlayerSelectActive = false;
        updateCardInteractivity();
        renderTurnEndButton();
        await setCardTargetSessionState(null);
        greenShareDock?.classList.add("hidden");
        closeZoom();
      }
      return;
    }
    openZoomFromDeckCard(card, spec.theme, { closeOnBackdrop:false, showCloseButton:false });
    setGreenDockMeta({ title:`${safeText(card?.name || "") }：効果を処理中です。`, subtitle:"" });
    greenShareActions?.classList.add("hidden");
    renderGreenWaitingSelection(targetUid, safeText(entry?.targetName || ""), safeText(entry?.targetInitial || ""), safeText(entry?.targetColor || ""));
    greenShareDock?.classList.remove("hidden");
    cardPlayerSelectActive = true;
    updateCardInteractivity();
    renderTurnEndButton();
    try {
      await spec.resolver(targetUid);
    } finally {

      pendingCardTargetSelection = null;
      cardPlayerSelectActive = false;
      updateCardInteractivity();
      renderTurnEndButton();
      await setCardTargetSessionState(null);
      greenShareDock?.classList.add("hidden");
      closeZoom();
    }
  }

  async function openPersistentCardTargetSelection(cardObj, { restore=false } = {}){
    const spec = cardTargetSelectionSpec(cardObj);
    if (!spec) return false;
    openZoomFromDeckCard(cardObj, spec.theme, { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(true);
    pendingCardTargetSelection = { cardObj };
    const opened = openTargetSelectDock({
      title: spec.title,
      lockEndTurnUntilResolved: true,
      includeSelf: !!spec.includeSelf,
      onlyAlive: !!spec.onlyAlive,
      nameSuffixForUid: spec.nameSuffixForUid,
      onSelect: async (uid, player) => {
        if (spec.instantCloseOnSelect){
          greenShareDock?.classList.add("hidden");
          cardPlayerSelectActive = false;
          updateCardInteractivity();
          renderTurnEndButton();
          closeZoom();
        }
        await setCardTargetSessionState({
          phase:"resolving",
          card: cardObj,
          targetUid: safeText(uid || ""),
          targetName: safeText(player?.name || ""),
          targetInitial: firstChar(player?.name || ""),
          targetColor: safeText(player?.color || "")
        });
        try {
          await spec.resolver(uid);
        } finally {
          pendingCardTargetSelection = null;
          await setCardTargetSessionState(null);
          closeZoom();
        }
      }
    });

    if (!opened){
      pendingCardTargetSelection = null;
      await setCardTargetSessionState(null);
      closeZoom();
      return false;
    }

    if (!restore){
      await setCardTargetSessionState({
        phase:"selecting",
        card: cardObj
      });
    }
    return true;
  }

  function openGreenShareDock(cardObj, { attackRangeOnly=false } = {}){
    greenShareCard = cardObj || null;
    if (!greenShareCard || !greenShareDock || !greenShareList){
      setGreenTurnEndButtonLock(false);
      greenShareDock?.classList.add("hidden");
      return;
    }
    setGreenTurnEndButtonLock(true);

    setGreenDockMeta({ title:"誰に渡しますか。", subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";
    const mySeat = currentMySeatIndex();
    const attackRangeTargetUids = attackRangeOnly ? attackRangeTargetUidsFor(state.userId) : null;
    const players = latestPlayers
      .filter(p => p.id !== state.userId && Number(p.seatIndex || 0) !== mySeat)
      .filter(p => !attackRangeOnly || (attackRangeTargetUids instanceof Set && attackRangeTargetUids.has(p.id)))
      .filter(p => !isPlayerEliminated(p.id))
      .sort((a,b) => Number(a.seatIndex||999)-Number(b.seatIndex||999));

    for (const p of players){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      btn.title = `${safeText(p.name)} に渡す`;

      const chip = buildChipFor(p.id);
      const name = document.createElement("span");
      name.textContent = nameFromSecondChar(p.name);
      btn.appendChild(chip);
      btn.appendChild(name);

      btn.addEventListener("click", async () => {
        if (!greenShareCard || !state.roomCode || !p?.id) return;
        const requestId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        const payload = {
          from: state.userId,
          to: p.id,
          requestId,
          card: greenShareCard,
          at: Date.now()
        };
        await set(ref(db, `rooms/${state.roomCode}/greenRequests/${requestId}`), payload);
        await set(ref(db, `rooms/${state.roomCode}/greenInbox/${p.id}`), payload);
        appendActionChatLog(state.userId, `緑ドロー：[${safeText(greenShareCard?.effect || greenShareCard?.text || "")}]>${displayNameForUid(p.id)}　回答待ち`).catch(() => {});

        pendingGreenRequestId = requestId;
        renderGreenWaitingSelection(p.id, p.name, firstChar(p.name || ""), safeText(p.color || ""));
        setGreenDockMeta({ title:"回答待ち...", subtitle:"" });
        greenShareActions?.classList.add("hidden");
        setGreenSessionState({
          phase: "waiting",
          card: greenShareCard,
          requestId,
          toUid: p.id,
          toName: safeText(p.name || ""),
          toInitial: firstChar(p.name || ""),
          toColor: safeText(p.color || ""),
          answerLabel: ""
        }).catch(() => {});

        if (isNpcPlayerUid(p.id)){
          resolveNpcGreenInboxPayload(payload).catch(() => {});
        }
      });

      greenShareList.appendChild(btn);
    }
    greenShareDock.classList.remove("hidden");
    updateGreenShareDockPosition();
    syncGreenInteractionUiState();
    setGreenSessionState({ phase:"selecting", card:greenShareCard, attackRangeOnly: !!attackRangeOnly }).catch(() => {});
  }

  function openGreenAnswerDock(msg){
    if (!greenShareDock || !greenShareList || !msg?.card) return;
    setGreenTurnEndButtonLock(true);
    greenShareCard = msg.card;
    pendingGreenAnswerMsg = msg;
    setGreenSessionState({ phase:"answering", msg }).catch(() => {});
    const reveal = greenRevealByRequestId[safeText(msg.requestId || "")];
    if (reveal?.roleId){
      showGreenRevealPanel(reveal.roleId, reveal.responderId);
    } else {
      hideGreenRevealPanel();
    }
    const cardText = safeText(msg.card.effect || "");
    const isRevealIdentity = isRevealIdentityGreenCard(msg.card);
    setGreenDockMeta({
      title: isRevealIdentity ? "質問が届きました" : "回答を選んでください",
      subtitle:cardText
    });
    greenShareActions?.classList.add("hidden");
    greenShareList.innerHTML = "";

    if (isRevealIdentity){
      const requestId = safeText(msg.requestId || "");
      const reveal = greenRevealByRequestId[requestId];
      if (!reveal?.roleId){
        applyGreenAnswerEffect(msg, { id:"reveal_identity", label:"私の正体です。" }).catch(() => {});
      }
      remove(ref(db, `rooms/${state.roomCode}/greenInbox/${state.userId}`)).catch(() => {});
      greenShareDock.classList.remove("hidden");
      updateGreenShareDockPosition();
      return;
    }

    const isUlrich = isMyRole("SHA_U1");
    for (const opt of greenAnswerOptions(msg.card)){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn answer";
      btn.textContent = opt.label;
      const canUlrichGiveEquip = (opt.id !== "give_equip") || hasAnyEquipment(state.userId);
      btn.disabled = !opt.enabled || (isUlrich && !canUlrichGiveEquip);
      btn.addEventListener("click", async () => {
        if (!state.roomCode || !msg?.from || !msg?.requestId) return;

        if (opt.id === "give_equip"){
          const myItems = listEquipForUid(state.userId).filter(it => !isIdentityEquipItem(it));
          if (myItems.length === 0) return;
          const action = {
            type:"green_give",
            fromUid: state.userId,
            toUid: msg.from,
            requestId: msg.requestId,
            cardObj: msg.card,
            answerOpt: opt
          };
          restoreGreenGiveZoomSelection(action);
          return;
        }

        await applyGreenAnswerEffect(msg, opt);
        await sendGreenResponse(msg, opt);
        await setGreenSessionState(null);
        closeZoom();
      });
      greenShareList.appendChild(btn);
    }
    greenShareDock.classList.remove("hidden");
    updateGreenShareDockPosition();
    syncGreenInteractionUiState();
  }

  function hideGreenShareDock(){
    if (activeRoleAbilitySelection) return;
    greenShareCard = null;
    pendingGreenRequestId = "";
    pendingGreenAnswerMsg = null;
    hideGreenRevealPanel();
    if (greenShareList) greenShareList.innerHTML = "";
    setGreenDockMeta({ title:"誰に渡しますか。", subtitle:"" });
    greenShareActions?.classList.add("hidden");
    greenShareDock?.classList.remove("over-equip-expand");
    greenShareDock?.classList.add("hidden");
    cardPlayerSelectActive = false;
    updateCardInteractivity();
    setGreenTurnEndButtonLock(false);
    renderTurnEndButton();
    setGreenSessionState(null).catch(() => {});
    pendingGreenSessionEntry = null;
    syncGreenInteractionUiState();
  }

  function restoreGreenSessionUI(entry){
    const phase = safeText(entry?.phase || "");
    if (!phase) return;
    setGreenTurnEndButtonLock(true);
    greenSessionRestoring = true;
    try {
      if (phase === "answering" && entry?.msg?.card){
        openZoomFromDeckCard(entry.msg.card, "green", { closeOnBackdrop:false, showCloseButton:false });
        openGreenAnswerDock(entry.msg);
        return;
      }
      if (!entry?.card) return;
      openZoomFromDeckCard(entry.card, "green", { closeOnBackdrop:false, showCloseButton:false });
      greenShareCard = entry.card;
      if (phase === "selecting"){
        openGreenShareDock(entry.card, { attackRangeOnly: !!entry.attackRangeOnly });
        return;
      }

      if (!greenShareDock || !greenShareList) return;
      greenShareDock.classList.remove("hidden");
      updateGreenShareDockPosition();
      greenShareActions?.classList.add("hidden");
      pendingGreenRequestId = safeText(entry.requestId || "");
      renderGreenWaitingSelection(safeText(entry.toUid || ""), safeText(entry.toName || ""), safeText(entry.toInitial || ""), safeText(entry.toColor || ""));
      const restoreReveal = greenRevealByRequestId[pendingGreenRequestId];
      if (restoreReveal?.roleId){
        showGreenRevealPanel(restoreReveal.roleId, restoreReveal.responderId);
      } else {
        hideGreenRevealPanel();
      }
      if (phase === "confirm"){
        setGreenDockMeta({ title:"回答が届きました", subtitle:safeText(entry.answerLabel || "") });
        greenShareActions?.classList.remove("hidden");
      } else {
        setGreenDockMeta({ title:"回答待ち...", subtitle:"" });
        greenShareActions?.classList.add("hidden");
        syncGreenResponseForPendingRequest(pendingGreenRequestId).catch(() => {});
      }
    } finally {
      greenSessionRestoring = false;
      syncGreenInteractionUiState();
    }
  }

  async function syncGreenResponseForPendingRequest(requestId){
    const rid = safeText(requestId || "");
    if (!state.roomCode || !state.userId || !rid) return;
    const snap = await get(ref(db, `rooms/${state.roomCode}/greenResponses/${state.userId}`));
    const msg = snap.val() || null;
    if (!msg || safeText(msg.requestId || "") !== rid) return;
    setGreenDockMeta({ title:"回答が届きました", subtitle:safeText(msg.answerLabel || "") });
    const reveal = greenRevealByRequestId[rid];
    if (reveal?.roleId){
      showGreenRevealPanel(reveal.roleId, reveal.responderId);
    }
    greenShareActions?.classList.remove("hidden");
    const responder = playerById(safeText(msg.to || ""));
    appendGreenHistoryLogFromResponse(msg);
    await setGreenSessionState({
      phase:"confirm",
      card: greenShareCard || msg.card || null,
      requestId: rid,
      toUid: safeText(msg.to || ""),
      toName: safeText(responder?.name || ""),
      toInitial: firstChar(responder?.name || ""),
      toColor: safeText(responder?.color || ""),
      answerLabel: safeText(msg.answerLabel || "")
    });
  }

  async function clearPendingGreenBubble(){
    if (!state.roomCode || !pendingGreenRequestId) return;
    const bubbleId = pendingGreenRequestId;
    const bRef = ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${bubbleId}`);
    await remove(bRef).catch(() => {});
    pendingGreenRequestId = "";
  }

  async function notifyGreenCloseToResponder(){
    if (!state.roomCode || !pendingGreenRequestId) return;
    const requestId = safeText(pendingGreenRequestId);
    if (!requestId) return;
    const reveal = greenRevealByRequestId[requestId];
    const responderId = safeText(reveal?.responderId || "");
    if (!responderId || responderId === state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/greenCloseSignals/${responderId}`), {
      requestId,
      from: state.userId,
      at: Date.now()
    });
  }

  greenShareCloseBtn?.addEventListener("click", async () => {
    await notifyGreenCloseToResponder();
    await clearPendingGreenBubble();
    closeZoom();
  });

  function openZoomContent(contentEl, { closeOnBackdrop=true, showCloseButton=true, closeOnAnyClick=false, stageClass="" } = {}){
    hidePersistentVenomOverlay();
    zoomStage.innerHTML = "";
    zoomStage.classList.remove("zoom-stage-multi");
    if (stageClass) zoomStage.classList.add(stageClass);
    hideGreenRevealPanel();
    zoomCloseOnBackdrop = !!closeOnBackdrop;
    zoomCloseOnAnyClick = !!closeOnAnyClick;
    zoomPassthroughMode = false;
    zoomDismissHandler = null;
    zoomBackdrop.classList.remove("passthrough");
    const equipExpandEl = document.getElementById("equipExpandBackdrop");
    const equipExpandOpen = !!equipExpandEl && !equipExpandEl.classList.contains("hidden");
    const venomResolutionActive = isVenomSelectionEntry(counterPromptEntryForMe());
    zoomBackdrop.classList.toggle("over-panel", equipExpandOpen && !venomResolutionActive);
    greenZoomLocked = !showCloseButton;
    zoomStage.appendChild(contentEl);
    zoomBackdrop.classList.remove("hidden");
    syncGreenInteractionUiState();
    refreshEquipDockLayer();
    syncPersistentVenomOverlay();
  }

  function isDeductionZoomActive(){
    if (zoomBackdrop?.classList.contains("hidden")) return false;
    return !!zoomStage?.querySelector('.card72.wb-front[data-card-type="green"]');
  }

  function refreshEquipDockLayer(){
    equipDock?.classList.toggle("deduction-front", isDeductionZoomActive());
  }

  function setZoomPassthrough(enabled){
    zoomPassthroughMode = !!enabled;
    zoomBackdrop?.classList.toggle("passthrough", zoomPassthroughMode);
  }
  function openZoomFromCard(cardEl, options){
    const clone = cardEl.cloneNode(true);
    clone.classList.remove("locked","blocked");
    clone.classList.remove("equip-steal-pulse","equip-defeat-pulse","eliminated-dim");
    clone.style.pointerEvents = "auto";
    openZoomContent(clone, options);
  }
  function setZoomOverPanel(enabled){
    zoomBackdrop?.classList.toggle("over-panel", !!enabled);
  }
  function openZoomFromRole(role, options){
    if (!role) return;
    const cardEl = createIdentityCard(role);
    if (options?.enableRevealPop) cardEl.dataset.revealInteractive = "1";
    openZoomContent(cardEl, { showCloseButton:false, ...(options || {}) });
  }
  function openIdentityRevealZoom(role, revealerUid, options = {}){
    if (!role) return;
    const wrap = document.createElement("div");
    wrap.style.position = "relative";
    const cardEl = createIdentityCard(role);
    wrap.appendChild(cardEl);

    const showOwnerTag = (options.showOwnerTag !== false);
    if (showOwnerTag && revealerUid && revealerUid !== state.userId){
      const owner = playerById(revealerUid);
      if (owner){
        const chip = buildChipFor(revealerUid);
        const label = document.createElement("div");
        label.className = "zoom-identity-owner";
        const name = document.createElement("span");
        name.textContent = nameFromSecondChar(owner.name || "");
        label.appendChild(chip);
        label.appendChild(name);
        wrap.appendChild(label);
        const ownerTagDurationMs = Math.max(0, Number(options.ownerTagDurationMs || 1200));
        if (ownerTagDurationMs > 0){
          setTimeout(() => { label.remove(); }, ownerTagDurationMs);
        }
      }
    }

    openZoomContent(wrap, { closeOnBackdrop:false, showCloseButton:false });
    if (options.persist) return;
    setTimeout(() => {
      if (activeRoleAbilitySelection) return;
      if (!zoomBackdrop.classList.contains("hidden")) closeZoom();
    }, 1800);
  }
  function openMultiIdentityRevealZoom(entries = []){
    const targets = (entries || []).filter(v => v?.role && v?.uid);
    if (!targets.length) return;
    const row = document.createElement("div");
    row.className = "zoom-identity-multi";

    for (const item of targets){
      const owner = playerById(item.uid);
      const cell = document.createElement("div");
      cell.className = "zoom-identity-multi-item";

      const inner = document.createElement("div");
      inner.className = "zoom-identity-multi-item-inner";
      const cardEl = createIdentityCard(item.role);
      inner.appendChild(cardEl);

      if (owner){
        const chip = buildChipFor(item.uid);
        const label = document.createElement("div");
        label.className = "zoom-identity-owner";
        const name = document.createElement("span");
        name.textContent = nameFromSecondChar(owner.name || "");
        label.appendChild(chip);
        label.appendChild(name);
        inner.appendChild(label);
      }

      cell.appendChild(inner);
      row.appendChild(cell);
    }

    openZoomContent(row, { closeOnBackdrop:false, showCloseButton:false, stageClass:"zoom-stage-multi" });
    setTimeout(() => {
      if (!zoomBackdrop.classList.contains("hidden")) closeZoom();
    }, 1800);
  }
  function openZoomFromDeckCard(cardObj, theme, options){
    if (!cardObj) return;
    const cardEl = document.createElement("div");
    cardEl.className = `card72 wb-front ${theme === "black" ? "wb-black" : theme === "green" ? "wb-green" : "wb-white"}`;
    cardEl.innerHTML = buildWbFrontHTML(cardObj, theme);
    adjustCardNameFont(cardEl);
    cardEl.dataset.cardType = theme || "";
    openZoomContent(cardEl, options);
  }

  async function waitUntilZoomClosed({ maxWaitMs = 12000, pollMs = 60 } = {}){
    const startedAt = Date.now();
    while (Date.now() - startedAt < Math.max(200, Number(maxWaitMs) || 12000)){
      if (zoomBackdrop?.classList.contains("hidden")) return true;
      await new Promise(resolve => setTimeout(resolve, Math.max(20, Number(pollMs) || 60)));
    }
    return !!zoomBackdrop?.classList.contains("hidden");
  }
  function closeZoom(){
    zoomBackdrop.classList.add("hidden");
    zoomBackdrop.classList.remove("passthrough");
    zoomBackdrop.classList.remove("david-overlay-global");
    zoomStage.innerHTML = "";
    hideGreenRevealPanel();
    zoomCloseOnBackdrop = true;
    zoomCloseOnAnyClick = false;
    zoomPassthroughMode = false;
    pendingGreenAnswerMsg = null;
    zoomDismissHandler = null;
    greenZoomLocked = false;
    hideGreenShareDock();
    hideRevealPop();
    hideRoomActionPop();
    hideDavidSelectPreview();
    zoomBackdrop?.classList.remove("david-select-active");
    equipDock?.classList.remove("david-select-front");
    refreshEquipDockLayer();
    syncPersistentVenomOverlay();
    ensureDavidOverlayVisibleForAll();
    syncGreenInteractionUiState();
  }
  zoomBackdrop.addEventListener("click", async (e) => {
    const canClose = zoomCloseOnAnyClick || (e.target === zoomBackdrop && zoomCloseOnBackdrop);
    if (canClose){
      const equipExpandOpen = !!equipExpandBackdrop && !equipExpandBackdrop.classList.contains("hidden");
      let shouldCloseEquipExpand = false;
      if (equipExpandOpen && e.target === zoomBackdrop){
        const popEl = equipExpandBackdrop.querySelector(".equip-expand-pop");
        if (popEl){
          const rect = popEl.getBoundingClientRect();
          const x = Number(e.clientX || 0);
          const y = Number(e.clientY || 0);
          shouldCloseEquipExpand = x < rect.left || x > rect.right || y < rect.top || y > rect.bottom;
        } else {
          shouldCloseEquipExpand = true;
        }
      }
      if (typeof zoomDismissHandler === "function"){
        await zoomDismissHandler();
        return;
      }
      await clearPendingGreenBubble();
      closeZoom();
      if (shouldCloseEquipExpand){
        closeEquipExpand();
      }
    }
  });

  let slot1 = document.getElementById('slot1');
  let slot2 = document.getElementById('slot2');
  const slot3 = document.getElementById('slot3');
  let slot4 = document.getElementById('slot4');
  const slot5 = document.getElementById('slot5');

  function updateCardInteractivity(){
    const s1 = document.getElementById('slot1');
    const s2 = document.getElementById('slot2');
    const s3 = document.getElementById('slot3');
    const s4 = document.getElementById('slot4');
    const s5 = document.getElementById('slot5');

    const types = [
      [s1, s1?.dataset.cardType],
      [s2, s2?.dataset.cardType],
      [s3, s3?.dataset.cardType],
      [s4, s4?.dataset.cardType],
      [s5, s5?.dataset.cardType],
    ];

    for (const [el, t] of types){
      if (!el || !t){
        applyLocked(el, false);
        continue;
      }

      const isRevealSlot = (el.id === "slot3" || el.id === "slot5") && el.classList.contains("wb-front");
      if (isRevealSlot){
        applyLocked(el, false);
        continue;
      }

      const shouldLock = !canClickType(t);

      const noDim = !isMyTurn() && ["white", "black", "green"].includes(t);

      applyLocked(el, shouldLock, { noDim });
    }
  }

  let equipCache = {};
  const equipBody = document.getElementById("equipBody");

  function subscribeEquipment(){
    const eRef = ref(db, `rooms/${state.roomCode}/equipment`);
    onValue(eRef, snap => {
      const next = snap.val() || {};
      if (!identityRevealInitialized){
        identityRevealInitialized = true;
        const initSeen = {};
        for (const [uid, row] of Object.entries(next)){
          initSeen[uid] = Number(row?.identity?.revealedAt || 0);
        }
        identityRevealSeenByUid = initSeen;
      } else {
        for (const [uid, row] of Object.entries(next)){
          const at = Number(row?.identity?.revealedAt || 0);
          if (!at) continue;
          if (Number(row?.identity?.inheritedAt || 0) > 0){
            identityRevealSeenByUid[uid] = at;
            continue;
          }
          const seen = Number(identityRevealSeenByUid[uid] || 0);
          if (at <= seen) continue;
          identityRevealSeenByUid[uid] = at;
          if (safeText(row?.identity?.revealedBy || "") === AUTO_IDENTITY_REVEAL_BY) continue;
          const rid = safeText(row?.identity?.roleId || "");
          const role = ROLE_BY_ID[rid];
          if (role){
            openIdentityRevealZoom(role, uid, {
              ownerTagDurationMs: 1200,
              showOwnerTag: true
            });
          }
        }
      }
      equipCache = next;
      renderEquipmentDock();
      evaluateAutoIdentityRevealTrigger();
    });
  }
  function isIdentityEquipItem(v){
    return v && (v.kind === "identity") && !!v.roleId;
  }
  function isPlayableEquipItem(v){
    if (!v || typeof v !== "object") return false;
    if (isIdentityEquipItem(v)) return true;
    const name = safeText(v.name || "").trim();
    const effect = safeText(v.effect || "").trim();
    return !!name && !!effect;
  }
  function equipItemCopies(item){
    if (!item || isIdentityEquipItem(item)) return 1;
    const raw = Number(item.count ?? item.qty ?? item.quantity ?? 1);
    if (!Number.isFinite(raw)) return 1;
    return Math.max(1, Math.floor(raw));
  }
  function expandedEquipItems(uid){
    const obj = equipCache?.[uid] || {};
    const expanded = [];
    for (const [key, value] of Object.entries(obj)){
      if (!isPlayableEquipItem(value)) continue;
      const item = { key, ...(value || {}) };
      const copies = equipItemCopies(item);
      for (let i = 0; i < copies; i++){
        expanded.push({ ...item, key: `${key}_${i}`, sourceKey:key, copyIndex:i });
      }
    }
    return expanded;
  }
  function listEquipForUid(uid){
    const arr = expandedEquipItems(uid);
    arr.sort((a,b) => {
      const ai = isIdentityEquipItem(a) ? 0 : 1;
      const bi = isIdentityEquipItem(b) ? 0 : 1;
      if (ai !== bi) return ai - bi;
      return Number(a.at||0) - Number(b.at||0);
    });
    return arr;
  }

  function buildEquipTag(colorHex, initial){
    const d = document.createElement("div");
    d.className = "equip-tag";
    d.style.background = String(colorHex || "#ddd");
    d.style.color = textColorFor(colorHex || "#ddd");
    d.textContent = String(initial || "").slice(0,1);
    return d;
  }

  function buildEquipCard(item){
    if (isIdentityEquipItem(item)){
      const role = ROLE_BY_ID[item.roleId];
      if (!role) return document.createElement("div");
      return createIdentityCard(role);
    }
    const theme = safeText(item.theme || "white");
    const cardObj = { name: safeText(item.name), effect: safeText(item.effect) };
    const el = document.createElement("div");
    el.className = `card72 wb-front ${theme === "black" ? "wb-black" : theme === "green" ? "wb-green" : "wb-white"}`;
    el.innerHTML = buildWbFrontHTML(cardObj, theme);
    adjustCardNameFont(el);
    el.dataset.cardType = theme || "";
    return el;
  }

  let latestPlayers = [];
  let lastAttackWatch = null;
  let attackExpectedEliminationUids = new Set();
  let attackExpectedEliminationAt = 0;
  let previousEliminatedMap = {};
  let pendingAttackLoot = null;
  let pendingAttackLootEndTurnRequest = null;
  let deferredTurnEndRequest = null;
  const attackLootBackdrop = document.getElementById("attackLootBackdrop");
  const attackLootBody = document.getElementById("attackLootBody");
  const attackLootHeader = document.getElementById("attackLootHeader");

  function normalizeAttackLootPayload(raw){
    if (!raw || typeof raw !== "object") return null;
    const uid = safeText(raw.uid || "");
    const mode = safeText(raw.mode || "defeated") || "defeated";
    const defeatedUids = Array.isArray(raw.defeatedUids)
      ? raw.defeatedUids.map(v => safeText(v || "")).filter(v => v && v !== uid)
      : [];
    const targetUids = Array.isArray(raw.targetUids)
      ? raw.targetUids.map(v => safeText(v || "")).filter(v => v && v !== uid)
      : [];
    const selected = raw.selected && typeof raw.selected === "object"
      ? {
          ownerUid: safeText(raw.selected.ownerUid || ""),
          sourceKey: safeText(raw.selected.sourceKey || ""),
          noSteal: !!raw.selected.noSteal
        }
      : null;
    const selectedByOwner = raw.selectedByOwner && typeof raw.selectedByOwner === "object"
      ? Object.entries(raw.selectedByOwner).reduce((acc, [ownerUid, item]) => {
          const normalizedOwner = safeText(ownerUid || "");
          if (!normalizedOwner || !item || typeof item !== "object") return acc;
          acc[normalizedOwner] = {
            ownerUid: normalizedOwner,
            sourceKey: safeText(item.sourceKey || ""),
            noSteal: !!item.noSteal
          };
          return acc;
        }, {})
      : null;
    const normalizedDefeated = [...new Set(defeatedUids)];
    const normalizedTargets = [...new Set(targetUids)];
    if (!uid) return null;
    if (mode === "byron"){
      if (!normalizedTargets.length) return null;
      return {
        uid,
        mode,
        targetUids:normalizedTargets,
        selectedByOwner:selectedByOwner || {},
        endTurnAfterResolve: !!raw.endTurnAfterResolve,
        endTurnExpectedUid: safeText(raw.endTurnExpectedUid || ""),
        at:Number(raw.at || Date.now())
      };
    }
    if (!normalizedDefeated.length) return null;
    return {
      uid,
      mode:"defeated",
      defeatedUids:normalizedDefeated,
      selected,
      endTurnAfterResolve: !!raw.endTurnAfterResolve,
      endTurnExpectedUid: safeText(raw.endTurnExpectedUid || ""),
      at:Number(raw.at || Date.now())
    };
  }

  function consumePendingAttackLootEndTurnRequest(){
    const req = pendingAttackLootEndTurnRequest;
    if (!req) return null;
    const isExpired = Number(req.expiresAt || 0) <= Date.now();
    const sameTurnOwner = safeText(req.turnOwnerUid || "") === safeText(currentTurnPlayerId() || "");
    pendingAttackLootEndTurnRequest = null;
    if (isExpired || !sameTurnOwner) return null;
    return req;
  }

  function roomNonIdentityEquipCount(roomData, uid){
    if (!uid || !roomData || typeof roomData !== "object") return 0;
    const equip = roomData.equipment?.[uid];
    if (!equip || typeof equip !== "object") return 0;
    let count = 0;
    for (const value of Object.values(equip)){
      if (!value || typeof value !== "object") continue;
      if (safeText(value.kind || "") === "identity") continue;
      const copies = Math.max(1, Math.floor(Number(value.count || 1)));
      count += copies;
    }
    return count;
  }

  function hasLootableAttackLootPending(roomData, turnOwnerUid){
    const uid = safeText(turnOwnerUid || "");
    if (!uid || !roomData || typeof roomData !== "object") return false;
    const pending = roomData.attackLootPending?.[uid];
    if (!pending || typeof pending !== "object") return false;
    const mode = safeText(pending.mode || "defeated") || "defeated";
    const targets = (mode === "byron" ? pending.targetUids : pending.defeatedUids) || [];
    if (!Array.isArray(targets)) return false;
    return targets.some((rawUid) => {
      const targetUid = safeText(rawUid || "");
      if (!targetUid || targetUid === uid) return false;
      return roomNonIdentityEquipCount(roomData, targetUid) > 0;
    });
  }

  function hasPendingGodwinSelection(roomData){
    const pendingRoleSelection = roomData?.roleAbilitySelection;
    if (!pendingRoleSelection || typeof pendingRoleSelection !== "object") return false;
    return safeText(pendingRoleSelection.roleId || "") === "RAI_G3";
  }

  function hasDeferredTurnEndBlockers(roomData, turnOwnerUid){
    return hasPendingGodwinSelection(roomData) || hasLootableAttackLootPending(roomData, turnOwnerUid);
  }

  async function tryResolveDeferredTurnEnd(){
    const req = deferredTurnEndRequest;
    if (!req) return;
    const ownerUid = safeText(req.ownerUid || "");
    if (!ownerUid || ownerUid !== safeText(state.userId || "")){
      deferredTurnEndRequest = null;
      return;
    }
    if (safeText(currentTurnPlayerId() || "") !== ownerUid){
      deferredTurnEndRequest = null;
      return;
    }
    if (hasDeferredTurnEndBlockers(state.room || {}, ownerUid)) return;
    deferredTurnEndRequest = null;
    await doEndTurn(ownerUid);
  }

  async function requestAttackLootAutoEndForCurrentTurn(options = {}){
    const turnOwnerUid = safeText(currentTurnPlayerId() || "");
    if (!turnOwnerUid) return;
    pendingAttackLootEndTurnRequest = {
      turnOwnerUid,
      expiresAt: Date.now() + Math.max(1000, Number(options.expiresInMs || 15000))
    };
    const shouldSyncPending = options.syncPending !== false;
    if (!shouldSyncPending) return;
    if (!pendingAttackLoot) return;
    if (safeText(pendingAttackLoot.uid || "") !== safeText(state.userId || "")) return;
    if (pendingAttackLoot.endTurnAfterResolve && safeText(pendingAttackLoot.endTurnExpectedUid || "") === turnOwnerUid) return;
    pendingAttackLoot = {
      ...pendingAttackLoot,
      endTurnAfterResolve: true,
      endTurnExpectedUid: turnOwnerUid,
      at: Date.now()
    };
    await setAttackLootPending(pendingAttackLoot);
    renderAttackLootPanel();
  }

  async function setAttackLootPending(payload){
    const roomCode = safeText(state.roomCode || "");
    const uid = safeText(state.userId || "");
    if (!roomCode || !uid) return;
    const normalized = normalizeAttackLootPayload(payload);
    await set(ref(db, `rooms/${roomCode}/attackLootPending/${uid}`), normalized);
  }

  function closeAttackLootPanel(){
    attackLootBackdrop?.classList.add("hidden");
    if (attackLootBody) attackLootBody.innerHTML = "";
    if (attackLootHeader) attackLootHeader.textContent = "脱落者の装備カード";
  }

  function closeEquipmentDockBeforeLootResolve(){
    equipDock?.classList.remove("visible");
    closeEquipExpand();
  }

  async function clearAttackLootPending(){
    pendingAttackLoot = null;
    closeAttackLootPanel();
    await setAttackLootPending(null);
  }

  async function createOrMergeAttackLootPending(defeatedUids = [], options = {}){
    const uid = safeText(state.userId || "");
    if (!uid) return;
    const list = (defeatedUids || []).map(v => safeText(v || "")).filter(v => v && v !== uid);
    if (!list.length) return;
    const requestedEndTurn = !!options.endTurnAfterResolve;
    const requestTurnOwnerUid = safeText(options.endTurnExpectedUid || "") || safeText(currentTurnPlayerId() || "");
    const carry = consumePendingAttackLootEndTurnRequest();
    const keepEndTurn = !!pendingAttackLoot?.endTurnAfterResolve;
    const shouldEndTurnAfterResolve = keepEndTurn || requestedEndTurn || !!carry;
    const endTurnExpectedUid = keepEndTurn
      ? safeText(pendingAttackLoot?.endTurnExpectedUid || "")
      : (requestedEndTurn ? requestTurnOwnerUid : safeText(carry?.turnOwnerUid || ""));
    const merged = new Set([...(pendingAttackLoot?.defeatedUids || []), ...list]);
    pendingAttackLoot = {
      uid,
      defeatedUids:[...merged],
      selected: pendingAttackLoot?.selected || null,
      endTurnAfterResolve: shouldEndTurnAfterResolve,
      endTurnExpectedUid,
      at: Date.now()
    };
    await setAttackLootPending(pendingAttackLoot);
    renderAttackLootPanel();
  }

  async function createByronAttackLootPending(targetUids = []){
    const uid = safeText(state.userId || "");
    if (!uid) return;
    const list = (targetUids || []).map(v => safeText(v || "")).filter(v => v && v !== uid);
    if (!list.length) return;
    pendingAttackLoot = {
      uid,
      mode:"byron",
      targetUids:[...new Set(list)],
      selectedByOwner:{},
      at: Date.now()
    };
    await setAttackLootPending(pendingAttackLoot);
    renderAttackLootPanel();
  }

  function orderedPlayersForEquip(){
    const byId = new Map(latestPlayers.map(p => [p.id, p]));
    const me = byId.get(state.userId) || null;
    const others = latestPlayers.filter(p => p.id !== state.userId).sort((a,b) => a.seatIndex - b.seatIndex);

    const davidPromoted = (pendingEquipAction?.type === "david_select")
      ? others.filter(p => pendingEquipAction.defeatedUids?.includes(p.id))
      : [];

    const arr = [];
    for (const p of davidPromoted){
      arr.push(p);
    }
    if (me) arr.push(me);
    for (const p of others){
      if (arr.some(row => row.id === p.id)) continue;
      arr.push(p);
    }
    return arr;
  }

  function getEquipCols(){
    const body = equipBody;
    const dock = equipDock;
    const w = (body?.clientWidth || dock?.clientWidth || 0);
    const cardW = 72;
    const gap = 8;
    const usable = Math.max(0, w);
    const cols = Math.floor((usable + gap) / (cardW + gap));
    return Math.max(2, Math.min(10, cols || 6));
  }
  function applyEquipCols(){
    const cols = getEquipCols();
    equipBody?.style.setProperty('--equip-cols', String(cols));
  }
  window.addEventListener('resize', () => applyEquipCols());

  function renderEquipmentDock(){
    syncRoomAbilityTurnState();
    equipDock?.classList.toggle("david-select-front", pendingEquipAction?.type === "david_select");
    refreshEquipDockLayer();
    if (!state.roomCode) { equipDock.classList.remove("visible"); closeEquipExpand(); return; }

    updateEquipDockTop();

    const players = orderedPlayersForEquip();
    const rows = [];
    for (const p of players){
      const list = listEquipForUid(p.id);
      if (!list || list.length === 0) continue;
      rows.push({ p, list });
    }

    equipBody.innerHTML = "";

    if (rows.length === 0){
      equipDock.classList.remove("visible");
      closeEquipExpand();
      return;
    }

    equipDock.classList.add("visible");

    for (const {p, list} of rows){
      const row = document.createElement("div");
      row.className = "equip-row";

      const tag = buildEquipTag(p.color || "#ddd", firstChar(p.name));
      row.appendChild(tag);

      const cards = document.createElement("div");
      cards.className = "equip-cards";
      const eliminated = isPlayerEliminated(p.id);
      for (const it of list){
        const cardEl = buildEquipCard(it);
        if (eliminated) cardEl.classList.add("eliminated-dim");
        cardEl.dataset.ownerUid = p.id;
        cardEl.dataset.sourceKey = safeText(it.sourceKey || "");
        cardEl.dataset.cardName = safeText(it.name || "");
        cardEl.dataset.cardTheme = safeText(it.theme || "white");
        cardEl.dataset.cardEffect = safeText(it.effect || "");
        const isNormalStealPulse = canUseRoom4Steal() && p.id !== state.userId && !eliminated && !isIdentityEquipItem(it);
        const isOliverPulse = pendingEquipAction?.type === "oliver_target" && p.id !== state.userId && !eliminated && !isIdentityEquipItem(it);
        const isBananaPulse = pendingEquipAction?.type === "banana_give" && p.id === state.userId && !isIdentityEquipItem(it);
        const isGreenGivePulse = pendingEquipAction?.type === "green_give" && p.id === state.userId && !isIdentityEquipItem(it);
        const isBenjaminPulse = pendingEquipAction?.type === "benjamin_give" && p.id === state.userId && !isIdentityEquipItem(it);
        const isVenomPulse = isVenomSelectionEntry(counterPromptEntryForMe()) && p.id === state.userId && !eliminated && !isIdentityEquipItem(it);
        const isDavidPulse = pendingEquipAction?.type === "david_select"
          && pendingEquipAction.defeatedUids?.includes(p.id)
          && p.id !== state.userId
          && eliminated
          && !isIdentityEquipItem(it);
        if (isNormalStealPulse || isOliverPulse || isBananaPulse || isGreenGivePulse || isBenjaminPulse){
          cardEl.classList.add("equip-steal-pulse");
        }
        if (isDavidPulse || isVenomPulse){
          cardEl.classList.add("equip-defeat-pulse");
        }
        cards.appendChild(cardEl);
      }
      row.appendChild(cards);
      equipBody.appendChild(row);
    }
    refreshRoomAbilityHint();
    ensureDavidIdentityZoomVisible();
    if (equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden')){
      renderEquipExpandBody();
    }
  }

  function renderAttackLootPanel(){
    const payload = pendingAttackLoot;
    if (!attackLootBackdrop || !attackLootBody){
      return;
    }
    if (!payload){
      closeAttackLootPanel();
      return;
    }

    attackLootBody.innerHTML = "";
    const byId = new Map(latestPlayers.map(p => [p.id, p]));
    const mode = safeText(payload.mode || "defeated") || "defeated";
    if (attackLootHeader){
      attackLootHeader.textContent = (mode === "byron") ? "奪う装備を選んでください。" : "脱落者の装備カード";
    }
    const selected = payload.selected || null;
    const selectedByOwner = payload.selectedByOwner || {};
    let lastCardsWrap = null;
    let hasLootableCard = false;

    const rowUids = mode === "byron" ? (payload.targetUids || []) : (payload.defeatedUids || []);

    for (const uid of rowUids){
      const p = byId.get(uid);
      if (!p) continue;
      const rawList = listEquipForUid(uid);
      const hasLootableEquip = rawList.some(it => !isIdentityEquipItem(it));
      if (!hasLootableEquip) continue;
      const identityItem = rawList.find(it => isIdentityEquipItem(it));
      const list = [];
      if (mode === "byron" && identityItem){
        list.push(identityItem);
      }
      for (const it of rawList){
        if (mode === "byron" && identityItem && it === identityItem) continue;
        list.push(it);
      }

      const row = document.createElement("div");
      row.className = "attack-loot-row";
      if (mode === "byron") row.classList.add("byron-row");
      row.appendChild(buildEquipTag(p.color || "#ddd", firstChar(p.name)));

      const cardsWrap = document.createElement("div");
      cardsWrap.className = "attack-loot-cards";
      const rowSelected = (mode === "byron") ? (selectedByOwner[uid] || null) : null;
      for (const it of list){
        const cardEl = buildEquipCard(it);
        cardEl.dataset.ownerUid = uid;
        cardEl.dataset.sourceKey = safeText(it.sourceKey || "");
        cardEl.dataset.cardName = safeText(it.name || "");
        cardEl.dataset.itemKind = isIdentityEquipItem(it) ? "identity" : "equip";
        if (!isIdentityEquipItem(it)){
          hasLootableCard = true;
          if (!rowSelected) cardEl.classList.add("equip-defeat-pulse");
        }
        const isSelected = mode === "byron"
          ? (!!rowSelected && !rowSelected.noSteal && rowSelected.sourceKey === safeText(it.sourceKey || ""))
          : (selected && !selected.noSteal && selected.ownerUid === uid && selected.sourceKey === safeText(it.sourceKey || ""));
        if (isSelected && !isIdentityEquipItem(it)){
          cardEl.classList.remove("equip-defeat-pulse");
          if (mode === "byron"){
            cardEl.classList.add("byron-selected-card");
          } else {
            cardEl.classList.add("equip-steal-pulse");
          }
        }
        cardsWrap.appendChild(cardEl);
      }

      if (mode === "byron"){
        const noStealCard = document.createElement("div");
        noStealCard.className = "card72 wb-front wb-white attack-loot-no-steal";
        if (!rowSelected) noStealCard.classList.add("equip-defeat-pulse");
        noStealCard.dataset.noSteal = "1";
        noStealCard.dataset.ownerUid = uid;
        noStealCard.textContent = "奪わない";
        if (rowSelected?.noSteal){
          noStealCard.classList.remove("equip-defeat-pulse");
          noStealCard.classList.add("byron-selected-card");
        }
        cardsWrap.appendChild(noStealCard);
        if (rowSelected){
          row.classList.add("selected");
        }
      }

      row.appendChild(cardsWrap);
      attackLootBody.appendChild(row);
      lastCardsWrap = cardsWrap;
    }

    if (!hasLootableCard){
      closeAttackLootPanel();
      return;
    }

    if (mode === "byron"){
      attackLootBackdrop.classList.remove("hidden");
      return;
    }

    const noStealCard = document.createElement("div");
    noStealCard.className = "card72 wb-front wb-white attack-loot-no-steal equip-defeat-pulse";
    noStealCard.dataset.noSteal = "1";
    noStealCard.textContent = "奪わない";
    if (selected?.noSteal){
      noStealCard.classList.remove("equip-defeat-pulse");
      noStealCard.classList.add("equip-steal-pulse");
    }
    if (lastCardsWrap){
      lastCardsWrap.appendChild(noStealCard);
    } else {
      const row = document.createElement("div");
      row.className = "attack-loot-row";
      const cardsWrap = document.createElement("div");
      cardsWrap.className = "attack-loot-cards";
      cardsWrap.appendChild(noStealCard);
      row.appendChild(cardsWrap);
      attackLootBody.appendChild(row);
    }
    attackLootBackdrop.classList.remove("hidden");
  }


  async function commitAttackLootSelection(selection){
    if (!pendingAttackLoot) return;
    if (safeText(pendingAttackLoot.mode || "") === "byron"){
      const selectedByOwner = pendingAttackLoot.selectedByOwner || {};
      const targets = (pendingAttackLoot.targetUids || []).filter(uid => !!selectedByOwner[uid]);
      if (!targets.length) return;
      const turnOwnerUid = currentTurnPlayerId();
      closeAttackLootPanel();
      closeEquipmentDockBeforeLootResolve();
      for (const ownerUid of targets){
        const pick = selectedByOwner[ownerUid];
        if (!pick || pick.noSteal) continue;
        const sourceKey = safeText(pick.sourceKey || "");
        if (!sourceKey) continue;
        await stealEquipmentFromPlayer(ownerUid, sourceKey);
      }
      await clearAttackLootPending();
      closeZoom();
      renderEquipmentDock();
      await doEndTurn(turnOwnerUid);
      return;
    }
    if (selection?.noSteal){
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "奪わなくて本当にいいですか。", async () => {
        const shouldEndTurn = !!pendingAttackLoot?.endTurnAfterResolve;
        const expectedUid = safeText(pendingAttackLoot?.endTurnExpectedUid || "") || safeText(currentTurnPlayerId() || "");
        await clearAttackLootPending();
        if (shouldEndTurn && expectedUid && expectedUid === safeText(currentTurnPlayerId() || "")){
          await doEndTurn(expectedUid);
        }
      }, { fixedLower:true, closeZoomOnNo:true });
      return;
    }
    const ownerUid = safeText(selection?.ownerUid || "");
    const sourceKey = safeText(selection?.sourceKey || "");
    if (!ownerUid || !sourceKey) return;
    closeAttackLootPanel();
    closeEquipmentDockBeforeLootResolve();
    const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
    if (ok){
      const shouldEndTurn = !!pendingAttackLoot?.endTurnAfterResolve;
      const expectedUid = safeText(pendingAttackLoot?.endTurnExpectedUid || "") || safeText(currentTurnPlayerId() || "");
      await clearAttackLootPending();
      closeZoom();
      renderEquipmentDock();
      if (shouldEndTurn && expectedUid && expectedUid === safeText(currentTurnPlayerId() || "")){
        await doEndTurn(expectedUid);
      }
    }
  }


  async function grantEquipmentToMe(cardObj, theme){
    if (!state.roomCode) return;
    if (!cardObj) return;
    if (!isEquipCard(cardObj)) return;

    const key = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const cardName = safeText(cardObj.name || "装備");
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${state.userId}/${key}`);
    await set(eRef, {
      theme: theme || "white",
      name: cardName,
      effect: safeText(cardObj.effect),
      at: Date.now()
    });
    appendActionChatLog(state.userId, `装備獲得:${cardName}`).catch(() => {});
  }

  async function setDeckToSingleCardForTest(theme, cardObj){
    if (!isTestPlayer()) return;
    if (!state.roomCode) return;
    if (!cardObj || (theme !== "white" && theme !== "black")) return;

    const deckRef = ref(db, `rooms/${state.roomCode}/deckState/${theme}`);
    await runTransaction(deckRef, (cur) => {
      if (!cur || !Array.isArray(cur.order)) return cur;
      const idx = Number(cur.idx || 0);
      const total = cur.order.length;
      if (idx >= total) return cur;
      const fixedCard = {
        name: safeText(cardObj.name),
        effect: safeText(cardObj.effect)
      };
      const nextOrder = [...cur.order];
      for (let i = idx; i < total; i++){
        nextOrder[i] = fixedCard;
      }
      return {
        ...cur,
        order: nextOrder,
      };
    });
  }

  async function removeEquipmentCardForTest(ownerUid, sourceKey){
    if (!isTestPlayer()) return;
    if (!state.roomCode) return;
    if (!ownerUid || !sourceKey) return;
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${ownerUid}/${sourceKey}`);
    await set(eRef, null);
  }

  async function revealMyIdentityToEquipment(options = {}){
    if (!state.roomCode) return;
    const my = state.hands?.[state.userId];
    if (!my || !my.roleId) return;

    const revealedBy = safeText(options.revealedBy || "");
    const useAgathaAbilityOnReveal = options.useAgathaAbilityOnReveal !== false;
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${state.userId}/identity`);
    let revealedNow = false;
    await runTransaction(eRef, (cur) => {
      if (cur && cur.kind === "identity" && cur.roleId) return cur;
      revealedNow = true;
      const next = {
        kind: "identity",
        roleId: String(my.roleId),
        at: 0,
        revealedAt: Date.now()
      };
      if (revealedBy) next.revealedBy = revealedBy;
      return next;
    });
    if (revealedNow){
      const roleName = safeText(ROLE_BY_ID?.[safeText(my.roleId)]?.name || "?");
      appendActionChatLog(state.userId, `カード公開:${roleName}`).catch(() => {});
    }
    if (revealedNow && safeText(my.roleId) === "CIT_C2" && !isMyAbilitySealed()){
      await healDamageToPlayer(state.userId, 2, "carol_reveal_heal");
      if (isMyTurn()){
        carolTurnHealKey = turnCycleKey();
      }
    }
    if (revealedNow && safeText(my.roleId) === "CIT_A3" && useAgathaAbilityOnReveal){
      if (zoomBackdrop && !zoomBackdrop.classList.contains("hidden")) closeZoom();
      await triggerAgathaRevealAbility();
    }
  }

  async function revealIdentityToEquipmentForUid(uid, options = {}){
    const targetUid = safeText(uid || "");
    if (!state.roomCode || !targetUid) return;
    const hand = state.hands?.[targetUid];
    if (!hand || !hand.roleId) return;

    const revealedBy = safeText(options.revealedBy || "");
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${targetUid}/identity`);
    let revealedNow = false;
    await runTransaction(eRef, (cur) => {
      if (cur && cur.kind === "identity" && cur.roleId) return cur;
      revealedNow = true;
      const next = {
        kind: "identity",
        roleId: String(hand.roleId),
        at: 0,
        revealedAt: Date.now()
      };
      if (revealedBy) next.revealedBy = revealedBy;
      return next;
    });
    if (revealedNow){
      const roleName = safeText(ROLE_BY_ID?.[safeText(hand.roleId)]?.name || "?");
      appendActionChatLog(targetUid, `カード公開:${roleName}`).catch(() => {});
    }
  }

  function hasNonIdentityEquipment(uid){
    return listEquipForUid(uid).some(it => !isIdentityEquipItem(it));
  }

  function getDavidEligibleEliminatedUids(){
    return latestPlayers
      .filter(p => p.id !== state.userId)
      .filter(p => isPlayerEliminated(p.id))
      .filter(p => hasNonIdentityEquipment(p.id))
      .map(p => p.id);
  }

  function isDavidAbilityPending(){
    return pendingEquipAction?.type === "david_select";
  }

  function isDavidAbilityUsed(){
    return !!state.room?.abilityUsage?.david?.[state.userId];
  }

  async function markDavidAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/david/${state.userId}`), true);
  }

  async function setDavidAbilityOverlayState(payload){
    if (!state.roomCode) return;
    const overlayRef = ref(db, `rooms/${state.roomCode}/davidAbilityOverlay`);
    if (!payload || !payload.actorUid){
      await remove(overlayRef).catch(() => {});
      syncDavidOverlayFloatingButtons();
      return;
    }
    await set(overlayRef, {
      actorUid: safeText(payload.actorUid || ""),
      active: payload.active !== false,
      at: Date.now()
    });
    syncDavidOverlayFloatingButtons();
  }

  function isAgathaAbilityUsed(){
    return !!state.room?.abilityUsage?.agatha?.[state.userId];
  }

  async function markAgathaAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/agatha/${state.userId}`), true);
  }

  async function triggerAgathaRevealAbility(options = {}){
    if (!state.userId || !state.roomCode) return;
    if (isAgathaAbilityUsed()) return;

    await markAgathaAbilityUsed();
    const rolled = {
      d6: 1 + Math.floor(Math.random() * 6),
      d4: 1 + Math.floor(Math.random() * 4)
    };
    const revealCloseAt = Date.now() + 1200;
    showAgathaRevealCardOverlay(state.userId, { closeAt: revealCloseAt });
    await emitCardDiceEvent({ kind:"role_agatha", uid:state.userId, d6:rolled.d6, d4:rolled.d4, closeAt: revealCloseAt });
    await waitMs(1000);
    const targetRoomId = diceTotalToRoomId(Number(rolled?.d6 || 0) + Number(rolled?.d4 || 0));
    await waitMs(1200);
    await addDamageToPlayers(playerIdsInRoom(targetRoomId), 3);
    await waitMs(500);
    const cleanupTimer = setTimeout(() => {
      diceRollOverlay.innerHTML = '';
      clearDiceRollTimers();
    }, 2000);
    diceRollTimers.push(cleanupTimer);

    if (options.endTurnAfterResolve && isMyTurn()){
      await doEndTurn();
    }
  }

  function restoreDavidIdentityZoom(){
    const my = state.hands?.[state.userId];
    const role = my?.roleId ? ROLE_BY_ID[my.roleId] : null;
    if (!role) return;
    openZoomFromRole(role, { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(true);
    hideDavidSelectPreview();
    zoomDismissHandler = null;
  }

  function activeDavidOverlayActorUid(){
    const entry = state.room?.davidAbilityOverlay;
    if (!entry || entry.active === false) return "";
    return safeText(entry.actorUid || "");
  }

  function syncDavidOverlayFloatingButtons(){
    const active = !!activeDavidOverlayActorUid();
    document.body?.classList.toggle("david-overlay-active", active);
  }

  function ensureDavidOverlayVisibleForAll(){
    syncDavidOverlayFloatingButtons();
    const actorUid = activeDavidOverlayActorUid();
    if (!actorUid){
      const wasDavidOverlay = !!zoomBackdrop?.classList.contains("david-overlay-global");
      zoomBackdrop?.classList.remove("david-overlay-global");
      if (wasDavidOverlay && !zoomBackdrop?.classList.contains("hidden")){
        closeZoom();
      }
      return;
    }
    zoomBackdrop?.classList.add("david-overlay-global");
    if (activeRoleAbilitySelection) return;
    if (!zoomBackdrop?.classList.contains("hidden")) return;
    const roleId = safeText(state.hands?.[actorUid]?.roleId || "");
    const role = ROLE_BY_ID[roleId];
    if (!role || role.id !== "CIT_D2") return;
    openIdentityRevealZoom(role, actorUid, {
      persist:true,
      showOwnerTag:false
    });
    setZoomPassthrough(true);
  }

  function restoreDavidAbilitySelection(){
    if (pendingEquipAction?.type !== "david_select") return;
    pendingEquipAction = {
      type: "david_select",
      defeatedUids: [...(pendingEquipAction.defeatedUids || [])]
    };
    restoreDavidIdentityZoom();
    renderEquipmentDock();
  }

  function ensureDavidIdentityZoomVisible(){
    if (pendingEquipAction?.type !== "david_select") return;
    if (!zoomBackdrop?.classList.contains("hidden")) return;
    restoreDavidAbilitySelection();
  }

  async function startDavidAbilityFlow(){
    const defeatedUids = getDavidEligibleEliminatedUids();
    if (defeatedUids.length === 0){
      showRevealPopAt(null, { mode:"notice", message:"今は公開できません。" });
      return;
    }
    await revealMyIdentityToEquipment({ revealedBy:"david_ability" });
    await setDavidAbilityOverlayState({ actorUid:state.userId, active:true });
    pendingEquipAction = { type:"david_select", defeatedUids };
    restoreDavidIdentityZoom();
    renderEquipmentDock();
  }

  async function revealIdentityByDamage(uid){
    if (!state.roomCode || !uid) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const hand = cur.hands?.[uid];
      if (!hand?.roleId) return cur;
      cur.equipment = cur.equipment || {};
      cur.equipment[uid] = cur.equipment[uid] || {};
      const old = cur.equipment[uid].identity;
      if (old && old.kind === "identity" && old.roleId) return cur;
      cur.equipment[uid].identity = {
        kind: "identity",
        roleId: String(hand.roleId),
        at: 0,
        revealedAt: Date.now(),
        revealedBy: "damage"
      };
      return cur;
    });
  }

  function isMyIdentityRevealed(){
    const v = equipCache?.[state.userId]?.identity;
    return !!(v && v.kind === "identity" && v.roleId);
  }

  function isIdentityRevealedFor(uid){
    const targetUid = safeText(uid);
    if (!targetUid) return false;
    const v = equipCache?.[targetUid]?.identity;
    return !!(v && v.kind === "identity" && v.roleId);
  }

  function isMyRevealedVendetta(){
    return isMyRole("SHA_V3") && isMyIdentityRevealed();
  }

  zoomStage.addEventListener("click", (e) => {
    const idCard = e.target.closest(".id72");
    if (!idCard) return;
    if (isGreenInteractionActive()){
      e.stopPropagation();
      return;
    }
    if (idCard.dataset.revealInteractive !== "1") return;
    if (isEquipSelectionLockActive()){
      e.stopPropagation();
      return;
    }
    if (isIdentityRevealPopBlockedByEffectPop()){
      e.stopPropagation();
      return;
    }

    const my = state.hands?.[state.userId];
    if (!my || !my.roleId) return;

    const myRoleId = safeText(my.roleId || "");
    if ((myRoleId === "CIT_C1" || myRoleId === "SHA_U3") && isMyTurn()){
      e.stopPropagation();
      return;
    }
    if (myRoleId === "CIT_B3" && isMyTurn()){
      e.stopPropagation();
      return;
    }
    if (myRoleId === "RAI_G2" && isMyTurn()){
      e.stopPropagation();
      return;
    }
    if (isErikaSealedPlayer(state.userId) && !isMyIdentityRevealed()){
      e.stopPropagation();
      return;
    }
    if (isMyAbilitySealed() && isMyIdentityRevealed()){
      e.stopPropagation();
      return;
    }
    if (myRoleId === "SHA_W3" || myRoleId === "SHA_V1"){
      if (isMyIdentityRevealed()){
        e.stopPropagation();
        return;
      }
      if (isCounterPromptSilentIdentityClickWindow()){
        e.stopPropagation();
        return;
      }
      e.stopPropagation();
      showRevealPopAt(idCard, { mode:"notice", message:"今は公開できません。" });
      return;
    }
    if (myRoleId === "CIT_A1" && isAliceAbilityUsed()){
      e.stopPropagation();
      return;
    }
    if (!isMyTurn()){
      if (isMyIdentityRevealed()){
        e.stopPropagation();
        return;
      }
      if (isCounterPromptSilentIdentityClickWindow()){
        e.stopPropagation();
        return;
      }
      e.stopPropagation();
      showRevealPopAt(idCard, { mode:"notice", message:"今は公開できません。" });
      return;
    }
    if (isMyIdentityRevealed()){
      if (isRoleSelectionAbility(myRoleId)){
        if (myRoleId === "RAI_G3"){
          e.stopPropagation();
          showRevealPopAt(idCard, { mode:"notice", message:"今は公開できません。" });
          return;
        }
        if (!isMyTurn()) return;
        if (myRoleId === "RAI_E3"){
          if (isRoleAbilityUsed("RAI_E3")) return;
          const check = emmaAbilityAvailability();
          if (!check.ok){
            e.stopPropagation();
            showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は使えません。" });
            return;
          }
        } else if (myRoleId === "SHA_U2"){
          if (isRoleAbilityUsed("SHA_U2")) return;
          const check = uranusAbilityAvailability();
          if (!check.ok){
            e.stopPropagation();
            showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は使えません。" });
            return;
          }
        } else if (myRoleId === "CIT_B2"){
          if (isRoleAbilityUsed("CIT_B2")) return;
          const check = benjaminAbilityAvailability();
          if (!check.ok){
            e.stopPropagation();
            showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は使えません。" });
            return;
          }
        } else {
          if (isRoleAbilityUsed(myRoleId)) return;
          if (START_ONLY_ABILITY_ROLE_IDS.has(myRoleId) && !!turnState()?.moveDone){
            e.stopPropagation();
            showRevealPopAt(idCard, { mode:"notice", message:"手番の初めにだけ使えます。" });
            return;
          }
          if (!canStartRoleSelection(myRoleId, state.userId)){
            e.stopPropagation();
            showRevealPopAt(idCard, { mode:"notice", message:"今は公開できません。" });
            return;
          }
        }
        const spec = roleSelectionSpec(myRoleId);
        e.stopPropagation();
        showRevealPopAt(idCard, {
          action: `role_select:${myRoleId}`,
          messageHtml: `<span class="ability-pill">${escapeHtml(spec.abilityName)}</span>を使いますか。${spec.endTurnAfterResolve ? "<br>使用後に手番が終了します。" : ""}`
        });
        return;
      }
      if (myRoleId === "CIT_A3"){
        if (isAgathaAbilityUsed()) return;
        if (!turnState()?.moveDone){
          e.stopPropagation();
          showRevealPopAt(idCard, { mode:"notice", message:"手番の最後にだけ正体を公開できます。" });
          return;
        }
        e.stopPropagation();
        showRevealPopAt(idCard, {
          action: "agatha_ability",
          messageHtml: `<span class="ability-pill">完全犯罪</span>を使いますか。<br>使用後に手番が終了します。`
        });
        return;
      }
      if (myRoleId === "CIT_A1"){
        const check = canUseAliceAbilityNow();
        if (!check.ok){
          if (isAliceAbilityUsed()){
            e.stopPropagation();
            return;
          }
          e.stopPropagation();
          showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は使えません。" });
          return;
        }
        e.stopPropagation();
        showRevealPopAt(idCard, {
          action: "alice_ability",
          messageHtml: `<span class="ability-pill">うさぎさんヒール</span>を使いますか。`
        });
        return;
      }
      if (myRoleId === "RAI_G1"){
        if (isGordonAbilityUsed()) return;
        if (!isMyTurn() || !turnState()?.moveDone || !!turnState()?.attackDone){
          e.stopPropagation();
          showRevealPopAt(idCard, { mode:"notice", message:"手番の最後にだけ使えます。" });
          return;
        }
        e.stopPropagation();
        showRevealPopAt(idCard, {
          action: "gordon_barrier",
          messageHtml: `<span class="ability-pill">絶対無敵バリア</span>を使いますか。<br>使用後に手番が終了します。`
        });
        return;
      }
      if (myRoleId !== "SHA_W1") return;
      const check = canUseWightAbilityNow();
      if (!check.ok){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は公開できません。" });
        return;
      }
      e.stopPropagation();
      showRevealPopAt(idCard, {
        action: "wight_ability",
        messageHtml: `<span class="ability-pill">亡者の王</span>を使いますか。`
      });
      return;
    }

    if (myRoleId === "CIT_D1"){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "今は公開できません。" });
      return;
    }
    if (myRoleId === "CIT_D2"){
      if (isDavidAbilityUsed()){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "この能力はすでに使用済みです。" });
        return;
      }
      if (getDavidEligibleEliminatedUids().length === 0){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "今は公開できません。" });
        return;
      }
    }
    if (myRoleId === "SHA_U1" || myRoleId === "RAI_G3"){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "今は公開できません。" });
      return;
    }
    if (myRoleId === "CIT_A3"){
      if (isAgathaAbilityUsed()){
        e.stopPropagation();
        return;
      }
      if (!turnState()?.moveDone){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "手番の最後にだけ正体を公開できます。" });
        return;
      }
    }
    if (myRoleId === "SHA_U2" && !canStartRoleSelection(myRoleId, state.userId)){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "今は公開できません。" });
      return;
    }
    if (myRoleId === "RAI_E3" && !canStartRoleSelection(myRoleId, state.userId)){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "今は使えません。" });
      return;
    }

    const moved = !!turnState()?.moveDone;
    if (myRoleId === "CIT_B2"){
      const check = benjaminRevealAvailability();
      if (!check.ok){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は使えません。" });
        return;
      }
    }
    if (myRoleId === "RAI_E1" && !moved){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "今は使えません。" });
      return;
    }
    if (myRoleId === "RAI_E1"){
      const roomActionState = turnRoomActionState();
      if (!!turnState()?.deckDrawDone || roomActionState.room3ActionUsed || roomActionState.room4StealUsed){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode: "notice", message: "今は使えません。" });
        return;
      }
    }
    if (TURN_START_ONLY_REVEAL_ROLE_IDS.has(myRoleId) && moved){
      const message = START_ONLY_ABILITY_ROLE_IDS.has(myRoleId)
        ? "手番の初めにだけ使えます。"
        : "手番の初めにだけ正体を公開できます。";
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message });
      return;
    }
    if (myRoleId === "SHA_W1"){
      const check = canUseWightAbilityNow();
      if (!check.ok){
        e.stopPropagation();
        showRevealPopAt(idCard, { mode:"notice", message:check.message || "今は公開できません。" });
        return;
      }
      e.stopPropagation();
      showRevealPopAt(idCard, {
        action: "wight_ability",
        messageHtml: `正体を公開して、<span class="ability-pill">亡者の王</span>を使いますか。<br>この手番を終了して、もう一手番行う。`
      });
      return;
    }
    if (REVEAL_ENDS_TURN_ROLE_IDS.has(myRoleId) && !moved){
      e.stopPropagation();
      showRevealPopAt(idCard, { mode: "notice", message: "手番の最後にだけ正体を公開できます。" });
      return;
    }

    e.stopPropagation();
    showRevealPopAt(idCard, { appendEndTurnNotice: REVEAL_ENDS_TURN_ROLE_IDS.has(myRoleId) || myRoleId === "CIT_A3" });
  });

  window.__lastPointerX = window.innerWidth / 2;
  window.__lastPointerY = window.innerHeight / 2;
  document.addEventListener("pointerdown", (e) => {
    window.__lastPointerX = Number(e.clientX);
    window.__lastPointerY = Number(e.clientY);
  }, true);

  document.addEventListener("click", (e) => {
    const now = Date.now();
    if (now < suppressOutsidePopCloseUntil) return;
    if (!revealPop.classList.contains("hidden") && !e.target.closest("#revealPop")){
      hideRevealPop();
    }
    if (!attackPop.classList.contains("hidden") && !e.target.closest("#attackPop")){
      hideAttackPop();
    }
    if (!endTurnConfirm?.classList.contains("hidden") && !e.target.closest("#endTurnConfirm") && !e.target.closest("#btnEndTurn")){
      hideEndTurnConfirm();
    }
    if (!roomActionPop.classList.contains("hidden") && !e.target.closest("#roomActionPop")){
      if (pendingRoomAction?.dismissOnOutside !== false){
        hideRoomActionPop();
        if (pendingEquipAction?.type === "david_select"){
          restoreDavidAbilitySelection();
        }
      }
    }
  }, true);

  btnRevealNo.addEventListener("click", (e) => {
    e.stopPropagation();
    hideRevealPop();
  });
  btnRevealYes.addEventListener("click", async (e) => {
    e.stopPropagation();
    const myRoleId = safeText(state.hands?.[state.userId]?.roleId || "");
    if (myRoleId === "CIT_D2"){
      await startDavidAbilityFlow();
      hideRevealPop();
      return;
    }
    if (pendingRevealAction === "wight_ability"){
      if (!isMyIdentityRevealed()){
        await revealMyIdentityToEquipment({ revealedBy:"wight_ability" });
      }
      const ok = await activateWightAbilityAndEndTurn();
      hideRevealPop();
      if (!ok){
        showRevealPopAt(null, { mode:"notice", message:canUseWightAbilityNow().message || "今は公開できません。" });
      }
      return;
    }
    if (pendingRevealAction === "agatha_ability"){
      hideRevealPop();
      if (zoomBackdrop && !zoomBackdrop.classList.contains("hidden")) closeZoom();
      if (!isMyIdentityRevealed()){
        await revealMyIdentityToEquipment({ revealedBy:"manual" });
      } else {
        await triggerAgathaRevealAbility({ endTurnAfterResolve:true });
      }
      return;
    }
    if (pendingRevealAction === "alice_ability"){
      const check = canUseAliceAbilityNow();
      hideRevealPop();
      if (!check.ok){
        showRevealPopAt(null, { mode:"notice", message:check.message || "今は使えません。" });
        return;
      }
      await markAliceAbilityUsed();
      setTimeout(() => {
        setDamageToPlayer(state.userId, 0, "alice_ability_heal");
      }, 1500);
      return;
    }
    if (pendingRevealAction === "gordon_barrier"){
      hideRevealPop();
      if (!isMyTurn() || !turnState()?.moveDone || !!turnState()?.attackDone || isGordonAbilityUsed()){
        showRevealPopAt(null, { mode:"notice", message:"手番の最後にだけ使えます。" });
        return;
      }
      if (state.roomCode){
        await set(ref(db, `rooms/${state.roomCode}/gordonBarrier/${state.userId}`), true);
        await markGordonAbilityUsed();
      }
      await emitIdentityZoomEvent("RAI_G1", state.userId);
      await doEndTurn();
      return;
    }
    if (pendingRevealAction.startsWith("role_select:")){
      const roleId = safeText(pendingRevealAction.split(":")[1] || "");
      const role = ROLE_BY_ID[roleId];
      if (role && !isRoleAbilityUsed(roleId)){
        if (!canStartRoleSelection(roleId, state.userId)){
          hideRevealPop();
          showRevealPopAt(null, { mode:"notice", message:((["RAI_E3","SHA_U2","CIT_B2"].includes(roleId)) ? "今は使えません。" : "今は公開できません。") });
          return;
        }
        await setRoleAbilitySelectionState({
          roleId,
          actorUid: state.userId,
          privateToActor: (roleId === "SHA_U2")
        });
      }
      hideRevealPop();
      return;
    }
    await revealMyIdentityToEquipment({ revealedBy:"manual" });
    if (myRoleId === "RAI_G1"){
      if (!isGordonAbilityUsed() && isMyTurn() && !!turnState()?.moveDone && !turnState()?.attackDone && state.roomCode){
        await set(ref(db, `rooms/${state.roomCode}/gordonBarrier/${state.userId}`), true);
        await markGordonAbilityUsed();
        await emitIdentityZoomEvent("RAI_G1", state.userId);
        hideRevealPop();
        await doEndTurn();
        return;
      }
    }
    if (isRoleSelectionAbility(myRoleId) && !isRoleAbilityUsed(myRoleId)){
      if (!canStartRoleSelection(myRoleId, state.userId)){
        hideRevealPop();
        showRevealPopAt(null, { mode:"notice", message:((["RAI_E3","SHA_U2","CIT_B2"].includes(myRoleId)) ? "今は使えません。" : "今は公開できません。") });
        return;
      }
      await setRoleAbilitySelectionState({
        roleId: myRoleId,
        actorUid: state.userId,
        justRevealed:true,
        privateToActor: (myRoleId === "RAI_E3" || myRoleId === "SHA_U2")
      });
    }
    if (myRoleId === "CIT_A1"){
      await markAliceAbilityUsed();
      setTimeout(() => {
        setDamageToPlayer(state.userId, 0, "alice_ability_heal");
      }, 1500);
    }
    hideRevealPop();
    if (myRoleId === "CIT_A3" && isAgathaAbilityUsed() && isMyTurn()){
      await doEndTurn();
    }
  });

  btnAttackNo.addEventListener("click", (e) => {
    e.stopPropagation();
    hideAttackPop();
  });
  btnRoomActionNo?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const closeZoomOnNo = !!pendingRoomAction?.closeZoomOnNo;
    const onNo = pendingRoomAction?.onNo;
    const msg = safeText(roomActionMsg?.textContent || "");
    hideRoomActionPop();
    appendActionChatLog(state.userId, `${msg || "選択"}：いいえ`).catch(() => {});
    if (typeof onNo === "function") await onNo();
    if (closeZoomOnNo) closeZoom();
  });
  btnRoomActionYes?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const handler = pendingRoomAction?.onYes;
    const msg = safeText(roomActionMsg?.textContent || "");
    hideRoomActionPop();
    appendActionChatLog(state.userId, `${msg || "選択"}：はい`).catch(() => {});
    if (handler) await handler();
  });
  btnAttackYes.addEventListener("click", async (e) => {
    e.stopPropagation();
    if (!canUseAttackDice()) {
      hideAttackPop();
      return;
    }
    const uid = pendingAttackTargetUid;
    const targetName = safeText(playerById(uid)?.name || "プレイヤー");
    appendActionChatLog(state.userId, `攻撃対象:${targetName}さん`).catch(() => {});
    const target = markerCache?.[uid] || null;
    if (!uid || !target){
      hideAttackPop();
      return;
    }
    const x = Number(target.x);
    const y = Number(target.y);
    const point = roomSvg && Number.isFinite(x) && Number.isFinite(y)
      ? (() => {
          const ctm = roomSvg.getScreenCTM();
          if (!ctm) return null;
          const pt = roomSvg.createSVGPoint();
          pt.x = x;
          pt.y = y;
          return pt.matrixTransform(ctm);
        })()
      : null;

    hideAttackPop();
    if (ulsterExtraAttackPending > 0 && isMyRole("SHA_U3")){
      if (!isMyIdentityRevealed()){
        await revealMyIdentityToEquipment({ revealedBy:"attack_ability" });
      } else {
        const role = myRoleInfo();
        if (role) await emitIdentityZoomEvent(role.id, state.userId);
      }
    }
    attackTurnEndChoicePending = true;
    attackFlowUiLockActive = true;
    renderTurnEndButton();
    const selectedSum = chooseSumForTestPlayer("攻撃");
    if (isTestPlayer() && selectedSum == null){
      attackTurnEndChoicePending = false;
      attackFlowUiLockActive = false;
      renderTurnEndButton();
      return;
    }
    const masamuneMode = hasMyEquipmentByName("妖刀マサムネ");
    const vendettaMode = isMyRevealedVendetta();
    const gatlingMode = hasMyEquipmentByName("ガトリング");
    const gatlingTargetUids = gatlingMode ? [...highlightedMarkerUids()] : [];
    const attackTargetUids = gatlingMode ? gatlingTargetUids : [uid];
    await recordLastAttackToMe(attackTargetUids);
    lastAttackWatch = {
      uid: state.userId,
      targetUids: attackTargetUids,
      hasRosary: hasMyEquipmentByName("銀のロザリオ"),
      at: Date.now()
    };
    const selectedPair = selectedSum != null ? pickDiceBySum(selectedSum) : null;
    const d6 = (masamuneMode || vendettaMode) ? 0 : (selectedPair?.d6 ?? (1 + Math.floor(Math.random() * 6)));
    const d4 = selectedPair?.d4 ?? (1 + Math.floor(Math.random() * 4));
    const width = window.innerWidth;
    const height = window.innerHeight;
    const landing = randomCenterLandingPoint(width, height);
    const endX = Number(landing.x || (point?.x || width/2));
    const endY = Number(landing.y || (point?.y || height/2));
    const motion = createDiceMotion(width, height, endX, endY);
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/attack`), {
      uid: state.userId,
      targetUid: uid,
      gatlingTargetUids,
      x: endX,
      y: endY,
      d6,
      d4,
      masamuneMode,
      vendettaMode,
      motion,
      at: Date.now()
    });
    if (state.roomCode && isMyTurn()){
      await update(ref(db, `rooms/${state.roomCode}/turn`), {
        attackDone: true,
        attackAt: Date.now()
      });
    }
  });


  btnAttackResultKeep?.addEventListener("click", async (e) => {
    e.stopPropagation();
    appendActionChatLog(state.userId, `攻撃時の選択:${safeText(btnAttackResultKeep?.textContent || "OK")}`).catch(() => {});
    const pending = pendingAttackResolution;
    const spec = attackAbilitySpecFromRows(pending?.rows || []);
    if (!spec){
      await finalizePendingAttackResolution(false);
      return;
    }
    if (safeText(myRoleInfo()?.id || "") === "CIT_C1" && shouldDisableCraigAbilityByDamage()){
      return;
    }

    const runKeepAbility = async () => {
      const role = myRoleInfo();
      const roleId = safeText(role?.id || "");
      if (pending?.rows?.length){
        pending.rows = applyAttackResultBonusRows(pending.rows);
      }
      const followupTargetUid = primaryAttackTargetUidFromRows(pending?.rows || []);
      const eliminationPreview = attackEliminationPreview(pending?.rows || []);

      if (roleId === "RAI_F3"){
        await requestAttackLootAutoEndForCurrentTurn({ syncPending:false });
      }

      if (roleId === "CIT_B1"){
        const byronTargets = (pending?.rows || [])
          .filter(item => Math.max(0, Number(item?.damage || 0)) >= 2)
          .map(item => safeText(item?.uid || ""))
          .filter(Boolean);
        pending.rows = (pending?.rows || []).map(item => ({ ...item, damage:0 }));
        await finalizePendingAttackResolution(false, true);
        await resolveAttackAbilityReveal(role);
        if (hasMyEquipmentByName("銀のロザリオ")){
          const turnOwnerUid = currentTurnPlayerId();
          await runRosaryAutoLootFlow(byronTargets);
          await doEndTurn(turnOwnerUid);
          return;
        }
        await createByronAttackLootPending(byronTargets);
        return;
      }

      if (roleId === "CIT_C1"){
        const preview = attackEliminationPreview(pending?.rows || []);
        if (preview.allAttackedEliminated){
          const turnOwnerUid = currentTurnPlayerId();
          await finalizePendingAttackResolution(false, true);
          showRevealPopAt(null, {
            mode:"notice",
            message:"この結果プレイヤーは脱落するため、能力を使用しません。"
          });
          await waitMs(2000);
          hideRevealPop();
          if (turnOwnerUid && currentTurnPlayerId() === turnOwnerUid){
            await doEndTurn(turnOwnerUid);
          }
          return;
        }
      }

      await finalizePendingAttackResolution(false, true);
      if (roleId !== "SHA_U3") await resolveAttackAbilityReveal(role);

      if (roleId === "CIT_C1"){
        markAttackAbilityUsedThisTurn(roleId);
        await addDamageToPlayer(state.userId, 2);
        await runFollowupAttackToTarget(followupTargetUid, 1500);
        return;
      }
      if (roleId === "RAI_G2"){
        await runFollowupAttackToTarget(followupTargetUid, 0);
        return;
      }
      if (roleId === "SHA_U3"){
        markAttackAbilityUsedThisTurn(roleId);
        await startUlsterExtraAttackSelection();
        return;
      }
      if (roleId === "SHA_V2"){
        await resolveVampireHealAfterAttack();
        const shouldOpenLoot = !hasMyEquipmentByName("銀のロザリオ") && eliminationPreview.eliminatedUids.length;
        if (shouldOpenLoot){
          await createOrMergeAttackLootPending(eliminationPreview.eliminatedUids, {
            endTurnAfterResolve:true,
            endTurnExpectedUid: safeText(currentTurnPlayerId() || "")
          });
          return;
        }
        const turnOwnerUid = currentTurnPlayerId();
        if (turnOwnerUid && currentTurnPlayerId() === turnOwnerUid){
          await doEndTurn(turnOwnerUid);
        }
        return;
      }
    };

    const roleId = safeText(myRoleInfo()?.id || "");
    const isVampireSingleButton = roleId === "SHA_V2" && !!spec && isMyIdentityRevealed() && !isErikaSealedPlayer(state.userId);
    if (attackResultChoiceBusy) return;
    if (isVampireSingleButton){
      attackResultChoiceBusy = true;
      try {
        await runKeepAbility();
      } finally {
        attackResultChoiceBusy = false;
      }
      return;
    }
    showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "", async () => {
      if (attackResultChoiceBusy) return;
      attackResultChoiceBusy = true;
      try {
        await runKeepAbility();
      } finally {
        attackResultChoiceBusy = false;
      }
    }, {
      messageHtml: `<span class="ability-pill">${escapeHtml(formatAttackAbilityPillLabel(spec.abilityName))}</span>${escapeHtml(spec.description)}`,
      yesLabel: "はい",
      noLabel: "いいえ",
      fixedLower:true,
      noCaret:true,
      dismissOnOutside:true
    });
  });


  btnAttackResultExcalibur?.addEventListener("click", async (e) => {
    e.stopPropagation();
    appendActionChatLog(state.userId, "攻撃時の選択:エクスカリバー").catch(() => {});
    if (attackResultChoiceBusy) return;
    const pending = pendingAttackResolution;
    if (!pending || !pendingAttackResultMeta?.allowExcaliburButton) return;
    attackResultChoiceBusy = true;
    try {
      await revealMyIdentityToEquipment({ revealedBy:"excalibur_attack" });
      pendingAttackResultMeta = {
        ...(pendingAttackResultMeta || {}),
        allowExcaliburButton: false,
        showBonusLabel: false,
        zeroDamagePreview: false
      };
      pending.rows = (pending.rows || []).map(item => ({ ...item, bonusLabelAmount: 0 }));
      pending.meta = normalizeAttackResultMeta(pendingAttackResultMeta);
      showAttackResultPop(pending.rows);

      pending.rows = excaliburExtraDamageRows(pending.rows, 2);
      cachePendingAttackResolution(pending);
      await upsertPendingAttackResolution(pending.rows, pending.turnKey || turnCycleKey(), pendingAttackResultMeta);
      showAttackResultPop(pending.rows);
    } finally {
      attackResultChoiceBusy = false;
    }
  });

  btnAttackResultEnd?.addEventListener("click", async (e) => {
    e.stopPropagation();
    appendActionChatLog(state.userId, `攻撃時の選択:${safeText(btnAttackResultEnd?.textContent || "OKおわる")}`).catch(() => {});
    const pending = pendingAttackResolution;
    const spec = attackAbilitySpecFromRows(pending?.rows || []);
    const shouldConfirmEmmaEnd = isMyRole("RAI_E3") && isMyIdentityRevealed();
    if (spec || shouldConfirmEmmaEnd){
      if (attackResultChoiceBusy) return;
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "本当に終了しますか。", async () => {
        if (attackResultChoiceBusy) return;
        attackResultChoiceBusy = true;
        try {
          await requestAttackLootAutoEndForCurrentTurn({ syncPending:true });
          await finalizePendingAttackResolution(true, true);
        } finally {
          attackResultChoiceBusy = false;
        }
      }, { fixedLower:true, noCaret:true, dismissOnOutside:true });
      return;
    }
    await requestAttackLootAutoEndForCurrentTurn({ syncPending:true });
    await finalizePendingAttackResolution(true, true);
  });

  btnIdentityPromptNo?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const handler = pendingIdentityPrompt?.onNo;
    const closeZoomOnChoice = !!pendingIdentityPrompt?.closeZoomOnChoice;
    hideIdentityPrompt();
    await setSeatIdentityPromptState(null);
    if (closeZoomOnChoice) closeZoom();
    if (handler) await handler();
  });

  btnIdentityPromptYes?.addEventListener("click", async (e) => {
    e.stopPropagation();
    if (btnIdentityPromptYes.disabled) return;
    const handler = pendingIdentityPrompt?.onYes;
    const closeZoomOnChoice = !!pendingIdentityPrompt?.closeZoomOnChoice;
    hideIdentityPrompt();
    await setSeatIdentityPromptState(null);
    if (closeZoomOnChoice) closeZoom();
    if (handler) await handler();
  });

  btnCounterAbilitySkip?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const entry = counterPromptEntryForMe();
    if (isVenomSelectionEntry(entry)){
      hideRoomActionPop();
      await resolveVenomCounterChoice("damage");
      return;
    }
    hideCounterAbilityPrompt();
    const resolvedEntry = await clearCounterPromptForMe(entry?.at || null);
    await tryAdvanceTurnAfterCounterChoice(resolvedEntry);
  });

  btnCounterAbilityUse?.addEventListener("click", async (e) => {
    e.stopPropagation();
    const entry = counterPromptEntryForMe();
    if (!entry) return;
    if (isCounterAbilityBlockedByGuardianShield(entry)) return;
    const role = ROLE_BY_ID[entry.roleId] || myRoleInfo();
    if (!role) return;

    if (!isMyIdentityRevealed()){
      await revealMyIdentityToEquipment({ revealedBy:"counter_attack" });
    } else {
      await emitRoleFlashEvent(role.id, "counter_attack_reveal_repeat", 1800);
    }

    if (safeText(role.id || "") === "SHA_W3"){
      await runWerewolfCounterAttack(entry.attackerUid);
    } else if (safeText(role.id || "") === "SHA_V1"){
      const roomRef = ref(db, `rooms/${state.roomCode}`);
      await runTransaction(roomRef, (cur) => {
        if (!cur) return cur;
        const map = cur.counterPromptState || {};
        const mine = map[state.userId];
        if (!mine || Number(mine.at || 0) !== Number(entry.at || 0)) return cur;
        delete map[state.userId];
        map[safeText(entry.attackerUid || "")] = {
          uid: safeText(entry.attackerUid || ""),
          roleId: "SHA_V1",
          attackerUid: safeText(entry.attackerUid || ""),
          venomUid: state.userId,
          turnKey: safeText(entry.turnKey || ""),
          advanceTurnOnResolve: !!entry.advanceTurnOnResolve,
          mustChoose: true,
          mode: "venom_resolution",
          expiresAt: 0,
          at: Date.now()
        };
        cur.counterPromptState = map;
        return cur;
      });
    }

    hideCounterAbilityPrompt();
    if (safeText(role.id || "") === "SHA_V1") return;
    const resolvedEntry = await clearCounterPromptForMe(entry.at);
    await tryAdvanceTurnAfterCounterChoice(resolvedEntry);
  });

  equipBody.addEventListener("click", (e) => {
    const card = e.target.closest(".card72.wb-front, .id72");
    const selectionAction = captureSelectionRestoreAction();
    if (!card){
      if (pendingEquipAction?.type === "david_select") hideRoomActionPop();
      openEquipExpand();
      return;
    }

    if (isVenomSelectionEntry(counterPromptEntryForMe())){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      const canGive = ownerUid === state.userId && !!sourceKey && card.classList.contains("equip-defeat-pulse");
      if (!canGive){
        openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
        setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
        return;
      }
      const name = safeText(card.dataset.cardName || "このカード");
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, `${name}を渡しますか？`, async () => {
        hideRoomActionPop();
        closeZoom();
        closeEquipExpandIfOpen();
        await resolveVenomCounterChoice("give", sourceKey);
      }, { fixedLower:true, noCaret:true, dismissOnOutside:true });
      return;
    }

    if (pendingEquipAction?.type === "david_select"){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      const isPulseCard = card.classList.contains("equip-defeat-pulse");
      const canPick = isPulseCard && pendingEquipAction.defeatedUids?.includes(ownerUid) && !!sourceKey;
      if (!canPick){
        openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
        setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
        setZoomPassthrough(false);
        zoomDismissHandler = async () => {
          equipSelectionStartedFromExpand = false;
          restoreDavidAbilitySelection();
        };
        return;
      }
      pendingEquipAction = {
        ...pendingEquipAction,
        selectedOwnerUid: ownerUid,
        selectedSourceKey: sourceKey
      };
      renderEquipmentDock();
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      hideDavidSelectPreview();
      zoomDismissHandler = async () => {
        restoreDavidAbilitySelection();
      };
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "このカードを獲得しますか。", async () => {
        const action = pendingEquipAction;
        if (!action || action.type !== "david_select") return;
        zoomDismissHandler = null;
        const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
        if (ok){
          await markDavidAbilityUsed();
          await setDavidAbilityOverlayState(null);
          pendingEquipAction = null;
          hideDavidSelectPreview();
          if (equipSelectionStartedFromExpand){
            closeEquipExpandIfOpen();
          }
          equipSelectionStartedFromExpand = false;
          closeZoom();
          renderEquipmentDock();
          renderMarkers();
        } else {
          equipSelectionStartedFromExpand = false;
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          equipSelectionStartedFromExpand = false;
          restoreDavidAbilitySelection();
        }
      });
      return;
    }

    if (pendingEquipAction?.type === "green_give"){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (ownerUid !== state.userId || !sourceKey) return;
      const action = { ...pendingEquipAction, sourceKey };
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "このカードをわたしますか。", async () => {
        pendingEquipAction = null;
        renderTurnEndButton();
        zoomDismissHandler = null;
        const ok = await moveEquipmentCardBetweenPlayers(action.fromUid, action.toUid, sourceKey);
        if (ok){
          await sendGreenResponse(
            { from: action.toUid, requestId: action.requestId, card: action.cardObj },
            action.answerOpt,
            "装備をわたす"
          );
          closeZoom();
          renderEquipmentDock();
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          zoomDismissHandler = null;
          restoreGreenGiveZoomSelection(action);
        }
      });
      zoomDismissHandler = async () => {
        restoreGreenGiveZoomSelection(action);
      };
      return;
    }

    if (pendingEquipAction?.type === "benjamin_give"){
      const action = { ...pendingEquipAction };
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (ownerUid !== state.userId || !sourceKey || !card.classList.contains("equip-steal-pulse")){
        greenShareDock?.classList.add("hidden");
        openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
        setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
        setZoomPassthrough(false);
        zoomDismissHandler = async () => {
          restorePendingEquipSelection(action);
        };
        return;
      }
      const cardName = safeText(card.dataset.cardName || "この装備");
      pendingEquipAction.selectedSourceKey = sourceKey;
      setSeatEquipSelectionState({ type:"benjamin_give", selectedSourceKey:sourceKey }).catch(() => {});
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
      const actorRoom = markerRoomId(markerCache?.[state.userId]);
      openTargetSelectDock({
        title: `「${cardName}」を誰かに渡しますか。`,
        includeSelf: false,
        onlyAlive: true,
        overEquipExpand: !equipExpandBackdrop?.classList.contains('hidden'),
        filterPlayer: (p) => markerRoomId(markerCache?.[p.id]) === actorRoom,
        lockEndTurnUntilResolved: true,
        onSelect: async (uid) => {
          const chosenSource = safeText(pendingEquipAction?.selectedSourceKey || "");
          pendingEquipAction = null;
          await setSeatEquipSelectionState(null);
          closeEquipExpandIfOpen();
          greenShareDock?.classList.add("hidden");
          const ok = await moveEquipmentCardBetweenPlayers(state.userId, uid, chosenSource);
          if (!ok){
            await setRoleAbilitySelectionState(null);
            closeZoom();
            renderEquipmentDock();
            return;
          }
          await markRoleAbilityUsed("CIT_B2");
          await setRoleAbilitySelectionState(null);
          closeZoom();
          renderEquipmentDock();
          await doEndTurn();
        }
      });
      zoomDismissHandler = async () => {
        restorePendingEquipSelection(action);
      };
      return;
    }

    if (pendingEquipAction?.type === "banana_give"){
      const action = { ...pendingEquipAction };
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (ownerUid !== state.userId || !sourceKey){
        greenShareDock?.classList.add("hidden");
        openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
        setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
        setZoomPassthrough(false);
        zoomDismissHandler = async () => {
          restorePendingEquipSelection(action);
        };
        return;
      }
      const cardName = safeText(card.dataset.cardName || "この装備");
      pendingEquipAction.selectedSourceKey = sourceKey;
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
      setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
      greenShareDock?.classList.add("hidden");
      const actionForRestore = { ...pendingEquipAction };
      openTargetSelectDock({
        title: `「${cardName}」を誰かに渡しますか。`,
        includeSelf: false,
        onlyAlive: true,
        overEquipExpand: !equipExpandBackdrop?.classList.contains('hidden'),
        onSelect: async (uid) => {
          const chosenSource = safeText(pendingEquipAction?.selectedSourceKey || "");
          pendingEquipAction = null;
          await setSeatEquipSelectionState(null);
          renderTurnEndButton();
          closeEquipExpandIfOpen();
          greenShareDock?.classList.add("hidden");
          const ok = await moveEquipmentCardBetweenPlayers(state.userId, uid, chosenSource);
          if (ok){
            await recordFactionRelationInferenceFromRevealedTarget(state.userId, uid, "same", "banana_give_target_revealed");
            closeZoom();
            renderEquipmentDock();
          }
        }
      });
      zoomDismissHandler = async () => {
        greenShareDock?.classList.remove("over-equip-expand");
        greenShareDock?.classList.add("hidden");
        cardPlayerSelectActive = false;
        updateCardInteractivity();
        renderTurnEndButton();
        restorePendingEquipSelection(actionForRestore);
      };
      return;
    }

    if (pendingEquipAction?.type === "oliver_target"){
      const action = { ...pendingEquipAction };
      if (!card.classList.contains("equip-steal-pulse")){
        greenShareDock?.classList.add("hidden");
        openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
        setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
        setZoomPassthrough(false);
        zoomDismissHandler = async () => {
          restorePendingEquipSelection(action);
        };
        return;
      }
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (!ownerUid || ownerUid === state.userId || !sourceKey) return;
      const cardObj = pendingEquipAction?.cardObj || null;
      pendingEquipAction = { type:"oliver_confirm", ownerUid, sourceKey, cardObj };
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
      renderTurnEndButton();
      zoomDismissHandler = async () => {
        restoreOliverZoomSelection();
      };
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "これを奪いますか。", async () => {
        const action = pendingEquipAction;
        pendingEquipAction = null;
        await setSeatEquipSelectionState(null);
        renderTurnEndButton();
        closeEquipExpandIfOpen();
        zoomDismissHandler = null;
        const ok = await stealEquipmentFromPlayer(action.ownerUid, action.sourceKey);
        if (ok){
          closeZoom();
          renderEquipmentDock();
        }
      }, {
        fixedLower:true,
        closeZoomOnNo:false,
        onNo: () => {
          zoomDismissHandler = null;
          restoreOliverZoomSelection();
        }
      });
      return;
    }

    if (canUseRoom4Steal() && card.classList.contains("equip-steal-pulse")){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      const sourceKey = safeText(card.dataset.sourceKey || "");
      if (!ownerUid || ownerUid === state.userId || !sourceKey) return;
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
      showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "この装備を奪いますか。", async () => {
        room4StealUsed = true;
        await updateTurnRoomActionState({ room4StealUsed:true });
        const ok = await stealEquipmentFromPlayer(ownerUid, sourceKey);
        if (ok){
          renderEquipmentDock();
          closeZoom();
        }
      }, { fixedLower:true, closeZoomOnNo:true });
      return;
    }

    if (selectionAction){
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
      setZoomOverPanel(!!equipExpandBackdrop && !equipExpandBackdrop.classList.contains('hidden'));
      setZoomPassthrough(false);
      zoomDismissHandler = async () => {
        await restoreSelectionAction(selectionAction);
      };
      return;
    }

    if (isDeductionZoomActive()) return;

    openZoomFromCard(card);
  });

  equipBody.addEventListener("dblclick", async (e) => {
    const card = e.target.closest(".card72.wb-front");
    if (!card) return;
    if (!isTestPlayer()) return;
    const ownerUid = safeText(card.dataset.ownerUid || "");
    const sourceKey = safeText(card.dataset.sourceKey || "");
    if (!ownerUid || !sourceKey) return;
    e.preventDefault();
    e.stopPropagation();
    hideRoomActionPop();
    await removeEquipmentCardForTest(ownerUid, sourceKey);
    if (zoomBackdrop && !zoomBackdrop.classList.contains("hidden")){
      closeZoom();
    }
  });


  attackLootBody?.addEventListener("click", async (e) => {
    const card = e.target.closest(".card72.wb-front, .id72");
    if (!card || !pendingAttackLoot) return;
    if (safeText(pendingAttackLoot.mode || "") === "byron"){
      const ownerUid = safeText(card.dataset.ownerUid || "");
      if (!ownerUid) return;
      if (card.dataset.itemKind === "identity") return;
      const current = { ...(pendingAttackLoot.selectedByOwner || {}) };
      if (card.dataset.noSteal === "1"){
        current[ownerUid] = { ownerUid, sourceKey:"", noSteal:true };
      } else {
        const sourceKey = safeText(card.dataset.sourceKey || "");
        if (!sourceKey) return;
        current[ownerUid] = { ownerUid, sourceKey, noSteal:false };
      }
      pendingAttackLoot = { ...pendingAttackLoot, selectedByOwner:current };
      await setAttackLootPending(pendingAttackLoot);
      renderAttackLootPanel();
      const rowUids = (pendingAttackLoot.targetUids || []).filter(uid => {
        const list = listEquipForUid(uid);
        return list.some(it => !isIdentityEquipItem(it));
      });
      const allSelected = rowUids.length > 0 && rowUids.every(uid => !!current[uid]);
      if (allSelected){
        await commitAttackLootSelection({ byron:true });
      }
      return;
    }
    if (card.dataset.noSteal === "1"){
      pendingAttackLoot = { ...pendingAttackLoot, selected:{ noSteal:true, ownerUid:"", sourceKey:"" } };
      await setAttackLootPending(pendingAttackLoot);
      renderAttackLootPanel();
      await commitAttackLootSelection({ noSteal:true });
      return;
    }

    const ownerUid = safeText(card.dataset.ownerUid || "");
    const sourceKey = safeText(card.dataset.sourceKey || "");
    if (!ownerUid || !sourceKey || card.dataset.itemKind === "identity") return;
    pendingAttackLoot = { ...pendingAttackLoot, selected:{ ownerUid, sourceKey, noSteal:false } };
    await setAttackLootPending(pendingAttackLoot);
    renderAttackLootPanel();
    openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false });
    setZoomOverPanel(true);
    await new Promise(resolve => setTimeout(resolve, 180));
    showRoomActionPopAt(window.innerWidth/2, window.innerHeight/2 + 40, "この装備を奪いますか。", async () => {
      await commitAttackLootSelection({ ownerUid, sourceKey });
    }, { fixedLower:true, closeZoomOnNo:true });
  });

  attackLootBackdrop?.addEventListener("click", (e) => {
    if (e.target === attackLootBackdrop){
      e.stopPropagation();
    }
  });

  const hpBoard = document.getElementById("hpBoard");
  const positionLine = document.getElementById("positionLine");
  const turnEndWrap = document.getElementById("turnEndWrap");
  const btnEndTurn = document.getElementById("btnEndTurn");
  const endTurnConfirm = document.getElementById("endTurnConfirm");
  const endTurnConfirmMsg = document.getElementById("endTurnConfirmMsg");
  const btnEndTurnYes = document.getElementById("btnEndTurnYes");
  const btnEndTurnNo = document.getElementById("btnEndTurnNo");
  let damageCache = {};

  function clampDamage(v){
    const n = Number(v);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.min(15, Math.floor(n)));
  }

  function buildHpCells(){
    hpBoard.innerHTML = "";
    for (let row=15; row>=0; row--){
      const cell = document.createElement("div");
      cell.className = "hp-cell";
      if (row >= 4) cell.classList.add("hp-cell-room4plus");
      cell.dataset.damage = String(row);
      hpBoard.appendChild(cell);
    }
  }

  function playerById(uid){
    return latestPlayers.find(p => p.id === uid) || null;
  }

  function isPlayerEliminated(uid){
    if (!uid) return false;
    const hand = state.hands?.[uid];
    const role = hand?.roleId ? ROLE_BY_ID[hand.roleId] : null;
    const hp = Number(role?.hp || 0);
    if (!hp) return false;
    const dmg = clampDamage(damageCache?.[uid]);
    return dmg >= hp;
  }

  function roleIdForUid(uid){
    return safeText(state.hands?.[uid]?.roleId || "");
  }

  function factionForUid(uid){
    const role = ROLE_BY_ID[roleIdForUid(uid)];
    return safeText(role?.faction || "");
  }

  function isRoleAlive(roleId){
    const rid = safeText(roleId || "");
    if (!rid) return false;
    return latestPlayers.some(p => roleIdForUid(p.id) === rid && !isPlayerEliminated(p.id));
  }

  function teamEliminationReached(factionName){
    const teamPlayers = latestPlayers.filter(p => factionForUid(p.id) === factionName);
    if (!teamPlayers.length) return false;
    return teamPlayers.every(p => isPlayerEliminated(p.id));
  }

  function nonIdentityEquipCount(uid){
    return listEquipForUid(uid).filter(it => !isIdentityEquipItem(it)).length;
  }

  function davidDistinctWinGearCount(uid){
    const names = new Set(
      listEquipForUid(uid)
        .filter(it => !isIdentityEquipItem(it))
        .map(it => safeText(it?.name || ""))
        .filter(name => DAVID_WIN_GEAR_NAMES.has(name))
    );
    return names.size;
  }

  function autoIdentityRevealReason(){
    if (!isGameStarted()) return "";

    if (teamEliminationReached("レイダー")){
      const recentUids = Array.isArray(lastEliminationBatch?.uids) ? lastEliminationBatch.uids : [];
      const recent = (Date.now() - Number(lastEliminationBatch?.at || 0)) <= 15000;
      const hasRecentGodwinElimination = recent && recentUids.some(uid => {
        if (factionForUid(uid) !== "レイダー") return false;
        return roleIdForUid(uid) === "RAI_G3";
      });
      if (!hasRecentGodwinElimination) return "all_raiders_eliminated";
    }
    if (teamEliminationReached("シャドウ")) return "all_shadows_eliminated";

    if (isRoleAlive("CIT_B2")){
      const others = latestPlayers.filter(p => roleIdForUid(p.id) !== "CIT_B2");
      if (others.some(p => nonIdentityEquipCount(p.id) >= 5)) return "benjamin_other_5_equips";
    }

    const byronUid = latestPlayers.find(p => roleIdForUid(p.id) === "CIT_B1" && !isPlayerEliminated(p.id))?.id || "";
    if (byronUid && nonIdentityEquipCount(byronUid) >= 5) return "byron_5_equips";

    const davidUid = latestPlayers.find(p => roleIdForUid(p.id) === "CIT_D2" && !isPlayerEliminated(p.id))?.id || "";
    if (davidUid && davidDistinctWinGearCount(davidUid) >= 3) return "david_3_unique_gears";

    return "";
  }

  async function scheduleAutoIdentityReveal(reason){
    const normalizedReason = safeText(reason || "");
    if (!normalizedReason || !state.roomCode || !state.userId) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !(cur.gameStarted || cur.startedAt)) return cur;
      if (cur.autoIdentityReveal && (cur.autoIdentityReveal.status === "scheduled" || cur.autoIdentityReveal.status === "revealed")) return cur;
      const now = Date.now();
      cur.autoIdentityReveal = {
        status: "scheduled",
        reason: normalizedReason,
        requestedBy: state.userId,
        requestedAt: now,
        revealAt: now + 3000
      };
      return cur;
    });
  }

  async function executeAutoIdentityRevealIfNeeded(){
    if (!state.roomCode) return;
    const auto = state.room?.autoIdentityReveal;
    if (!auto || auto.status !== "scheduled") return;

    const equipRef = ref(db, `rooms/${state.roomCode}/equipment`);
    await runTransaction(equipRef, (cur) => {
      const next = (cur && typeof cur === "object") ? { ...cur } : {};
      const now = Date.now();
      for (const p of latestPlayers){
        const uid = safeText(p?.id || "");
        const roleId = roleIdForUid(uid);
        if (!uid || !roleId) continue;
        const row = (next[uid] && typeof next[uid] === "object") ? { ...next[uid] } : {};
        row.identity = {
          kind: "identity",
          roleId,
          uid,
          revealedAt: now,
          revealedBy: AUTO_IDENTITY_REVEAL_BY
        };
        next[uid] = row;
      }
      return next;
    });

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !cur.autoIdentityReveal || cur.autoIdentityReveal.status !== "scheduled") return cur;
      cur.autoIdentityReveal = {
        ...cur.autoIdentityReveal,
        status: "revealed",
        revealedAt: Date.now(),
        revealedBy: state.userId
      };
      return cur;
    });
  }

  function syncAutoIdentityRevealTimer(){
    const auto = state.room?.autoIdentityReveal;
    if (!auto || auto.status !== "scheduled"){
      if (autoIdentityRevealTimer){
        clearTimeout(autoIdentityRevealTimer);
        autoIdentityRevealTimer = null;
      }
      autoIdentityRevealTimerKey = "";
      return;
    }
    const revealAt = Number(auto.revealAt || 0);
    if (!revealAt) return;
    const timerKey = `${revealAt}:${safeText(auto.reason || "")}`;
    if (autoIdentityRevealTimer && autoIdentityRevealTimerKey === timerKey) return;
    if (autoIdentityRevealTimer){
      clearTimeout(autoIdentityRevealTimer);
      autoIdentityRevealTimer = null;
    }
    autoIdentityRevealTimerKey = timerKey;
    const delay = Math.max(0, revealAt - Date.now());
    autoIdentityRevealTimer = setTimeout(() => {
      autoIdentityRevealTimer = null;
      executeAutoIdentityRevealIfNeeded().catch(() => {});
    }, delay);
  }

  function evaluateAutoIdentityRevealTrigger(){
    if (!isGameStarted()) return;
    if (state.room?.autoIdentityReveal && (state.room.autoIdentityReveal.status === "scheduled" || state.room.autoIdentityReveal.status === "revealed")) return;
    const reason = autoIdentityRevealReason();
    if (!reason) return;
    scheduleAutoIdentityReveal(reason).catch(() => {});
  }

  function hasGuardianAngelShield(uid){
    const targetUid = safeText(uid);
    if (!targetUid) return false;
    return !!state.room?.guardianAngelShield?.[targetUid];
  }

  function hasGordonBarrier(uid){
    const targetUid = safeText(uid);
    if (!targetUid) return false;
    return !!state.room?.gordonBarrier?.[targetUid];
  }

  function isGordonAbilityUsed(){
    return !!state.room?.abilityUsage?.gordon?.[state.userId];
  }

  async function markGordonAbilityUsed(){
    if (!state.roomCode || !state.userId) return;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/gordon/${state.userId}`), true);
  }

  function isGordonBarrierHpChangeAllowed(uid, source = ""){
    if (!hasGordonBarrier(uid)) return true;
    const normalized = safeText(source || "").trim();
    const allowed = new Set([
      "room3_heal",
      "green_heal",
      "card_kohrin_heal",
      "card_blessing_heal",
      "card_holy_water_heal",
      "card_mermaid_tears_heal",
      "emma_ability_heal",
      "card_vampire_bat_heal",
      "felicia_set",
      "first_aid_set",
      "claire_swap_set"
    ]);
    return allowed.has(normalized);
  }

  function isAttackTargetProtected(uid){
    return hasGuardianAngelShield(uid) || hasGordonBarrier(uid);
  }

  function buildChipFor(uid){
    const p = playerById(uid);
    const color = p?.color || "#ddd";
    const initial = firstChar(p?.name || "");
    const d = document.createElement("div");
    d.className = "chip16";
    d.style.background = color;
    d.style.color = textColorFor(color);
    d.textContent = initial || "";
    d.title = p ? p.name : "";
    if (canControlHpBoard()){
      d.style.cursor = "pointer";
      const longPressMs = 500;
      let longPressTimer = null;
      let longPressDone = false;
      const clearLongPressTimer = () => {
        if (!longPressTimer) return;
        clearTimeout(longPressTimer);
        longPressTimer = null;
      };

      d.addEventListener("pointerdown", (e) => {
        if (!e.target.closest("#hpBoard")) return;
        longPressDone = false;
        clearLongPressTimer();
        longPressTimer = setTimeout(async () => {
          longPressDone = true;
          if (!uid) return;
          await healDamageToPlayer(uid, 1);
        }, longPressMs);
      });
      d.addEventListener("pointerup", clearLongPressTimer);
      d.addEventListener("pointerleave", clearLongPressTimer);
      d.addEventListener("pointercancel", clearLongPressTimer);

      d.addEventListener("click", async (e) => {
        e.stopPropagation();
        clearLongPressTimer();
        if (longPressDone || !e.target.closest("#hpBoard")){
          longPressDone = false;
          return;
        }
        if (!uid) return;
        await addDamageToPlayer(uid, 1);
      });
    }
    return d;
  }

  function bindEliminatedChipRoomUp(chipEl, uid){
    if (!chipEl || !uid) return;
    chipEl.classList.add("eliminated-clickable");
    chipEl.title = `${chipEl.title ? chipEl.title + "\n" : ""}クリックで+1上の部屋へ移動`;
    chipEl.addEventListener("click", async (e) => {
      if (cardPlayerSelectActive || isEquipSelectionLockActive()) return;
      e.stopPropagation();
      await moveEliminatedPlayerToUpperRoom(uid);
    });
  }

  function turnState(){
    return state.room?.turn || null;
  }

  function currentTurnPlayerId(){
    return safeText(turnState()?.currentPlayerId || "");
  }

  function isMyTurn(){
    const cur = currentTurnPlayerId();
    return !!cur && cur === state.userId;
  }

  function isTestPlayer(){
    return safeText(state.userName).trim().toLowerCase() === "test";
  }

  function canControlHpBoard(){
    return isTestPlayer() || !!state.isHost;
  }

  function chooseSumForTestPlayer(label){
    if (!isTestPlayer()) return null;
    const input = window.prompt(`${label}の合計目を選んでください（2〜10）`, "7");
    if (input == null) return null;
    const sum = Number(input);
    if (!Number.isFinite(sum)) return null;
    return Math.max(2, Math.min(10, Math.floor(sum)));
  }

  function pickDiceBySum(sum){
    const pairs = [];
    for (let d6 = 1; d6 <= 6; d6++){
      const d4 = sum - d6;
      if (d4 >= 1 && d4 <= 4) pairs.push({ d6, d4 });
    }
    if (!pairs.length) return null;
    return pairs[Math.floor(Math.random() * pairs.length)];
  }

  function canUseMoveDice(){
    if (!isMyTurn()) return false;
    if (isDavidAbilityPending()) return false;
    if (mustResolveUranusMeteorStrike()) return false;
    return !turnState()?.moveDone;
  }

  function canUseAttackDice(){
    if (!isMyTurn()) return false;
    return !!turnState()?.moveDone && !turnState()?.attackDone;
  }

  function syncRoomAbilityTurnState(){
    const key = turnCycleKey();
    const turnOwnerUid = currentTurnPlayerId();
    if (!turnOwnerUid || turnOwnerUid !== attackAbilityUsageTurnOwnerUid){
      resetAttackAbilityUsageTurnState();
    }
    const roomActionState = turnRoomActionState();
    room4StealUsed = roomActionState.room4StealUsed;
    room3ActionUsed = roomActionState.room3ActionUsed;
    movedByDiceRoomId = roomActionState.movedByDiceRoomId;
    const hasMatchingPending = !!pendingAttackResolution
      && safeText(pendingAttackResolution.turnKey || "") === key
      && currentTurnPlayerId() === state.userId;
    if (roomAbilityTurnKey === key) return;
    roomAbilityTurnKey = key;
    suppressSelfTurnStartPulse = false;
    uranusMeteorResolved = false;
    vampireHiddenAttackSuccess = false;
    hideRoomActionPop();
    if (!hasMatchingPending){
      hideAttackResultPop();
      pendingAttackResolution = null;
      pendingAttackResultMeta = null;
      attackTurnEndChoicePending = false;
      attackFlowUiLockActive = false;
      cachePendingAttackResolution(null);
    }
    showTurnHint("");
    clearCarolTurnHealTimer();
    scheduleCarolTurnStartHeal();
    if (isMyTurn() && hasGordonBarrier(state.userId) && gordonBarrierClearTurnKey !== key){
      gordonBarrierClearTurnKey = key;
      remove(ref(db, `rooms/${state.roomCode}/gordonBarrier/${state.userId}`)).catch(() => {});
    }
    if (isMyTurn() && isMyIdentityRevealed() && isMyRole("SHA_U2") && !isRoleAbilityUsed("SHA_U2")){
      const check = uranusAbilityAvailability();
      if (check.ok){
        setRoleAbilitySelectionState({ roleId:"SHA_U2", actorUid: state.userId, privateToActor:true }).catch(() => {});
      }
    }
  }

  function canUseRoom4Steal(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    const roomActionState = turnRoomActionState();
    if (roomActionState.room4StealUsed) return false;
    if (roomActionState.movedByDiceRoomId !== 4) return false;
    const others = latestPlayers.filter(p => p.id !== state.userId && !isPlayerEliminated(p.id));
    return others.some(p => hasAnyEquipment(p.id));
  }

  function canUseRoom3Action(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    const roomActionState = turnRoomActionState();
    if (roomActionState.room3ActionUsed) return false;
    return roomActionState.movedByDiceRoomId === 3;
  }


  function canUseWalpurgisSwap(){
    if (!isMyTurn() || !canUseAttackDice()) return false;
    if (!isMyRole("SHA_W2")) return false;
    if (isMyAbilitySealed()) return false;
    if (!isMyIdentityRevealed()) return false;
    if (isRoleAbilityUsed("SHA_W2")) return false;
    return true;
  }

  async function animateMarkerSwapVisual(uidA, uidB, durationMs = 560){
    const markerA = markerCache?.[uidA] || null;
    const markerB = markerCache?.[uidB] || null;
    if (!markerA || !markerB) return;
    const ax = Number(markerA.x), ay = Number(markerA.y);
    const bx = Number(markerB.x), by = Number(markerB.y);
    if (![ax, ay, bx, by].every(Number.isFinite)) return;

    const ctm = roomSvg?.getScreenCTM();
    if (!roomSvg || !ctm) return;
    const aPt = roomSvg.createSVGPoint();
    aPt.x = ax; aPt.y = ay;
    const bPt = roomSvg.createSVGPoint();
    bPt.x = bx; bPt.y = by;
    const aScr = aPt.matrixTransform(ctm);
    const bScr = bPt.matrixTransform(ctm);

    const markerVisualByUid = (uid, marker) => {
      const player = playerById(uid);
      const color = safeText(player?.color || "") || String(marker?.color || "#ddd");
      const initial = firstChar(player?.name || "") || String(marker?.initial || "").slice(0,1);
      const size = (uid && uid === state.userId) ? 17 : 16;
      return { color, initial, size, rx: 3 };
    };

    const makeChip = (uid, marker) => {
      const visual = markerVisualByUid(uid, marker);
      const chip = document.createElement("div");
      chip.style.position = "fixed";
      chip.style.left = "0";
      chip.style.top = "0";
      chip.style.zIndex = "11200";
      chip.style.pointerEvents = "none";
      chip.style.display = "grid";
      chip.style.placeItems = "center";
      chip.style.width = `${visual.size}px`;
      chip.style.height = `${visual.size}px`;
      chip.style.borderRadius = `${visual.rx}px`;
      chip.style.border = "1px solid #111";
      chip.style.fontWeight = "1000";
      chip.style.fontSize = "10px";
      chip.style.lineHeight = "1";
      chip.style.userSelect = "none";
      chip.style.background = visual.color;
      chip.style.color = textColorFor(visual.color);
      chip.style.transform = "translate(-50%,-50%)";
      chip.textContent = visual.initial;
      document.body.appendChild(chip);
      return chip;
    };

    const setChipPos = (chip, x, y) => {
      chip.style.transform = `translate(${x}px, ${y}px) translate(-50%,-50%)`;
    };

    const bezierPoint = (p0, p1, p2, t) => {
      const it = 1 - t;
      return {
        x: it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x,
        y: it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y
      };
    };

    const chipA = makeChip(uidA, markerA);
    const chipB = makeChip(uidB, markerB);
    setChipPos(chipA, aScr.x, aScr.y);
    setChipPos(chipB, bScr.x, bScr.y);

    walpurgisSwapHiddenUids.add(uidA);
    walpurgisSwapHiddenUids.add(uidB);
    renderMarkers();

    const mid = { x: (aScr.x + bScr.x) / 2, y: (aScr.y + bScr.y) / 2 };
    const dx = bScr.x - aScr.x;
    const dy = bScr.y - aScr.y;
    const dist = Math.hypot(dx, dy) || 1;
    const nx = -dy / dist;
    const ny = dx / dist;
    const arc = Math.max(26, Math.min(96, dist * 0.34));

    const pA0 = { x: aScr.x, y: aScr.y };
    const pA1 = { x: mid.x + nx * arc, y: mid.y + ny * arc };
    const pA2 = { x: bScr.x, y: bScr.y };
    const pB0 = { x: bScr.x, y: bScr.y };
    const pB1 = { x: mid.x - nx * arc, y: mid.y - ny * arc };
    const pB2 = { x: aScr.x, y: aScr.y };

    await new Promise(resolve => {
      const startedAt = performance.now();
      const step = (now) => {
        const elapsed = now - startedAt;
        const raw = Math.max(0, Math.min(1, elapsed / durationMs));
        const eased = raw;
        const pa = bezierPoint(pA0, pA1, pA2, eased);
        const pb = bezierPoint(pB0, pB1, pB2, eased);
        setChipPos(chipA, pa.x, pa.y);
        setChipPos(chipB, pb.x, pb.y);
        if (raw < 1){
          requestAnimationFrame(step);
          return;
        }
        resolve();
      };
      requestAnimationFrame(step);
    });

    const waitSwapCommit = async () => {
      const started = Date.now();
      const epsilon = 0.01;
      while ((Date.now() - started) < 1500){
        const currentA = markerCache?.[uidA] || null;
        const currentB = markerCache?.[uidB] || null;
        const axNow = Number(currentA?.x);
        const ayNow = Number(currentA?.y);
        const bxNow = Number(currentB?.x);
        const byNow = Number(currentB?.y);
        const aReached = Number.isFinite(axNow) && Number.isFinite(ayNow) && Math.abs(axNow - bx) <= epsilon && Math.abs(ayNow - by) <= epsilon;
        const bReached = Number.isFinite(bxNow) && Number.isFinite(byNow) && Math.abs(bxNow - ax) <= epsilon && Math.abs(byNow - ay) <= epsilon;
        if (aReached && bReached) break;
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    };

    await waitSwapCommit();
    walpurgisSwapHiddenUids.delete(uidA);
    walpurgisSwapHiddenUids.delete(uidB);
    renderMarkers();
    await new Promise(resolve => requestAnimationFrame(resolve));
    chipA.remove();
    chipB.remove();
  }

  async function swapMarkerPositionWithPlayer(targetUid){
    const myUid = safeText(state.userId || "");
    const otherUid = safeText(targetUid || "");
    if (!state.roomCode || !myUid || !otherUid || myUid === otherUid) return false;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const tx = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      cur.markers = cur.markers || {};
      const mine = cur.markers[myUid];
      const other = cur.markers[otherUid];
      if (!mine || !other) return cur;
      const nextMine = { ...mine };
      const nextOther = { ...other };

      nextMine.x = Number(other.x);
      nextMine.y = Number(other.y);
      nextMine.roomId = Number(other.roomId || mine.roomId || 7);
      nextMine.updatedAt = Date.now();

      nextOther.x = Number(mine.x);
      nextOther.y = Number(mine.y);
      nextOther.roomId = Number(mine.roomId || other.roomId || 7);
      nextOther.updatedAt = Date.now();

      cur.markers[myUid] = nextMine;
      cur.markers[otherUid] = nextOther;
      return cur;
    });
    return !!tx?.committed;
  }

  function showWalpurgisSwapConfirm(clientX, clientY, targetUid){
    const uid = safeText(targetUid || "");
    if (!uid || !canUseWalpurgisSwap()) return;
    const player = playerById(uid);
    const name = safeText(player?.name || "このプレイヤー");
    suppressOutsidePopCloseUntil = Date.now() + 700;
    showRoomActionPopAt(clientX, clientY, "", async () => {
      if (!canUseWalpurgisSwap()) return;
      await markRoleAbilityUsed("SHA_W2");
      await emitRoleFlashEvent("SHA_W2", "walpurgis_swap");
      await new Promise(resolve => setTimeout(resolve, 1800));
      try {
        await emitWalpurgisSwapEvent(state.userId, uid, 620);
        await new Promise(resolve => setTimeout(resolve, 620));
        await swapMarkerPositionWithPlayer(uid);
      } finally {
        renderMarkers();
      }
    }, {
      messageHtml: `${escapeHtml(name)}と位置を交換しますか。`,
      yesLabel: "はい",
      noLabel: "いいえ",
      yesBtnClass: "pop-purple",
      noBtnClass: "pop-white"
    });
  }

  function showWalpurgisCannotAttackPopAt(clientX, clientY){
    showRoomActionPopAt(clientX, clientY, "この後、攻撃できません。", null, {
      hideActions: true,
      fitText: true,
      noWrap: true
    });
  }

  function refreshRoomAbilityHint(){
    if (canUseRoom4Steal()){
      showTurnHint("他プレイヤーの装備を奪うことができます。");
      return;
    }
    if (canUseRoom3Action()){
      showTurnHint({
        text: "任意のプレイヤーへ2ダメージ/1回復できます。",
        showRoom3Skip: true
      });
      return;
    }
    if (canUseWalpurgisSwap()){
      showTurnHint("プレイヤーを長押しで位置を交換");
      return;
    }
    showTurnHint("");
  }

  async function stealEquipmentFromPlayer(targetUid, sourceKey){
    if (!state.roomCode || !targetUid || !sourceKey) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let stolenName = "";
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const targetRow = cur.equipment?.[targetUid];
      if (!targetRow) return cur;
      const item = targetRow[sourceKey];
      if (!item || item.kind === "identity") return cur;
      stolenName = safeText(item.name || "装備");

      const oldCount = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
      if (oldCount > 1){
        const next = { ...item, count: oldCount - 1 };
        delete next.qty;
        delete next.quantity;
        targetRow[sourceKey] = next;
      } else {
        delete targetRow[sourceKey];
      }

      const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
      cur.equipment[state.userId] = cur.equipment[state.userId] || {};
      cur.equipment[state.userId][addKey] = {
        theme: safeText(item.theme || "white"),
        name: safeText(item.name || ""),
        effect: safeText(item.effect || ""),
        at: Date.now()
      };
      return cur;
    });
    if (!!result.committed){
      const ownerName = safeText(playerById(targetUid)?.name || "プレイヤー");
      appendActionChatLog(state.userId, `装備奪取:${ownerName}さんから${stolenName || "装備"}`).catch(() => {});
    }
    return !!result.committed;
  }


  async function stealAllEquipmentFromPlayer(targetUid){
    const uid = safeText(targetUid);
    if (!state.roomCode || !uid || uid === state.userId) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const targetRow = cur.equipment?.[uid];
      if (!targetRow) return cur;
      const stealItems = Object.entries(targetRow)
        .filter(([, item]) => item && item.kind !== "identity")
        .map(([, item]) => item);
      if (!stealItems.length) return cur;
      cur.equipment = cur.equipment || {};
      cur.equipment[state.userId] = cur.equipment[state.userId] || {};
      for (const item of stealItems){
        const copies = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
        for (let i = 0; i < copies; i++){
          const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
          cur.equipment[state.userId][addKey] = {
            theme: safeText(item.theme || "white"),
            name: safeText(item.name || ""),
            effect: safeText(item.effect || ""),
            at: Date.now()
          };
        }
      }
      for (const [key, item] of Object.entries(targetRow)){
        if (!item || item.kind === "identity") continue;
        delete targetRow[key];
      }
      return cur;
    });
    return !!result.committed;
  }


  async function runRosaryAutoLootFlow(defeatedUids = []){
    const targets = [...new Set((defeatedUids || []).map(uid => safeText(uid)).filter(uid => uid && uid !== state.userId))]
      .filter(uid => listEquipForUid(uid).some(it => !isIdentityEquipItem(it)));
    if (!targets.length) return;

    await waitUntilZoomClosed({ maxWaitMs:16000, pollMs:80 });
    openZoomFromDeckCard({ name:"銀のロザリオ", effect:"装備、ダイスの攻撃によって倒したPLの全ての装備を奪う。" }, "white", {
      closeOnBackdrop:false,
      showCloseButton:false
    });
    setZoomOverPanel(true);

    await new Promise(resolve => setTimeout(resolve, 1000));
    for (const uid of targets){
      await stealAllEquipmentFromPlayer(uid);
    }
    closeZoom();
    renderEquipmentDock();
  }

  async function moveEquipmentCardBetweenPlayers(fromUid, toUid, sourceKey){
    if (!state.roomCode || !fromUid || !toUid || !sourceKey) return false;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let movedName = "";
    const result = await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const fromRow = cur.equipment?.[fromUid];
      if (!fromRow) return cur;
      const item = fromRow[sourceKey];
      if (!item || item.kind === "identity") return cur;
      movedName = safeText(item.name || "装備");

      const oldCount = Math.max(1, Math.floor(Number(item.count ?? item.qty ?? item.quantity ?? 1) || 1));
      if (oldCount > 1){
        const next = { ...item, count: oldCount - 1 };
        delete next.qty;
        delete next.quantity;
        fromRow[sourceKey] = next;
      } else {
        delete fromRow[sourceKey];
      }

      cur.equipment = cur.equipment || {};
      cur.equipment[toUid] = cur.equipment[toUid] || {};
      const addKey = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
      cur.equipment[toUid][addKey] = {
        theme: safeText(item.theme || "white"),
        name: safeText(item.name || ""),
        effect: safeText(item.effect || ""),
        at: Date.now()
      };
      return cur;
    });
    if (!!result.committed){
      const fromName = safeText(playerById(fromUid)?.name || "プレイヤー");
      const toName = safeText(playerById(toUid)?.name || "プレイヤー");
      appendActionChatLog(fromUid, `装備譲渡:${toName}さんへ${movedName || "装備"}（元:${fromName}）`).catch(() => {});
    }
    return !!result.committed;
  }

  function restoreOliverZoomSelection(){
    const cardObj = pendingEquipAction?.cardObj || null;
    if (!cardObj) return;
    openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
    setZoomOverPanel(false);
    setZoomPassthrough(true);
    pendingEquipAction = { type:"oliver_target", cardObj };
    renderEquipmentDock();
    renderTurnEndButton();
  }

  function isEquipSelectionLockActive(){
    return pendingEquipAction?.type === "oliver_target" || pendingEquipAction?.type === "banana_give" || pendingEquipAction?.type === "benjamin_give";
  }

  function captureSelectionRestoreAction(){
    if (isEquipSelectionLockActive()) return { kind:"equip", ...pendingEquipAction };
    if (activeRoleAbilitySelection){
      return { kind:"role_ability", entry: activeRoleAbilitySelection };
    }
    if (cardPlayerSelectActive && pendingCardTargetSelection?.cardObj){
      return { kind:"card_target", cardObj: pendingCardTargetSelection.cardObj };
    }
    if (isIdentityPromptInteractionLockActive()){
      return {
        kind:"identity_prompt",
        cardObj: pendingIdentityPrompt?.cardObj || null,
        cardTheme: safeText(pendingIdentityPrompt?.cardTheme || "white") || "white",
        message: safeText(pendingIdentityPrompt?.message || ""),
        canReveal: !!pendingIdentityPrompt?.canReveal
      };
    }
    return null;
  }

  async function restoreSelectionAction(action){
    if (!action) return;
    if (action.kind === "equip"){
      restorePendingEquipSelection(action);
      return;
    }
    if (action.kind === "role_ability"){
      openRoleAbilitySelectionUI(action.entry || null);
      return;
    }
    if (action.kind === "card_target"){
      await openPersistentCardTargetSelection(action.cardObj, { restore:true });
      return;
    }
    if (action.kind === "identity_prompt") restoreIdentityPromptSelection(action);
  }

  function restorePendingEquipSelection(action = null){
    const next = action || pendingEquipAction;
    const type = safeText(next?.type || "");
    if (!next || (type !== "oliver_target" && type !== "banana_give" && type !== "benjamin_give")) return;
    if (type === "benjamin_give"){
      pendingEquipAction = { type:"benjamin_give", selectedSourceKey:safeText(next.selectedSourceKey || "") };
      const abilityEntry = (activeRoleAbilitySelection?.roleId === "CIT_B2")
        ? activeRoleAbilitySelection
        : (safeText(state.room?.roleAbilitySelection?.roleId || "") === "CIT_B2" ? state.room.roleAbilitySelection : null);
      const role = ROLE_BY_ID["CIT_B2"];
      if (role){
        openIdentityRevealZoom(role, safeText(abilityEntry?.actorUid || state.userId), {
          persist:true,
          showOwnerTag: !!abilityEntry?.justRevealed,
          ownerTagDurationMs: 1200
        });
      }
      setGreenDockMeta({ title:"", subtitle:"" });
      if (greenShareList) greenShareList.innerHTML = "";
      greenShareActions?.classList.add("hidden");
      greenShareDock?.classList.add("hidden");
      setZoomPassthrough(true);
      renderEquipmentDock();
      renderTurnEndButton();
      return;
    }
    const cardObj = next.cardObj || null;
    if (!cardObj) return;
    openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
    setZoomPassthrough(true);
    if (type === "banana_give"){
      pendingEquipAction = { type:"banana_give", selectedSourceKey:"", cardObj };
    } else {
      pendingEquipAction = { type:"oliver_target", cardObj };
    }
    renderEquipmentDock();
    renderTurnEndButton();
  }

  function restoreSeatEquipSelection(entry){
    const type = safeText(entry?.type || "");
    const cardObj = entry?.cardObj || null;
    if ((type !== "banana_give" && type !== "oliver_target" && type !== "benjamin_give")){
      pendingEquipAction = null;
      renderTurnEndButton();
      return;
    }
    restoringSeatEquipSelection = true;
    try {
      restorePendingEquipSelection({ type, cardObj, selectedSourceKey:safeText(entry?.selectedSourceKey || "") });
    } finally {
      restoringSeatEquipSelection = false;
    }
  }

  function isGreenSessionEntryActive(entry){
    const phase = safeText(entry?.phase || "");
    return phase === "selecting" || phase === "waiting" || phase === "confirm" || phase === "answering";
  }

  function isGreenInteractionActive(){
    if (isGreenSessionEntryActive(state.room?.greenSessions?.[state.userId])) return true;
    if (isGreenSessionEntryActive(pendingGreenSessionEntry)) return true;
    if (!!pendingGreenAnswerMsg || !!pendingGreenRequestId) return true;
    if (!!greenShareCard && !greenShareDock?.classList.contains("hidden")) return true;
    if (!zoomBackdrop?.classList.contains("hidden") && isDeductionZoomActive()) return true;
    return false;
  }

  function syncGreenInteractionUiState(){
    const active = isGreenInteractionActive();
    document.body?.classList.toggle("green-interaction-active", active);
    if (!active) hideRoleHoldPreview();
  }

  function canShowEndTurnButton(){
    if (!isMyTurn()) return false;
    if (!identityPromptPop?.classList.contains("hidden")) return false;
    if (cardPlayerSelectActive) return false;
    if (isEquipSelectionLockActive()) return false;
    if (pendingEquipAction?.type === "oliver_confirm") return false;
    if (mustAttackWithMasamune()) return false;
    if (attackTurnEndChoicePending) return false;
    if (attackFlowUiLockActive) return false;
    if (suppressEndTurnButton) return false;
    if (greenTurnEndButtonLockActive) return false;
    if (hpBoardAnimationActive) return false;
    if (hasUnresolvedAttackLootSelection()) return false;
    if (safeText(state.room?.roleAbilitySelection?.roleId || "") === "RAI_G3") return false;
    if (isGreenInteractionActive()) return false;
    return !!turnState()?.moveDone;
  }

  function hasUnresolvedAttackLootSelection(){
    const mine = normalizeAttackLootPayload(state.room?.attackLootPending?.[state.userId] || pendingAttackLoot || null);
    if (!mine) return false;
    const mode = safeText(mine.mode || "defeated") || "defeated";
    const targets = mode === "byron" ? (mine.targetUids || []) : (mine.defeatedUids || []);
    return targets.some(uid => {
      if (!uid || uid === state.userId) return false;
      return listEquipForUid(uid).some(it => !isIdentityEquipItem(it));
    });
  }

  function mustAttackWithMasamune(){
    if (!isMyTurn()) return false;
    if (!hasMyEquipmentByName("妖刀マサムネ")) return false;
    if (!!turnState()?.attackDone) return false;
    return highlightedMarkerUids().size > 0;
  }

  function hideEndTurnConfirm(){
    endTurnConfirm?.classList.add("hidden");
  }

  function showEndTurnConfirm(options = {}){
    if (endTurnConfirmMsg){
      endTurnConfirmMsg.textContent = safeText(options.message || "本当に終了しますか。");
    }
    endTurnConfirm?.classList.remove("hidden");
  }

  function repeatTurnPending(){
    return Number(turnState()?.repeatTurnRemaining || 0) > 0;
  }

  function repeatTurnLabel(){
    const rest = Math.max(0, Number(turnState()?.repeatTurnRemaining || 0));
    if (rest <= 0) return "もう一度手番を行う";
    return `もう一度手番を行う(あと${rest}回)`;
  }

  function repeatTurnSuffixLabel(){
    const rest = Math.max(0, Number(turnState()?.repeatTurnRemaining || 0));
    if (rest <= 0) return "";
    return `(あと${rest}回)`;
  }

  function hasSealWisdomBonusThisTurn(){
    return !!turnState()?.sealWisdomBonus;
  }

  function renderTurnEndButton(){
    syncRoomAbilityTurnState();
    syncGreenInteractionUiState();
    if (!turnEndWrap) return;
    if (suppressTurnButtonUntilNextTurnStart){
      const moved = !!turnState()?.moveDone;
      if (isMyTurn() && moved){
        turnEndWrap.classList.add("hidden");
        hideEndTurnConfirm();
        return;
      }
      suppressTurnButtonUntilNextTurnStart = false;
    }
    const visible = isGameStarted() && canShowEndTurnButton();
    turnEndWrap.classList.toggle("hidden", !visible);
    if (btnEndTurn){
      if (hasSealWisdomBonusThisTurn()){
        btnEndTurn.textContent = "手番を終わる(+1)";
      } else {
        btnEndTurn.textContent = repeatTurnPending() ? repeatTurnLabel() : "手番を終わる";
      }
    }
    if (!visible) hideEndTurnConfirm();
  }

  function turnCycleKey(){
    const t = turnState() || {};
    const cur = safeText(t.currentPlayerId || "");
    const updatedAt = Number(t.updatedAt || 0);
    return `${cur}:${updatedAt}`;
  }

  function maybeAutoRollMoveDiceOnTurnStart(){
    if (!isGameStarted()) return;
    if (!canUseMoveDice()) return;
    if (!state.userId) return;

    const pendingGodwinReviveMove = !!state.room?.godwinRevivePendingMove?.[state.userId];
    const myMarker = markerCache?.[state.userId] || null;
    if (!pendingGodwinReviveMove && myMarker) return;

    const key = turnCycleKey();
    if (!key || key === autoMoveTriggeredTurnKey) return;

    autoMoveTriggeredTurnKey = key;
    hideAttackPop();
    setTimeout(() => triggerMoveDiceForAll(), 80);
  }

  async function triggerMoveDiceForAll(){
    if (!state.roomCode || !canUseMoveDice()) return;
    const selectedSum = chooseSumForTestPlayer("移動");
    if (isTestPlayer() && selectedSum == null) return;
    suppressSelfTurnStartPulse = true;
    renderMarkers();
    const selectedPair = selectedSum != null ? pickDiceBySum(selectedSum) : null;
    const d6 = selectedPair?.d6 ?? (1 + Math.floor(Math.random() * 6));
    const d4 = selectedPair?.d4 ?? (1 + Math.floor(Math.random() * 4));
    const compass = hasMyEquipmentByName('神秘のコンパス');
    const secondD6 = 1 + Math.floor(Math.random() * 6);
    const secondD4 = 1 + Math.floor(Math.random() * 4);
    const width = window.innerWidth;
    const height = window.innerHeight;
    const motion = createDiceMotion(width, height, width/2, height/2);
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/move`), {
      uid: state.userId,
      d6,
      d4,
      compass,
      secondD6,
      secondD4,
      motion,
      at: Date.now()
    });
    const moveRollText = compass
      ? `移動ロール：合計${d6 + d4} (6d${d6},4d${d4}) / 合計${secondD6 + secondD4} (6d${secondD6},4d${secondD4})`
      : `移動ロール：合計${d6 + d4} (6d${d6},4d${d4})`;
    appendActionChatLog(state.userId, moveRollText).catch(() => {});
  }


  function isNpcPlayerUid(uid){
    const targetUid = safeText(uid || "");
    if (!targetUid) return false;
    const row = latestPlayers.find((p) => safeText(p.id || "") === targetUid) || null;
    if (!row) return false;
    const table = state.room?.tables?.[String(row.seatIndex)] || null;
    return !!table?.isNpc || targetUid.startsWith("npc_");
  }

  const NPC_TURN_PACING = {
    turnStartDelayMs: 700,
    phaseIntervalMs: 700,
    speechMinMs: 250,
    speechDefaultMs: 900,
    speechMaxMs: 1200,
    diceAfterMs: 150,
    attackAfterMs: 150,
    retryMs: 80
  };

  async function showNpcSpeech(uid, text, durationMs = NPC_TURN_PACING.speechDefaultMs, options = {}){
    const targetUid = safeText(uid || "");
    const label = safeText(text || "").trim();
    if (!state.roomCode || !targetUid || !label) return;
    const resolvedMs = Math.max(
      NPC_TURN_PACING.speechMinMs,
      Math.min(NPC_TURN_PACING.speechMaxMs, Number(durationMs || NPC_TURN_PACING.speechDefaultMs))
    );
    const style = safeText(options?.style || "");
    const at = Date.now();
    await set(ref(db, `rooms/${state.roomCode}/npcSpeech`), {
      uid: targetUid,
      text: label,
      style,
      at,
      expiresAt: at + resolvedMs
    });
    await waitMs(resolvedMs);
  }

  function npcSpeechStyleByFaction(uid){
    const faction = safeText(roleInfoByUid(uid)?.faction || "");
    if (faction === "レイダー") return "raider";
    if (faction === "シャドウ") return "shadow";
    return "";
  }

  async function npcAnnounceAbilityUse(uid, abilityName = "", targetUid = "", options = {}){
    const actorUid = safeText(uid || "");
    const name = safeText(abilityName || "").trim();
    const target = safeText(targetUid || "");
    if (!actorUid || !name) return;
    const targetName = safeText(playerById(target)?.name || "");
    const line2 = targetName ? `
${targetName}さん...` : "";
    await showNpcSpeech(actorUid, `${name}！！${line2}`, 1200, { style:npcSpeechStyleByFaction(actorUid) });

    const hasDelta = Number.isFinite(Number(options?.delta));
    if (target && hasDelta){
      const delta = Number(options.delta || 0);
      const useCurrent = !!options?.useCurrentDamage;
      const dmgText = useCurrent
        ? currentDamageForUid(target)
        : clampProjectedDamageValue(currentDamageForUid(target), delta);
      appendActionChatLog(actorUid, `${name} ${actionDeltaText(delta)}>${displayNameRoleForUid(target)} (${dmgText})`);
      return;
    }

    const logTail = target ? `>${displayNameRoleForUid(target)}` : "";
    appendActionChatLog(actorUid, `${name}${logTail}`);
  }

  function npcHumanPlayerCount(){
    const tables = state.room?.tables || {};
    return Object.values(tables).filter((row) => !!row?.playerId && !row?.isNpc).length;
  }

  function isNpcActionChatMode(){
    return !!state.room?.computerMode && npcHumanPlayerCount() <= 1;
  }

  function isActionLogPlaceholderText(text, kind = "name"){
    const v = safeText(text || "");
    if (!v) return true;
    if (kind === "name"){
      return v === "プレイヤー" || v.includes("プレイヤー名") || v.includes("[プレイヤー名]");
    }
    return v === "?" || v.includes("正体名");
  }

  function displayNameForUid(uid){
    const targetUid = safeText(uid || "");
    if (!targetUid) return "プレイヤー";
    const fromPlayers = safeText(playerById(targetUid)?.name || "");
    if (!isActionLogPlaceholderText(fromPlayers, "name")) return fromPlayers;
    for (const row of Object.values(state.room?.tables || {})){
      if (safeText(row?.playerId || "") !== targetUid) continue;
      const n = safeText(row?.playerName || "");
      if (!isActionLogPlaceholderText(n, "name")) return n;
    }
    const cached = safeText(lastKnownNameByUid[targetUid] || "");
    if (!isActionLogPlaceholderText(cached, "name")) return cached;
    return "プレイヤー";
  }

  function roleNameForUid(uid){
    const targetUid = safeText(uid || "");
    const roleId = safeText(state.room?.hands?.[targetUid]?.roleId || state.hands?.[targetUid]?.roleId || "");
    const name = safeText(ROLE_BY_ID?.[roleId]?.name || roleInfoByUid(targetUid)?.name || "");
    if (!isActionLogPlaceholderText(name, "role")) return name;
    const cached = safeText(lastKnownRoleNameByUid[targetUid] || "");
    if (!isActionLogPlaceholderText(cached, "role")) return cached;
    return "?";
  }

  function actionSourceLabel(sourceRaw){
    const src = safeText(sourceRaw || "");
    if (!src) return "";
    const map = {
      card_blessing_heal: "恩恵",
      card_vampire_bat_heal: "吸血コウモリ",
      card_holy_water_heal: "いやしの聖水",
      card_mermaid_tears_heal: "人魚の涙",
      first_aid_set: "応急手当",
      felicia_set: "スラム街の天使"
    };
    return safeText(map[src] || src);
  }

  function displayRoleOrHiddenForUid(uid){
    const roleName = roleNameForUid(uid);
    return roleName && roleName !== "?" ? roleName : "正体名";
  }

  function displayNameRoleForUid(uid){
    return `${displayNameForUid(uid)}[${displayRoleOrHiddenForUid(uid)}]`;
  }

  function currentDamageForUid(uid){
    return clampDamage(Number(state.room?.damage?.[uid] || 0));
  }

  function actionDeltaText(delta){
    const v = Number(delta || 0);
    if (!Number.isFinite(v) || v === 0) return "0";
    return v > 0 ? `${v}` : `${v}`;
  }

  function actionTargetWithDamage(uid, delta){
    const total = currentDamageForUid(uid);
    return `${displayNameForUid(uid)} (${total})`;
  }

  function displayNameBracketRoleForUid(uid){
    return `${displayNameForUid(uid)} [${displayRoleOrHiddenForUid(uid)}]`;
  }

  function clampProjectedDamageValue(base, delta){
    return clampDamage(Number(base || 0) + Number(delta || 0));
  }

  function greenAnswerDeltaForLog(cardText, answerId, targetUid){
    const text = safeText(cardText || "");
    const aid = safeText(answerId || "");
    if (aid === "take_damage") return 1;
    if (aid !== "yes") return null;
    if (text.includes("1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ")){
      const cur = currentDamageForUid(targetUid);
      return cur <= 0 ? 1 : -1;
    }
    if (text.includes("❿に移動せよ")){
      const nowRoom = markerRoomId(markerCache?.[targetUid]);
      return nowRoom === 7 ? 1 : null;
    }
    const m = text.match(/(\d+)ダメージ受けよ/);
    const dmg = m ? Number(m[1] || 0) : 0;
    return dmg > 0 ? dmg : null;
  }

  function greenHistoryLogLine({ responderUid, cardText, answerLabel, answerId, useCurrentDamage=false } = {}){
    const uid = safeText(responderUid || "");
    const q = safeText(cardText || "");
    const aid = safeText(answerId || "");
    const answer = (aid === "reveal_identity") ? "" : safeText(answerLabel || aid || "");
    if (!uid || !q) return "";
    const delta = greenAnswerDeltaForLog(q, aid, uid);
    const target = displayNameBracketRoleForUid(uid);
    if (delta == null){
      return `[${q}] >${target}${answer ? ` ${answer}` : ""}`.trim();
    }
    const damageText = useCurrentDamage
      ? ` (${currentDamageForUid(uid)})`
      : ` (${clampProjectedDamageValue(currentDamageForUid(uid), delta)})`;
    return `[${q}] ${actionDeltaText(delta)}>${target}${answer ? ` ${answer}` : ""}${damageText}`.trim();
  }

  function appendGreenHistoryLogFromResponse(msg, options = {}){
    const requestId = safeText(msg?.requestId || "");
    if (!requestId) return;
    if (greenHistoryLoggedRequestIds.has(requestId)) return;
    const responderUid = safeText(msg?.to || options?.responderUid || "");
    const q = safeText(msg?.card?.effect || msg?.card?.text || options?.cardText || "");
    const answerLabel = safeText(msg?.answerLabel || options?.answerLabel || "");
    const answerId = safeText(msg?.answerId || options?.answerId || "");
    const line = greenHistoryLogLine({
      responderUid,
      cardText: q,
      answerLabel,
      answerId,
      useCurrentDamage: true
    });
    if (!line) return;
    greenHistoryLoggedRequestIds.add(requestId);
    appendActionChatLog(safeText(msg?.from || options?.actorUid || responderUid || state.userId), line).catch(() => {});
  }

  async function appendActionChatLog(uid, actionText){
    const actorUid = safeText(uid || state.userId || "");
    const action = safeText(actionText || "").trim();
    if (!state.roomCode || !actorUid || !action) return;
    if (!isNpcActionChatMode()) return;
    const name = displayNameForUid(actorUid);
    const roleName = roleNameForUid(actorUid);
    if (!isActionLogPlaceholderText(name, "name")) lastKnownNameByUid[actorUid] = name;
    if (!isActionLogPlaceholderText(roleName, "role")) lastKnownRoleNameByUid[actorUid] = roleName;
    const key = `${Date.now()}_${Math.random().toString(16).slice(2,8)}`;
    const path = `rooms/${state.roomCode}/actionChatLog/${key}`;
    await set(ref(db, path), {
      uid: actorUid,
      playerName: name,
      roleName,
      action,
      at: Date.now()
    }).catch(() => {});
  }

  function renderActionChatLog(){
    if (!actionChatBody) return;
    const rows = Object.values(state.room?.actionChatLog || {})
      .filter((row) => !!row && !!safeText(row.action || ""))
      .sort((a,b) => Number(a?.at || 0) - Number(b?.at || 0));
    actionChatBody.innerHTML = "";
    if (!rows.length){
      const empty = document.createElement("div");
      empty.className = "action-chat-row";
      empty.textContent = "ログはまだありません。";
      actionChatBody.appendChild(empty);
      return;
    }
    for (const row of rows){
      const line = document.createElement("div");
      line.className = "action-chat-row";
      const uid = safeText(row.uid || "");
      const rawName = safeText(row.playerName || "");
      const rawRole = safeText(row.roleName || "");
      const playerName = isActionLogPlaceholderText(rawName, "name") ? displayNameForUid(uid) : rawName;
      const roleName = isActionLogPlaceholderText(rawRole, "role") ? roleNameForUid(uid) : rawRole;
      const action = safeText(row.action || "");
      line.textContent = `${playerName}[${roleName}]：${action}`;
      actionChatBody.appendChild(line);
    }
  }

  function factionPercentMapFromHint(hint){
    const map = { "レイダー":34, "シャドウ":33, "シチズン":33 };
    const row = hint && typeof hint === "object" ? hint : {};
    const confirmed = safeText(row.confirmedFaction || "");
    if (confirmed && map[confirmed] != null){
      for (const key of Object.keys(map)) map[key] = (key === confirmed) ? 100 : 0;
      return map;
    }
    const possible = Array.isArray(row.possibleFactions)
      ? [...new Set(row.possibleFactions.map((f) => safeText(f)).filter((f) => map[f] != null))]
      : [];
    if (possible.length){
      for (const key of Object.keys(map)) map[key] = 0;
      const base = Math.floor(100 / possible.length);
      let rest = 100 - (base * possible.length);
      for (const f of possible){
        map[f] = base + (rest > 0 ? 1 : 0);
        if (rest > 0) rest -= 1;
      }
    }
    return map;
  }

  function appendFactionInferenceChangeLog(observerUid, targetUid, prevHint, nextHint){
    const observer = safeText(observerUid || "");
    const target = safeText(targetUid || "");
    if (!observer || !target) return;
    const before = factionPercentMapFromHint(prevHint || null);
    const after = factionPercentMapFromHint(nextHint || null);
    const deltas = [];
    for (const faction of ["レイダー", "シャドウ", "シチズン"]){
      const diff = Number(after[faction] || 0) - Number(before[faction] || 0);
      if (Math.abs(diff) < 5) continue;
      const sign = diff > 0 ? "+" : "";
      deltas.push(`${safeText(playerById(target)?.name || "プレイヤー")}→${faction}${sign}${diff}%`);
    }
    if (!deltas.length) return;
    appendActionChatLog(observer, deltas.join(" / ")).catch(() => {});
  }

  async function grantEquipmentToPlayer(uid, cardObj, theme){
    const targetUid = safeText(uid || "");
    if (!state.roomCode || !targetUid || !cardObj || !isEquipCard(cardObj)) return false;
    const key = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    await set(ref(db, `rooms/${state.roomCode}/equipment/${targetUid}/${key}`), {
      theme: theme || "white",
      name: safeText(cardObj.name),
      effect: safeText(cardObj.effect),
      at: Date.now()
    });
    return true;
  }

  function roleInfoByUid(uid){
    const rid = safeText(state.room?.hands?.[safeText(uid || "")]?.roleId || state.hands?.[safeText(uid || "")]?.roleId || "");
    return ROLE_BY_ID[rid] || null;
  }

  function npcGreenConditionMatchedForUid(cardObj, uid){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const compactText = text.replace(/[\s　]+/g, "");
    const role = roleInfoByUid(uid);
    if (!role) return null;
    if (text.includes("A / B / C / E / U")) return ["A","B","C","E","U"].includes(role.initial) && Number(role.hp) <= 11;
    if (text.includes("D / F / G / V / W")) return ["D","F","G","V","W"].includes(role.initial) && Number(role.hp) >= 12;
    if (compactText.includes("シチズンかシャドウ")) return role.faction === "シチズン" || role.faction === "シャドウ";
    if (compactText.includes("シチズンかレイダー")) return role.faction === "シチズン" || role.faction === "レイダー";
    if (compactText.includes("レイダーかシャドウ")) return role.faction === "レイダー" || role.faction === "シャドウ";
    if (text.includes("シャドウ？")) return role.faction === "シャドウ";
    if (text.includes("レイダー？")) return role.faction === "レイダー";
    if (text.includes("シチズン？")) return role.faction === "シチズン";
    return null;
  }

  async function applyNpcGreenAnswerEffect(targetUid, cardObj, answerId){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    if (answerId === "take_damage"){
      await addDamageToPlayer(targetUid, 1, { skipActionLog:true });
      return;
    }
    const isPositive = (answerId === "yes" || answerId === "reveal_identity");
    if (!isPositive) return;
    if (text.includes("1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ")){
      const cur = clampDamage(damageCache?.[targetUid]);
      if (cur <= 0) await addDamageToPlayer(targetUid, 1, { skipActionLog:true });
      else await healDamageToPlayer(targetUid, 1, "green_heal", { skipActionLog:true });
    } else if (!text.includes("❿に移動せよ")) {
      const m = text.match(/(\d+)ダメージ受けよ/);
      const dmg = m ? Number(m[1] || 0) : 0;
      if (dmg > 0) await addDamageToPlayer(targetUid, dmg, { skipActionLog:true });
    }
    if (text.includes("❿に移動せよ")){
      const nowRoom = markerRoomId(markerCache?.[targetUid]);
      if (nowRoom === 7) await addDamageToPlayer(targetUid, 1, { skipActionLog:true });
      else await placePlayerMarkerInRoom(targetUid, 7);
    }
  }

  function pickNpcGreenAnswer(cardObj, targetUid){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const matched = npcGreenConditionMatchedForUid(cardObj, targetUid);
    if (text.includes("正体カードを見せよ")) return { id:"reveal_identity", label:"私の正体です。" };
    if (text.includes("装備を渡すか、1ダメージ受けよ")){
      if (matched) return { id:"take_damage", label:"1ダメージうける" };
      return { id:"no", label:"いいえ" };
    }
    if (text.includes("❿に移動せよ")){
      if (!matched) return { id:"no", label:"いいえ" };
      const nowRoom = markerRoomId(markerCache?.[targetUid]);
      return { id:"yes", label:(nowRoom === 7 ? "1ダメージうける" : "➓に移動する") };
    }
    if (text.includes("1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ")){
      if (!matched) return { id:"no", label:"いいえ" };
      const cur = clampDamage(damageCache?.[targetUid]);
      return { id:"yes", label:(cur <= 0 ? "1ダメージうける" : "1ダメージ回復する") };
    }
    if (matched) return { id:"yes", label:(text.match(/(\d+)ダメージ受けよ/) ? `${text.match(/(\d+)ダメージ受けよ/)[1]}ダメージうける` : "はい") };
    return { id:"no", label:"いいえ" };
  }

  async function resolveNpcGreenInboxPayload(payload){
    if (!state.roomCode || !payload?.from || !payload?.to || !payload?.requestId || !payload?.card) return null;
    const responderUid = safeText(payload.to || "");
    if (!responderUid || !isNpcPlayerUid(responderUid)) return null;
    await waitMs(450);
    const opt = pickNpcGreenAnswer(payload.card, responderUid);
    const roleId = (opt.id === "reveal_identity") ? safeText(state.hands?.[responderUid]?.roleId || "") : "";
    await set(ref(db, `rooms/${state.roomCode}/greenResponses/${payload.from}`), {
      from: safeText(payload.from || ""),
      to: responderUid,
      requestId: safeText(payload.requestId || ""),
      answerId: opt.id,
      answerLabel: opt.label,
      roleId,
      card: payload.card,
      at: Date.now()
    });
    await set(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${payload.requestId}`), {
      from: safeText(payload.from || ""),
      responderId: responderUid,
      requestId: safeText(payload.requestId || ""),
      answerLabel: opt.label,
      at: Date.now()
    });
    if (roleId){
      await set(ref(db, `rooms/${state.roomCode}/greenReveals/${payload.requestId}`), {
        requestId: safeText(payload.requestId || ""),
        from: safeText(payload.from || ""),
        responderId: responderUid,
        roleId,
        at: Date.now()
      });
    }
    await remove(ref(db, `rooms/${state.roomCode}/greenInbox/${responderUid}`)).catch(() => {});
    await applyNpcGreenAnswerEffect(responderUid, payload.card, opt.id);
    const q = safeText(payload?.card?.effect || payload?.card?.text || "");
    appendGreenHistoryLogFromResponse({
      requestId: safeText(payload?.requestId || ""),
      from: safeText(payload?.from || ""),
      to: responderUid,
      card: payload?.card || null,
      answerLabel: safeText(opt?.label || opt?.id || ""),
      answerId: safeText(opt?.id || "")
    });
    return { answerId: opt.id, roleId };
  }

  function npcYesNoByDamage(uid){
    const dmg = clampDamage(damageCache?.[uid]);
    if (dmg <= 3) return false;
    if (dmg <= 5) return Math.random() < 0.5;
    return true;
  }

  function pickRandomAliveUidForNpc(actorUid, { includeSelf=false } = {}){
    const pool = latestPlayers
      .filter((p) => includeSelf || p.id !== actorUid)
      .filter((p) => !isPlayerEliminated(p.id));
    if (!pool.length) return "";
    const picked = pool[Math.floor(Math.random() * pool.length)] || null;
    return safeText(picked?.id || "");
  }

  function chooseNpcTargetForCard(actorUid, { purpose="attack", includeSelf=false } = {}){
    const actor = safeText(actorUid || "");
    if (!actor) return "";
    const actorFaction = safeText(roleInfoByUid(actor)?.faction || "");
    const pool = latestPlayers
      .filter((p) => includeSelf || p.id !== actor)
      .filter((p) => !isPlayerEliminated(p.id))
      .map((p) => p.id);
    if (!pool.length) return "";

    if (purpose === "attack") return chooseNpcAttackTarget(actor, pool);

    if (purpose === "heal"){
      if (actorFaction !== "シチズン"){
        const revealedAlly = pool.filter((uid) => revealedFactionForUid(uid) === actorFaction && clampDamage(damageCache?.[uid]) > 0);
        if (revealedAlly.length){
          return revealedAlly.sort((a,b) => clampDamage(damageCache?.[b]) - clampDamage(damageCache?.[a]))[0] || "";
        }
        const safeUnknown = pool.filter((uid) => npcEnemyLikelihoodByIntel(actor, uid) < 0.5 && clampDamage(damageCache?.[uid]) > 0);
        if (safeUnknown.length){
          return safeUnknown.sort((a,b) => clampDamage(damageCache?.[b]) - clampDamage(damageCache?.[a]))[0] || "";
        }
      }
      const damagedPool = pool.filter((uid) => clampDamage(damageCache?.[uid]) > 0);
      if (!damagedPool.length) return "";
      return damagedPool[Math.floor(Math.random() * damagedPool.length)] || "";
    }

    if (purpose === "first_aid"){
      if (actorFaction !== "シチズン"){
        const allies = pool.filter((uid) => revealedFactionForUid(uid) === actorFaction && clampDamage(damageCache?.[uid]) > 7);
        const enemies = pool.filter((uid) => {
          const f = revealedFactionForUid(uid);
          return !!f && isRivalFactionPair(actorFaction, f) && clampDamage(damageCache?.[uid]) < 7;
        });
        const picked = [...allies, ...enemies].sort((a,b) => Math.abs(clampDamage(damageCache?.[b]) - 7) - Math.abs(clampDamage(damageCache?.[a]) - 7))[0];
        if (picked) return picked;
      }
      return pool[Math.floor(Math.random() * pool.length)] || "";
    }
    return pool[Math.floor(Math.random() * pool.length)] || "";
  }

  async function npcAnnounceSelectedPlayer(uid, targetUid){
    const targetName = safeText(playerById(targetUid)?.name || "プレイヤー");
    await showNpcSpeech(uid, `じゃ、${targetName}さん！`, 1200);
  }

  function isRivalFactionPair(a, b){
    const fa = safeText(a || "");
    const fb = safeText(b || "");
    return (fa === "シャドウ" && fb === "レイダー") || (fa === "レイダー" && fb === "シャドウ");
  }

  function revealedFactionForUid(uid){
    const targetUid = safeText(uid || "");
    if (!targetUid || !isIdentityRevealedFor(targetUid)) return "";
    const rid = safeText(equipCache?.[targetUid]?.identity?.roleId || "");
    return safeText(ROLE_BY_ID[rid]?.faction || "");
  }

  function factionRuleForCurrentPlayers(){
    const totalCount = Math.max(1, latestPlayers.length || 1);
    return DEAL_RULE[totalCount] || DEAL_RULE[1] || null;
  }

  function npcEnemyLikelihoodByIntel(observerUid, targetUid){
    const observer = safeText(observerUid || "");
    const target = safeText(targetUid || "");
    if (!observer || !target || observer === target || isPlayerEliminated(target)) return 0;
    const observerFaction = safeText(roleInfoByUid(observer)?.faction || "");
    if (observerFaction !== "レイダー" && observerFaction !== "シャドウ") return 0;
    const rivalFaction = observerFaction === "レイダー" ? "シャドウ" : "レイダー";
    const revealedTargetFaction = revealedFactionForUid(target);
    if (revealedTargetFaction) return isRivalFactionPair(observerFaction, revealedTargetFaction) ? 1 : 0;

    const hint = state.room?.npcIntel?.factionHints?.[observer]?.[target] || null;
    let likelihood = 0.34;

    const rule = factionRuleForCurrentPlayers();
    const totalRival = Math.max(0, Number(rule?.[rivalFaction] || 0));
    const totalObserverFaction = Math.max(0, Number(rule?.[observerFaction] || 0));
    const allOthers = latestPlayers.filter((p) => p.id !== observer);
    const aliveOthers = allOthers.filter((p) => !isPlayerEliminated(p.id));
    const revealedRaiderCount = allOthers.filter((p) => revealedFactionForUid(p.id) === "レイダー").length;
    const revealedShadowCount = allOthers.filter((p) => revealedFactionForUid(p.id) === "シャドウ").length;
    const revealedSameCount = allOthers.filter((p) => revealedFactionForUid(p.id) === observerFaction).length;
    const revealedRivalCount = allOthers.filter((p) => revealedFactionForUid(p.id) === rivalFaction).length;
    const unrevealedAliveOthers = aliveOthers.filter((p) => !revealedFactionForUid(p.id));

    const remainingRival = Math.max(0, totalRival - revealedRivalCount);
    if (unrevealedAliveOthers.length > 0){
      likelihood = Math.max(likelihood, Math.min(1, remainingRival / unrevealedAliveOthers.length));
    }
    if (totalObserverFaction === 2 && revealedSameCount >= 1) likelihood = Math.max(likelihood, 0.75);
    if (revealedRaiderCount === 1 && revealedShadowCount === 1) likelihood = Math.max(likelihood, 0.5);
    if ((revealedRaiderCount + revealedShadowCount) === 1 && revealedSameCount >= 1) likelihood = Math.max(likelihood, 2 / 3);
    const hintPossible = Array.isArray(hint?.possibleFactions)
      ? hint.possibleFactions.map((f) => safeText(f)).filter(Boolean)
      : [];
    if (hintPossible.length){
      const totalInHint = hintPossible.reduce((sum, f) => sum + Math.max(0, Number(rule?.[f] || 0)), 0);
      const rivalInHint = hintPossible.includes(rivalFaction) ? Math.max(0, Number(rule?.[rivalFaction] || 0)) : 0;
      if (totalInHint > 0){
        likelihood = Math.max(likelihood, Math.min(1, rivalInHint / totalInHint));
      }
      if (!hintPossible.includes(rivalFaction)) likelihood = 0;
      if (hintPossible.length === 1 && hintPossible[0] === rivalFaction) likelihood = 1;
    }
    if (hint?.sameImpossible) likelihood = Math.max(likelihood, 0.9);
    if (hint?.samePossible) likelihood = Math.min(likelihood, 0.2);
    const attackedMeCount = Number(state.room?.npcIntel?.attackedByUid?.[target]?.[observer] || 0);
    if (attackedMeCount > 0 && !!hint?.sameConfirmed && !hint?.sameImpossible){
      likelihood = Math.max(likelihood, 0.85);
    }
    return Math.max(0, Math.min(1, likelihood));
  }

  function greenFactionSetFromCard(cardObj, askerFaction=""){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const compact = text.replace(/[\s　]+/g, "");
    const faction = safeText(askerFaction || "");
    const rivalFaction = faction === "レイダー" ? "シャドウ" : faction === "シャドウ" ? "レイダー" : "";
    if (compact.includes("同陣営") && compact.includes("シチズン") && faction) return new Set([faction, "シチズン"]);
    if (compact.includes("敵陣営") && compact.includes("シチズン") && rivalFaction) return new Set([rivalFaction, "シチズン"]);
    if (compact.includes("同陣営") && faction) return new Set([faction]);
    if (compact.includes("敵陣営") && rivalFaction) return new Set([rivalFaction]);
    if (text.includes("シャドウ？")) return new Set(["シャドウ"]);
    if (text.includes("レイダー？")) return new Set(["レイダー"]);
    if (text.includes("シチズン？")) return new Set(["シチズン"]);
    if (compact.includes("シチズンかシャドウ")) return new Set(["シチズン","シャドウ"]);
    if (compact.includes("シチズンかレイダー")) return new Set(["シチズン","レイダー"]);
    if (compact.includes("レイダーかシャドウ")) return new Set(["レイダー","シャドウ"]);
    return null;
  }

  async function recordNpcFactionInference(fromUid, toUid, cardObj, answerId, revealedRoleId=""){
    const asker = safeText(fromUid || "");
    const target = safeText(toUid || "");
    if (!state.roomCode || !asker || !target || asker === target) return;
    if (!isNpcPlayerUid(asker)) return;
    const askerFaction = safeText(roleInfoByUid(asker)?.faction || "");
    if (!askerFaction || askerFaction === "シチズン") return;
    const ans = safeText(answerId || "");
    if (ans !== "yes" && ans !== "reveal_identity" && ans !== "no") return;

    const prevHint = state.room?.npcIntel?.factionHints?.[asker]?.[target] || null;
    const revealCard = isRevealIdentityGreenCard(cardObj);
    if (revealCard && ans === "reveal_identity"){
      const roleId = safeText(revealedRoleId || "");
      const revealedFaction = safeText(ROLE_BY_ID[roleId]?.faction || "");
      if (!revealedFaction) return;
      const samePossible = revealedFaction === askerFaction;
      const sameImpossible = !samePossible;
      const rivalFaction = askerFaction === "レイダー" ? "シャドウ" : askerFaction === "シャドウ" ? "レイダー" : "";
      const nextHint = {
        ...(prevHint || {}),
        samePossible,
        sameImpossible,
        sameConfirmed: samePossible,
        enemyCertain: !!rivalFaction && revealedFaction === rivalFaction,
        possibleFactions: [revealedFaction],
        confirmedFaction: revealedFaction,
        confirmedBy: "green_reveal_identity",
        at: Date.now()
      };
      await runTransaction(ref(db, `rooms/${state.roomCode}/npcIntel`), (cur) => {
        const next = cur && typeof cur === "object" ? cur : {};
        next.factionHints = next.factionHints || {};
        next.factionHints[asker] = next.factionHints[asker] || {};
        const prev = next.factionHints[asker][target] || {};
        next.factionHints[asker][target] = {
          ...prev,
          ...nextHint
        };
        return next;
      });
      appendFactionInferenceChangeLog(asker, target, prevHint, nextHint);
      return;
    }

    const setAsked = greenFactionSetFromCard(cardObj, askerFaction);
    if (!(setAsked instanceof Set)) return;
    const allSet = new Set(["シチズン","レイダー","シャドウ"]);
    const possible = new Set(ans === "no" ? [...allSet].filter(f => !setAsked.has(f)) : [...setAsked]);
    const rivalFaction = askerFaction === "レイダー" ? "シャドウ" : askerFaction === "シャドウ" ? "レイダー" : "";

    const prevPossible = Array.isArray(prevHint?.possibleFactions)
      ? new Set(prevHint.possibleFactions.map((f) => safeText(f)).filter(Boolean))
      : new Set(allSet);
    const mergedPossible = new Set([...prevPossible].filter((f) => possible.has(f)));
    const decidedPossible = mergedPossible.size ? mergedPossible : possible;
    const samePossible = decidedPossible.has(askerFaction);
    const sameImpossible = !samePossible;
    const sameConfirmed = decidedPossible.size === 1 && decidedPossible.has(askerFaction);
    const enemyCertain = !!rivalFaction && decidedPossible.size === 1 && decidedPossible.has(rivalFaction);
    const nextHint = {
      ...(prevHint || {}),
      possibleFactions: [...decidedPossible],
      samePossible,
      sameImpossible,
      sameConfirmed,
      enemyCertain,
      at: Date.now()
    };

    await runTransaction(ref(db, `rooms/${state.roomCode}/npcIntel`), (cur) => {
      const next = cur && typeof cur === "object" ? cur : {};
      next.factionHints = next.factionHints || {};
      next.factionHints[asker] = next.factionHints[asker] || {};
      const prev = next.factionHints[asker][target] || {};
      next.factionHints[asker][target] = {
        ...prev,
        ...nextHint
      };
      return next;
    });
    appendFactionInferenceChangeLog(asker, target, prevHint, nextHint);
  }


  async function recordNpcAttackTarget(attackerUid, targetUid){
    const attacker = safeText(attackerUid || "");
    const target = safeText(targetUid || "");
    if (!state.roomCode || !attacker || !target) return;
    await runTransaction(ref(db, `rooms/${state.roomCode}/npcIntel`), (cur) => {
      const next = cur && typeof cur === "object" ? cur : {};
      next.lastAttackTargetByUid = next.lastAttackTargetByUid || {};
      next.lastAttackTargetByUid[attacker] = { targetUid: target, at: Date.now() };
      next.attackedByUid = next.attackedByUid || {};
      next.attackedByUid[attacker] = next.attackedByUid[attacker] || {};
      next.attackedByUid[attacker][target] = Number(next.attackedByUid[attacker][target] || 0) + 1;
      return next;
    });
    await recordNpcFactionCertaintyFromRevealedAttack(attacker, target);
  }

  async function recordFactionRelationInferenceFromRevealedTarget(actorUid, targetUid, relation = "enemy", reason = ""){
    const actor = safeText(actorUid || "");
    const target = safeText(targetUid || "");
    const rel = safeText(relation || "");
    if (!state.roomCode || !actor || !target || actor === target) return;
    const targetFaction = safeText(revealedFactionForUid(target) || "");
    if (targetFaction !== "レイダー" && targetFaction !== "シャドウ") return;

    let inferredFaction = "";
    if (rel === "same"){
      inferredFaction = targetFaction;
    } else if (rel === "enemy"){
      inferredFaction = targetFaction === "レイダー" ? "シャドウ" : "レイダー";
    }
    if (!inferredFaction) return;

    const prevHintsMap = state.room?.npcIntel?.factionHints || {};
    const observerUidsForLog = latestPlayers.map((p) => safeText(p.id || "")).filter(Boolean);

    await runTransaction(ref(db, `rooms/${state.roomCode}/npcIntel`), (cur) => {
      const next = cur && typeof cur === "object" ? cur : {};
      const observers = new Set();
      for (const uid of Object.keys(cur?.users || {})) observers.add(safeText(uid));
      for (const uid of Object.keys(cur?.hands || {})) observers.add(safeText(uid));
      for (const row of Object.values(cur?.tables || {})){
        const uid = safeText(row?.playerId || "");
        if (uid) observers.add(uid);
      }
      const observerUids = [...observers].filter(Boolean);
      if (!observerUids.length) return next;

      next.factionHints = next.factionHints || {};
      for (const observerUid of observerUids){
        const observerRoleId = safeText(cur?.hands?.[observerUid]?.roleId || "");
        const observerFaction = safeText(ROLE_BY_ID?.[observerRoleId]?.faction || "");
        const samePossible = !!observerFaction && observerFaction === inferredFaction;
        const sameImpossible = !!observerFaction && observerFaction !== inferredFaction;
        next.factionHints[observerUid] = next.factionHints[observerUid] || {};
        const prev = next.factionHints[observerUid][actor] || {};
        next.factionHints[observerUid][actor] = {
          ...prev,
          possibleFactions: [inferredFaction],
          samePossible,
          sameImpossible,
          sameConfirmed: samePossible,
          enemyCertain: !!observerFaction && isRivalFactionPair(observerFaction, inferredFaction),
          confirmedFaction: inferredFaction,
          confirmedBy: safeText(reason || (rel === "same" ? "revealed_target_same" : "revealed_target_enemy")),
          at: Date.now()
        };
      }
      return next;
    });

    for (const observerUid of observerUidsForLog){
      const observerFaction = safeText(roleInfoByUid(observerUid)?.faction || "");
      if (!observerFaction) continue;
      const prevHint = prevHintsMap?.[observerUid]?.[actor] || null;
      const nextHint = {
        ...(prevHint || {}),
        possibleFactions: [inferredFaction],
        samePossible: observerFaction === inferredFaction,
        sameImpossible: observerFaction !== inferredFaction,
        sameConfirmed: observerFaction === inferredFaction,
        enemyCertain: isRivalFactionPair(observerFaction, inferredFaction),
        confirmedFaction: inferredFaction,
        confirmedBy: safeText(reason || (rel === "same" ? "revealed_target_same" : "revealed_target_enemy")),
        at: Date.now()
      };
      appendFactionInferenceChangeLog(observerUid, actor, prevHint, nextHint);
    }
  }

  async function recordNpcFactionCertaintyFromRevealedAttack(attackerUid, targetUid){
    await recordFactionRelationInferenceFromRevealedTarget(attackerUid, targetUid, "enemy", "attack_revealed_faction");
  }

  function chooseNpcAttackTarget(attackerUid, candidateUids){
    const attacker = safeText(attackerUid || "");
    const candidates = [...new Set((candidateUids || []).map(v => safeText(v)).filter(Boolean))];
    if (!attacker || !candidates.length) return "";
    const attackerFaction = safeText(roleInfoByUid(attacker)?.faction || "");
    const intel = state.room?.npcIntel || {};
    const hints = intel?.factionHints?.[attacker] || {};
    const attackedMap = intel?.attackedByUid?.[attacker] || {};
    const revealedEnemies = candidates.filter((uid) => {
      const f = revealedFactionForUid(uid);
      return !!f && isRivalFactionPair(attackerFaction, f);
    });
    if (revealedEnemies.length){
      return revealedEnemies.sort((a,b) => clampDamage(damageCache?.[b]) - clampDamage(damageCache?.[a]))[0] || "";
    }

    let pool = candidates.filter((uid) => {
      const f = revealedFactionForUid(uid);
      if (!f) return true;
      if (attackerFaction !== "シチズン" && f === attackerFaction) return false;
      return true;
    });
    if (!pool.length) return "";

    if (attackerFaction !== "シチズン"){
      const allyRevealedAttackTargets = latestPlayers
        .filter((p) => p.id !== attacker && !isPlayerEliminated(p.id))
        .filter((p) => revealedFactionForUid(p.id) === attackerFaction)
        .map((p) => safeText(intel?.lastAttackTargetByUid?.[p.id]?.targetUid || ""))
        .filter((uid) => pool.includes(uid));
      if (allyRevealedAttackTargets.length){
        return allyRevealedAttackTargets.sort((a,b) => clampDamage(damageCache?.[b]) - clampDamage(damageCache?.[a]))[0] || "";
      }
    }

    if (attackerFaction !== "シチズン"){
      const certainEnemy = pool.filter((uid) => npcEnemyLikelihoodByIntel(attacker, uid) >= 0.9 || !!hints?.[uid]?.sameImpossible || !!hints?.[uid]?.enemyCertain);
      if (certainEnemy.length){
        return certainEnemy.sort((a,b) => clampDamage(damageCache?.[b]) - clampDamage(damageCache?.[a]))[0] || "";
      }
      const likelyPool = pool
        .map((uid) => ({ uid, likelihood:npcEnemyLikelihoodByIntel(attacker, uid), attacked:Number(attackedMap?.[uid] || 0), damage:clampDamage(damageCache?.[uid]) }))
        .filter((row) => row.likelihood >= 0.5)
        .sort((a,b) => (b.likelihood - a.likelihood) || (b.damage - a.damage) || (b.attacked - a.attacked));
      if (likelyPool.length) return safeText(likelyPool[0]?.uid || "");
      pool = pool.filter((uid) => !hints?.[uid]?.samePossible);
      if (!pool.length) return "";
    }

    const attackedBefore = pool.filter((uid) => Number(attackedMap?.[uid] || 0) > 0);
    if (attackedBefore.length){
      return attackedBefore.sort((a,b) => Number(attackedMap?.[b] || 0) - Number(attackedMap?.[a] || 0))[0] || "";
    }
    return pool[Math.floor(Math.random() * pool.length)] || "";
  }

  function isNpcCertainShadowByIntel(attackerUid, targetUid){
    const a = safeText(attackerUid || "");
    const t = safeText(targetUid || "");
    if (!a || !t) return false;
    const attackerFaction = safeText(roleInfoByUid(a)?.faction || "");
    if (attackerFaction !== "レイダー") return false;
    const hint = state.room?.npcIntel?.factionHints?.[a]?.[t] || null;
    return !!hint?.sameImpossible;
  }

  function isNpcCertainNotSameFactionByIntel(observerUid, targetUid){
    const o = safeText(observerUid || "");
    const t = safeText(targetUid || "");
    if (!o || !t) return false;
    const hint = state.room?.npcIntel?.factionHints?.[o]?.[t] || null;
    return !!hint?.sameImpossible;
  }

  function npcRoleAbilityUsedByUid(roleId, uid){
    const rid = safeText(roleId || "");
    const actorUid = safeText(uid || "");
    const spec = roleSelectionSpec(rid);
    if (!spec || !actorUid) return false;
    const value = state.room?.abilityUsage?.[spec.usageKey]?.[actorUid];
    if (spec.perTurn){
      return safeText(value || "") === currentTurnKey();
    }
    return !!value;
  }

  async function markNpcRoleAbilityUsed(roleId, uid){
    const rid = safeText(roleId || "");
    const actorUid = safeText(uid || "");
    const spec = roleSelectionSpec(rid);
    if (!spec || !state.roomCode || !actorUid) return;
    const value = spec.perTurn ? currentTurnKey() : true;
    await set(ref(db, `rooms/${state.roomCode}/abilityUsage/${spec.usageKey}/${actorUid}`), value);
  }

  function npcKnownEnemyTarget(actorUid, { rivalFaction = "", threshold = 0.9, roomId = 0, includeRevealedOnly = false } = {}){
    const actor = safeText(actorUid || "");
    if (!actor) return "";
    const role = roleInfoByUid(actor);
    const myFaction = safeText(role?.faction || "");
    const enemyFaction = safeText(rivalFaction || (myFaction === "レイダー" ? "シャドウ" : myFaction === "シャドウ" ? "レイダー" : ""));
    const pool = latestPlayers
      .filter((p) => p.id !== actor)
      .filter((p) => !isPlayerEliminated(p.id))
      .filter((p) => !roomId || markerRoomId(markerCache?.[p.id]) === Number(roomId));
    if (!pool.length) return "";

    const revealed = pool
      .filter((p) => revealedFactionForUid(p.id) === enemyFaction)
      .sort((a,b) => clampDamage(damageCache?.[b.id]) - clampDamage(damageCache?.[a.id]));
    if (revealed.length) return safeText(revealed[0]?.id || "");
    if (includeRevealedOnly) return "";

    const likely = pool
      .map((p) => ({ uid:p.id, likelihood:npcEnemyLikelihoodByIntel(actor, p.id) }))
      .filter((row) => row.likelihood >= Math.max(0.1, Number(threshold) || 0.9))
      .sort((a,b) => b.likelihood - a.likelihood);
    return safeText(likely[0]?.uid || "");
  }

  async function npcPerformAttackRoll(attackerUid, targetUid){
    const actor = safeText(attackerUid || "");
    const target = safeText(targetUid || "");
    if (!actor || !target || !state.roomCode) return { hit:false, damage:0, d6:0, d4:0 };
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const d6 = 1 + Math.floor(Math.random() * 6);
    const d4 = 1 + Math.floor(Math.random() * 4);
    const motion = createDiceMotion(window.innerWidth, window.innerHeight, centerX, centerY);
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/attack`), {
      uid: actor,
      targetUid: target,
      gatlingTargetUids:[],
      x: centerX,
      y: centerY,
      d6,
      d4,
      masamuneMode:false,
      vendettaMode:false,
      motion,
      at: Date.now()
    });
    await waitMs(900);
    const hit = didAttackRollSucceed(d6, d4, { masamuneMode:false, vendettaMode:false });
    await waitMs(NPC_TURN_PACING.attackAfterMs);
    let damage = 0;
    if (hit){
      damage = calcAttackDamageFromRoll(actor, d6, d4, { targetUid:target });
      if (damage > 0) await addDamageToPlayer(target, damage, { source:"attack", actorUid: actor, skipActionLog:true });
    }
    appendActionChatLog(actor, `攻撃ロール：ダメージ${Math.max(0,damage)} (6d${d6},4d${d4})>${displayNameRoleForUid(target)} (${currentDamageForUid(target)})`).catch(() => {});
    await recordNpcAttackTarget(actor, target);
    return { hit, damage, d6, d4 };
  }

  async function resolveNpcCounterPromptsIfNeeded(){
    if (!state.isHost || !state.roomCode || !state.room?.computerMode) return;
    const map = state.room?.counterPromptState || {};
    const entries = Object.entries(map)
      .map(([uid, entry]) => ({ uid: safeText(uid), entry }))
      .filter((row) => row.uid && isNpcPlayerUid(row.uid) && !!row.entry);
    if (!entries.length) return;

    for (const row of entries){
      const uid = row.uid;
      const entry = row.entry || {};
      const roleId = safeText(entry.roleId || "");
      const attackerUid = safeText(entry.attackerUid || "");

      if (roleId === "SHA_W3"){
        const attackerFaction = safeText(roleInfoByUid(attackerUid)?.faction || "");
        const attackerIsRevealedRaider = !!attackerUid && isIdentityRevealedFor(attackerUid) && attackerFaction === "レイダー";
        const attackerLikelyEnemy = npcEnemyLikelihoodByIntel(uid, attackerUid) >= 0.75 || isNpcCertainNotSameFactionByIntel(uid, attackerUid);
        const blockedByGuardian = hasGuardianAngelShield(attackerUid);
        const blockedByGordon = hasGordonBarrier(attackerUid);
        if (!attackerUid || blockedByGuardian || blockedByGordon || (!attackerIsRevealedRaider && !attackerLikelyEnemy)){
          await remove(ref(db, `rooms/${state.roomCode}/counterPromptState/${uid}`)).catch(() => {});
          continue;
        }
        await npcAnnounceAbilityUse(uid, "反撃", attackerUid);
        await runWerewolfCounterAttackForUid(uid, attackerUid);
        await remove(ref(db, `rooms/${state.roomCode}/counterPromptState/${uid}`)).catch(() => {});
        continue;
      }

      if (roleId === "SHA_V1" && safeText(entry.mode || "") !== "venom_resolution"){
        const attackerRole = roleInfoByUid(attackerUid);
        const attackerIsRevealedRaider = !!attackerUid
          && isIdentityRevealedFor(attackerUid)
          && safeText(attackerRole?.faction || "") === "レイダー";
        const attackerIsCertainEnemy = isNpcCertainNotSameFactionByIntel(uid, attackerUid)
          || npcEnemyLikelihoodByIntel(uid, attackerUid) >= 0.75;
        const shouldUseVenom = attackerIsRevealedRaider || attackerIsCertainEnemy;

        if (!shouldUseVenom){
          await remove(ref(db, `rooms/${state.roomCode}/counterPromptState/${uid}`)).catch(() => {});
          continue;
        }

        await npcAnnounceAbilityUse(uid, "反駁の猛毒", attackerUid);
        await revealIdentityToEquipmentForUid(uid);
        const roomRef = ref(db, `rooms/${state.roomCode}`);
        await runTransaction(roomRef, (cur) => {
          if (!cur) return cur;
          const map = cur.counterPromptState || {};
          const mine = map[uid];
          if (!mine || Number(mine.at || 0) !== Number(entry.at || 0)) return cur;
          delete map[uid];
          map[safeText(entry.attackerUid || "")] = {
            uid: safeText(entry.attackerUid || ""),
            roleId: "SHA_V1",
            attackerUid: safeText(entry.attackerUid || ""),
            venomUid: uid,
            turnKey: safeText(entry.turnKey || ""),
            advanceTurnOnResolve: !!entry.advanceTurnOnResolve,
            mustChoose: true,
            mode: "venom_resolution",
            expiresAt: 0,
            at: Date.now()
          };
          cur.counterPromptState = map;
          return cur;
        });
        continue;
      }

      if (roleId === "SHA_V1" && safeText(entry.mode || "") === "venom_resolution"){
        const venomUid = safeText(entry.venomUid || "");
        if (!venomUid) continue;
        const role = roleInfoByUid(uid);
        const hp = Number(role?.hp || 0);
        const curDamage = clampDamage(damageCache?.[uid]);
        const hasEquip = hasAnyEquipment(uid);
        const damageNonLethal = hp > 0 ? (curDamage + 1 < hp) : true;
        const shouldDamage = (!hasEquip) || damageNonLethal;

        if (shouldDamage){
          await resolveVenomCounterChoiceForUid(uid, "damage");
        } else {
          const items = listEquipForUid(uid).filter(it => !isIdentityEquipItem(it));
          const choice = items[Math.floor(Math.random() * items.length)] || null;
          const sourceKey = safeText(choice?.sourceKey || "");
          if (!sourceKey){
            await resolveVenomCounterChoiceForUid(uid, "damage");
            continue;
          }
          await resolveVenomCounterChoiceForUid(uid, "give", sourceKey);
          const venomName = safeText(playerById(venomUid)?.name || "プレイヤー");
          const cardName = safeText(choice?.name || "装備");
          await showNpcSpeech(uid, `${venomName}さんに${cardName}をあげますよ...`, 1600);
        }
      }
    }
  }

  async function applyNpcImmediateDeckCardEffect(uid, cardObj, theme){
    const name = safeText(cardObj?.name || "");
    if (!uid || !name) return;
    const role = roleInfoByUid(uid);
    const chooseYes = npcYesNoByDamage(uid);

    if (name === "応急手当"){
      const targetUid = chooseNpcTargetForCard(uid, { purpose:"first_aid", includeSelf:true });
      if (!targetUid) return;
      await npcAnnounceSelectedPlayer(uid, targetUid);
      await setDamageToPlayer(targetUid, 7, "first_aid_set", { actorUid:uid });
      return;
    }
    if (name === "恩恵"){
      const targetUid = chooseNpcTargetForCard(uid, { purpose:"heal", includeSelf:false });
      if (!targetUid) return;
      await npcAnnounceSelectedPlayer(uid, targetUid);
      const eye = 1 + Math.floor(Math.random() * 6);
      await emitCardDiceEvent({ kind:"blessing", uid, d6:eye });
      await healDamageToPlayer(targetUid, eye, "card_blessing_heal", { actorUid:uid, skipActionLog:true });
      appendActionChatLog(uid, `[恩恵] (6d${eye}) ${actionDeltaText(-eye)}>${actionTargetWithDamage(targetUid, -eye)}`).catch(() => {});
      return;
    }
    if (name === "吸血コウモリ"){
      const targetUid = chooseNpcTargetForCard(uid, { purpose:"attack", includeSelf:false });
      if (!targetUid) return;
      await npcAnnounceSelectedPlayer(uid, targetUid);
      await recordFactionRelationInferenceFromRevealedTarget(uid, targetUid, "enemy", "card_attack_target_revealed");
      let dmg = 0;
      if (!hasEquipmentByName(targetUid, "いにしえの聖杯")){
        dmg = 2;
        await addDamageToPlayer(targetUid, 2, { actorUid:uid, skipActionLog:true });
      }
      await healDamageToPlayer(uid, 1, "card_vampire_bat_heal", { actorUid:uid, skipActionLog:true });
      appendActionChatLog(uid, `[吸血コウモリ] ${actionDeltaText(-1)}>${actionTargetWithDamage(uid, -1)}, ${actionDeltaText(dmg)}>${actionTargetWithDamage(targetUid, dmg)}`).catch(() => {});
      return;
    }
    if (name === "三つ目の黒犬"){
      const targetUid = chooseNpcTargetForCard(uid, { purpose:"attack", includeSelf:false });
      if (!targetUid) return;
      await npcAnnounceSelectedPlayer(uid, targetUid);
      await recordFactionRelationInferenceFromRevealedTarget(uid, targetUid, "enemy", "card_attack_target_revealed");
      if (!hasEquipmentByName(targetUid, "いにしえの聖杯")) await addDamageToPlayer(targetUid, 2, { actorUid:uid });
      if (!hasEquipmentByName(uid, "いにしえの聖杯")) await addDamageToPlayer(uid, 2, { actorUid:uid });
      return;
    }
    if (name === "呪いの人形"){
      const targetUid = chooseNpcTargetForCard(uid, { purpose:"attack", includeSelf:true });
      if (!targetUid) return;
      await npcAnnounceSelectedPlayer(uid, targetUid);
      await recordFactionRelationInferenceFromRevealedTarget(uid, targetUid, "enemy", "card_attack_target_revealed");
      const eye = 1 + Math.floor(Math.random() * 6);
      await emitCardDiceEvent({ kind:"curse_doll", uid, d6:eye });
      if (eye <= 4){
        if (!hasEquipmentByName(targetUid, "いにしえの聖杯")) await addDamageToPlayer(targetUid, 3, { actorUid:uid });
      } else if (!hasEquipmentByName(uid, "いにしえの聖杯")){
        await addDamageToPlayer(uid, 3, { actorUid:state.userId });
      }
      return;
    }
    if (name === "光臨"){
      const canChooseYes = role?.faction === "レイダー";
      if (canChooseYes && chooseYes){
        await revealIdentityToEquipmentForUid(uid);
        await setDamageToPlayer(uid, 0, "card_kohrin_heal", { actorUid:uid });
      }
      return;
    }
    if (name === "戦慄の闇儀式"){
      const canChooseYes = role?.faction === "シャドウ";
      if (canChooseYes && chooseYes){
        await revealIdentityToEquipmentForUid(uid);
        await setDamageToPlayer(uid, 0, "card_kohrin_heal", { actorUid:uid });
      }
      return;
    }
    if (name === "幸せのクッキー"){
      const canChooseYes = (role?.initial === "A" || role?.initial === "U");
      if (canChooseYes && chooseYes){
        await revealIdentityToEquipmentForUid(uid, identityPromptRevealOptions(name));
        await setDamageToPlayer(uid, 0, "card_kohrin_heal", { actorUid:uid });
      }
      return;
    }
    if (name === "闇を祓う鏡"){
      if (role?.faction === "シャドウ" && role?.name !== "ウルリッヒ"){
        await revealIdentityToEquipmentForUid(uid);
      }
      return;
    }
    if (name === "いやしの聖水"){
      await healDamageToPlayer(uid, 2, "card_holy_water_heal", { actorUid:uid });
      return;
    }
    if (name === "裁きの閃光"){
      await addDamageToAllOtherPlayers(uid, 2);
      return;
    }
    if (name === "人魚の涙"){
      const topUids = maxDamageAlivePlayerIds();
      for (const targetUid of topUids){
        await healDamageToPlayer(targetUid, 3, "card_mermaid_tears_heal", { actorUid:uid });
      }
      return;
    }
    if (name === "封印の知恵"){
      const turn = turnState();
      if (safeText(turn?.currentPlayerId || "") === uid){
        await update(ref(db, `rooms/${state.roomCode}/turn`), {
          repeatTurnRemaining: 1,
          repeatTurnTotal: 1,
          sealWisdomBonus: true,
          updatedAt: Date.now()
        });
      }
      return;
    }
    if (name === "守護天使"){
      await enableGuardianAngelShieldForPlayer(uid);
      return;
    }
    if (name === "暴動"){
      const rolled = { d6: 1 + Math.floor(Math.random() * 6), d4: 1 + Math.floor(Math.random() * 4) };
      await emitCardDiceEvent({ kind:"riot", uid, d6: rolled.d6, d4: rolled.d4 });
      const targetRoomId = diceTotalToRoomId(Number(rolled?.d6 || 0) + Number(rolled?.d4 || 0));
      await addDamageToPlayers(playerIdsInRoom(targetRoomId), 3);
      return;
    }
    if (name === "オリバーの子分"){
      const stolen = await npcStealRandomEquipment(uid);
      if (stolen?.ownerUid){
        const ownerName = safeText(playerById(stolen.ownerUid)?.name || "プレイヤー");
        const cardName = safeText(stolen.cardName || "装備");
        await showNpcSpeech(uid, `${ownerName}さんから${cardName}をもらいます！`, 1500);
      }
      return;
    }
    if (name === "バナナの皮"){
      const myItems = listEquipForUid(uid).filter(it => !isIdentityEquipItem(it));
      if (myItems.length === 0){
        await addDamageToPlayer(uid, 1);
        return;
      }
      const aliveOthers = latestPlayers
        .filter((p) => p.id !== uid)
        .filter((p) => !isPlayerEliminated(p.id))
        .map((p) => p.id);
      const friendPool = aliveOthers.filter((targetUid) => npcEnemyLikelihoodByIntel(uid, targetUid) < 0.5);
      const sourcePool = friendPool.length ? friendPool : aliveOthers;
      const targetUid = sourcePool[Math.floor(Math.random() * sourcePool.length)] || "";
      if (!targetUid) return;
      const choice = myItems[Math.floor(Math.random() * myItems.length)] || null;
      const sourceKey = safeText(choice?.sourceKey || "");
      if (!sourceKey) return;
      const ok = await moveEquipmentCardBetweenPlayers(uid, targetUid, sourceKey);
      if (!ok) return;
      await recordFactionRelationInferenceFromRevealedTarget(uid, targetUid, "same", "banana_give_target_revealed");
      const targetName = safeText(playerById(targetUid)?.name || "プレイヤー");
      const cardName = safeText(choice?.name || "装備");
      await showNpcSpeech(uid, `${targetName}さんに${cardName}をあげますよ...`, 1600);
      return;
    }
  }

  async function handleNpcGreenRoom5(senderUid, cardObj){
    if (!state.roomCode || !cardObj) return;
    const aliveOthers = latestPlayers.filter(p => p.id !== senderUid && !isPlayerEliminated(p.id));
    if (!aliveOthers.length) return;
    const inRange = [...attackRangeTargetUidsFor(senderUid)].filter(uid => uid !== senderUid && !isPlayerEliminated(uid));
    const pool = inRange.length ? inRange : aliveOthers.map(p => p.id);
    const targetUid = pool[Math.floor(Math.random() * pool.length)];
    if (!targetUid) return;
    await npcAnnounceSelectedPlayer(senderUid, targetUid);

    const requestId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
    const payload = { from: senderUid, to: targetUid, requestId, card: cardObj, at: Date.now() };
    await set(ref(db, `rooms/${state.roomCode}/greenRequests/${requestId}`), payload);
    await set(ref(db, `rooms/${state.roomCode}/greenInbox/${targetUid}`), payload);

    if (!isNpcPlayerUid(targetUid)){
      const waitStart = Date.now();
      while (Date.now() - waitStart < 25000){
        const snap = await get(ref(db, `rooms/${state.roomCode}/greenResponses/${senderUid}`));
        const row = snap.val() || null;
        if (safeText(row?.requestId || "") === requestId){
          await recordNpcFactionInference(senderUid, targetUid, cardObj, safeText(row?.answerId || ""), safeText(row?.roleId || ""));
          await waitMs(500);
          await Promise.all([
            remove(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${requestId}`)).catch(() => {}),
            remove(ref(db, `rooms/${state.roomCode}/greenRequests/${requestId}`)).catch(() => {}),
            remove(ref(db, `rooms/${state.roomCode}/greenResponses/${senderUid}`)).catch(() => {})
          ]);
          return;
        }
        await waitMs(300);
      }
      return;
    }

    const npcRes = await resolveNpcGreenInboxPayload(payload);
    await recordNpcFactionInference(senderUid, targetUid, cardObj, safeText(npcRes?.answerId || ""), safeText(npcRes?.roleId || ""));
    await waitMs(500);
    await Promise.all([
      remove(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${requestId}`)).catch(() => {}),
      remove(ref(db, `rooms/${state.roomCode}/greenRequests/${requestId}`)).catch(() => {}),
      remove(ref(db, `rooms/${state.roomCode}/greenResponses/${senderUid}`)).catch(() => {})
    ]);
  }

  async function handleNpcGreenRequestToTarget(senderUid, targetUid, cardObj){
    const fromUid = safeText(senderUid || "");
    const toUid = safeText(targetUid || "");
    if (!state.roomCode || !fromUid || !toUid || !cardObj) return;
    await npcAnnounceSelectedPlayer(fromUid, toUid);
    const requestId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
    const payload = { from: fromUid, to: toUid, requestId, card: cardObj, at: Date.now() };
    await set(ref(db, `rooms/${state.roomCode}/greenRequests/${requestId}`), payload);
    await set(ref(db, `rooms/${state.roomCode}/greenInbox/${toUid}`), payload);

    if (!isNpcPlayerUid(toUid)){
      const waitStart = Date.now();
      while (Date.now() - waitStart < 25000){
        const snap = await get(ref(db, `rooms/${state.roomCode}/greenResponses/${fromUid}`));
        const row = snap.val() || null;
        if (safeText(row?.requestId || "") === requestId){
          await recordNpcFactionInference(fromUid, toUid, cardObj, safeText(row?.answerId || ""), safeText(row?.roleId || ""));
          break;
        }
        await waitMs(300);
      }
    } else {
      const npcRes = await resolveNpcGreenInboxPayload(payload);
      await recordNpcFactionInference(fromUid, toUid, cardObj, safeText(npcRes?.answerId || ""), safeText(npcRes?.roleId || ""));
    }

    await waitMs(500);
    await Promise.all([
      remove(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${requestId}`)).catch(() => {}),
      remove(ref(db, `rooms/${state.roomCode}/greenRequests/${requestId}`)).catch(() => {}),
      remove(ref(db, `rooms/${state.roomCode}/greenResponses/${fromUid}`)).catch(() => {})
    ]);
  }

  async function npcUseParasolGreenOnTarget(senderUid, targetUid){
    const fromUid = safeText(senderUid || "");
    const toUid = safeText(targetUid || "");
    if (!state.roomCode || !fromUid || !toUid) return false;
    let drawn = null;
    await runTransaction(ref(db, `rooms/${state.roomCode}`), (cur) => {
      if (!cur) return cur;
      const deck = cur.deckState?.green;
      if (!deck || !Array.isArray(deck.order)) return cur;
      const idx = Number(deck.idx || 0);
      if (idx >= deck.order.length) return cur;
      drawn = deck.order[idx];
      deck.idx = idx + 1;
      cur.deckState.updatedAt = Date.now();
      return cur;
    });
    if (!drawn) return false;
    await handleNpcGreenRequestToTarget(fromUid, toUid, drawn);
    return true;
  }

  async function npcDrawFromRoom(uid, roomId){
    const types = allowedTypesByRoom(roomId);
    if (!types.length || !state.roomCode) return;
    let drawType = types[0];
    if (roomId === 6){
      drawType = types[Math.floor(Math.random() * types.length)] || "white";
    } else if (roomId === 1){
      drawType = "white";
    } else if (roomId === 2){
      drawType = "black";
    } else if (roomId === 5){
      drawType = "green";
    }
    let drawn = null;
    await runTransaction(ref(db, `rooms/${state.roomCode}`), (cur) => {
      if (!cur) return cur;
      const deck = cur.deckState?.[drawType];
      if (!deck || !Array.isArray(deck.order)) return cur;
      const idx = Number(deck.idx || 0);
      if (idx >= deck.order.length) return cur;
      drawn = deck.order[idx];
      deck.idx = idx + 1;
      cur.deckState.reveal = cur.deckState.reveal || { slot3:null, slot5:null };
      if (drawType === "white"){
        cur.deckState.reveal.slot3 = { theme:"white", card: drawn, at: Date.now() };
      } else if (drawType === "black"){
        cur.deckState.reveal.slot5 = { theme:"black", card: drawn, at: Date.now() };
      }
      cur.deckState.updatedAt = Date.now();
      return cur;
    });
    if (drawn && (drawType === "white" || drawType === "black")){
      await showNpcSpeech(uid, `${safeText(drawn?.name || "カード")}を引きました！`, 1200);
      const granted = await grantEquipmentToPlayer(uid, drawn, drawType);
      if (!granted){
        await applyNpcImmediateDeckCardEffect(uid, drawn, drawType);
      }
    } else if (drawn && drawType === "green"){
      await handleNpcGreenRoom5(uid, drawn);
    }
  }

  async function npcStealRandomEquipment(uid){
    const actor = safeText(uid || "");
    const others = latestPlayers
      .filter((p) => p.id !== actor)
      .map((p) => ({ uid:p.id, cards:listEquipForUid(p.id).filter((it) => !isIdentityEquipItem(it)) }))
      .filter((row) => row.cards.length > 0);
    if (!others.length || !state.roomCode) return null;
    const enemyPool = others.filter((row) => npcEnemyLikelihoodByIntel(actor, row.uid) >= 0.5);
    const sourcePool = enemyPool.length ? enemyPool : others;
    const target = sourcePool[Math.floor(Math.random() * sourcePool.length)];
    const card = target.cards[Math.floor(Math.random() * target.cards.length)];
    if (!card?.sourceKey) return null;
    let stolenName = safeText(card?.name || "装備");
    await runTransaction(ref(db, `rooms/${state.roomCode}`), (cur) => {
      if (!cur) return cur;
      const item = cur?.equipment?.[target.uid]?.[card.sourceKey];
      if (!item || safeText(item.kind || "") === "identity") return cur;
      stolenName = safeText(item?.name || stolenName || "装備");
      cur.equipment = cur.equipment || {};
      cur.equipment[target.uid] = cur.equipment[target.uid] || {};
      delete cur.equipment[target.uid][card.sourceKey];
      cur.equipment[actor] = cur.equipment[actor] || {};
      const nextKey = `${Date.now()}_${Math.random().toString(16).slice(2,8)}`;
      cur.equipment[actor][nextKey] = { ...item, at: Date.now() };
      return cur;
    });
    return { ownerUid:target.uid, cardName:stolenName };
  }

  async function executeNpcRoomAction(uid, roomId){
    const rid = Number(roomId || 0);
    if ([1,2,5,6].includes(rid)){
      await npcDrawFromRoom(uid, rid);
      return;
    }
    if (rid === 4){
      const stolen = await npcStealRandomEquipment(uid);
      if (stolen?.ownerUid){
        const ownerName = safeText(playerById(stolen.ownerUid)?.name || "プレイヤー");
        const cardName = safeText(stolen.cardName || "装備");
        await showNpcSpeech(uid, `${ownerName}さんから${cardName}をもらいます！`, 1500);
      }
      return;
    }
    if (rid === 3){
      const attackableTargets = latestPlayers.filter((p) => {
        if (p.id === uid || isPlayerEliminated(p.id)) return false;
        if (hasGuardianAngelShield(p.id)) return false;
        if (hasGordonBarrier(p.id)) return false;
        if (hasEquipmentByName(p.id, "幸運のブローチ")) return false;
        return true;
      });
      const enemyPriorityTargets = attackableTargets
        .map((p) => ({
          uid: p.id,
          likelihood: npcEnemyLikelihoodByIntel(uid, p.id),
          damage: clampDamage(damageCache?.[p.id])
        }))
        .filter((row) => row.likelihood >= 0.5)
        .sort((a,b) => (b.likelihood - a.likelihood) || (b.damage - a.damage));
      if (enemyPriorityTargets.length){
        const targetUid = safeText(enemyPriorityTargets[0]?.uid || "");
        if (!targetUid) return;
        const targetName = safeText(playerById(targetUid)?.name || "プレイヤー");
        await showNpcSpeech(uid, `${targetName}さんに2ダメージ！`, 1500);
        await recordFactionRelationInferenceFromRevealedTarget(uid, targetUid, "enemy", "room3_damage_target_revealed");
        await addDamageToPlayer(targetUid, 2, { source:"room3", actorUid:uid, skipActionLog:true });
        appendActionChatLog(uid, `市庁舎 ${actionDeltaText(2)}>${actionTargetWithDamage(targetUid, 2)}`).catch(() => {});
        await recordNpcAttackTarget(uid, targetUid);
        return;
      }

      const myDamage = clampDamage(damageCache?.[uid]);
      if (myDamage > 0){
        await showNpcSpeech(uid, "1回復します！", 1500);
        await healDamageToPlayer(uid, 1, "room3_heal", { actorUid:uid, skipActionLog:true });
        appendActionChatLog(uid, `市庁舎 ${actionDeltaText(-1)}>${actionTargetWithDamage(uid, -1)}`).catch(() => {});
        return;
      }

      const healableAllies = latestPlayers
        .filter((p) => p.id !== uid && !isPlayerEliminated(p.id))
        .map((p) => ({ uid:p.id, dmg:clampDamage(damageCache?.[p.id]), likelihood:npcEnemyLikelihoodByIntel(uid, p.id), revealed:revealedFactionForUid(p.id) }))
        .filter((row) => row.dmg > 0)
        .filter((row) => row.likelihood < 0.5)
        .sort((a,b) => b.dmg - a.dmg);
      if (!healableAllies.length) return;

      const myFaction = safeText(roleInfoByUid(uid)?.faction || "");
      const revealedFriend = healableAllies.filter((row) => row.revealed && row.revealed === myFaction);
      const healTargetUid = (revealedFriend.length && Math.random() < 0.2)
        ? safeText(revealedFriend[0]?.uid || "")
        : safeText(healableAllies[0]?.uid || "");
      if (!healTargetUid) return;
      const targetName = safeText(playerById(healTargetUid)?.name || "プレイヤー");
      await showNpcSpeech(uid, `${targetName}を1回復！`, 1500);
      await recordFactionRelationInferenceFromRevealedTarget(uid, healTargetUid, "same", "room3_heal_target_revealed");
      await healDamageToPlayer(healTargetUid, 1, "room3_heal", { actorUid:uid, skipActionLog:true });
      appendActionChatLog(uid, `市庁舎 ${actionDeltaText(-1)}>${actionTargetWithDamage(healTargetUid, -1)}`).catch(() => {});
    }
  }

  let npcAutoTurnRunning = false;
  let npcAutoTurnKey = "";
  let npcAutoTurnRetryTimer = null;

  function scheduleNpcTurnRetry(delayMs = 80){
    if (npcAutoTurnRetryTimer){
      clearTimeout(npcAutoTurnRetryTimer);
    }
    npcAutoTurnRetryTimer = setTimeout(() => {
      npcAutoTurnRetryTimer = null;
      runNpcTurnIfNeeded();
    }, Math.max(10, Number(delayMs || 80)));
  }

  async function runNpcTurnIfNeeded(){
    if (npcAutoTurnRunning) return;
    if (!state.isHost || !isGameStarted() || !state.roomCode) return;
    if (!state.room?.computerMode) return;
    const turnUid = currentTurnPlayerId();
    const turnKey = turnCycleKey();
    if (!turnUid || !turnKey || !isNpcPlayerUid(turnUid)) return;
    if (turnKey === npcAutoTurnKey) return;
    npcAutoTurnKey = turnKey;
    npcAutoTurnRunning = true;
    try {
      await waitMs(NPC_TURN_PACING.turnStartDelayMs);
      if (turnCycleKey() !== turnKey) return;
      const turnRoleId = safeText(roleIdForUid(turnUid) || "");

      if (["RAI_E2","RAI_F1","RAI_F2"].includes(turnRoleId) && !npcRoleAbilityUsedByUid(turnRoleId, turnUid) && !isAbilitySealedForPlayer(turnUid, turnRoleId)){
        const certainShadowUid = npcKnownEnemyTarget(turnUid, { rivalFaction:"シャドウ", threshold:0.75 });
        if (certainShadowUid){
          await revealIdentityToEquipmentForUid(turnUid, { revealedBy:"npc_start_role" });
          if (turnRoleId === "RAI_E2"){
            await npcAnnounceAbilityUse(turnUid, "封印の鎖", certainShadowUid);
            await set(ref(db, `rooms/${state.roomCode}/erikaSealedTargets/${certainShadowUid}`), true);
          } else if (turnRoleId === "RAI_F1"){
            const eye = 1 + Math.floor(Math.random() * 6);
            await emitCardDiceEvent({ kind:"role_felix", uid: turnUid, d6: eye });
            await waitMs(1000);
            await addDamageToPlayer(certainShadowUid, eye, { actorUid:turnUid, skipActionLog:true });
            await npcAnnounceAbilityUse(turnUid, "アストラル・メイス", certainShadowUid, { delta:eye, useCurrentDamage:true });
          } else if (turnRoleId === "RAI_F2"){
            await npcAnnounceAbilityUse(turnUid, "スラム街の天使", certainShadowUid);
            await setDamageToPlayer(certainShadowUid, 7, "felicia_set");
          }
          await markNpcRoleAbilityUsed(turnRoleId, turnUid);
        }
      }

      if (turnRoleId === "SHA_U2" && !npcRoleAbilityUsedByUid("SHA_U2", turnUid) && !isAbilitySealedForPlayer(turnUid, "SHA_U2")){
        const meteorTarget = latestPlayers
          .filter((p) => p.id !== turnUid && !isPlayerEliminated(p.id))
          .filter((p) => [6,7].includes(markerRoomId(markerCache?.[p.id])))
          .filter((p) => !hasGordonBarrier(p.id))
          .map((p) => p.id)
          .find((uid) => {
            const revealed = revealedFactionForUid(uid);
            return revealed === "レイダー" || isNpcCertainNotSameFactionByIntel(turnUid, uid) || npcEnemyLikelihoodByIntel(turnUid, uid) >= 0.9;
          }) || "";
        if (meteorTarget){
          await revealIdentityToEquipmentForUid(turnUid, { revealedBy:"npc_uranus_start" });
          await addDamageToPlayer(meteorTarget, 3, { actorUid:turnUid, skipActionLog:true });
          await npcAnnounceAbilityUse(turnUid, "メテオストライク", meteorTarget, { delta:3, useCurrentDamage:true });
          await markNpcRoleAbilityUsed("SHA_U2", turnUid);
        }
      }

      const currentTurn = turnState() || {};
      if (!currentTurn.moveDone){
        const marker = markerCache?.[turnUid] || null;
        const nowRoom = markerRoomId(marker);
        if (nowRoom === 7){
          const nextRoom = 1 + Math.floor(Math.random() * 6);
          await placePlayerMarkerInRoom(turnUid, nextRoom);
        } else {
          await showNpcSpeech(turnUid, "ふります！", 700);
          const hasCompass = hasEquipmentByName(turnUid, "神秘のコンパス");
          const d6 = 1 + Math.floor(Math.random() * 6);
          const d4 = 1 + Math.floor(Math.random() * 4);
          const secondD6 = 1 + Math.floor(Math.random() * 6);
          const secondD4 = 1 + Math.floor(Math.random() * 4);
          const width = window.innerWidth;
          const height = window.innerHeight;
          const centerX = width / 2;
          const centerY = height / 2;
          const motion = createDiceMotion(width, height, centerX, centerY);
          const secondMotion = hasCompass ? createDiceMotion(width, height, centerX, centerY) : null;
          await set(ref(db, `rooms/${state.roomCode}/diceEvents/move`), {
            uid: turnUid,
            d6,
            d4,
            compass:hasCompass,
            secondD6,
            secondD4,
            motion,
            secondMotion,
            at: Date.now()
          });
          const moveRollText = hasCompass
            ? `移動ロール：合計${d6 + d4} (6d${d6},4d${d4}) / 合計${secondD6 + secondD4} (6d${secondD6},4d${secondD4})`
            : `移動ロール：合計${d6 + d4} (6d${d6},4d${d4})`;
          appendActionChatLog(turnUid, moveRollText).catch(() => {});
          await waitMs(hasCompass ? 3200 : 900);
          await waitMs(NPC_TURN_PACING.diceAfterMs);
          const roomA = diceTotalToRoomId(d6 + d4);
          const roomB = diceTotalToRoomId(secondD6 + secondD4);
          const candidateRooms = hasCompass ? [roomA, roomB].filter((rid) => Number.isFinite(Number(rid))) : [roomA];
          const targetRoomId = candidateRooms[Math.floor(Math.random() * candidateRooms.length)] || roomA;
          if (targetRoomId) await placePlayerMarkerInRoom(turnUid, targetRoomId);
        }
        await update(ref(db, `rooms/${state.roomCode}/turn`), { moveDone:true, moveAt:Date.now() });
      }

      if (turnRoleId === "RAI_E1" && isIdentityRevealedFor(turnUid) && !turnState()?.emiTeleportUsed){
        const inRangeBefore = [...attackRangeTargetUidsFor(turnUid)].filter((uid) => revealedFactionForUid(uid) === "シャドウ" || npcEnemyLikelihoodByIntel(turnUid, uid) >= 0.9);
        if (!inRangeBefore.length){
          const nowRoom = markerRoomId(markerCache?.[turnUid]);
          const adj = adjacentOuterRoomIds(nowRoom);
          for (const rid of adj){
            const targets = latestPlayers
              .filter((p) => p.id !== turnUid && !isPlayerEliminated(p.id))
              .filter((p) => markerRoomId(markerCache?.[p.id]) === Number(rid))
              .map((p) => p.id)
              .filter((uid) => revealedFactionForUid(uid) === "シャドウ" || npcEnemyLikelihoodByIntel(turnUid, uid) >= 0.9);
            if (!targets.length) continue;
            await npcAnnounceAbilityUse(turnUid, "テレポート");
            await emitRoleFlashEvent("RAI_E1", "emi_teleport", 1800);
            await placePlayerMarkerInRoom(turnUid, rid);
            await update(ref(db, `rooms/${state.roomCode}/turn`), { emiTeleportUsed:true, updatedAt:Date.now() });
            break;
          }
        }
      }

      await waitMs(NPC_TURN_PACING.phaseIntervalMs);
      if (turnCycleKey() !== turnKey) return;
      const roomAfterMove = markerRoomId(markerCache?.[turnUid]);
      if (!turnState()?.deckDrawDone){
        await executeNpcRoomAction(turnUid, roomAfterMove);
        await update(ref(db, `rooms/${state.roomCode}/turn`), { deckDrawDone:true });
      }

      await waitMs(NPC_TURN_PACING.phaseIntervalMs);
      if (turnCycleKey() !== turnKey) return;
      if (!turnState()?.attackDone){
        const targets = [...attackRangeTargetUidsFor(turnUid)].filter((uid) => uid !== turnUid && !isPlayerEliminated(uid));
        let targetUid = chooseNpcAttackTarget(turnUid, targets);
        const attackerRole = roleInfoByUid(turnUid);
        const hasMasamune = hasEquipmentByName(turnUid, "妖刀マサムネ");
        const hasParasol = hasEquipmentByName(turnUid, "虹色のパラソル");
        const masamuneOnlySameFaction = (hasMasamune && targets.length === 1 && !!attackerRole && !!targets[0]
          && safeText(roleInfoByUid(targets[0])?.faction || "") === safeText(attackerRole.faction || ""));
        if (masamuneOnlySameFaction){
          targetUid = safeText(targets[0] || "");
          if (hasParasol && targetUid){
            const usedParasol = await npcUseParasolGreenOnTarget(turnUid, targetUid);
            if (usedParasol){
              await update(ref(db, `rooms/${state.roomCode}/turn`), { attackDone:true, attackAt:Date.now() });
              await waitMs(NPC_TURN_PACING.phaseIntervalMs);
              if (turnCycleKey() !== turnKey) return;
              await advanceTurnToNextPlayer(turnUid);
              return;
            }
          }
        }

        if (targetUid){
          const npcRole = roleInfoByUid(turnUid);
          const shouldExcaliburReveal = !!(npcRole?.faction === "レイダー"
            && hasEquipmentByName(turnUid, "エクスカリバー")
            && !isIdentityRevealedFor(turnUid)
            && (revealedFactionForUid(targetUid) === "シャドウ" || isNpcCertainShadowByIntel(turnUid, targetUid)));
          if (shouldExcaliburReveal){
            await revealIdentityToEquipmentForUid(turnUid, { revealedBy:"excalibur_attack" });
          }
          const targetName = safeText(playerById(targetUid)?.name || "");
          await showNpcSpeech(turnUid, `${targetName}さんを攻撃！`, 700);
          const attackRes = await npcPerformAttackRoll(turnUid, targetUid);

          if (!attackRes.hit && turnRoleId === "RAI_G2" && hasEquipmentByName(turnUid, "エクスカリバー")
            && !isAbilitySealedForPlayer(turnUid, "RAI_G2")
            && (revealedFactionForUid(targetUid) === "シャドウ" || npcEnemyLikelihoodByIntel(turnUid, targetUid) >= 0.75)){
            await revealIdentityToEquipmentForUid(turnUid, { revealedBy:"galahad_reroll" });
            await npcAnnounceAbilityUse(turnUid, "魔剣の伝承者", targetUid);
            await npcPerformAttackRoll(turnUid, targetUid);
          }

          if (turnRoleId === "SHA_U3" && !isAbilitySealedForPlayer(turnUid, "SHA_U3") && !isAttackAbilityUsedThisTurn("SHA_U3")
            && (revealedFactionForUid(targetUid) === "レイダー" || isNpcCertainNotSameFactionByIntel(turnUid, targetUid) || npcEnemyLikelihoodByIntel(turnUid, targetUid) >= 0.9)){
            markAttackAbilityUsedThisTurn("SHA_U3");
            await npcAnnounceAbilityUse(turnUid, "デル・フリス");
            const secondPool = [...attackRangeTargetUidsFor(turnUid)]
              .filter((uid) => uid !== turnUid && !isPlayerEliminated(uid));
            const raiderPriority = secondPool.filter((uid) => revealedFactionForUid(uid) === "レイダー" || npcEnemyLikelihoodByIntel(turnUid, uid) >= 0.9);
            const secondTarget = safeText((raiderPriority.length ? raiderPriority : [])[0] || "");
            if (secondTarget){
              await npcPerformAttackRoll(turnUid, secondTarget);
            }
          }

          if (turnRoleId === "SHA_V2" && clampDamage(damageCache?.[turnUid]) >= 5 && attackRes.hit && !isAbilitySealedForPlayer(turnUid, "SHA_V2")){
            await emitRoleFlashEvent("SHA_V2", "vampire_heal");
            await healDamageToPlayer(turnUid, 2, "vampire_role_heal", { actorUid:turnUid, skipActionLog:true });
            await npcAnnounceAbilityUse(turnUid, "吸血", turnUid, { delta:-2, useCurrentDamage:true });
          }
        }
        await update(ref(db, `rooms/${state.roomCode}/turn`), { attackDone:true, attackAt:Date.now() });
      }

      if (turnRoleId === "RAI_E3" && !isAbilitySealedForPlayer(turnUid, "RAI_E3") && !npcRoleAbilityUsedByUid("RAI_E3", turnUid)){
        const actorRoom = markerRoomId(markerCache?.[turnUid]);
        const sameRoom = latestPlayers.filter((p) => p.id !== turnUid && !isPlayerEliminated(p.id) && markerRoomId(markerCache?.[p.id]) === actorRoom);
        const roomHasKnownRaider = sameRoom.some((p) => revealedFactionForUid(p.id) === "レイダー" || npcEnemyLikelihoodByIntel(turnUid, p.id) < 0.25);
        if (roomHasKnownRaider){
          const friend = sameRoom
            .map((p) => ({ uid:p.id, dmg:clampDamage(damageCache?.[p.id]), enemy:npcEnemyLikelihoodByIntel(turnUid, p.id) }))
            .filter((row) => row.enemy < 0.5 && row.dmg > 0)
            .sort((a,b) => b.dmg - a.dmg)[0];
          if (friend?.uid){
            const eye = 1 + Math.floor(Math.random() * 4);
            await revealIdentityToEquipmentForUid(turnUid, { revealedBy:"emma_heal" });
            await emitCardDiceEvent({ kind:"role_emma", uid: turnUid, d4: eye });
            await waitMs(1000);
            await healDamageToPlayer(friend.uid, eye, "emma_ability_heal", { actorUid:turnUid, skipActionLog:true });
            await npcAnnounceAbilityUse(turnUid, "癒しの光", friend.uid, { delta:-eye, useCurrentDamage:true });
            await markNpcRoleAbilityUsed("RAI_E3", turnUid);
          }
        }
      }

      if (turnRoleId === "RAI_G1" && !isAbilitySealedForPlayer(turnUid, "RAI_G1") && !state.room?.abilityUsage?.gordon?.[turnUid]){
        const dmg = clampDamage(damageCache?.[turnUid]);
        if (dmg >= 10 && dmg <= 14){
          if (!isIdentityRevealedFor(turnUid)){
            await revealIdentityToEquipmentForUid(turnUid, { revealedBy:"npc_gordon_barrier" });
          }
          await npcAnnounceAbilityUse(turnUid, "絶対無敵バリア");
          await set(ref(db, `rooms/${state.roomCode}/gordonBarrier/${turnUid}`), true);
          await set(ref(db, `rooms/${state.roomCode}/abilityUsage/gordon/${turnUid}`), true);
        }
      }

      if (turnRoleId === "SHA_W1" && !isAbilitySealedForPlayer(turnUid, "SHA_W1") && !state.room?.abilityUsage?.wight?.[turnUid]){
        const eliminated = eliminatedPlayerCount();
        const knownEnemy = npcKnownEnemyTarget(turnUid, { rivalFaction:"レイダー", threshold:0.75 });
        if (eliminated > 0 && knownEnemy && Math.random() < 0.5){
          await npcAnnounceAbilityUse(turnUid, "亡者の王");
          await set(ref(db, `rooms/${state.roomCode}/abilityUsage/wight/${turnUid}`), true);
          await update(ref(db, `rooms/${state.roomCode}/turn`), {
            repeatTurnRemaining: eliminated,
            repeatTurnTotal: eliminated,
            updatedAt: Date.now()
          });
        }
      }

      await waitMs(NPC_TURN_PACING.phaseIntervalMs);
      if (turnCycleKey() !== turnKey) return;
      await advanceTurnToNextPlayer(turnUid);
    } finally {
      npcAutoTurnRunning = false;
      scheduleNpcTurnRetry(NPC_TURN_PACING.retryMs);
    }
  }



  function nameFromSecondChar(name){
    const chars = Array.from(safeText(name || "").trim());
    return chars.slice(1).join("");
  }

  function hideAttackResultPop(){
    attackResultPop?.classList.add("hidden");
    attackResultChoiceBusy = false;
  }

  function normalizeAttackResultMeta(meta){
    if (!meta || typeof meta !== "object") return null;
    return {
      showBonusLabel: !!meta.showBonusLabel,
      allowExcaliburButton: !!meta.allowExcaliburButton,
      freddieSpecial: !!meta.freddieSpecial,
      zeroDamagePreview: !!meta.zeroDamagePreview
    };
  }

  function cachePendingAttackResolution(pending){
    if (!state.roomCode || !state.userId) return;
    const key = attackResolutionKey(state.roomCode);
    if (!pending || typeof pending !== "object"){
      sessionStorage.removeItem(key);
      return;
    }
    const rows = Array.isArray(pending.rows)
      ? pending.rows.map(item => ({
          uid: safeText(item?.uid || ""),
          damage: Math.max(0, Number(item?.damage || 0)),
          bonusLabelAmount: Math.max(0, Number(item?.bonusLabelAmount || 0))
        })).filter(item => item.uid)
      : [];
    if (!rows.length){
      sessionStorage.removeItem(key);
      return;
    }
    const meta = normalizeAttackResultMeta(pending.meta);
    sessionStorage.setItem(key, JSON.stringify({ rows, turnKey: safeText(pending.turnKey || ""), meta }));
  }

  async function upsertPendingAttackResolution(rows = [], turnKey = "", meta = null){
    const uid = safeText(state.userId || "");
    const roomCode = safeText(state.roomCode || "");
    if (!uid || !roomCode) return;
    const normalizedRows = (rows || [])
      .map(item => ({
        uid: safeText(item?.uid || ""),
        damage: Math.max(0, Number(item?.damage || 0)),
        bonusLabelAmount: Math.max(0, Number(item?.bonusLabelAmount || 0))
      }))
      .filter(item => item.uid);
    const normalizedTurnKey = safeText(turnKey || "");
    const payload = normalizedRows.length ? {
      uid,
      rows: normalizedRows,
      turnKey: normalizedTurnKey,
      meta: normalizeAttackResultMeta(meta),
      at: Date.now()
    } : null;
    await set(ref(db, `rooms/${roomCode}/attackResolutionPending/${uid}`), payload);
  }

  function restorePendingAttackResolutionFromRoom(){
    const roomPending = state.room?.attackResolutionPending || {};
    const mine = roomPending?.[state.userId] || null;
    const rows = Array.isArray(mine?.rows)
      ? mine.rows.map(item => ({
          uid: safeText(item?.uid || ""),
          damage: Math.max(0, Number(item?.damage || 0)),
          bonusLabelAmount: Math.max(0, Number(item?.bonusLabelAmount || 0))
        })).filter(item => item.uid)
      : [];
    const meta = normalizeAttackResultMeta(mine?.meta);
    const pendingTurnKey = safeText(mine?.turnKey || "");
    const canRestore = !!rows.length && currentTurnPlayerId() === state.userId && pendingTurnKey === turnCycleKey();
    if (!canRestore){
      pendingAttackResolution = null;
      pendingAttackResultMeta = null;
      attackTurnEndChoicePending = false;
      cachePendingAttackResolution(null);
      hideAttackResultPop();
      renderTurnEndButton();
      return false;
    }
    pendingAttackResolution = { rows, applied:false, turnKey: pendingTurnKey, meta };
    pendingAttackResultMeta = meta;
    cachePendingAttackResolution(pendingAttackResolution);
    showAttackResultPop(rows);
    attackTurnEndChoicePending = true;
    attackFlowUiLockActive = true;
    renderTurnEndButton();
    return true;
  }

  function restoreAttackLootPendingFromRoom(){
    const roomPending = state.room?.attackLootPending || {};
    const mine = normalizeAttackLootPayload(roomPending?.[state.userId] || null);
    pendingAttackLoot = mine;
    renderAttackLootPanel();
  }

  function restorePendingAttackResolutionFromSession(){
    if (!state.roomCode || !state.userId) return false;
    const raw = sessionStorage.getItem(attackResolutionKey(state.roomCode));
    if (!raw) return false;
    let parsed = null;
    try {
      parsed = JSON.parse(raw);
    } catch {
      sessionStorage.removeItem(attackResolutionKey(state.roomCode));
      return false;
    }
    const rows = Array.isArray(parsed?.rows)
      ? parsed.rows.map(item => ({
          uid: safeText(item?.uid || ""),
          damage: Math.max(0, Number(item?.damage || 0)),
          bonusLabelAmount: Math.max(0, Number(item?.bonusLabelAmount || 0))
        })).filter(item => item.uid)
      : [];
    const meta = normalizeAttackResultMeta(parsed?.meta);
    const pendingTurnKey = safeText(parsed?.turnKey || "");
    if (!rows.length || !pendingTurnKey){
      sessionStorage.removeItem(attackResolutionKey(state.roomCode));
      return false;
    }
    pendingAttackResolution = { rows, applied:false, turnKey: pendingTurnKey, meta };
    pendingAttackResultMeta = meta;
    showAttackResultPop(rows);
    attackTurnEndChoicePending = true;
    attackFlowUiLockActive = true;
    renderTurnEndButton();
    return true;
  }

  function makeAttackResultNameNode(uid){
    const wrap = document.createElement("span");
    wrap.className = "green-share-btn attack-result-pop-name";
    const p = playerById(uid);
    const chip = document.createElement("span");
    chip.className = "chip16";
    const color = p?.color || "#ddd";
    chip.style.background = color;
    chip.style.color = textColorFor(color);
    chip.textContent = firstChar(p?.name || "");
    const text = document.createElement("span");
    text.className = "attack-result-pop-name-text";
    const rest = nameFromSecondChar(p?.name || "");
    text.textContent = rest || safeText(p?.name || "-");
    wrap.appendChild(chip);
    wrap.appendChild(text);
    return wrap;
  }

  function shouldDisableCraigAbilityByDamage(){
    if (!isMyRole("CIT_C1")) return false;
    if (isMyAbilitySealed()) return false;
    const damage = clampDamage(damageCache?.[state.userId]);
    return damage >= 9;
  }

  function showAttackResultPop(rows = []){
    if (!attackResultPop || !attackResultRows) return;
    attackResultRows.innerHTML = "";
    const exMeta = pendingAttackResultMeta || {};
    if (!rows.length){
      const row = document.createElement("div");
      row.className = "attack-result-pop-row";
      row.textContent = "ダメージ対象はいません。";
      attackResultRows.appendChild(row);
    }
    for (const item of rows){
      const uid = safeText(item?.uid || "");
      if (!uid) continue;
      const row = document.createElement("div");
      row.className = "attack-result-pop-row";
      const amount = document.createElement("span");
      const damageValue = Math.max(0, Number(item?.damage || 0));
      const treatZeroAsPreview = !!(exMeta.zeroDamagePreview && damageValue === 0);
      const hasDamageLabel = (damageValue > 0 || treatZeroAsPreview);
      if (!hasDamageLabel){
        amount.textContent = "攻撃失敗 >";
        row.appendChild(amount);
        row.appendChild(makeAttackResultNameNode(uid));
        attackResultRows.appendChild(row);
        continue;
      }
      amount.textContent = `${damageValue}`;

      row.appendChild(amount);
      const bonusAmount = Math.max(0, Number(item?.bonusLabelAmount || 0));
      if (bonusAmount > 0){
        const plus = document.createElement("span");
        plus.className = "attack-result-plus-two";
        plus.textContent = `(+${bonusAmount})`;
        row.appendChild(plus);
      } else if (exMeta.showBonusLabel){
        const plus = document.createElement("span");
        plus.className = "attack-result-plus-two";
        plus.textContent = "(+2)";
        row.appendChild(plus);
      }
      const suffix = document.createElement("span");
      suffix.textContent = "Damege >";
      row.appendChild(suffix);
      row.appendChild(makeAttackResultNameNode(uid));
      attackResultRows.appendChild(row);
    }
    const spec = attackAbilitySpecFromRows(rows);
    const sealedVictim = isErikaSealedPlayer(state.userId);
    if (btnAttackResultEnd){
      if (hasSealWisdomBonusThisTurn()){
        btnAttackResultEnd.textContent = "OKおわる(+1)";
      } else {
        btnAttackResultEnd.textContent = `OKおわる${repeatTurnSuffixLabel()}`;
      }
    }
    if (btnAttackResultKeep){
      btnAttackResultKeep.classList.remove("pop-light-gray");
      btnAttackResultKeep.disabled = false;
      btnAttackResultKeep.removeAttribute("aria-disabled");
      if (sealedVictim){
        btnAttackResultKeep.textContent = `OKおわる${repeatTurnSuffixLabel()}`;
      } else if (spec){
        btnAttackResultKeep.innerHTML = `OK <span class="ability-pill">${escapeHtml(formatAttackAbilityPillLabel(spec.abilityName))}</span>`;
        if (safeText(myRoleInfo()?.id || "") === "CIT_C1" && shouldDisableCraigAbilityByDamage()){
          btnAttackResultKeep.classList.add("pop-light-gray");
          btnAttackResultKeep.disabled = true;
          btnAttackResultKeep.setAttribute("aria-disabled", "true");
        }
      } else {
        btnAttackResultKeep.textContent = "OKおわらない";
      }
    }
    const roleId = safeText(myRoleInfo()?.id || "");
    const shouldHideKeepAsSecondAttack = !spec
      && (roleId === "CIT_C1" || roleId === "SHA_U3")
      && isAttackAbilityUsedThisTurn(roleId);
    const isVampireSingleButton = roleId === "SHA_V2" && !!spec && isMyIdentityRevealed() && !sealedVictim;
    btnAttackResultExcalibur?.classList.toggle("hidden", !exMeta.allowExcaliburButton);
    btnAttackResultEnd?.classList.toggle("hidden", isVampireSingleButton);
    if (btnAttackResultKeep){
      btnAttackResultKeep.classList.remove("primary");
      btnAttackResultKeep.classList.add("ghost");
      if (isVampireSingleButton){
        btnAttackResultKeep.innerHTML = `OK <span class="ability-pill">${escapeHtml(formatAttackAbilityPillLabel("吸血"))}</span>`;
      }
      btnAttackResultKeep.classList.toggle("hidden", (!isVampireSingleButton && sealedVictim) || shouldHideKeepAsSecondAttack);
    }
    attackResultChoiceBusy = false;
    attackResultPop.classList.remove("hidden");
  }

  async function queueCounterPromptsForDamagedPlayers(entries = [], options = {}){
    if (!state.roomCode || !entries.length) return;
    const advanceTurnOnResolve = !!options.advanceTurnOnResolve;

    const attackerUid = safeText(state.userId || "");
    const turnKey = turnCycleKey();
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const map = cur.counterPromptState || {};
      for (const item of entries){
        const uid = safeText(item?.uid || "");
        const roleId = safeText(item?.roleId || "");
        if (!uid || !isCounterRole(roleId)) continue;
        const incomingDamage = Math.max(0, Number(item?.damage || 0));
        if (isAbilitySealedForPlayer(uid, roleId)) continue;
        const hp = Number(ROLE_BY_ID?.[cur.hands?.[uid]?.roleId || ""]?.hp || 0);
        const beforeDamage = clampDamage(cur.damage?.[uid]);
        const afterDamage = clampDamage(beforeDamage + incomingDamage);
        if (hp > 0 && beforeDamage < hp && afterDamage >= hp) continue;
        const mustChoose = !!(cur.equipment?.[uid]?.identity?.roleId);
        const now = Date.now();
        map[uid] = {
          uid,
          roleId,
          attackerUid,
          turnKey,
          advanceTurnOnResolve,
          mustChoose,
          expiresAt: mustChoose ? 0 : (now + 8000),
          at: now
        };
      }
      if (Object.keys(map).length){
        cur.counterPromptState = map;
      }
      return cur;
    });
  }

  async function addResolvedDamageToPlayers(rows = [], options = {}){
    const allEntries = (rows || [])
      .map(item => ({
        uid: safeText(item?.uid || ""),
        damage: Math.max(0, Number(item?.damage || 0)),
        bonusLabelAmount: Math.max(0, Number(item?.bonusLabelAmount || 0)),
        roleId: safeText(state.hands?.[safeText(item?.uid || "")]?.roleId || "")
      }))
      .filter(item => item.uid);
    if (!state.roomCode || !allEntries.length) return;

    await queueCounterPromptsForDamagedPlayers(allEntries, options);

    const entries = allEntries.filter(item => item.damage > 0);
    if (!entries.length) return;

    const expected = new Set();
    for (const item of entries){
      const roleId = safeText(state.hands?.[item.uid]?.roleId || "");
      const hp = Number(ROLE_BY_ID?.[roleId]?.hp || 0);
      if (hp <= 0) continue;
      const before = clampDamage(damageCache?.[item.uid]);
      const after = clampDamage(before + item.damage);
      if (before < hp && after >= hp){
        expected.add(item.uid);
      }
    }
    attackExpectedEliminationUids = expected;
    attackExpectedEliminationAt = Date.now();

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      cur.damage = cur.damage || {};
      for (const item of entries){
        cur.damage[item.uid] = clampDamage(Number(cur.damage[item.uid] || 0) + item.damage);
      }
      return cur;
    });
  }

  async function waitForHpBoardSwapAnimationEnd(maxWaitMs = 1800){
    const startedAt = Date.now();
    while (hpBoardAnimationActive && (Date.now() - startedAt) < maxWaitMs){
      await new Promise(resolve => setTimeout(resolve, 40));
    }
  }

  async function finalizePendingAttackResolution(endTurnAfterApply, advanceTurnOnCounterResolve = false){
    const pending = pendingAttackResolution;
    const attackTurnOwnerUid = currentTurnPlayerId();
    pendingAttackResolution = null;
    pendingAttackResultMeta = null;
    attackTurnEndChoicePending = false;
    suppressEndTurnButton = true;
    cachePendingAttackResolution(null);
    await upsertPendingAttackResolution([], "");
    renderTurnEndButton();
    hideAttackResultPop();
    clearAttackResultDice();
    if (!pending || pending.applied){
      if (!endTurnAfterApply){
        attackFlowUiLockActive = false;
        suppressEndTurnButton = false;
        renderTurnEndButton();
      }
      return;
    }
    pending.applied = true;
    const attackedUids = [...new Set((pending.rows || []).map((row) => safeText(row?.uid || "")).filter(Boolean))];
    for (const attackedUid of attackedUids){
      await recordNpcAttackTarget(attackTurnOwnerUid, attackedUid);
    }
    await addResolvedDamageToPlayers(pending.rows || [], { advanceTurnOnResolve: advanceTurnOnCounterResolve });
    if (endTurnAfterApply){
      ulsterExtraAttackPending = 0;
      await new Promise(resolve => setTimeout(resolve, 2000));
      if (currentTurnPlayerId() === attackTurnOwnerUid){
        await doEndTurn(attackTurnOwnerUid);
      }
      attackFlowUiLockActive = false;
      suppressEndTurnButton = false;
      renderTurnEndButton();
      return;
    }

    await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
    await waitForHpBoardSwapAnimationEnd();
    if (ulsterExtraAttackPending > 0){
      ulsterExtraAttackPending = Math.max(0, ulsterExtraAttackPending - 1);
    }
    attackFlowUiLockActive = false;
    suppressEndTurnButton = false;
    renderTurnEndButton();
  }

  function animateHpBoardSwapIfNeeded(){
    const swap = pendingHpSwapAnimation;
    if (!swap || !hpBoard) return;
    pendingHpSwapAnimation = null;
    const fromA = hpBoard.querySelector(`.hp-cell .chip16[data-uid="${swap.aUid}"]`);
    const fromB = hpBoard.querySelector(`.hp-cell .chip16[data-uid="${swap.bUid}"]`);
    if (!fromA || !fromB) return;

    const rectA = fromA.getBoundingClientRect();
    const rectB = fromB.getBoundingClientRect();
    if (!rectA.width || !rectB.width) return;

    const floatA = fromA.cloneNode(true);
    const floatB = fromB.cloneNode(true);
    for (const node of [floatA, floatB]){
      node.style.position = 'fixed';
      node.style.margin = '0';
      node.style.zIndex = '360';
      node.style.pointerEvents = 'none';
    }

    floatA.style.left = `${rectA.left}px`;
    floatA.style.top = `${rectA.top}px`;
    floatB.style.left = `${rectB.left}px`;
    floatB.style.top = `${rectB.top}px`;

    document.body.appendChild(floatA);
    document.body.appendChild(floatB);

    fromA.style.opacity = '0';
    fromB.style.opacity = '0';

    const dxAB = rectB.left - rectA.left;
    const dyAB = rectB.top - rectA.top;
    const dxBA = rectA.left - rectB.left;
    const dyBA = rectA.top - rectB.top;
    const curveY = Math.max(28, Math.min(84, Math.abs(dxAB) * 0.28));

    const animationMs = 520;
    const easing = 'cubic-bezier(.22,.75,.2,1)';
    const endA = floatA.animate([
      { transform:'translate(0px, 0px) scale(1)' },
      { transform:`translate(${dxAB*0.5}px, ${dyAB*0.5-curveY}px) scale(1.05)` },
      { transform:`translate(${dxAB}px, ${dyAB}px) scale(1)` }
    ], { duration:animationMs, easing, fill:'forwards' });

    const endB = floatB.animate([
      { transform:'translate(0px, 0px) scale(1)' },
      { transform:`translate(${dxBA*0.5}px, ${dyBA*0.5+curveY}px) scale(1.05)` },
      { transform:`translate(${dxBA}px, ${dyBA}px) scale(1)` }
    ], { duration:animationMs, easing, fill:'forwards' });

    hpBoardAnimationActive = true;
    renderTurnEndButton();

    Promise.allSettled([endA.finished, endB.finished]).finally(() => {
      floatA.remove();
      floatB.remove();
      fromA.style.opacity = '';
      fromB.style.opacity = '';
      hpBoardAnimationActive = false;
      renderTurnEndButton();
    });
  }

  function renderHpBoard(){
    if (!hpBoard) return;
    if (!state.roomCode) return;

    if (!hpBoard.firstChild) buildHpCells();

    const cells = Array.from(hpBoard.querySelectorAll(".hp-cell"));
    for (const c of cells){
      c.querySelectorAll(".chip16").forEach(x => x.remove());
    }

    const entries = Object.entries(damageCache || {}).map(([uid, lvl]) => ({
      uid, lvl: clampDamage(lvl)
    }));

    const started = isGameStarted();
    if (started && entries.length === 0 && latestPlayers.length > 0){
      for (const p of latestPlayers){
        entries.push({ uid: p.id, lvl: 0 });
      }
    }

    const byLvl = new Map();
    for (const e of entries){
      const arr = byLvl.get(e.lvl) || [];
      arr.push(e.uid);
      byLvl.set(e.lvl, arr);
    }

    for (const [lvl, uids] of byLvl.entries()){
      uids.sort((a,b) => {
        const pa = playerById(a);
        const pb = playerById(b);
        return Number(pa?.seatIndex||999) - Number(pb?.seatIndex||999);
      });
      byLvl.set(lvl, uids);
    }

    for (const cell of cells){
      const lvl = Number(cell.dataset.damage);
      const uids = byLvl.get(lvl) || [];
      for (const uid of uids){
        const chip = buildChipFor(uid);
        if (isPlayerEliminated(uid)){
          bindEliminatedChipRoomUp(chip, uid);
        }
        cell.appendChild(chip);
      }
    }
    animateHpBoardSwapIfNeeded();
  }

  function renderPositionLine(){
    if (!positionLine) return;

    const started = isGameStarted();
    const order = Array.isArray(state.room?.positionOrder) ? state.room.positionOrder : [];
    const turnPlayerId = currentTurnPlayerId();

    let players = [];
    if (started && order.length > 0){
      players = order
        .map(uid => latestPlayers.find(p => p.id === uid) || null)
        .filter(Boolean);
      const rest = latestPlayers
        .filter(p => !order.includes(p.id))
        .sort((a,b) => Number(a.seatIndex || 999) - Number(b.seatIndex || 999));
      players.push(...rest);
    } else {
      players = latestPlayers
        .slice()
        .sort((a,b) => Number(a.seatIndex || 999) - Number(b.seatIndex || 999));
    }

    positionLine.innerHTML = "";
    if (!started || players.length === 0){
      positionLine.classList.add("hidden");
      renderTurnEndButton();
      return;
    }

    players.forEach((p, idx) => {
      if (idx > 0){
        const arrow = document.createElement("span");
        arrow.className = "position-arrow";
        arrow.textContent = "▶";
        positionLine.appendChild(arrow);
      }
      const item = document.createElement("div");
      item.className = "position-item";

      const eliminated = isPlayerEliminated(p.id);
      const chipWrap = document.createElement("div");
      chipWrap.className = "position-chip-wrap";
      const chip = buildChipFor(p.id);
      if (started && p.id === turnPlayerId && !eliminated){
        chip.classList.add("turn-pulse");
      }
      if (eliminated) bindEliminatedChipRoomUp(chip, p.id);
      chipWrap.appendChild(chip);

      const marker = document.createElement("div");
      marker.className = "starter-mark";
      marker.textContent = (started && p.id === turnPlayerId) ? "△" : "";

      const tempRole = temporaryRoleTagByUid?.[p.id];
      if (tempRole && Number(tempRole.until || 0) <= Date.now()){
        delete temporaryRoleTagByUid[p.id];
      }
      const tempBubbleText = safeText(temporaryRoleTagByUid?.[p.id]?.text || "");
      const npcBubble = activeNpcSpeechByUid?.[p.id] || null;
      const npcBubbleText = safeText(npcBubble?.text || "");
      const npcBubbleStyle = safeText(npcBubble?.style || "");
      const greenBubbleText = safeText(activeGreenReplies?.[p.id] || "");
      const bubbleText = safeText(tempBubbleText || npcBubbleText || greenBubbleText);
      if (bubbleText){
        const bubble = document.createElement("div");
        bubble.className = "position-bubble";
        const isGreenReplyBubble = !!greenBubbleText && !tempBubbleText && !npcBubbleText;
        bubble.classList.toggle("white-text", !isGreenReplyBubble && !npcBubbleStyle);
        if (npcBubbleStyle === "raider") bubble.classList.add("faction-raider");
        if (npcBubbleStyle === "shadow") bubble.classList.add("faction-shadow");
        bubble.textContent = bubbleText;
        chipWrap.appendChild(bubble);
      }

      item.appendChild(chipWrap);
      item.appendChild(marker);

      positionLine.appendChild(item);
    });

    positionLine.classList.remove("hidden");
    updateRoomChoiceUi();
    renderTurnEndButton();
  }


  async function ensureCurrentTurnPlayerAlive(){
    const curId = currentTurnPlayerId();
    if (!curId) return;
    if (!isPlayerEliminated(curId)) return;
    await advanceTurnToNextPlayer();
  }

  function subscribeDamage(){
    const dRef = ref(db, `rooms/${state.roomCode}/damage`);
    onValue(dRef, snap => {
      damageCache = snap.val() || {};

      const eliminatedNow = {};
      for (const p of latestPlayers){
        eliminatedNow[p.id] = isPlayerEliminated(p.id);
      }
      const watchActive = lastAttackWatch
        && lastAttackWatch.uid === state.userId
        && (Date.now() - Number(lastAttackWatch.at || 0) < 12000);
      const expectedAttackWindowActive = (Date.now() - Number(attackExpectedEliminationAt || 0) < 12000);
      const attackDefeatedUids = [];
      if (watchActive && expectedAttackWindowActive){
        for (const uid of (lastAttackWatch.targetUids || [])){
          if (!uid || !attackExpectedEliminationUids.has(uid)) continue;
          const becameEliminated = !!eliminatedNow[uid] && !previousEliminatedMap[uid];
          if (!becameEliminated) continue;
          attackDefeatedUids.push(uid);
          attackExpectedEliminationUids.delete(uid);
        }
      }

      const myRoleId = safeText(state.hands?.[state.userId]?.roleId || "");
      if (myRoleId === "CIT_D1" && !isMyIdentityRevealed() && !isMyAbilitySealed()){
        const othersEliminatedNow = latestPlayers.some(p => p.id !== state.userId && !!eliminatedNow[p.id]);
        const othersEliminatedBefore = latestPlayers.some(p => p.id !== state.userId && !!previousEliminatedMap[p.id]);
        if (othersEliminatedNow && !othersEliminatedBefore && !danielAutoRevealTimer){
          danielAutoRevealTimer = setTimeout(async () => {
            danielAutoRevealTimer = null;
            await waitUntilZoomClosed();
            await revealMyIdentityToEquipment({ revealedBy:"daniel_forced" });
          }, 2000);
        }
      }

      const justEliminatedUids = latestPlayers
        .map(p => p.id)
        .filter(uid => !!eliminatedNow[uid] && !previousEliminatedMap[uid]);

      if (justEliminatedUids.length){
        lastEliminationBatch = {
          uids: [...justEliminatedUids],
          at: Date.now()
        };
        for (const uid of justEliminatedUids){
          const name = safeText(playerById(uid)?.name || "プレイヤー");
          appendActionChatLog(uid, `脱落:${name}`).catch(() => {});
        }
      }

      if (myRoleId === "CIT_B3" && attackDefeatedUids.length && !isMyIdentityRevealed() && !bruceAutoRevealTimer && !isMyAbilitySealed()){
        const hadHiddenRevealTarget = attackDefeatedUids.some(uid => justEliminatedUids.includes(uid) && !isIdentityRevealedFor(uid));
        const revealDelayMs = hadHiddenRevealTarget ? 2200 : 0;
        bruceAutoRevealTimer = setTimeout(async () => {
          bruceAutoRevealTimer = null;
          if (isMyIdentityRevealed()) return;
          if (!isMyRole("CIT_B3")) return;
          await waitUntilZoomClosed();
          await revealMyIdentityToEquipment({ revealedBy:"bruce_ability" });
          const role = myRoleInfo();
          if (role) openIdentityRevealZoom(role, state.userId);
        }, revealDelayMs);
      }

      if (justEliminatedUids.includes(state.userId) && isMyRole("RAI_G3") && !isRoleAbilityUsed("RAI_G3")){
        setRoleAbilitySelectionState({ roleId:"RAI_G3", actorUid: state.userId }).catch(() => {});
      }

      if (state.isHost && state.roomCode && state.room?.computerMode){
        for (const uid of justEliminatedUids){
          if (!isNpcPlayerUid(uid)) continue;
          if (safeText(roleIdForUid(uid) || "") !== "RAI_G3") continue;
          if (state.room?.abilityUsage?.godwin?.[uid]) continue;
          const eliminatedOthers = latestPlayers.filter((p) => p.id !== uid && isPlayerEliminated(p.id));
          const raiderTarget = eliminatedOthers.find((p) => safeText(roleInfoByUid(p.id)?.faction || "") === "レイダー");
          if (!raiderTarget) continue;
          const selectedUid = safeText(raiderTarget.id || "");
          if (!selectedUid) continue;
          npcAnnounceAbilityUse(uid, "蘇生装置TYPE-G", selectedUid).catch(() => {});
          runTransaction(ref(db, `rooms/${state.roomCode}`), (cur) => {
            if (!cur) return cur;
            cur.damage = cur.damage || {};
            cur.damage[selectedUid] = clampDamage(7);
            recycleRevivedPlayerEquipIntoDeck(cur, selectedUid);
            cur.markers = cur.markers || {};
            delete cur.markers[selectedUid];
            cur.godwinRevivePendingMove = cur.godwinRevivePendingMove || {};
            cur.godwinRevivePendingMove[selectedUid] = true;
            if (cur.deckState && typeof cur.deckState === "object"){
              cur.deckState.updatedAt = Date.now();
            }
            return cur;
          }).catch(() => {});
          set(ref(db, `rooms/${state.roomCode}/abilityUsage/godwin/${uid}`), true).catch(() => {});
        }
      }

      if (activeRoleAbilitySelection?.roleId === "RAI_G3" && isRoleAbilityUsed("RAI_G3")){
        activeRoleAbilitySelection = null;
        cardPlayerSelectActive = false;
        greenShareDock?.classList.add("hidden");
        renderTurnEndButton();
        updateCardInteractivity();
        if (!zoomBackdrop?.classList.contains("hidden")) closeZoom();
      }

      previousEliminatedMap = eliminatedNow;

      renderHpBoard();
      ensureCurrentTurnPlayerAlive();

      const justEliminatedUnrevealed = [];

      for (const [uid, dmgRaw] of Object.entries(damageCache)){
        const myHand = state.hands?.[uid];
        const role = myHand?.roleId ? ROLE_BY_ID[myHand.roleId] : null;
        const hp = Number(role?.hp || 0);
        const dmg = clampDamage(dmgRaw);
        if (!uid || !hp || dmg < hp){
          autoDamageRevealLock[uid] = false;
          continue;
        }
        if (autoDamageRevealLock[uid]) continue;
        autoDamageRevealLock[uid] = true;
        const alreadyRevealed = isIdentityRevealedFor(uid);
        if (!alreadyRevealed && justEliminatedUids.includes(uid)){
          justEliminatedUnrevealed.push({ uid, role });
        }
        revealIdentityByDamage(uid).catch(() => {});
      }

      if (justEliminatedUnrevealed.length >= 2){
        openMultiIdentityRevealZoom(justEliminatedUnrevealed);
      } else if (justEliminatedUnrevealed.length === 1){
        const entry = justEliminatedUnrevealed[0];
        openIdentityRevealZoom(entry.role, entry.uid);
      }

      if (attackDefeatedUids.length){
        const shouldUseRosaryLoot = !!lastAttackWatch?.hasRosary;
        setTimeout(() => {
          if (shouldUseRosaryLoot){
            runRosaryAutoLootFlow(attackDefeatedUids).catch(() => {});
          } else {
            createOrMergeAttackLootPending(attackDefeatedUids).catch(() => {});
          }
        }, 2200);
      }

      evaluateAutoIdentityRevealTrigger();

      renderEquipmentDock();
      const myRoleBack = myRoleCard?.querySelector('.role-back');
      if (myRoleBack){
        myRoleBack.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));
      }
    });
  }


  function subscribeDiceEvents(){
    const moveRef = ref(db, `rooms/${state.roomCode}/diceEvents/move`);
    onValue(moveRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!moveDiceEventInitialized){
        moveDiceEventInitialized = true;
        moveDiceEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= moveDiceEventSeenAt) return;
      moveDiceEventSeenAt = at;
      runDiceRollAnimation({
        force:true,
        finalD6:Number(ev.d6 || 1),
        finalD4:Number(ev.d4 || 1),
        secondD6:Number(ev.secondD6 || 1),
        secondD4:Number(ev.secondD4 || 1),
        compass: !!ev.compass,
        applyMove: safeText(ev.uid || "") === state.userId,
        motion: ev.motion || null
      });
    });

    const attackRef = ref(db, `rooms/${state.roomCode}/diceEvents/attack`);
    onValue(attackRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!attackDiceEventInitialized){
        attackDiceEventInitialized = true;
        attackDiceEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= attackDiceEventSeenAt) return;
      attackDiceEventSeenAt = at;
      runAttackDiceAnimation(safeText(ev.targetUid || ""), Number(ev.x || 0), Number(ev.y || 0), {
        force:true,
        finalD6:Number(ev.d6 || 1),
        finalD4:Number(ev.d4 || 1),
        masamuneMode: !!ev.masamuneMode,
        vendettaMode: !!ev.vendettaMode,
        gatlingTargetUids: Array.isArray(ev.gatlingTargetUids) ? ev.gatlingTargetUids : [],
        applyDamage: safeText(ev.uid || "") === state.userId,
        motion: ev.motion || null
      });
    });

    const cardRef = ref(db, `rooms/${state.roomCode}/diceEvents/card`);
    onValue(cardRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!cardDiceEventInitialized){
        cardDiceEventInitialized = true;
        cardDiceEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= cardDiceEventSeenAt) return;
      cardDiceEventSeenAt = at;
      const kind = safeText(ev.kind || "");
      if (kind === "curse_doll"){
        runCornerD6Roll(Number(ev.d6 || 1));
      } else if (kind === "blessing"){
        if (safeText(ev.uid || "") === state.userId) return;
        runCornerD6Roll(Number(ev.d6 || 1));
      } else if (kind === "riot"){
        runCornerD6D4Roll({
          d6: Number(ev.d6 || 1),
          d4: Number(ev.d4 || 1)
        });
      } else if (kind === "role_agatha"){
        showAgathaRevealCardOverlay(safeText(ev.uid || ""), {
          closeAt: Number(ev.closeAt || 0),
          duration: 1200
        });
        runCornerD6D4Roll({
          d6: Number(ev.d6 || 1),
          d4: Number(ev.d4 || 1)
        });
      } else if (kind === "role_felix"){
        runCornerD6Roll(Number(ev.d6 || 1));
      } else if (kind === "role_emma"){
        runCornerD4Roll(Number(ev.d4 || 1));
      } else if (kind === "role_werewolf_counter"){
        if (!!ev.masamuneMode){
          runCornerD4Roll(Number(ev.d4 || 1));
        } else {
          runCornerD6D4Roll({
            d6: Number(ev.d6 || 1),
            d4: Number(ev.d4 || 1)
          });
        }
      }
    });
  }

  function subscribeRoleFlashEvents(){
    const flashRef = ref(db, `rooms/${state.roomCode}/effectEvents/roleFlash`);
    onValue(flashRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!roleFlashEventInitialized){
        roleFlashEventInitialized = true;
        roleFlashEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= roleFlashEventSeenAt) return;
      roleFlashEventSeenAt = at;
      showRoleFlashOverlay(safeText(ev.roleId || ""), Number(ev.durationMs || 1800));
    });
  }

  
  function subscribeHpSwapEvents(){
    const hpSwapRef = ref(db, `rooms/${state.roomCode}/effectEvents/hpSwap`);
    onValue(hpSwapRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!hpSwapEventInitialized){
        hpSwapEventInitialized = true;
        hpSwapEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= hpSwapEventSeenAt) return;
      hpSwapEventSeenAt = at;
      const aUid = safeText(ev.aUid || "");
      const bUid = safeText(ev.bUid || "");
      if (!aUid || !bUid) return;
      pendingHpSwapAnimation = { aUid, bUid, at };
      renderHpBoard();
      setTimeout(() => {
        if (!pendingHpSwapAnimation){
          pendingHpSwapAnimation = { aUid, bUid, at };
        }
        renderHpBoard();
      }, 120);
    });
  }

  function subscribeWalpurgisSwapEvents(){
    const swapRef = ref(db, `rooms/${state.roomCode}/effectEvents/walpurgisSwap`);
    onValue(swapRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!walpurgisSwapEventInitialized){
        walpurgisSwapEventInitialized = true;
        walpurgisSwapEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= walpurgisSwapEventSeenAt) return;
      walpurgisSwapEventSeenAt = at;
      const uidA = safeText(ev.uidA || "");
      const uidB = safeText(ev.uidB || "");
      const durationMs = Math.max(240, Number(ev.durationMs) || 620);
      if (!uidA || !uidB || uidA === uidB) return;
      animateMarkerSwapVisual(uidA, uidB, durationMs);
    });
  }

  function subscribeIdentityZoomEvents(){
    const zoomRef = ref(db, `rooms/${state.roomCode}/effectEvents/identityZoom`);
    onValue(zoomRef, snap => {
      const ev = snap.val() || null;
      const at = Number(ev?.at || 0);
      if (!identityZoomEventInitialized){
        identityZoomEventInitialized = true;
        identityZoomEventSeenAt = at || 0;
        return;
      }
      if (!ev || !at || at <= identityZoomEventSeenAt) return;
      identityZoomEventSeenAt = at;
      const uid = safeText(ev.uid || "");
      const roleId = safeText(ev.roleId || "");
      const role = ROLE_BY_ID[roleId];
      if (!uid || !role) return;
      openIdentityRevealZoom(role, uid, {
        ownerTagDurationMs: 1200,
        showOwnerTag: true
      });
    });
  }

  function subscribeGreenReplyBubbles(){
    const bRef = ref(db, `rooms/${state.roomCode}/greenReplyBubbles`);
    onValue(bRef, snap => {
      const raw = snap.val() || {};
      const next = {};
      for (const row of Object.values(raw)){
        const uid = safeText(row?.responderId || "");
        const label = safeText(row?.answerLabel || "");
        if (!uid || !label) continue;
        next[uid] = label;
      }
      activeGreenReplies = next;
      renderPositionLine();
    });
  }


  function subscribeNpcSpeech(){
    const speechRef = ref(db, `rooms/${state.roomCode}/npcSpeech`);
    onValue(speechRef, snap => {
      const row = snap.val() || null;
      const at = Number(row?.at || 0);
      if (!npcSpeechInitialized){
        npcSpeechInitialized = true;
        npcSpeechSeenAt = at || 0;
        if (row?.uid && row?.text && Number(row?.expiresAt || 0) > Date.now()){
          activeNpcSpeechByUid = { [safeText(row.uid)]: { text:safeText(row.text), style:safeText(row.style || "") } };
        }
        renderPositionLine();
        return;
      }
      if (!row || !at || at <= npcSpeechSeenAt){
        if (!row){
          activeNpcSpeechByUid = {};
          renderPositionLine();
        }
        return;
      }
      npcSpeechSeenAt = at;
      const expiresAt = Number(row?.expiresAt || 0);
      const uid = safeText(row?.uid || "");
      const text = safeText(row?.text || "");
      const style = safeText(row?.style || "");
      if (!uid || !text || (expiresAt && expiresAt <= Date.now())){
        activeNpcSpeechByUid = {};
        renderPositionLine();
        return;
      }
      activeNpcSpeechByUid = { [uid]: { text, style } };
      renderPositionLine();
      const timeoutMs = Math.max(0, expiresAt - Date.now());
      if (timeoutMs > 0){
        setTimeout(() => {
          if (!activeNpcSpeechByUid[uid]) return;
          if (safeText(activeNpcSpeechByUid?.[uid]?.text || "") !== text) return;
          activeNpcSpeechByUid = {};
          renderPositionLine();
        }, timeoutMs + 20);
      }
    });
  }

  async function initDamageAllToZero(players){
    if (!state.roomCode) return;
    const baseRef = ref(db, `rooms/${state.roomCode}/damage`);
    const obj = {};
    for (const p of players){
      obj[p.id] = 0;
    }
    await set(baseRef, obj);
  }

  async function ensureTurnInitialized(){
    if (!state.roomCode || !isGameStarted()) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !(cur.gameStarted || cur.startedAt)) return cur;
      if (cur.turn && cur.turn.currentPlayerId) return cur;
      const startPlayerId = safeText(cur.startPlayerId || "");
      if (!startPlayerId) return cur;
      cur.turn = {
        currentPlayerId: startPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        drawnTypes: { green:false, white:false, black:false },
        movedByDiceRoomId: null,
        room3ActionUsed: false,
        room4StealUsed: false,
        repeatTurnRemaining: 0,
        repeatTurnTotal: 0,
        sealWisdomBonus: false,
        updatedAt: Date.now()
      };
      if (cur.guardianAngelShield && cur.guardianAngelShield[startPlayerId]){
        delete cur.guardianAngelShield[startPlayerId];
      }
      return cur;
    });
  }

  async function advanceTurnToNextPlayer(expectedCurrentPlayerId = ""){
    if (!state.roomCode) return false;
    const expectedUid = safeText(expectedCurrentPlayerId || "");
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let advanced = false;
    await runTransaction(roomRef, (cur) => {
      if (!cur || !(cur.gameStarted || cur.startedAt)) return cur;
      const order = Array.isArray(cur.positionOrder) ? cur.positionOrder : [];
      if (order.length === 0) return cur;

      const isEliminatedInRoom = (uid) => {
        if (!uid) return false;
        const hand = cur.hands?.[uid];
        const role = hand?.roleId ? ROLE_BY_ID[hand.roleId] : null;
        const hp = Number(role?.hp || 0);
        if (!hp) return false;
        const dmg = clampDamage(cur.damage?.[uid]);
        return dmg >= hp;
      };
      const aliveOrder = order.filter(uid => !isEliminatedInRoom(uid));
      if (aliveOrder.length === 0) return cur;

      const counterMap = cur.counterPromptState || {};
      const hasBlockingCounterPrompt = Object.values(counterMap).some((entry) => !!entry && !!entry.mustChoose);
      if (hasBlockingCounterPrompt) return cur;

      const curTurn = cur.turn || {};
      const curId = safeText(curTurn.currentPlayerId || cur.startPlayerId || aliveOrder[0] || "");
      if (expectedUid && curId !== expectedUid) return cur;

      const pendingRoleSelection = cur.roleAbilitySelection;
      if (pendingRoleSelection && typeof pendingRoleSelection === "object"){
        const pendingRoleId = safeText(pendingRoleSelection.roleId || "");
        if (pendingRoleId === "RAI_G3") return cur;
      }


      if (hasLootableAttackLootPending(cur, curId)) return cur;

      const rest = Math.max(0, Number(curTurn.repeatTurnRemaining || 0));
      const total = Math.max(0, Number(curTurn.repeatTurnTotal || 0));
      const repeat = rest > 0 && !isEliminatedInRoom(curId);
      const nextRepeatRemaining = repeat ? Math.max(0, rest - 1) : 0;
      const nextRepeatTotal = repeat ? Math.max(total, rest) : 0;
      let nextPlayerId = curId;
      if (!repeat){
        let nextIdx = aliveOrder.indexOf(curId);
        if (nextIdx < 0) nextIdx = 0;
        nextPlayerId = safeText(aliveOrder[(nextIdx + 1) % aliveOrder.length] || aliveOrder[0] || "");
      }
      if (!nextPlayerId || isEliminatedInRoom(nextPlayerId)){
        nextPlayerId = safeText(aliveOrder[0] || "");
      }
      if (!nextPlayerId) return cur;

      cur.turn = {
        currentPlayerId: nextPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        drawnTypes: { green:false, white:false, black:false },
        movedByDiceRoomId: null,
        room3ActionUsed: false,
        room4StealUsed: false,
        repeatTurnRemaining: nextRepeatRemaining,
        repeatTurnTotal: nextRepeatTotal,
        sealWisdomBonus: false,
        updatedAt: Date.now()
      };
      if (cur.guardianAngelShield && cur.guardianAngelShield[nextPlayerId]){
        delete cur.guardianAngelShield[nextPlayerId];
      }
      if (cur.gordonBarrier && cur.gordonBarrier[nextPlayerId]){
        delete cur.gordonBarrier[nextPlayerId];
      }
      advanced = true;
      return cur;
    });
    return advanced;
  }

  function toGreenOrder(){
    return GREEN_DECK.map(x => {
      const text = safeText(x?.text||"").replace(/^推理カード：/,"").trim();
      return { name:"推理カード", effect:text };
    });
  }
  function toWhiteOrder(){ return WHITE_DECK.map(x => ({ name:safeText(x.name), effect:safeText(x.effect) })); }
  function toBlackOrder(){ return BLACK_DECK.map(x => ({ name:safeText(x.name), effect:safeText(x.effect) })); }
  function remainingCount(d){
    const o = Array.isArray(d?.order) ? d.order.length : 0;
    const i = Number(d?.idx||0);
    return Math.max(0, o - i);
  }

  let deckCache = null;
  function subscribeDeckState(){
    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    onValue(dsRef, snap => {
      deckCache = snap.val() || null;
      renderDeckRowFromRoom();
      updateEquipDockTop();
    });
  }

  async function ensureRoomDeckState(){
    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    await runTransaction(dsRef, (cur) => {
      if (cur && cur.green && cur.white && cur.black) return cur;

      const green = { order: shuffle(toGreenOrder()), idx: 0 };
      const white = { order: shuffle(toWhiteOrder()), idx: 0 };
      const black = { order: shuffle(toBlackOrder()), idx: 0 };

      return {
        green, white, black,
        reveal: { slot3: null, slot5: null },
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };
    });
  }

  async function drawFromSharedDeck(type, { viaParasol=false } = {}){
    if (!state.roomCode) return;
    if (viaParasol){
      if (type !== "green" || !canUseParasolGreenDraw()) return;
    } else if (!canDrawTypeNormally(type)){
      return;
    }

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let drawn = null;

    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      if (!cur.turn || safeText(cur.turn.currentPlayerId || "") !== state.userId) return cur;

      const turn = cur.turn;
      const allowUnlimitedDraw = isTestPlayer();
      if (!turn.moveDone || turn.attackDone) return cur;
      if (!viaParasol && !allowUnlimitedDraw && turn.deckDrawDone) return cur;

      const ds = cur.deckState;
      if (!ds || !ds[type] || !Array.isArray(ds[type].order)) return cur;

      const d = ds[type];
      const idx = Number(d.idx || 0);
      if (idx >= d.order.length) return cur;

      drawn = d.order[idx];
      d.idx = idx + 1;

      ds.reveal = ds.reveal || { slot3:null, slot5:null };
      if (type === "black"){
        ds.reveal.slot5 = { theme:"black", card: drawn, at: Date.now() };
      } else if (type === "white"){
        ds.reveal.slot3 = { theme:"white", card: drawn, at: Date.now() };
      }

      if (viaParasol){
        turn.attackDone = true;
        turn.attackAt = Date.now();
      } else if (!allowUnlimitedDraw) {
        turn.deckDrawDone = true;
      }
      turn.drawnTypes = {
        green: !!(turn?.drawnTypes?.green || type === "green"),
        white: !!(turn?.drawnTypes?.white || type === "white"),
        black: !!(turn?.drawnTypes?.black || type === "black")
      };
      turn.updatedAt = Date.now();
      ds.updatedAt = Date.now();
      return cur;
    });

    if (drawn && (type === "white" || type === "black")){
      clearDiceRollTimers();
      if (diceRollOverlay) diceRollOverlay.innerHTML = '';
      await grantEquipmentToMe(drawn, type);
      await applyImmediateDeckCardEffect(drawn);
    } else if (drawn && type === "green"){
      clearDiceRollTimers();
      if (diceRollOverlay) diceRollOverlay.innerHTML = '';
      openZoomFromDeckCard(drawn, "green", { closeOnBackdrop:false, showCloseButton:false });
      openGreenShareDock(drawn, { attackRangeOnly: viaParasol });
    }

    if (drawn){
      const cardName = safeText(drawn?.name || "カード");
      const cardEffect = safeText(drawn?.effect || "");
      const selectionCards = new Set(["応急手当", "恩恵", "吸血コウモリ", "三つ目の黒犬", "呪いの人形"]);
      const skipBasic = type === "green" || selectionCards.has(cardName);
      if (!skipBasic){
        const themeLabel = type === "white" ? "白" : (type === "black" ? "黒" : "緑");
        const tail = (type === "green" && cardEffect) ? ` ${cardEffect}` : "";
        appendActionChatLog(state.userId, `${themeLabel}ドロー：[${cardName}]${tail}`).catch(() => {});
      }
    }

    scheduleDeckRebuildIfEmpty(type).catch(() => {});
  }

  function baseOrderWithoutEquip(type){
    if (type === "green") return toGreenOrder();
    if (type === "white") return toWhiteOrder().filter(card => !isEquipCard(card));
    if (type === "black") return toBlackOrder().filter(card => !isEquipCard(card));
    return [];
  }

  function recycleRevivedPlayerEquipIntoDeck(cur, uid){
    const targetUid = safeText(uid || "");
    if (!cur || !targetUid) return;
    const equipRow = cur?.equipment?.[targetUid];
    if (!equipRow || typeof equipRow !== "object") return;

    const returnedByType = { white: [], black: [] };

    for (const [key, item] of Object.entries(equipRow)){
      if (!item || item.kind === "identity") continue;
      if (!isEquipCard(item)) continue;
      const theme = safeText(item.theme || "");
      if (theme !== "white" && theme !== "black") continue;
      returnedByType[theme].push({
        name: safeText(item.name || ""),
        effect: safeText(item.effect || "")
      });
      delete equipRow[key];
    }

    if (Object.keys(equipRow).length === 0){
      delete cur.equipment[targetUid];
    }

    for (const type of ["white", "black"]){
      const returned = returnedByType[type];
      if (!returned.length) continue;
      const deck = cur?.deckState?.[type];
      if (!deck || typeof deck !== "object") continue;
      const order = Array.isArray(deck.order) ? deck.order : [];
      const idx = Math.max(0, Math.min(Number(deck.idx || 0), order.length));
      const remaining = order.slice(idx);
      deck.order = shuffle([...remaining, ...returned]);
      deck.idx = 0;
      delete deck.rebuildPendingAt;
    }
  }

  function isEliminatedInRoomState(cur, uid){
    if (!cur || !uid) return false;
    const roleId = safeText(cur?.hands?.[uid]?.roleId || "");
    const hp = Number(ROLE_BY_ID?.[roleId]?.hp || 0);
    if (!hp) return false;
    const dmg = clampDamage(Number(cur?.damage?.[uid] || 0));
    return dmg >= hp;
  }

  function collectEliminatedEquipCardsForDeck(cur, type){
    const recycled = [];
    if (!cur?.equipment || !type) return recycled;
    for (const [uid, row] of Object.entries(cur.equipment || {})){
      if (!isEliminatedInRoomState(cur, uid) || !row || typeof row !== "object") continue;
      for (const [key, item] of Object.entries(row)){
        if (!item || item.kind === "identity") continue;
        if (!isEquipCard(item)) continue;
        if (safeText(item.theme || "") !== type) continue;
        recycled.push({
          name: safeText(item.name || ""),
          effect: safeText(item.effect || "")
        });
        delete row[key];
      }
      if (Object.keys(row).length === 0){
        delete cur.equipment[uid];
      }
    }
    return recycled;
  }

  async function scheduleDeckRebuildIfEmpty(type){
    if (!state.roomCode || !["green","white","black"].includes(type)) return;
    if (deckRebuildTimers[type]) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    let pendingAt = 0;
    const tx = await runTransaction(roomRef, (cur) => {
      if (!cur?.deckState?.[type]) return cur;
      const deck = cur.deckState[type];
      const idx = Number(deck.idx || 0);
      const total = Array.isArray(deck.order) ? deck.order.length : 0;
      if (idx < total) return cur;
      const prevPending = Number(deck.rebuildPendingAt || 0);
      if (prevPending > 0) return cur;
      pendingAt = Date.now();
      deck.rebuildPendingAt = pendingAt;
      cur.deckState.updatedAt = Date.now();
      return cur;
    });
    if (!tx?.committed || !pendingAt) return;

    deckRebuildTimers[type] = setTimeout(async () => {
      deckRebuildTimers[type] = null;
      await runTransaction(roomRef, (cur) => {
        if (!cur?.deckState?.[type]) return cur;
        const deck = cur.deckState[type];
        if (Number(deck.rebuildPendingAt || 0) !== pendingAt) return cur;
        const idx = Number(deck.idx || 0);
        const total = Array.isArray(deck.order) ? deck.order.length : 0;
        if (idx < total){
          delete deck.rebuildPendingAt;
          return cur;
        }
        const base = baseOrderWithoutEquip(type);
        const recycled = collectEliminatedEquipCardsForDeck(cur, type);
        deck.order = shuffle([...base, ...recycled]);
        deck.idx = 0;
        cur.deckState.reveal = cur.deckState.reveal || { slot3:null, slot5:null };
        if (type === "white") cur.deckState.reveal.slot3 = null;
        if (type === "black") cur.deckState.reveal.slot5 = null;
        delete deck.rebuildPendingAt;
        cur.deckState.updatedAt = Date.now();
        return cur;
      });
    }, 2000);
  }

  function renderDeckRowFromRoom(){
    if (!deckCache || !deckCache.green || !deckCache.white || !deckCache.black){
      setSlotAsDeck(slot1, 'greendeck.jpg', 0, { disabled:true, type:"green" });
      setSlotAsDeck(slot2, 'whitedeck.jpg', 0, { disabled:true, type:"white" });
      setSlotEmptyNoFrame(slot3);
      setSlotAsDeck(slot4, 'blackdeck.jpg', 0, { disabled:true, type:"black" });
      setSlotEmptyNoFrame(slot5);
      bindDeckClicksShared();
      updateCardInteractivity();
      return;
    }

    const gLeft = remainingCount(deckCache.green);
    const wLeft = remainingCount(deckCache.white);
    const bLeft = remainingCount(deckCache.black);

    setSlotAsDeck(slot1, 'greendeck.jpg', gLeft, { disabled: gLeft===0, type:"green" });
    setSlotAsDeck(slot2, 'whitedeck.jpg', wLeft, { disabled: wLeft===0, type:"white" });
    setSlotAsDeck(slot4, 'blackdeck.jpg', bLeft, { disabled: bLeft===0, type:"black" });

    const r3 = deckCache?.reveal?.slot3;
    const r5 = deckCache?.reveal?.slot5;

    if (r3 && r3.card){
      setSlotAsWbFront(slot3, r3.card, r3.theme || "white");
    } else {
      setSlotEmptyNoFrame(slot3);
    }

    if (r5 && r5.card){
      setSlotAsWbFront(slot5, r5.card, "black");
    } else {
      setSlotEmptyNoFrame(slot5);
    }

    bindDeckClicksShared();
    updateCardInteractivity();
  }

  function bindDeckClicksShared(){
    const s1 = slot1.cloneNode(true);
    slot1.parentNode.replaceChild(s1, slot1);
    slot1 = s1;
    slot1.dataset.cardType = "green";
    slot1.style.backgroundImage = remainingCount(deckCache?.green) <= 0 ? 'none' : `url('greendeck.jpg')`;
    slot1.style.backgroundColor = remainingCount(deckCache?.green) <= 0 ? '#f3f4f6' : '';
    ensureCountTag(slot1);

    const s2 = slot2.cloneNode(true);
    slot2.parentNode.replaceChild(s2, slot2);
    slot2 = s2;
    slot2.dataset.cardType = "white";
    slot2.style.backgroundImage = remainingCount(deckCache?.white) <= 0 ? 'none' : `url('whitedeck.jpg')`;
    slot2.style.backgroundColor = remainingCount(deckCache?.white) <= 0 ? '#f3f4f6' : '';
    ensureCountTag(slot2);

    const s4 = slot4.cloneNode(true);
    slot4.parentNode.replaceChild(s4, slot4);
    slot4 = s4;
    slot4.dataset.cardType = "black";
    slot4.style.backgroundImage = remainingCount(deckCache?.black) <= 0 ? 'none' : `url('blackdeck.jpg')`;
    slot4.style.backgroundColor = remainingCount(deckCache?.black) <= 0 ? '#f3f4f6' : '';
    ensureCountTag(slot4);

    slot1.addEventListener('click', async (e) => {
      const left = remainingCount(deckCache?.green);
      if (!canClickType("green")) return;
      if (left <= 0) return;
      if (canDrawTypeNormally("green")){
        await drawFromSharedDeck("green");
        return;
      }
      if (!canUseParasolGreenDraw()) return;
      const clickX = Number(e?.clientX || (window.innerWidth / 2));
      const clickY = Number(e?.clientY || (window.innerHeight / 2));
      showRoomActionPopAt(
        clickX,
        clickY,
        "攻撃の代わりにカードを引きますか。（虹色のパラソル）",
        async () => {
          const warningMessage = parasolBlockedDrawWarningMessage();
          if (!warningMessage){
            await drawFromSharedDeck("green", { viaParasol:true });
            return;
          }
          showRoomActionPopAt(
            clickX,
            clickY,
            warningMessage,
            async () => {
              await drawFromSharedDeck("green", { viaParasol:true });
            },
            { noCaret:true, yesLabel:"OK", noLabel:"やめる" }
          );
        },
        { noCaret:true }
      );
    });
    slot2.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.white);
      if (!canClickType("white")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("white");
    });
    slot4.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.black);
      if (!canClickType("black")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("black");
    });
  }

  const cardsPanelEl = document.getElementById("cardsPanel");
  cardsPanelEl.addEventListener("click", (e) => {
    if (isEquipSelectionLockActive()) return;
    const card = e.target.closest(".card72.wb-front");
    if (!card) return;
    if (card.classList.contains("locked") || card.classList.contains("blocked")) return;
    const selectionAction = captureSelectionRestoreAction();
    if (selectionAction){
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
      setZoomPassthrough(false);
      zoomDismissHandler = async () => {
        await restoreSelectionAction(selectionAction);
      };
      return;
    }
    openZoomFromCard(card);
  });

  const roomSvg = document.getElementById('roomSvg');
  const roomG   = document.getElementById('roomG');

  function svgEl(name, attrs={}, parent=roomG){
    const n = document.createElementNS('http://www.w3.org/2000/svg', name);
    for(const k in attrs) n.setAttribute(k, attrs[k]);
    parent.appendChild(n);
    return n;
  }
  function ptsToStr(pts){ return pts.map(p=>`${p[0]},${p[1]}`).join(' '); }
  function poly(pts, cls, parent=roomG){ return svgEl('polygon', {points: ptsToStr(pts), class: cls}, parent); }

  function ensureRoomPatterns(){
    let defs = roomSvg.querySelector('#roomPatternDefs');
    if (defs) return defs;
    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.setAttribute('id', 'roomPatternDefs');
    roomSvg.insertBefore(defs, roomSvg.firstChild);

    const roomImageScaleMap = {
      1: 2.7,
      2: 1.90,
      3: 2.80,
      4: 2.80,
      5: 1.90,
      6: 2.20,
      7: 1.05,
    };

    for (let roomId = 1; roomId <= 7; roomId++){
      const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
      pattern.setAttribute('id', `roomPattern${roomId}`);
      pattern.setAttribute('patternUnits', 'objectBoundingBox');
      pattern.setAttribute('patternContentUnits', 'userSpaceOnUse');
      pattern.setAttribute('viewBox', '0 0 100 100');
      pattern.setAttribute('width', '1');
      pattern.setAttribute('height', '1');

      const scale = roomImageScaleMap[roomId] || 1;
      const imageSize = 100 * scale;
      const imageOffset = (100 - imageSize) / 2;
      const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      image.setAttribute('href', `room${roomId}.jpg`);
      image.setAttribute('x', String(imageOffset));
      image.setAttribute('y', String(imageOffset));
      image.setAttribute('width', String(imageSize));
      image.setAttribute('height', String(imageSize));
      image.setAttribute('preserveAspectRatio', 'xMidYMid slice');

      pattern.appendChild(image);
      defs.appendChild(pattern);
    }
    return defs;
  }

  function hexFlat(cx, cy, s){
    const rt3 = Math.sqrt(3);
    const h = (rt3/2)*s;
    return [
      [cx+s,   cy],
      [cx+s/2, cy+h],
      [cx-s/2, cy+h],
      [cx-s,   cy],
      [cx-s/2, cy-h],
      [cx+s/2, cy-h],
    ];
  }
  function buildStarRooms(cx, cy, s0, t, tip){
    const P = hexFlat(cx, cy, s0);

    const add=(a,b)=>[a[0]+b[0],a[1]+b[1]];
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
    const mul=(a,k)=>[a[0]*k,a[1]*k];
    const norm=(v)=>{ const L=Math.hypot(v[0],v[1])||1; return [v[0]/L,v[1]/L]; };

    function intersectRayRay(p,u,q,v){
      const det = u[0]*(-v[1]) - u[1]*(-v[0]);
      const b = sub(q,p);
      const s = ( b[0]*(-v[1]) - b[1]*(-v[0]) ) / det;
      return add(p, mul(u, s));
    }
    function outwardNormal(a,b){
      const u = norm(sub(b,a));
      return [u[1], -u[0]];
    }

    const lines = [];
    for(let i=0;i<6;i++){
      const a = P[i], b = P[(i+1)%6];
      const d = norm(sub(b,a));
      const n = outwardNormal(a,b);
      const p0 = add(a, mul(n, t));
      lines.push({ p:p0, d, n });
    }

    const Q = [];
    for(let i=0;i<6;i++){
      const L0 = lines[(i+5)%6];
      const L1 = lines[i];
      Q.push(intersectRayRay(L0.p, L0.d, L1.p, L1.d));
    }

    const T = [];
    for(let i=0;i<6;i++){
      const a = P[i], b = P[(i+1)%6];
      const mid = mul(add(a,b), 0.5);
      const n = lines[i].n;
      T.push(add(mid, mul(n, tip)));
    }

    const rooms = [];
    for(let i=0;i<6;i++){
      const i2 = (i+1)%6;
      rooms.push([ P[i], P[i2], Q[i2], T[i], Q[i] ]);
    }

    return { centerHex:P, rooms };
  }

  const cx  = 0,  cy  = 0;
  const s0  = 48;
  const t   = 26;
  const tip = 90;

  function fitRoomViewBox(margin = 2){
    const bb = roomG.getBBox();
    const x = bb.x - margin;
    const y = bb.y - margin;
    const w = bb.width + margin*2;
    const h = bb.height + margin*2;
    roomSvg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
  }

  let markerLayer = null;
  let attackRangeLayer = null;
  let roomGuideLayer = null;
  let markerCache = {};
  const roomShapeEls = {};
  const roomHitEls = {};
  let autoMoveTriggeredTurnKey = "";
  const roomPolygons = {};
  let roomGuideVisible = false;
  const ROOM_GUIDE_LINES = {
    1: ["白カードが", "ひける。"],
    2: ["黒カードが", "ひける。"],
    3: ["任意のプレイヤーへ", "2ダメージ / 1回復"],
    4: ["任意のプレイヤーから", "装備をうばう"],
    5: ["推理カードが", "ひける"],
    6: ["推理 / 白 / 黒カード", "がひける"],
    7: ["次の手番に自由に", "移動できる"]
  };
  const ROOM_GUIDE_OFFSET = {
    1:[0,-5],2:[0,-5],3:[0,-5],4:[0,-5],5:[0,-5],6:[0,-5],7:[0,0]
  };
  const agathaRevealOverlay = document.getElementById('agathaRevealOverlay');
  const diceRollOverlay = document.getElementById('diceRollOverlay');
  let diceRollTimers = [];
  let agathaRevealHideTimer = null;
  let agathaRevealVisibleUntil = 0;
  let pendingMoveChoice = null;

  function clearDiceRollTimers(){
    for (const id of diceRollTimers) clearTimeout(id);
    diceRollTimers = [];
  }

  function hideAgathaRevealCardOverlay(){
    if (agathaRevealHideTimer){
      clearTimeout(agathaRevealHideTimer);
      agathaRevealHideTimer = null;
    }
    agathaRevealVisibleUntil = 0;
    if (agathaRevealOverlay){
      agathaRevealOverlay.innerHTML = '';
      agathaRevealOverlay.classList.add('hidden');
    }
  }

  function showAgathaRevealCardOverlay(uid, options = {}){
    if (!agathaRevealOverlay) return;
    const roleId = safeText(state.hands?.[uid]?.roleId || "CIT_A3");
    const role = ROLE_BY_ID[roleId] || ROLE_BY_ID.CIT_A3;
    if (!role) return;

    const duration = Math.max(0, Number(options.duration || 1200));
    const requestedCloseAt = Number(options.closeAt || 0);
    const closeAt = requestedCloseAt > 0 ? requestedCloseAt : (Date.now() + duration);
    if (closeAt <= agathaRevealVisibleUntil) return;

    agathaRevealVisibleUntil = closeAt;
    agathaRevealOverlay.innerHTML = '';
    agathaRevealOverlay.appendChild(createIdentityCard(role));
    agathaRevealOverlay.classList.remove('hidden');

    if (agathaRevealHideTimer) clearTimeout(agathaRevealHideTimer);
    const remainMs = Math.max(0, closeAt - Date.now());
    agathaRevealHideTimer = setTimeout(() => {
      hideAgathaRevealCardOverlay();
    }, remainMs);
  }

  function myEquipmentNames(){
    return listEquipForUid(state.userId)
      .filter(v => !isIdentityEquipItem(v))
      .map(v => safeText(v?.name))
      .filter(Boolean);
  }

  function hasMyEquipmentByName(name){
    const n = safeText(name);
    if (!n) return false;
    return myEquipmentNames().includes(n);
  }

  function hasEquipmentByName(uid, name){
    const targetUid = safeText(uid);
    const targetName = safeText(name);
    if (!targetUid || !targetName) return false;
    return listEquipForUid(targetUid)
      .filter(v => !isIdentityEquipItem(v))
      .map(v => safeText(v?.name))
      .includes(targetName);
  }

  function countEquipmentByNames(uid, names){
    const targetUid = safeText(uid);
    const nameSet = new Set((names || []).map(v => safeText(v)).filter(Boolean));
    if (!targetUid || nameSet.size === 0) return 0;
    return listEquipForUid(targetUid)
      .filter(v => !isIdentityEquipItem(v))
      .reduce((sum, item) => sum + (nameSet.has(safeText(item?.name)) ? 1 : 0), 0);
  }

  function calcAttackDamageFromRoll(attackerUid, d6, d4, options = {}){
    const uid = safeText(attackerUid);
    const a = Number(d6) || 0;
    const b = Number(d4) || 0;
    if (!uid) return 0;

    const plusDamageFromEquipment = countEquipmentByNames(uid, ["サーベル", "拳銃R", "拳銃L", "クロスボウガン"]);
    const d4OnlyMode = !!options.masamuneMode || !!options.vendettaMode;

    if (!d4OnlyMode && !didAttackRollSucceed(a, b, options)) return 0;

    let damage = d4OnlyMode ? b : Math.abs(a - b);
    damage += plusDamageFromEquipment;

    const role = roleInfoByUid(uid);
    if (role && hasEquipmentByName(uid, "エクスカリバー") && isIdentityRevealedFor(uid) && role.faction === "レイダー"){
      damage += 2;
    }

    if (hasEquipmentByName(uid, "賢者のローブ")){
      damage -= 1;
    }

    const targetUid = safeText(options.targetUid || "");
    if (uid === state.userId && isMyRole("RAI_F3") && isMyIdentityRevealed() && !isMyAbilitySealed() && targetUid && isIdentityRevealedFor(targetUid)){
      damage += 2;
    }

    if (options.excaliburRevealBoost){
      damage += 2;
    }

    return Math.max(0, damage);
  }

  function excaliburExtraDamageRows(rows = [], amount = 2){
    const plus = Math.max(0, Number(amount) || 0);
    if (plus <= 0) return rows;
    return (rows || []).map(item => {
      const uid = safeText(item?.uid || "");
      const base = Math.max(0, Number(item?.damage || 0));
      if (!uid) return { ...item, damage: base };
      const add = applyIncomingDamageModifiers(uid, plus, { source:"attack" });
      return { ...item, uid, damage: Math.max(0, base + add) };
    });
  }

  function applyAttackResultBonusRows(rows = []){
    return (Array.isArray(rows) ? rows : []).map(item => {
      const uid = safeText(item?.uid || "");
      const baseDamage = Math.max(0, Number(item?.damage || 0));
      const bonusAmount = Math.max(0, Number(item?.bonusLabelAmount || 0));
      if (!uid || bonusAmount <= 0){
        return { ...item, uid, damage: baseDamage, bonusLabelAmount: 0 };
      }
      const addDamage = applyIncomingDamageModifiers(uid, bonusAmount, { source:"attack" });
      return {
        ...item,
        uid,
        damage: Math.max(0, baseDamage + addDamage),
        bonusLabelAmount: 0
      };
    });
  }

  function buildExcaliburAttackMeta({ attackerUid, targetUid, attackSucceeded, d6, d4 }){
    const uid = safeText(attackerUid);
    if (uid !== state.userId) return null;
    const role = myRoleInfo();
    if (!role || role.faction !== "レイダー") return null;
    if (!hasEquipmentByName(uid, "エクスカリバー")) return null;
    if (isMyIdentityRevealed()) return null;

    const roleId = safeText(role.id || "");
    const success = !!attackSucceeded;
    const sameDice = (Number(d6) || 0) === (Number(d4) || 0);
    return {
      showBonusLabel: success,
      allowExcaliburButton: success && !sameDice,
      autoBoost: false,
      freddieSpecial: false
    };
  }

  function applyIncomingDamageModifiers(uid, amount, options = {}){
    const targetUid = safeText(uid);
    let add = Math.max(0, Number(amount) || 0);
    if (!targetUid || add <= 0) return 0;
    if (options.source === "attack" && hasGuardianAngelShield(targetUid)){
      return 0;
    }
    if (!isGordonBarrierHpChangeAllowed(targetUid, options.source || "")){
      return 0;
    }
    if (options.source === "attack" && hasEquipmentByName(targetUid, "賢者のローブ")){
      add -= 1;
    }
    return Math.max(0, add);
  }

  function clearPendingMoveChoiceUi(){
    for (let roomId = 1; roomId <= 7; roomId++){
      roomShapeEls[roomId]?.classList.remove('room-choice-once');
      roomHitEls[roomId]?.classList.remove('room-choice-once');
    }
  }

  const EMI_TELEPORT_ROOM_NAMES = {
    1: "大聖堂",
    2: "地下通路",
    3: "市庁舎",
    4: "オリバーの隠れ場",
    5: "探偵事務所",
    6: "ブラックミスト地区",
    7: "飛行船"
  };

  function adjacentOuterRoomIds(roomId){
    const rid = Number(roomId || 0);
    if (!Number.isFinite(rid) || rid < 1 || rid > 6) return [];
    const left = rid === 1 ? 6 : (rid - 1);
    const right = rid === 6 ? 1 : (rid + 1);
    return [left, right];
  }

  function isMyIdentityRevealedThisTurn(){
    if (!isMyIdentityRevealed()) return false;
    const revealedAt = Number(equipCache?.[state.userId]?.identity?.revealedAt || 0);
    const turnUpdatedAt = Number(turnState()?.updatedAt || 0);
    if (!revealedAt || !turnUpdatedAt) return false;
    return revealedAt >= turnUpdatedAt;
  }

  function emiTeleportChoiceRoomIds(){
    if (!isGameStarted()) return [];
    if (!isMyTurn()) return [];
    if (!isMyRole("RAI_E1")) return [];
    if (!isMyIdentityRevealed()) return [];
    if (!turnState()?.moveDone || !!turnState()?.attackDone) return [];
    if (!!turnState()?.deckDrawDone) return [];
    const roomActionState = turnRoomActionState();
    if (roomActionState.room3ActionUsed || roomActionState.room4StealUsed) return [];
    if (!!turnState()?.emiTeleportUsed) return [];
    const myMarker = markerCache?.[state.userId] || null;
    const nowRoom = markerRoomId(myMarker);
    return adjacentOuterRoomIds(nowRoom);
  }

  async function confirmAndMoveByEmiTeleport(roomId, clickX, clickY){
    const rid = Number(roomId || 0);
    if (!emiTeleportChoiceRoomIds().includes(rid)) return false;
    const roomName = safeText(EMI_TELEPORT_ROOM_NAMES[rid] || `ROOM${rid}`);
    showRoomActionPopAt(clickX, clickY, `「${roomName}」に移動しますか。`, async () => {
      if (!isMyIdentityRevealedThisTurn()){
        await emitRoleFlashEvent("RAI_E1", "emi_teleport", 1800);
      }
      await placeMarkerInRoom(rid);
      if (state.roomCode && isMyTurn()){
        await update(ref(db, `rooms/${state.roomCode}/turn`), {
          emiTeleportUsed: true,
          updatedAt: Date.now()
        });
      }
    }, {
      yesLabel: "はい",
      noLabel: "いいえ"
    });
    return true;
  }

  function bringRoomPulseToFront(roomId){
    const shape = roomShapeEls[roomId];
    const hit = roomHitEls[roomId];
    if (!shape || !roomG) return;
    const anchor =
      (attackRangeLayer && attackRangeLayer.parentNode === roomG && attackRangeLayer) ||
      (markerLayer && markerLayer.parentNode === roomG && markerLayer) ||
      (roomGuideLayer && roomGuideLayer.parentNode === roomG && roomGuideLayer) ||
      null;
    if (anchor){
      roomG.insertBefore(shape, anchor);
      if (hit) roomG.insertBefore(hit, anchor);
      return;
    }
    roomG.appendChild(shape);
    if (hit) roomG.appendChild(hit);
  }

  function setPendingMoveChoice(roomIds){
    clearPendingMoveChoiceUi();
    const unique = [...new Set((roomIds || []).filter(v => Number.isFinite(v) && v >= 1 && v <= 7))];
    pendingMoveChoice = unique.length ? { roomIds: unique, consumed: false } : null;
    for (const rid of unique){
      roomShapeEls[rid]?.classList.add('room-choice-once');
      roomHitEls[rid]?.classList.add('room-choice-once');
    }
    updateRoomChoiceUi();
    updateAttackRangeUi();
    refreshRoomAbilityHint();
  }

  function mySeatMoveChoiceFromRoom(){
    const seatIndex = Number(state.seatedTable || 0);
    if (!seatIndex) return null;
    const table = state.room?.tables?.[String(seatIndex)] || null;
    if (!table || safeText(table.playerId || "") !== safeText(state.userId || "")) return null;
    const node = table.moveDiceChoice || null;
    if (!node || typeof node !== "object") return null;
    const roomIds = Array.isArray(node.roomIds)
      ? [...new Set(node.roomIds.map(v => Number(v)).filter(v => Number.isFinite(v) && v >= 1 && v <= 7))]
      : [];
    if (!roomIds.length) return null;
    return {
      roomIds,
      d6: Number(node.d6 || 0),
      d4: Number(node.d4 || 0),
      secondD6: Number(node.secondD6 || 0),
      secondD4: Number(node.secondD4 || 0),
      at: Number(node.at || 0)
    };
  }

  async function saveMySeatMoveChoice(payload = null){
    if (!state.roomCode || !state.seatedTable) return;
    await set(ref(db, `rooms/${state.roomCode}/tables/${state.seatedTable}/moveDiceChoice`), payload);
  }

  function clearPendingMoveChoiceState(){
    if (!pendingMoveChoice) return;
    pendingMoveChoice = null;
    clearPendingMoveChoiceUi();
    updateRoomChoiceUi();
    refreshRoomAbilityHint();
  }

  function syncPendingMoveChoiceOwnership(){
    const seatIndex = Number(state.seatedTable || 0);
    if (!seatIndex){
      clearPendingMoveChoiceState();
      return;
    }
    const table = state.room?.tables?.[String(seatIndex)] || null;
    const isSeatOwner = !!table && safeText(table.playerId || "") === safeText(state.userId || "");
    if (!isSeatOwner){
      clearPendingMoveChoiceState();
      return;
    }
    if (!isMyTurn() || !!turnState()?.moveDone){
      clearPendingMoveChoiceState();
    }
  }

  function restorePendingMoveChoiceFromSeat(){
    if (!isMyTurn()) return;
    if (!!turnState()?.moveDone) return;
    const saved = mySeatMoveChoiceFromRoom();
    if (!saved) return;
    const now = pendingMoveChoice || null;
    const sameChoice = !!now
      && !now.consumed
      && Array.isArray(now.roomIds)
      && now.roomIds.length === saved.roomIds.length
      && now.roomIds.every((rid, idx) => rid === saved.roomIds[idx]);
    if (sameChoice) return;
    setPendingMoveChoice(saved.roomIds);
  }

  async function resolvePendingMoveChoice(roomId){
    if (!pendingMoveChoice || pendingMoveChoice.consumed) return false;
    if (!pendingMoveChoice.roomIds.includes(roomId)) return false;
    pendingMoveChoice.consumed = true;
    clearPendingMoveChoiceUi();
    pendingMoveChoice = null;
    await placeMarkerInRoom(roomId);
    await saveMySeatMoveChoice(null);
    if (state.roomCode && isMyTurn()){
      await update(ref(db, `rooms/${state.roomCode}/turn`), {
        moveDone: true,
        moveAt: Date.now()
      });
    }
    const cleanupTimer = setTimeout(() => {
      diceRollOverlay.innerHTML = '';
      clearDiceRollTimers();
    }, 1000);
    updateRoomChoiceUi();
    diceRollTimers.push(cleanupTimer);
    return true;
  }

  function dicePipsD6(face){
    const map = {
      1:["mc"],
      2:["tl","br"],
      3:["tl","mc","br"],
      4:["tl","tr","bl","br"],
      5:["tl","tr","mc","bl","br"],
      6:["tl","ml","bl","tr","mr","br"]
    };
    return map[face] || map[1];
  }

  function renderD6Face(el, face){
    el.innerHTML = '';
    for (const klass of dicePipsD6(face)){
      const pip = document.createElement('span');
      pip.className = `pip ${klass}`;
      el.appendChild(pip);
    }
  }

  function renderD4Face(el, face){
    el.innerHTML = '';
    const num = document.createElement('span');
    num.className = 'd4-num';
    num.textContent = String(Math.max(1, Math.min(4, Number(face) || 1)));
    el.appendChild(num);
  }

  function randomCornerStart(width, height){
    const corner = Math.floor(Math.random() * 4);
    const pad = 40;
    if (corner === 0) return { x: width - pad, y: pad };      // 右上
    if (corner === 1) return { x: width - pad, y: height - pad }; // 右下
    if (corner === 2) return { x: pad, y: height - pad };      // 左下
    return { x: pad, y: pad };                                  // 左上
  }

  function randomCenterOffsets(){
    let a = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
    let b = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
    let guard = 0;
    while (Math.hypot(a.x-b.x, a.y-b.y) < 62 && guard < 40){
      b = { x:(Math.random()-0.5)*100, y:(Math.random()-0.5)*100 };
      guard++;
    }
    if (Math.hypot(a.x-b.x, a.y-b.y) < 62){
      b = { x:a.x + 64, y:a.y + 10 };
    }
    return [a,b];
  }

  function randomCenterLandingPoint(width, height){
    const cx = width / 2;
    const cy = height / 2;
    const rangeX = Math.max(40, width * 0.12);
    const rangeY = Math.max(36, height * 0.10);
    const x = cx + (Math.random() * 2 - 1) * rangeX;
    const y = cy + (Math.random() * 2 - 1) * rangeY;
    return {
      x: Math.max(50, Math.min(width - 50, x)),
      y: Math.max(50, Math.min(height - 50, y))
    };
  }

  function createDiceMotion(width, height, endX, endY){
    const startBase = randomCornerStart(width, height);
    const [offsetA, offsetB] = randomCenterOffsets();
    const startDegA = Math.random() * 90;
    const startDegB = Math.random() * 90;
    const endDegA = startDegA + 720 + Math.random() * 360;
    const endDegB = startDegB + 720 + Math.random() * 360;
    return { startBase, offsetA, offsetB, startDegA, startDegB, endDegA, endDegB, endX, endY };
  }

  function setFlyerTransform(el, x, y, deg){
    el.style.transform = `translate(${x}px, ${y}px) rotate(${deg}deg)`;
  }

  function diceTotalToRoomId(total){
    if (total === 2 || total === 3) return 5;
    if (total === 4 || total === 5) return 6;
    if (total === 6) return 1;
    if (total === 7) return 2;
    if (total === 8) return 3;
    if (total === 9) return 4;
    if (total === 10) return 7;
    return null;
  }

  function pointInPolygon(x, y, pts){
    let inside = false;
    for (let i = 0, j = pts.length - 1; i < pts.length; j = i++){
      const xi = pts[i][0], yi = pts[i][1];
      const xj = pts[j][0], yj = pts[j][1];
      const intersects = ((yi > y) !== (yj > y))
        && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
      if (intersects) inside = !inside;
    }
    return inside;
  }

  function previousRoomId(roomId){
    if (roomId === 1) return 6;
    if (roomId >= 2 && roomId <= 6) return roomId - 1;
    return null;
  }

  function attackTargetRoomIdsFromRoom(roomId, extraScope = 0){
    const current = Number(roomId);
    if (!Number.isFinite(current) || current < 1 || current > 7) return new Set();
    if (current === 7) return new Set([1,2,3,4,5,6,7]);

    const bonus = Math.max(0, Number(extraScope) || 0);
    const rooms = new Set([current, 7]);
    let cursor = current;

    for (let i = 0; i < 1 + bonus; i++){
      cursor = previousRoomId(cursor);
      if (!cursor) break;
      rooms.add(cursor);
    }
    return rooms;
  }

  function attackRangeTargetUidsFor(uid = state.userId){
    const attackerUid = safeText(uid);
    if (!attackerUid) return new Set();
    const myMarker = markerCache?.[attackerUid] || null;
    const myRoomId = markerRoomId(myMarker);
    if (!myRoomId) return new Set();

    const deadScopeCount = countEquipmentByNames(attackerUid, ["死神スコープ"]);
    const attackRooms = attackTargetRoomIdsFromRoom(myRoomId, deadScopeCount);
    const targets = new Set();
    for (const [targetUid, marker] of Object.entries(markerCache || {})){
      if (!marker || targetUid === attackerUid) continue;
      if (isPlayerEliminated(targetUid)) continue;
      const rid = markerRoomId(marker);
      if (!rid || !attackRooms.has(rid)) continue;
      if (isAttackTargetProtected(targetUid)) continue;
      targets.add(targetUid);
    }
    return targets;
  }

  function walpurgisSwapCanAttackAfterSwap(targetUid){
    const myUid = safeText(state.userId || "");
    const otherUid = safeText(targetUid || "");
    if (!myUid || !otherUid || myUid === otherUid) return false;
    const myMarker = markerCache?.[myUid] || null;
    const targetMarker = markerCache?.[otherUid] || null;
    const myRoomId = markerRoomId(myMarker);
    const swappedRoomId = markerRoomId(targetMarker);
    if (!myRoomId || !swappedRoomId) return false;

    const deadScopeCount = countEquipmentByNames(myUid, ["死神スコープ"]);
    const attackRooms = attackTargetRoomIdsFromRoom(swappedRoomId, deadScopeCount);
    if (!attackRooms.size) return false;

    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!marker || uid === myUid) continue;
      if (isPlayerEliminated(uid)) continue;
      const rid = (uid === otherUid) ? myRoomId : markerRoomId(marker);
      if (!rid || !attackRooms.has(rid)) continue;
      if (isAttackTargetProtected(uid)) continue;
      return true;
    }
    return false;
  }

  function inferRoomIdFromPoint(x, y){
    for (const [ridText, pts] of Object.entries(roomPolygons)){
      const rid = Number(ridText);
      if (!Number.isFinite(rid)) continue;
      if (pointInPolygon(x, y, pts)) return rid;
    }
    return null;
  }

  function markerRoomId(marker){
    if (!marker) return null;
    const roomId = Number(marker.roomId);
    if (Number.isFinite(roomId) && roomId >= 1 && roomId <= 7) return roomId;

    const x = Number(marker.x);
    const y = Number(marker.y);
    if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
    return inferRoomIdFromPoint(x, y);
  }

  function canChooseOuterRoomDirectly(){
    if (!canUseMoveDice()) return false;
    if (hasMovedByDiceInCurrentTurn()) return false;
    const myMarker = markerCache?.[state.userId] || null;
    return markerRoomId(myMarker) === 7;
  }

  function hasMovedByDiceInCurrentTurn(){
    return !!turnRoomActionState()?.movedByDiceRoomId;
  }

  function highlightedMarkerUids(){
    if (mustResolveUranusMeteorStrike()){
      return new Set(uranusMeteorTargetUids());
    }
    if (canUseRoom3Action()){
      return new Set(
        Object.keys(markerCache || {}).filter(uid => !!uid && !isPlayerEliminated(uid))
      );
    }
    if (!canUseAttackDice()) return new Set();
    return attackRangeTargetUidsFor(state.userId);
  }

  function randomPointInRoom(roomId, padding = 12){
    const pts = roomPolygons[roomId];
    if (!Array.isArray(pts) || !pts.length) return null;
    const xs = pts.map(p => p[0]);
    const ys = pts.map(p => p[1]);
    const minX = Math.min(...xs) + padding;
    const maxX = Math.max(...xs) - padding;
    const minY = Math.min(...ys) + padding;
    const maxY = Math.max(...ys) - padding;
    if (!(minX < maxX && minY < maxY)) return null;

    for (let i = 0; i < 180; i++){
      const x = minX + Math.random() * (maxX - minX);
      const y = minY + Math.random() * (maxY - minY);
      if (pointInPolygon(x, y, pts)) return { x, y };
    }
    return { x:(minX + maxX) / 2, y:(minY + maxY) / 2 };
  }

  function hasMarkerCollision(x, y, exceptUid = null, minDistance = 20){
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!marker || uid === exceptUid) continue;
      const mx = Number(marker.x);
      const my = Number(marker.y);
      if (!Number.isFinite(mx) || !Number.isFinite(my)) continue;
      if (Math.hypot(mx - x, my - y) < minDistance) return true;
    }
    return false;
  }

  async function placeMarkerInRoom(roomId){
    if (!roomId || !state.roomCode || !state.userId) return;

    movedByDiceRoomId = roomId;
    updateTurnRoomActionState({ movedByDiceRoomId:roomId, room3ActionUsed:false, room4StealUsed:false });

    let target = null;
    for (let i = 0; i < 120; i++){
      const p = randomPointInRoom(roomId);
      if (!p) break;
      if (!hasMarkerCollision(p.x, p.y, state.userId, 22)){
        target = p;
        break;
      }
      if (!target) target = p;
    }
    if (!target) return;

    setCurrentRoom(roomId);

    if (!hasMarkerCollision(target.x, target.y, state.userId, 22)){
      await writeMyMarker(target.x, target.y);
      return;
    }

    const updates = {};
    const pushLen = 14;
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!marker || uid === state.userId) continue;
      const mx = Number(marker.x);
      const my = Number(marker.y);
      if (!Number.isFinite(mx) || !Number.isFinite(my)) continue;
      const dx = mx - target.x;
      const dy = my - target.y;
      const dist = Math.hypot(dx, dy);
      if (dist >= 22) continue;
      const ux = dist > 0.001 ? dx / dist : Math.cos(Math.random() * Math.PI * 2);
      const uy = dist > 0.001 ? dy / dist : Math.sin(Math.random() * Math.PI * 2);
      updates[`markers/${uid}/x`] = mx + ux * pushLen;
      updates[`markers/${uid}/y`] = my + uy * pushLen;
      updates[`markers/${uid}/updatedAt`] = Date.now();
    }

    const myColor = getMyColor();
    const myInitial = getMyInitial();
    if (!myColor || !myInitial) return;
    updates[`markers/${state.userId}`] = {
      x: target.x,
      y: target.y,
      color: myColor,
      initial: myInitial,
      updatedAt: Date.now(),
      viaDice: true,
      roomId
    };
    await update(ref(db, `rooms/${state.roomCode}`), updates);
  }

  function upperRoomId(roomId){
    const rid = Number(roomId);
    if (!Number.isFinite(rid) || rid < 1 || rid > 7) return null;
    return Math.min(7, rid + 1);
  }

  async function placePlayerMarkerInRoom(uid, roomId){
    if (!uid || !roomId || !state.roomCode) return false;
    let target = null;
    for (let i = 0; i < 120; i++){
      const p = randomPointInRoom(roomId);
      if (!p) break;
      if (!hasMarkerCollision(p.x, p.y, uid, 22)){
        target = p;
        break;
      }
      if (!target) target = p;
    }
    if (!target) return false;

    await update(ref(db, `rooms/${state.roomCode}/markers/${uid}`), {
      x: target.x,
      y: target.y,
      roomId,
      updatedAt: Date.now()
    });
    return true;
  }

  async function moveEliminatedPlayerToUpperRoom(uid){
    if (!uid || !state.roomCode) return;
    if (!isPlayerEliminated(uid)) return;
    const marker = markerCache?.[uid] || null;
    const nowRoomId = markerRoomId(marker);
    const targetRoomId = upperRoomId(nowRoomId);
    if (!targetRoomId) return;
    await placePlayerMarkerInRoom(uid, targetRoomId);
  }

  async function placeMarkerByDice(total){
    const roomId = diceTotalToRoomId(total);
    await placeMarkerInRoom(roomId);
    await saveMySeatMoveChoice(null);
    renderEquipmentDock();
    renderMarkers();
  }

  function clearAttackResultDice(){
    if (!diceRollOverlay) return;
    diceRollOverlay.querySelectorAll('.attack-result-pin').forEach(el => el.remove());
  }

  async function addDamageToPlayer(uid, amount, options = {}){
    const add = applyIncomingDamageModifiers(uid, amount, options);
    if (!uid || !state.roomCode || add <= 0) return;
    const dRef = ref(db, `rooms/${state.roomCode}/damage/${uid}`);
    await runTransaction(dRef, (cur) => clampDamage(Number(cur || 0) + add));
    if (!!options?.skipActionLog) return;
    const targetName = displayNameForUid(uid);
    const source = safeText(options?.source || "");
    const srcLabel = actionSourceLabel(source);
    const src = srcLabel ? `(${srcLabel})` : "";
    appendActionChatLog(safeText(options?.actorUid || state.userId), `ダメージ${src}:${targetName}さんに${add}`).catch(() => {});
  }

  async function healDamageToPlayer(uid, amount, source = "", options = {}){
    const heal = Math.max(0, Number(amount) || 0);
    if (!uid || !state.roomCode || heal <= 0) return;
    if (!isGordonBarrierHpChangeAllowed(uid, source)) return;
    const dRef = ref(db, `rooms/${state.roomCode}/damage/${uid}`);
    await runTransaction(dRef, (cur) => clampDamage(Number(cur || 0) - heal));
    if (!!options?.skipActionLog) return;
    const targetName = displayNameForUid(uid);
    const src = actionSourceLabel(source || "");
    appendActionChatLog(safeText(options?.actorUid || state.userId), `回復${src ? `(${src})` : ""}:${targetName}さんを${heal}`).catch(() => {});
  }

  async function fullRecoverPlayer(uid){
    if (!uid || !state.roomCode) return;
    await set(ref(db, `rooms/${state.roomCode}/damage/${uid}`), 0);
  }

  async function enableGuardianAngelShieldForPlayer(uid){
    const targetUid = safeText(uid);
    if (!state.roomCode || !targetUid) return;
    await set(ref(db, `rooms/${state.roomCode}/guardianAngelShield/${targetUid}`), true);
  }


  async function setDamageToPlayer(uid, damage, source = "", options = {}){
    if (!uid || !state.roomCode) return;
    if (!isGordonBarrierHpChangeAllowed(uid, source)) return;
    await set(ref(db, `rooms/${state.roomCode}/damage/${uid}`), clampDamage(damage));
    if (!!options?.skipActionLog) return;
    const targetName = displayNameForUid(uid);
    const src = actionSourceLabel(source || "");
    appendActionChatLog(safeText(options?.actorUid || state.userId), `ダメージ設定${src ? `(${src})` : ""}:${targetName}さん=${clampDamage(damage)}`).catch(() => {});
  }

  async function enableRepeatTurnOnce(){
    if (!state.roomCode || !isMyTurn()) return;
    await update(ref(db, `rooms/${state.roomCode}/turn`), {
      repeatTurnRemaining: 1,
      repeatTurnTotal: 1,
      sealWisdomBonus: true,
      updatedAt: Date.now()
    });
  }

  async function runCornerD6Roll(fixedFace = null){
    if (!diceRollOverlay) return Number(fixedFace || (1 + Math.floor(Math.random() * 6)));
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const wrap = document.createElement('div');
    wrap.className = 'dice-flyer rolling';
    const d6 = document.createElement('div');
    d6.className = 'die';
    wrap.appendChild(d6);
    diceRollOverlay.appendChild(wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const corners = [
      { x: 60, y: 60 },
      { x: Math.max(60, width - 60), y: 60 },
      { x: 60, y: Math.max(60, height - 60) },
      { x: Math.max(60, width - 60), y: Math.max(60, height - 60) }
    ];
    const start = corners[Math.floor(Math.random() * corners.length)];
    const end = { x: width / 2, y: height / 2 };
    setFlyerTransform(wrap, start.x, start.y, Math.floor(Math.random() * 360));

    const animDuration = 900;
    const rollStartAt = Date.now();
    const tick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      const id = setTimeout(tick, 70 + Math.floor(Math.random() * 80));
      diceRollTimers.push(id);
    };
    tick();

    const launch = setTimeout(() => {
      setFlyerTransform(wrap, end.x, end.y, 720 + Math.floor(Math.random() * 360));
    }, 20);
    diceRollTimers.push(launch);

    const finalFace = Number(fixedFace || (1 + Math.floor(Math.random() * 6)));
    await new Promise(resolve => {
      const stop = setTimeout(() => {
        wrap.classList.remove('rolling');
        renderD6Face(d6, finalFace);
        resolve();
      }, 980);
      diceRollTimers.push(stop);
    });
    return finalFace;
  }

  async function runCornerD4Roll(fixedFace = null){
    if (!diceRollOverlay) return Number(fixedFace || (1 + Math.floor(Math.random() * 4)));
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const wrap = document.createElement('div');
    wrap.className = 'dice-flyer rolling';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    wrap.appendChild(d4);
    diceRollOverlay.appendChild(wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const corners = [
      { x: 60, y: 60 },
      { x: Math.max(60, width - 60), y: 60 },
      { x: 60, y: Math.max(60, height - 60) },
      { x: Math.max(60, width - 60), y: Math.max(60, height - 60) }
    ];
    const start = corners[Math.floor(Math.random() * corners.length)];
    const end = { x: width / 2, y: height / 2 };
    setFlyerTransform(wrap, start.x, start.y, Math.floor(Math.random() * 360));

    const animDuration = 900;
    const rollStartAt = Date.now();
    const tick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      renderD4Face(d4, 1 + Math.floor(Math.random() * 4));
      const id = setTimeout(tick, 70 + Math.floor(Math.random() * 80));
      diceRollTimers.push(id);
    };
    tick();

    const launch = setTimeout(() => {
      setFlyerTransform(wrap, end.x, end.y, 720 + Math.floor(Math.random() * 360));
    }, 20);
    diceRollTimers.push(launch);

    const finalFace = Number(fixedFace || (1 + Math.floor(Math.random() * 4)));
    await new Promise(resolve => {
      const stop = setTimeout(() => {
        wrap.classList.remove('rolling');
        renderD4Face(d4, finalFace);
        resolve();
      }, 980);
      diceRollTimers.push(stop);
    });
    return finalFace;
  }

  async function emitCardDiceEvent(payload = {}){
    if (!state.roomCode) return;
    await set(ref(db, `rooms/${state.roomCode}/diceEvents/card`), {
      ...payload,
      at: Date.now()
    });
  }



  async function runCornerD6D4Roll(fixed = null){
    if (!diceRollOverlay) return { d6: Number(fixed?.d6 || (1 + Math.floor(Math.random() * 6))), d4: Number(fixed?.d4 || (1 + Math.floor(Math.random() * 4))) };
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer rolling';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer rolling';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    diceRollOverlay.appendChild(d6Wrap);
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const corners = [
      { x: 60, y: 60 },
      { x: Math.max(60, width - 60), y: 60 },
      { x: 60, y: Math.max(60, height - 60) },
      { x: Math.max(60, width - 60), y: Math.max(60, height - 60) }
    ];
    const startA = corners[Math.floor(Math.random() * corners.length)] || corners[0];
    const startB = startA;
    const end = { x: width / 2, y: height / 2 };

    setFlyerTransform(d6Wrap, startA.x, startA.y, Math.floor(Math.random() * 360));
    setFlyerTransform(d4Wrap, startB.x, startB.y, Math.floor(Math.random() * 360));

    const animDuration = 900;
    const rollStartAt = Date.now();
    const tick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      renderD4Face(d4, 1 + Math.floor(Math.random() * 4));
      const id = setTimeout(tick, 70 + Math.floor(Math.random() * 80));
      diceRollTimers.push(id);
    };
    tick();

    const launch = setTimeout(() => {
      setFlyerTransform(d6Wrap, end.x - 18, end.y - 6, 720 + Math.floor(Math.random() * 360));
      setFlyerTransform(d4Wrap, end.x + 18, end.y + 6, 720 + Math.floor(Math.random() * 360));
    }, 20);
    diceRollTimers.push(launch);

    const finalD6 = Number(fixed?.d6 || (1 + Math.floor(Math.random() * 6)));
    const finalD4 = Number(fixed?.d4 || (1 + Math.floor(Math.random() * 4)));
    await new Promise(resolve => {
      const stop = setTimeout(() => {
        d6Wrap.classList.remove('rolling');
        d4Wrap.classList.remove('rolling');
        renderD6Face(d6, finalD6);
        renderD4Face(d4, finalD4);
        resolve();
      }, 980);
      diceRollTimers.push(stop);
    });

    return { d6: finalD6, d4: finalD4 };
  }

  async function addDamageToAllOtherPlayers(uid, amount){
    const baseAdd = Math.max(0, Number(amount) || 0);
    if (!state.roomCode || baseAdd <= 0) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      const order = Array.isArray(cur.positionOrder) ? cur.positionOrder : [];
      if (order.length === 0) return cur;
      cur.damage = cur.damage || {};
      for (const pid of order){
        if (!pid || pid === uid) continue;
        const add = applyIncomingDamageModifiers(pid, baseAdd);
        if (add <= 0) continue;
        cur.damage[pid] = clampDamage(Number(cur.damage[pid] || 0) + add);
      }
      return cur;
    });
  }

  function alivePlayerIds(){
    return latestPlayers
      .map(p => safeText(p?.id || ""))
      .filter(Boolean)
      .filter(uid => !isPlayerEliminated(uid));
  }

  function maxDamageAlivePlayerIds(){
    const alive = alivePlayerIds();
    if (!alive.length) return [];
    let maxDamage = -1;
    for (const uid of alive){
      const dmg = clampDamage(damageCache?.[uid]);
      if (dmg > maxDamage) maxDamage = dmg;
    }
    if (maxDamage < 0) return [];
    return alive.filter(uid => clampDamage(damageCache?.[uid]) === maxDamage);
  }

  function playerIdsInRoom(roomId){
    const rid = Number(roomId);
    if (!Number.isFinite(rid) || rid < 1 || rid > 7) return [];
    const uids = [];
    for (const [uid, marker] of Object.entries(markerCache || {})){
      if (!uid || !marker) continue;
      if (markerRoomId(marker) === rid) uids.push(uid);
    }
    return uids;
  }

  async function addDamageToPlayers(uids, amount, options = {}){
    const baseAdd = Math.max(0, Number(amount) || 0);
    if (!state.roomCode || baseAdd <= 0) return;
    const targets = [...new Set((uids || []).map(uid => safeText(uid)).filter(Boolean))];
    if (!targets.length) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur) return cur;
      cur.damage = cur.damage || {};
      for (const uid of targets){
        const add = applyIncomingDamageModifiers(uid, baseAdd, options);
        if (add <= 0) continue;
        cur.damage[uid] = clampDamage(Number(cur.damage[uid] || 0) + add);
      }
      return cur;
    });
  }

  async function applyImmediateDeckCardEffect(cardObj){
    const name = safeText(cardObj?.name || "");
    if (!name || !state.userId) return;
    const role = myRoleInfo();
    if (!role) return;
    const lockKey = `${name}:${state.userId}`;
    if (isEffectResolutionLocked(lockKey)) return;
    setEffectResolutionLock(lockKey, true);
    try {
    if (name === "いやしの聖水"){
      await waitMs(1500);
      await healDamageToPlayer(state.userId, 2, "card_holy_water_heal");
      return;
    }

    if (name === "裁きの閃光"){
      await waitMs(1500);
      await addDamageToAllOtherPlayers(state.userId, 2);
      return;
    }

    if (name === "戦慄の闇儀式" || name === "光臨"){
      const targetFaction = (name === "戦慄の闇儀式") ? "シャドウ" : "レイダー";
      const message = (name === "戦慄の闇儀式")
        ? "シャドウとして正体を公開しますか。"
        : "レイダーとして正体を公開しますか。";
      const canReveal = role.faction === targetFaction;
      showIdentityPromptPop({
        message,
        canReveal,
        cardObj,
        cardTheme: name === "戦慄の闇儀式" ? "black" : "white",
        openZoom: true,
        onYes: async () => {
          await revealMyIdentityToEquipment();
          openIdentityRevealZoom(role, state.userId);
          await setDamageToPlayer(state.userId, 0, "card_kohrin_heal");
        }
      });
      return;
    }

    if (name === "幸せのクッキー"){
      const canReveal = role.initial === "A" || role.initial === "U";
      showIdentityPromptPop({
        message: "AまたはUとして正体を公開しますか。",
        canReveal,
        cardObj,
        cardTheme: "white",
        openZoom: true,
        onYes: async () => {
          await revealMyIdentityToEquipment(identityPromptRevealOptions(name));
          openIdentityRevealZoom(role, state.userId);
          await setDamageToPlayer(state.userId, 0, "card_kohrin_heal");
        }
      });
      return;
    }

    if (name === "闇を祓う鏡"){
      const shouldReveal = role.faction === "シャドウ" && role.name !== "ウルリッヒ" && !isMyIdentityRevealed();
      if (!shouldReveal) return;
      await revealMyIdentityToEquipment();
      openIdentityRevealZoom(role, state.userId);
      return;
    }

    if (name === "封印の知恵"){
      await enableRepeatTurnOnce();
      return;
    }

    if (name === "守護天使"){
      await enableGuardianAngelShieldForPlayer(state.userId);
      return;
    }

    if (name === "応急手当"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "恩恵"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "吸血コウモリ"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "三つ目の黒犬"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "バナナの皮"){
      const myItems = listEquipForUid(state.userId).filter(it => !isIdentityEquipItem(it));
      if (myItems.length === 0){
        await waitMs(1000);
        await addDamageToPlayer(state.userId, 1);
        return;
      }
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      setZoomPassthrough(true);
      pendingEquipAction = { type:"banana_give", selectedSourceKey:"", cardObj };
      await setSeatEquipSelectionState({ type:"banana_give", cardObj });
      renderEquipmentDock();
      renderTurnEndButton();
      return;
    }

    if (name === "オリバーの子分"){
      const hasStealableEquip = latestPlayers
        .filter(p => p.id !== state.userId && !isPlayerEliminated(p.id))
        .some(p => hasAnyEquipment(p.id));
      if (!hasStealableEquip){
        return;
      }
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      setZoomPassthrough(true);
      pendingEquipAction = { type:"oliver_target", cardObj };
      await setSeatEquipSelectionState({ type:"oliver_target", cardObj });
      renderEquipmentDock();
      renderTurnEndButton();
      return;
    }

    if (name === "人魚の涙"){
      await waitMs(1500);
      const topUids = maxDamageAlivePlayerIds();
      for (const uid of topUids){
        await healDamageToPlayer(uid, 3, "card_mermaid_tears_heal");
      }
      return;
    }

    if (name === "呪いの人形"){
      await openPersistentCardTargetSelection(cardObj);
      return;
    }

    if (name === "暴動"){
      openZoomFromDeckCard(cardObj, "black", { closeOnBackdrop:false, showCloseButton:false });
      await waitMs(2000);
      const rolled = { d6: 1 + Math.floor(Math.random() * 6), d4: 1 + Math.floor(Math.random() * 4) };
      await emitCardDiceEvent({ kind:"riot", uid: state.userId, d6: rolled.d6, d4: rolled.d4 });
      await waitMs(1000);
      const targetRoomId = diceTotalToRoomId(Number(rolled?.d6 || 0) + Number(rolled?.d4 || 0));
      await waitMs(1500);
      await addDamageToPlayers(playerIdsInRoom(targetRoomId), 3);
      closeZoom();
      return;
    }
    } finally {
      setEffectResolutionLock(lockKey, false);
    }
  }

  async function runAttackDiceAnimation(targetUid, clickClientX, clickClientY, options = {}){
    if (!diceRollOverlay || !targetUid) return;
    const applyDamage = options.applyDamage !== false;
    const masamuneMode = !!options.masamuneMode;
    const vendettaMode = !!options.vendettaMode;
    const d4OnlyMode = masamuneMode || vendettaMode;

    if (vendettaMode){
      showRoleFlashOverlay("SHA_V3", 1800);
      await waitMs(500);
    }

    clearDiceRollTimers();
    clearAttackResultDice();

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    if (!d4OnlyMode){
      diceRollOverlay.appendChild(d6Wrap);
    }
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const fallbackEndX = Math.max(50, Math.min(width - 50, Number(clickClientX) || width / 2));
    const fallbackEndY = Math.max(50, Math.min(height - 50, Number(clickClientY) || height / 2));
    const motion = options.motion || createDiceMotion(width, height, fallbackEndX, fallbackEndY);

    const startA = { x:Number(motion.startBase?.x || 0) - 16, y:Number(motion.startBase?.y || 0) - 6 };
    const startB = { x:Number(motion.startBase?.x || 0) + 16, y:Number(motion.startBase?.y || 0) + 6 };
    const endX = Number(motion.endX || fallbackEndX);
    const endY = Number(motion.endY || fallbackEndY);
    const offsetA = { x:Number(motion.offsetA?.x || 0), y:Number(motion.offsetA?.y || 0) };
    const offsetB = { x:Number(motion.offsetB?.x || 0), y:Number(motion.offsetB?.y || 0) };

    const startDegA = Number(motion.startDegA || 0);
    const startDegB = Number(motion.startDegB || 0);
    if (!d4OnlyMode){
      setFlyerTransform(d6Wrap, startA.x, startA.y, startDegA);
    }
    setFlyerTransform(d4Wrap, startB.x, startB.y, startDegB);

    const animDuration = 950;
    const rollStartAt = Date.now();
    const rollFaceTick = () => {
      const elapsed = Date.now() - rollStartAt;
      if (elapsed >= animDuration) return;
      if (!d4OnlyMode){
        renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
      }
      renderD4Face(d4, 1 + Math.floor(Math.random() * 4));

      const t = elapsed / animDuration;
      const nextInterval = 55 + Math.floor(185 * t);
      const id = setTimeout(rollFaceTick, nextInterval);
      diceRollTimers.push(id);
    };
    rollFaceTick();

    const launchDelayMs = 30;
    const moveDurationMs = 950;
    const settleBufferMs = 80;

    const moveTimer = setTimeout(() => {
      if (!d4OnlyMode){
        d6Wrap.classList.add('rolling');
      }
      d4Wrap.classList.add('rolling');
      const endDegA = Number(motion.endDegA || (startDegA + 720));
      const endDegB = Number(motion.endDegB || (startDegB + 720));
      if (!d4OnlyMode){
        setFlyerTransform(d6Wrap, endX + offsetA.x, endY + offsetA.y, endDegA);
      }
      setFlyerTransform(d4Wrap, endX + offsetB.x, endY + offsetB.y, endDegB);
    }, launchDelayMs);
    diceRollTimers.push(moveTimer);

    const finalD6 = Number(options.finalD6 || (1 + Math.floor(Math.random() * 6)));
    const finalD4 = Number(options.finalD4 || (1 + Math.floor(Math.random() * 4)));

    const stopDelayMs = launchDelayMs + moveDurationMs + settleBufferMs;
    const stopTimer = setTimeout(() => {
      if (!d4OnlyMode){
        d6Wrap.classList.remove('rolling');
      }
      d4Wrap.classList.remove('rolling');
      if (!d4OnlyMode){
        renderD6Face(d6, finalD6);
      }
      renderD4Face(d4, finalD4);

      if (!d4OnlyMode){
        d6Wrap.classList.add('attack-result-pin');
      }
      d4Wrap.classList.add('attack-result-pin');

      Promise.resolve().then(async () => {
        const attackSucceeded = didAttackRollSucceed(finalD6, finalD4, { masamuneMode, vendettaMode });
        setAttackRollResultLabel(attackSucceeded);
        if (!applyDamage) return;
        const gatlingTargets = Array.isArray(options.gatlingTargetUids)
          ? options.gatlingTargetUids.map(uid => safeText(uid)).filter(Boolean)
          : [];
        const targetUids = (gatlingTargets.length > 0) ? gatlingTargets : [targetUid];
        const exMeta = d4OnlyMode
          ? null
          : buildExcaliburAttackMeta({ attackerUid:state.userId, targetUid, attackSucceeded, d6:finalD6, d4:finalD4 });
        const hiddenFreddie = isMyRole("RAI_F3") && !isMyIdentityRevealed() && !isMyAbilitySealed();
        const hiddenExcaliburPreview = !!exMeta?.allowExcaliburButton;
        const hasExcalibur = hasEquipmentByName(state.userId, "エクスカリバー");
        let resolvedRows = targetUids.map(uid => {
          const normalizedUid = safeText(uid);
          const targetRevealed = isIdentityRevealedFor(normalizedUid);
          const damage = calcAttackDamageFromRoll(state.userId, finalD6, finalD4, {
            masamuneMode,
            vendettaMode,
            excaliburRevealBoost: false,
            targetUid: normalizedUid
          });
          const damageAfterMods = (attackSucceeded && damage > 0)
            ? applyIncomingDamageModifiers(normalizedUid, damage, { source:"attack" })
            : 0;
          let bonusLabelAmount = 0;
          if (hiddenFreddie && attackSucceeded && targetRevealed){
            bonusLabelAmount += 2;
            if (hasExcalibur){
              bonusLabelAmount += 2;
            }
          } else if (hiddenExcaliburPreview && attackSucceeded){
            bonusLabelAmount += 2;
          }
          return {
            uid: normalizedUid,
            damage: damageAfterMods,
            bonusLabelAmount
          };
        });
        const freddieHiddenExcaliburRevealHit = hiddenFreddie
          && hasExcalibur
          && resolvedRows.some(row => Number(row.bonusLabelAmount || 0) >= 4);
        pendingAttackResultMeta = {
          showBonusLabel: !!exMeta?.showBonusLabel,
          allowExcaliburButton: !!exMeta?.allowExcaliburButton && !freddieHiddenExcaliburRevealHit,
          freddieSpecial: hiddenFreddie && resolvedRows.some(row => Number(row.bonusLabelAmount || 0) >= 2),
          zeroDamagePreview: false
        };
        const hasAttackerSageRobe = hasEquipmentByName(state.userId, "賢者のローブ");
        const hasTargetSageRobe = targetUids.some(uid => hasEquipmentByName(uid, "賢者のローブ"));
        const hasExcaliburPreviewZero = !!pendingAttackResultMeta.allowExcaliburButton
          && (hasAttackerSageRobe || hasTargetSageRobe)
          && Math.abs((Number(finalD6) || 0) - (Number(finalD4) || 0)) === 1
          && resolvedRows.some(row => Number(row.damage || 0) === 0);
        const hasFreddiePreviewZero = hiddenFreddie
          && attackSucceeded
          && resolvedRows.some(row => Number(row.bonusLabelAmount || 0) > 0)
          && (hasAttackerSageRobe || hasTargetSageRobe)
          && Math.abs((Number(finalD6) || 0) - (Number(finalD4) || 0)) === 1
          && resolvedRows.some(row => Number(row.damage || 0) === 0);
        if (hasExcaliburPreviewZero || hasFreddiePreviewZero){
          pendingAttackResultMeta.zeroDamagePreview = true;
        }
        if (isMyRole("RAI_G2") && !isMyIdentityRevealed() && !isMyAbilitySealed()){
          const hasZeroDamage = resolvedRows.some(row => Number(row.damage || 0) === 0);
          if (!attackSucceeded || hasZeroDamage){
            pendingAttackResultMeta.allowExcaliburButton = false;
          }
        }
        for (const row of resolvedRows){
          const rowUid = safeText(row.uid || "");
          const dmg = Math.max(0, Number(row.damage || 0));
          appendActionChatLog(state.userId, `攻撃ロール：ダメージ${dmg} (6d${finalD6},4d${finalD4})>${displayNameRoleForUid(rowUid)} (${currentDamageForUid(rowUid)})`).catch(() => {});
        }
        const dealtDamage = resolvedRows.some(row => Number(row.damage || 0) > 0);
        const pendingTurnKey = turnCycleKey();
        pendingAttackResolution = { rows: resolvedRows, applied:false, turnKey: pendingTurnKey, meta: normalizeAttackResultMeta(pendingAttackResultMeta) };
        cachePendingAttackResolution(pendingAttackResolution);
        await upsertPendingAttackResolution(resolvedRows, pendingTurnKey, pendingAttackResultMeta);
        showAttackResultPop(resolvedRows);
        if (dealtDamage && isMyRole("SHA_V2")){
          vampireHiddenAttackSuccess = true;
        }
      });
    }, stopDelayMs);
    diceRollTimers.push(stopTimer);
  }


  function runDiceRollAnimation(options = {}){
    const force = !!options.force;
    if (!force && !canUseMoveDice()) return;
    const applyMove = options.applyMove !== false;
    const compass = !!options.compass;
    if (!diceRollOverlay) return;
    pendingMoveChoice = null;
    clearPendingMoveChoiceUi();
    updateRoomChoiceUi();
    clearDiceRollTimers();
    diceRollOverlay.innerHTML = '';

    const d6Wrap = document.createElement('div');
    d6Wrap.className = 'dice-flyer';
    const d6 = document.createElement('div');
    d6.className = 'die';
    d6Wrap.appendChild(d6);

    const d4Wrap = document.createElement('div');
    d4Wrap.className = 'dice-flyer';
    const d4 = document.createElement('div');
    d4.className = 'd4';
    d4Wrap.appendChild(d4);

    diceRollOverlay.appendChild(d6Wrap);
    diceRollOverlay.appendChild(d4Wrap);

    const width = window.innerWidth;
    const height = window.innerHeight;
    const center = { x: width / 2, y: height / 2 };
    const animDuration = 950;

    const runSingleRoll = ({ motion, finalD6, finalD4, startAfterMs = 0, onStop = null }) => {
      const m = motion || createDiceMotion(width, height, center.x, center.y);
      const startA = { x:Number(m.startBase?.x || 0) - 16, y:Number(m.startBase?.y || 0) - 6 };
      const startB = { x:Number(m.startBase?.x || 0) + 16, y:Number(m.startBase?.y || 0) + 6 };
      const offsetA = { x:Number(m.offsetA?.x || 0), y:Number(m.offsetA?.y || 0) };
      const offsetB = { x:Number(m.offsetB?.x || 0), y:Number(m.offsetB?.y || 0) };
      const startDegA = Number(m.startDegA || 0);
      const startDegB = Number(m.startDegB || 0);

      const launchTimer = setTimeout(() => {
        setFlyerTransform(d6Wrap, startA.x, startA.y, startDegA);
        setFlyerTransform(d4Wrap, startB.x, startB.y, startDegB);

        const rollStartAt = Date.now();
        const rollFaceTick = () => {
          const elapsed = Date.now() - rollStartAt;
          if (elapsed >= animDuration) return;
          renderD6Face(d6, 1 + Math.floor(Math.random() * 6));
          renderD4Face(d4, 1 + Math.floor(Math.random() * 4));
          const t = elapsed / animDuration;
          const nextInterval = 55 + Math.floor(185 * t);
          const id = setTimeout(rollFaceTick, nextInterval);
          diceRollTimers.push(id);
        };
        rollFaceTick();

        const moveTimer = setTimeout(() => {
          d6Wrap.classList.add('rolling');
          d4Wrap.classList.add('rolling');
          const endDegA = Number(m.endDegA || (startDegA + 720));
          const endDegB = Number(m.endDegB || (startDegB + 720));
          const endX = Number(m.endX || center.x);
          const endY = Number(m.endY || center.y);
          setFlyerTransform(d6Wrap, endX + offsetA.x, endY + offsetA.y, endDegA);
          setFlyerTransform(d4Wrap, endX + offsetB.x, endY + offsetB.y, endDegB);
        }, 30);
        diceRollTimers.push(moveTimer);

        const stopTimer = setTimeout(() => {
          d6Wrap.classList.remove('rolling');
          d4Wrap.classList.remove('rolling');
          renderD6Face(d6, finalD6);
          renderD4Face(d4, finalD4);
          if (typeof onStop === 'function') onStop();
        }, 980);
        diceRollTimers.push(stopTimer);
      }, startAfterMs);
      diceRollTimers.push(launchTimer);
    };

    const finalD6 = Number(options.finalD6 || (1 + Math.floor(Math.random() * 6)));
    const finalD4 = Number(options.finalD4 || (1 + Math.floor(Math.random() * 4)));
    const secondD6 = Number(options.secondD6 || (1 + Math.floor(Math.random() * 6)));
    const secondD4 = Number(options.secondD4 || (1 + Math.floor(Math.random() * 4)));

    if (!compass){
      runSingleRoll({ motion: options.motion || null, finalD6, finalD4 });

      const placeMarkerTimer = setTimeout(async () => {
        if (applyMove) await placeMarkerByDice(finalD6 + finalD4);
        if (applyMove && state.roomCode && isMyTurn()){
          await update(ref(db, `rooms/${state.roomCode}/turn`), {
            moveDone: true,
            moveAt: Date.now()
          });
          remove(ref(db, `rooms/${state.roomCode}/godwinRevivePendingMove/${state.userId}`)).catch(() => {});
        }
      }, 1900);
      diceRollTimers.push(placeMarkerTimer);

      const cleanupTimer = setTimeout(() => {
        diceRollOverlay.innerHTML = '';
        clearDiceRollTimers();
      }, 3200);
      diceRollTimers.push(cleanupTimer);
      return;
    }

    runSingleRoll({ motion: options.motion || null, finalD6, finalD4 });
    runSingleRoll({
      motion: options.secondMotion || null,
      finalD6: secondD6,
      finalD4: secondD4,
      startAfterMs: 2980,
      onStop: () => {
        if (!applyMove) return;
        const roomA = diceTotalToRoomId(finalD6 + finalD4);
        const roomB = diceTotalToRoomId(secondD6 + secondD4);
        saveMySeatMoveChoice({
          roomIds: [roomA, roomB],
          d6: finalD6,
          d4: finalD4,
          secondD6,
          secondD4,
          at: Date.now()
        }).catch(() => {});
        setPendingMoveChoice([roomA, roomB]);
      }
    });
  }

  function getMyColor(){
    if (state.seatedTable != null){
      return SEAT_COLORS[state.seatedTable-1] || "#ddd";
    }
    return null;
  }
  function getMyInitial(){
    return firstChar(state.userName || "");
  }

  function ensureMarkerLayer(){
    if (markerLayer && markerLayer.isConnected){
      roomG.appendChild(markerLayer);
      return markerLayer;
    }
    markerLayer = svgEl('g', { id:"markerLayer" }, roomG);
    return markerLayer;
  }
  function clearMarkerLayer(){
    if (!markerLayer) return;
    while(markerLayer.firstChild) markerLayer.removeChild(markerLayer.firstChild);
  }

  function ensureAttackRangeLayer(){
    if (attackRangeLayer && attackRangeLayer.isConnected){
      if (markerLayer && markerLayer.parentNode === roomG){
        roomG.insertBefore(attackRangeLayer, markerLayer);
      }
      return attackRangeLayer;
    }
    attackRangeLayer = svgEl('g', { class:'attack-range-layer' }, roomG);
    if (markerLayer && markerLayer.parentNode === roomG){
      roomG.insertBefore(attackRangeLayer, markerLayer);
    }
    return attackRangeLayer;
  }

  function clearAttackRangeLayer(){
    if (!attackRangeLayer) return;
    while (attackRangeLayer.firstChild) attackRangeLayer.removeChild(attackRangeLayer.firstChild);
  }

  function normalizedEdgeKey(ax, ay, bx, by){
    const pa = `${Number(ax).toFixed(3)},${Number(ay).toFixed(3)}`;
    const pb = `${Number(bx).toFixed(3)},${Number(by).toFixed(3)}`;
    return pa < pb ? `${pa}|${pb}` : `${pb}|${pa}`;
  }

  function polygonCentroid(pts){
    if (!Array.isArray(pts) || !pts.length) return { x:0, y:0 };
    let sx = 0;
    let sy = 0;
    for (const [x, y] of pts){
      sx += Number(x) || 0;
      sy += Number(y) || 0;
    }
    return { x: sx / pts.length, y: sy / pts.length };
  }

  function offsetEdgeOutward(edge){
    const ax = Number(edge.ax) || 0;
    const ay = Number(edge.ay) || 0;
    const bx = Number(edge.bx) || 0;
    const by = Number(edge.by) || 0;

    const dx = bx - ax;
    const dy = by - ay;
    const len = Math.hypot(dx, dy) || 1;

    let nx = -dy / len;
    let ny = dx / len;

    const mx = (ax + bx) / 2;
    const my = (ay + by) / 2;
    const pts = roomPolygons[edge.roomId];
    const c = polygonCentroid(pts);

    const plusDist = Math.hypot((mx + nx) - c.x, (my + ny) - c.y);
    const minusDist = Math.hypot((mx - nx) - c.x, (my - ny) - c.y);
    if (plusDist < minusDist){
      nx *= -1;
      ny *= -1;
    }

    const offset = 1.25;
    return {
      x1: ax + nx * offset,
      y1: ay + ny * offset,
      x2: bx + nx * offset,
      y2: by + ny * offset
    };
  }

  function updateAttackRangeUi(){
    ensureAttackRangeLayer();
    clearAttackRangeLayer();

    if (!canUseAttackDice()) return;

    const myMarker = markerCache?.[state.userId] || null;
    const myRoomId = markerRoomId(myMarker);
    if (!myRoomId) return;

    const deadScopeCount = countEquipmentByNames(state.userId, ["死神スコープ"]);
    const attackRooms = attackTargetRoomIdsFromRoom(myRoomId, deadScopeCount);
    if (!attackRooms.size) return;

    const edges = new Map();
    for (const rid of attackRooms){
      const pts = roomPolygons[rid];
      if (!Array.isArray(pts) || pts.length < 2) continue;
      for (let i = 0; i < pts.length; i++){
        const a = pts[i];
        const b = pts[(i + 1) % pts.length];
        const key = normalizedEdgeKey(a[0], a[1], b[0], b[1]);
        const cur = edges.get(key);
        if (cur){
          cur.count += 1;
        } else {
          edges.set(key, { ax:a[0], ay:a[1], bx:b[0], by:b[1], count:1, roomId: rid });
        }
      }
    }

    for (const edge of edges.values()){
      if (edge.count !== 1) continue;
      const outlinePos = offsetEdgeOutward(edge);
      const outline = svgEl('line', {
        class:'attack-range-edge-outline',
        x1: outlinePos.x1,
        y1: outlinePos.y1,
        x2: outlinePos.x2,
        y2: outlinePos.y2
      });
      const line = svgEl('line', {
        class:'attack-range-edge',
        x1: edge.ax,
        y1: edge.ay,
        x2: edge.bx,
        y2: edge.by
      });
      attackRangeLayer.appendChild(outline);
      attackRangeLayer.appendChild(line);
    }
  }


  function showUranusSkipPop(clientX, clientY){
    const ability = '<span class="ability-pill">メテオストライク</span>';
    showRoomActionPopAt(clientX, clientY, "", async () => {
      uranusMeteorResolved = true;
      if (canChooseOuterRoomDirectly()){
        renderMarkers();
        return;
      }
      hideAttackPop();
      setTimeout(() => {
        triggerMoveDiceForAll();
      }, 40);
    }, {
      messageHtml: `${ability}を使用せずに移動しますか。`,
      yesLabel: "はい",
      noLabel: "いいえ"
    });
  }

  function showUranusMeteorConfirmPop(clientX, clientY, targetUid){
    const uid = safeText(targetUid || "");
    if (!uid) return;
    const player = playerById(uid);
    const name = safeText(player?.name || "このプレイヤー");
    const ability = '<span class="ability-pill">メテオストライク</span>';
    showRoomActionPopAt(clientX, clientY, "", async () => {
      await emitRoleFlashEvent("SHA_U2", "meteor_strike");
      await new Promise(resolve => setTimeout(resolve, 1800));
      await addDamageToPlayer(uid, 3, { actorUid:state.userId });
      uranusMeteorResolved = true;
      renderMarkers();
    }, {
      messageHtml: `${ability}${escapeHtml(name)}に3ダメージ与えますか。`,
      yesLabel: "はい",
      noLabel: "いいえ"
    });
  }
 function drawMarker({x,y,color,initial,uid,pulse=false,eliminated=false}){
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  g.setAttribute("data-uid", uid || "");
  if (uid && walpurgisSwapHiddenUids.has(uid)) g.classList.add("marker-swap-hidden");
  if (pulse) {
    g.classList.add("mark-pulse-target");
    if (uid && uid === state.userId && canUseMoveDice() && !mustResolveUranusMeteorStrike() && !hasMovedByDiceInCurrentTurn() && !suppressSelfTurnStartPulse){
      g.classList.add("mark-pulse-self-turn-start");
    }
  }
  if (eliminated) g.classList.add("marker-eliminated");

  const size = (uid && uid === state.userId) ? 17 : 16;
  const rx = 3;

  if (!eliminated && uid && uid === state.userId){
    g.style.cursor = canInteractWithMapPlayerIcons() ? 'pointer' : 'default';
    g.addEventListener('click', (e) => {
      if (!canInteractWithMapPlayerIcons()) return;
      if (cardPlayerSelectActive) return;
      if (canUseRoom3Action()){
        e.stopPropagation();
        const p = playerById(uid);
        const nm = safeText(p?.name || "このプレイヤー");
        const room3DamageBlocked = hasGuardianAngelShield(uid) || hasGordonBarrier(uid) || hasEquipmentByName(uid, "幸運のブローチ");
        showRoomActionPopAt(e.clientX, e.clientY, `「${nm}」に実行する効果を選んでください。`, async () => {
          room3ActionUsed = true;
          await updateTurnRoomActionState({ room3ActionUsed:true });
          showTurnHint("");
          await new Promise(resolve => setTimeout(resolve, 1000));
          await healDamageToPlayer(uid, 1, "room3_heal", { actorUid:uid, skipActionLog:true });
        appendActionChatLog(uid, `市庁舎 ${actionDeltaText(-1)}>${actionTargetWithDamage(uid, -1)}`).catch(() => {});
          renderMarkers();
        }, {
          yesLabel: "1回復する",
          noLabel: "2ダメージ与える",
          noDisabled: room3DamageBlocked,
          compactButtons: true,
          yOffset: -14,
          onNo: async () => {
            room3ActionUsed = true;
            await updateTurnRoomActionState({ room3ActionUsed:true });
            showTurnHint("");
            await recordFactionRelationInferenceFromRevealedTarget(state.userId, uid, "enemy", "room3_damage_target_revealed");
            await new Promise(resolve => setTimeout(resolve, 1000));
            await addDamageToPlayer(uid, 2, { source:"room3", actorUid:state.userId, skipActionLog:true });
            appendActionChatLog(state.userId, `市庁舎 ${actionDeltaText(2)}>${actionTargetWithDamage(uid, 2)}`).catch(() => {});
            renderMarkers();
          }
        });
        return;
      }
      if (mustResolveUranusMeteorStrike()){
        e.stopPropagation();
        showUranusSkipPop(e.clientX, e.clientY);
        return;
      }
      if (!canUseMoveDice()) return;
      if (canChooseOuterRoomDirectly()) return;
      e.stopPropagation();
      hideAttackPop();
      triggerMoveDiceForAll();
    });
  } else if (!eliminated && uid){
    if (pulse) g.style.cursor = canInteractWithMapPlayerIcons() ? 'pointer' : 'default';
    const longPressMs = 500;
    let markerLongPressTimer = null;
    let markerLongPressDone = false;
    const clearMarkerLongPress = () => {
      if (!markerLongPressTimer) return;
      clearTimeout(markerLongPressTimer);
      markerLongPressTimer = null;
    };

    g.addEventListener('pointerdown', (e) => {
      if (!canInteractWithMapPlayerIcons()) return;
      if (cardPlayerSelectActive) return;
      if (isEquipSelectionLockActive()) return;
      markerLongPressDone = false;
      clearMarkerLongPress();
      if (!canUseWalpurgisSwap()) return;
      if (uid === state.userId) return;
      markerLongPressTimer = setTimeout(() => {
        markerLongPressDone = true;
        if (!walpurgisSwapCanAttackAfterSwap(uid)){
          showWalpurgisCannotAttackPopAt(e.clientX, e.clientY);
          return;
        }
        showWalpurgisSwapConfirm(e.clientX, e.clientY, uid);
      }, longPressMs);
    });
    g.addEventListener('pointerup', clearMarkerLongPress);
    g.addEventListener('pointerleave', clearMarkerLongPress);
    g.addEventListener('pointercancel', clearMarkerLongPress);

    g.addEventListener('click', (e) => {
      if (!canInteractWithMapPlayerIcons()) return;
      if (cardPlayerSelectActive) return;
      if (isEquipSelectionLockActive()) return;
      clearMarkerLongPress();
      if (markerLongPressDone){
        e.preventDefault();
        e.stopPropagation();
        markerLongPressDone = false;
        return;
      }
      if (!pulse) return;
      e.stopPropagation();
      if (canUseRoom3Action()){
        const p = playerById(uid);
        const nm = safeText(p?.name || "このプレイヤー");
        const room3DamageBlocked = hasGuardianAngelShield(uid) || hasGordonBarrier(uid) || hasEquipmentByName(uid, "幸運のブローチ");
        showRoomActionPopAt(e.clientX, e.clientY, `「${nm}」に実行する効果を選んでください。`, async () => {
          room3ActionUsed = true;
          await updateTurnRoomActionState({ room3ActionUsed:true });
          showTurnHint("");
          await recordFactionRelationInferenceFromRevealedTarget(state.userId, uid, "same", "room3_heal_target_revealed");
          await new Promise(resolve => setTimeout(resolve, 1000));
          await healDamageToPlayer(uid, 1, "room3_heal", { actorUid:uid, skipActionLog:true });
        appendActionChatLog(uid, `市庁舎 ${actionDeltaText(-1)}>${actionTargetWithDamage(uid, -1)}`).catch(() => {});
          renderMarkers();
        }, {
          yesLabel: "1回復する",
          noLabel: "2ダメージ与える",
          noDisabled: room3DamageBlocked,
          compactButtons: true,
          yOffset: -14,
          onNo: async () => {
            room3ActionUsed = true;
            await updateTurnRoomActionState({ room3ActionUsed:true });
            showTurnHint("");
            await recordFactionRelationInferenceFromRevealedTarget(state.userId, uid, "enemy", "room3_damage_target_revealed");
            await new Promise(resolve => setTimeout(resolve, 1000));
            await addDamageToPlayer(uid, 2, { source:"room3", actorUid:state.userId, skipActionLog:true });
            appendActionChatLog(state.userId, `市庁舎 ${actionDeltaText(2)}>${actionTargetWithDamage(uid, 2)}`).catch(() => {});
            renderMarkers();
          }
        });
        return;
      }
      if (mustResolveUranusMeteorStrike()){
        showUranusMeteorConfirmPop(e.clientX, e.clientY, uid);
        return;
      }
      if (!canUseAttackDice()) return;
      const p = playerById(uid);
      pendingAttackTargetUid = uid;
      showAttackPopAt(e.clientX, e.clientY, p?.name || 'このプレイヤー');
    });
  }

  const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
  rect.setAttribute("x", String(x - size/2));
  rect.setAttribute("y", String(y - size/2));
  rect.setAttribute("width", String(size));
  rect.setAttribute("height", String(size));
  rect.setAttribute("rx", String(rx));
  rect.setAttribute("class", "mark-rect");
  if (uid && hasGuardianAngelShield(uid)) rect.classList.add("guardian-shield");
  if (uid && hasGordonBarrier(uid)) rect.classList.add("gordon-barrier");
  rect.setAttribute("fill", String(color || "#ddd"));

  const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
  txt.setAttribute("x", String(x));
  txt.setAttribute("y", String(y+0.5));
  txt.setAttribute("class","mark-text");
  txt.setAttribute("fill", textColorFor(color || "#ddd"));
  txt.textContent = String(initial || "").slice(0,1);

  g.appendChild(rect);
  g.appendChild(txt);
  markerLayer.appendChild(g);
}

  function updateRoomChoiceUi(){
    const choiceMode = canChooseOuterRoomDirectly();
    const emiChoiceSet = new Set(emiTeleportChoiceRoomIds());
    for (let roomId = 1; roomId <= 6; roomId++){
      const pending = !!pendingMoveChoice && !pendingMoveChoice.consumed && pendingMoveChoice.roomIds.includes(roomId);
      roomShapeEls[roomId]?.classList.toggle('room-choice-pulse', choiceMode);
      roomHitEls[roomId]?.classList.toggle('room-choice-pulse', choiceMode);
      roomShapeEls[roomId]?.classList.toggle('emi-room-choice-pulse', emiChoiceSet.has(roomId));
      roomHitEls[roomId]?.classList.toggle('emi-room-choice-pulse', emiChoiceSet.has(roomId));
      if (roomHitEls[roomId]){
        roomHitEls[roomId].style.cursor = (choiceMode || pending || emiChoiceSet.has(roomId)) ? 'pointer' : (isGameStarted() ? 'default' : 'pointer');
      }
    }

    const centerPending = !!pendingMoveChoice && !pendingMoveChoice.consumed && pendingMoveChoice.roomIds.includes(7);
    roomShapeEls[7]?.classList.toggle('room-choice-once', centerPending);
    roomHitEls[7]?.classList.toggle('room-choice-once', centerPending);
    if (roomHitEls[7]){
      roomHitEls[7].style.cursor = centerPending ? 'pointer' : (isGameStarted() ? 'default' : 'pointer');
    }

    for (let roomId = 1; roomId <= 7; roomId++){
      const pulsing =
        roomShapeEls[roomId]?.classList.contains('room-choice-pulse') ||
        roomShapeEls[roomId]?.classList.contains('room-choice-once') ||
        roomShapeEls[roomId]?.classList.contains('emi-room-choice-pulse');
      if (pulsing) bringRoomPulseToFront(roomId);
    }
  }


  function renderMarkers(){
    syncRoomAbilityTurnState();
    ensureMarkerLayer();
    clearMarkerLayer();
    const pulseTargets = highlightedMarkerUids();
    if (canUseMoveDice() && !mustResolveUranusMeteorStrike() && !hasMovedByDiceInCurrentTurn() && !suppressSelfTurnStartPulse) pulseTargets.add(state.userId);
    const entries = Object.entries(markerCache || {});
    for (const [uid, m] of entries){
      if (!m) continue;
      const x = Number(m.x);
      const y = Number(m.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
      const eliminated = isPlayerEliminated(uid);
      if (eliminated) continue;
      const player = playerById(uid);
      const markerColor = safeText(player?.color || "") || String(m.color || "#ddd");
      const markerInitial = firstChar(player?.name || "") || String(m.initial || "");
      drawMarker({
        uid,
        x, y,
        color: markerColor,
        initial: markerInitial,
        pulse: pulseTargets.has(uid),
        eliminated
      });
    }
    updateRoomChoiceUi();
    updateAttackRangeUi();
    if (roomGuideVisible && roomGuideLayer && roomGuideLayer.parentNode === roomG){
      roomG.appendChild(roomGuideLayer);
    }
    refreshRoomAbilityHint();
  }

  function clientToSvgPoint(svg, clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) return {x:0,y:0};
    const p = pt.matrixTransform(ctm.inverse());
    return { x: p.x, y: p.y };
  }

  async function writeMyMarker(x, y){
    if (!state.roomCode) return;
    const color = getMyColor();
    const initial = getMyInitial();
    if (!color || !initial) return;

    const mRef = ref(db, `rooms/${state.roomCode}/markers/${state.userId}`);
    const roomId = inferRoomIdFromPoint(x, y) || state.currentRoomId || null;
    await set(mRef, { x, y, color, initial, roomId, updatedAt: Date.now() });
  }

  function subscribeMarkers(){
    const mRef = ref(db, `rooms/${state.roomCode}/markers`);
    onValue(mRef, snap => {
      markerCache = snap.val() || {};
      const myMarker = markerCache?.[state.userId] || null;
      const myRoomId = markerRoomId(myMarker);
      if (myRoomId && state.currentRoomId !== myRoomId){
        setCurrentRoom(myRoomId);
      }
      renderMarkers();
      maybeAutoRollMoveDiceOnTurnStart();
    });
  }

  function setCurrentRoom(roomId){
    state.currentRoomId = roomId;
    updateCardInteractivity();
  }

  function polygonCenter(pts){
    if (!Array.isArray(pts) || !pts.length) return { x:0, y:0 };
    const sum = pts.reduce((acc, [x,y]) => ({ x: acc.x + Number(x || 0), y: acc.y + Number(y || 0) }), { x:0, y:0 });
    return { x: sum.x / pts.length, y: sum.y / pts.length };
  }

  function clearRoomGuideLayer(){
    if (!roomGuideLayer) return;
    while (roomGuideLayer.firstChild) roomGuideLayer.removeChild(roomGuideLayer.firstChild);
  }

  function ensureRoomGuideLayer(){
    if (roomGuideLayer && roomGuideLayer.parentNode === roomG){
      roomG.appendChild(roomGuideLayer);
      return;
    }
    roomGuideLayer = svgEl('g', { class:'room-guide-layer', id:'roomGuideLayer' }, roomG);
    roomG.appendChild(roomGuideLayer);
  }

  function renderRoomGuideLayer(){
    if (!roomGuideVisible){
      clearRoomGuideLayer();
      return;
    }
    ensureRoomGuideLayer();
    clearRoomGuideLayer();
    for (let roomId = 1; roomId <= 7; roomId++){
      const pts = roomPolygons[roomId];
      const lines = ROOM_GUIDE_LINES[roomId];
      if (!pts || !lines) continue;
      const center = polygonCenter(pts);
      const [dx, dy] = ROOM_GUIDE_OFFSET[roomId] || [0,0];
      const noteG = svgEl('g', {
        transform: `translate(${(center.x + dx).toFixed(2)}, ${(center.y + dy).toFixed(2)})`
      }, roomGuideLayer);
      const lineHeight = 8;
      const paddingX = 5;
      const paddingY = 3;
      const contentHeight = lines.length * lineHeight;
      const topY = -contentHeight / 2;
      const textNodes = [];

      lines.forEach((line, idx) => {
        const txt = svgEl('text', {
          class:'room-guide-note-text',
          x: '0',
          y: (topY + (idx + 0.5) * lineHeight).toFixed(2),
          'dominant-baseline': 'middle'
        }, noteG);
        txt.textContent = String(line);
        textNodes.push(txt);
      });

      const contentWidth = textNodes.reduce((maxWidth, node) => {
        try {
          const w = Number(node.getBBox().width) || 0;
          return Math.max(maxWidth, w);
        } catch {
          return maxWidth;
        }
      }, 0);
      const width = Math.max(34, contentWidth + paddingX * 2);
      const height = contentHeight + paddingY * 2;
      const rect = svgEl('rect', {
        class:'room-guide-note',
        x: (-width / 2).toFixed(2),
        y: (-height / 2).toFixed(2),
        width: width.toFixed(2),
        height: height.toFixed(2),
        rx: 4,
        ry: 4
      }, noteG);
      noteG.insertBefore(rect, noteG.firstChild);
    }
  }

  function renderRoomShape(){
    ensureRoomPatterns();
    while(roomG.firstChild) roomG.removeChild(roomG.firstChild);
    roomGuideLayer = null;
    Object.keys(roomPolygons).forEach(k => delete roomPolygons[k]);
    for (const k of Object.keys(roomShapeEls)) delete roomShapeEls[k];
    for (const k of Object.keys(roomHitEls)) delete roomHitEls[k];

    const { centerHex, rooms } = buildStarRooms(cx, cy, s0, t, tip);
    roomPolygons[7] = centerHex.map(([x,y]) => [x,y]);

    const centerShape = poly(centerHex, 'shape');
    centerShape.dataset.roomId = "7";
    centerShape.setAttribute('fill', "url('#roomPattern7')");
    roomShapeEls[7] = centerShape;

    rooms.forEach((pts, idx)=>{
      const shapeEl = poly(pts, 'shape');
      const hit = poly(pts, 'roomhit');
      const roomId = idx + 1;
      shapeEl.setAttribute('fill', `url('#roomPattern${roomId}')`);
      shapeEl.dataset.roomId = String(roomId);
      roomPolygons[roomId] = pts.map(([x,y]) => [x,y]);
      hit.dataset.roomId = String(roomId);
      roomShapeEls[roomId] = shapeEl;
      roomHitEls[roomId] = hit;

      hit.addEventListener('click', async (ev) => {
        if (cardPlayerSelectActive) return;
        if (isEquipSelectionLockActive()) return;
        if (isGameStarted()){
          if (await resolvePendingMoveChoice(roomId)) return;
          if (await confirmAndMoveByEmiTeleport(roomId, ev.clientX, ev.clientY)) return;
          if (!canChooseOuterRoomDirectly()) return;
          await placeMarkerInRoom(roomId);
          if (state.roomCode && isMyTurn()){
            await update(ref(db, `rooms/${state.roomCode}/turn`), {
              moveDone: true,
              moveAt: Date.now()
            });
          }
          return;
        }
        setCurrentRoom(roomId);
        const p = clientToSvgPoint(roomSvg, ev.clientX, ev.clientY);
        await writeMyMarker(p.x, p.y);
      });
    });

    const centerHit = poly(centerHex, 'roomhit');
    centerHit.dataset.roomId = "7";
    roomHitEls[7] = centerHit;
    centerHit.addEventListener('click', async (ev) => {
      if (cardPlayerSelectActive) return;
      if (isEquipSelectionLockActive()) return;
      if (isGameStarted()){
        if (await resolvePendingMoveChoice(7)) return;
        return;
      }
      setCurrentRoom(7);
      const p = clientToSvgPoint(roomSvg, ev.clientX, ev.clientY);
      await writeMyMarker(p.x, p.y);
    });

    ensureMarkerLayer();
    ensureAttackRangeLayer();
    ensureMarkerLayer();
    renderRoomGuideLayer();
    updateRoomChoiceUi();
    updateAttackRangeUi();
    fitRoomViewBox(2);
  }

  const ROLES = [
    { id:"CIT_A1", name:"アリス",    en:"ALICE",    initial:"A", faction:"シチズン", hp:8,  win:"ゲーム終了時に生存している。", effect:"うさぎさんヒール：手番の初めに使用する。自分のダメージを全回復する。（1回のみ）" },
    { id:"CIT_A2", name:"アンジェラ", en:"ANGELA",  initial:"A", faction:"シチズン", hp:8,  win:"右隣のプレイヤーが勝利する。", effect:"移り気：勝利条件を「左隣のプレイヤーが勝利する」に変更する。（1回のみ）" },
    { id:"CIT_A3", name:"アガサ",    en:"AGATHA",   initial:"A", faction:"シチズン", hp:8,  win:"自分の手番でゲームが終了する。", effect:"完全犯罪：手番の最後に、ダイスを2個振り、合計のエリアにいるプレイヤー全員に3ダメージ与える。（1回のみ）" },
    { id:"CIT_B1", name:"バイロン",  en:"BYRON",    initial:"B", faction:"シチズン", hp:10, win:"装備カードを5枚以上所持している。", effect:"念力の懐中時計：攻撃でダメージを2以上与えた時、ダメージの代わりに装備を1つ奪える。" },
    { id:"CIT_B2", name:"ベンジャミン", en:"BENJAMIN", initial:"B", faction:"シチズン", hp:10, win:"他PLが装備を5つ以上所持している。", effect:"太鼓持ち：手番の最後に使用する。同じエリアにいるプレイヤーに装備を1つ渡せる。" },
    { id:"CIT_B3", name:"ブルース",  en:"BRUCE",    initial:"B", faction:"シチズン", hp:10, win:"攻撃でHP12以上のPLを脱落させるか、終了時にオリバーの隠れ家にいる", effect:"国士無双：攻撃でHP11以下のPLを脱落させた時、必ず自分の正体を公開する。" },
    { id:"CIT_C1", name:"クレイグ",  en:"CRAIG",    initial:"C", faction:"シチズン", hp:11, win:"2人脱落後に他PLを攻撃して脱落させる", effect:"死の饗宴：攻撃した後、自分に2ダメージ与えて、もう一度同じ相手に攻撃できる。" },
    { id:"CIT_C2", name:"キャロル",  en:"CAROL",    initial:"C", faction:"シチズン", hp:11, win:"最初に脱落するか、誰かと2人だけで生存する。", effect:"聖痕：手番の初めに使用できる。自分のダメージを2回復する。" },
    { id:"CIT_C3", name:"クレア",    en:"CLAIRE",   initial:"C", faction:"シチズン", hp:11, win:"自分のダメージが6～8で終わる。", effect:"キャスリング：手番の初めに使用する。自分と他プレイヤーのダメージを入れ替える（1回のみ）" },
    { id:"CIT_D1", name:"ダニエル",  en:"DANIEL",   initial:"D", faction:"シチズン", hp:13, win:"最初に脱落する。またはシャドウ全員が脱落して自分が生存する。", effect:"絶叫：最初に他プレイヤーが脱落した時、必ず自分の正体カードを公開する。" },
    { id:"CIT_D2", name:"デーヴィッド", en:"DAVID",  initial:"D", faction:"シチズン", hp:13, win:"「いにしえの聖杯」「神秘のコンパス」「幸運のブローチ」「銀のロザリオ」のうち3種を所持する。", effect:"グレイブディガー：手番の初めに使用する。脱落者の装備を1枚獲得できる。（1回のみ）" },
    { id:"CIT_D3", name:"デボラ",    en:"DEBORAH",  initial:"D", faction:"シチズン", hp:13, win:"5人：終了時に最もダメージが多い／6人以上：自分以外のシチズンが勝利する。", effect:"献身的な愛：手番の初めに使用する。勝利条件を「脱落する」に変更する。" },
    { id:"RAI_E1", name:"エミ",      en:"EMI",      initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"テレポート：移動のダイスを振った後に、両隣のエリアに移動してもよい。" },
    { id:"RAI_E2", name:"エリカ",    en:"ERIKA",    initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"封印の鎖：手番の初めに使用する。他プレイヤー1人の能力をゲームが終わるまで封印できる。（1回のみ）" },
    { id:"RAI_E3", name:"エマ",      en:"EMMA",     initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"癒しの光：手番の最後に使用する。4面ダイスを振って、同じエリアの他プレイヤー1人を目の数だけ回復する。" },
    { id:"RAI_F1", name:"フェリックス", en:"FELIX", initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"アストラル・メイス：手番初めに、他プレイヤー1人を選んで、6面ダイスを振る。出た目の数だけダメージを与える。（1回）" },
    { id:"RAI_F2", name:"フェリシア", en:"FELICIA", initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"スラム街の天使：手番の初めに使用する。任意のプレイヤーのダメージを7にする（1回）" },
    { id:"RAI_F3", name:"フレディ",  en:"FREDDIE",  initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"ドラゴンアタック：正体公開中のプレイヤーへの攻撃が成功した時、そのダメージを+2する。" },
    { id:"RAI_G1", name:"ゴードン",  en:"GORDON",   initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"絶対無敵バリア：手番の最後に使用する。次の自分の手番の初めまであらゆるダメージを受けない。（1回）" },
    { id:"RAI_G2", name:"ガラハド",  en:"GALAHAD",  initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"魔剣の伝承者：エクスカリバーを持っているなら、攻撃が失敗した時にダイスを振り直す。" },
    { id:"RAI_G3", name:"ゴドウィン", en:"GODWIN",  initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"蘇生装置TYPE-G：自分が脱落した時、既に脱落している他プレイヤー1人を選んでダメージ7で復活させる。" },
    { id:"SHA_U1", name:"ウルリッヒ", en:"ULRICH",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員、またはシチズン3人の脱落", effect:"推理カードを受け取った時、ウソをついてよい。" },
    { id:"SHA_U2", name:"ウラヌス",   en:"URANUS",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員、またはシチズン3人の脱落", effect:"メテオストライク：手番の最初に、「ブラックミス地区」「女王陛下の飛行船」にいるPL1人に3ダメージ与えられる。" },
    { id:"SHA_U3", name:"アルスター", en:"ULSTER",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員、またはシチズン3人の脱落", effect:"デル・フリス：2回攻撃できる。" },
    { id:"SHA_V1", name:"ヴェノム",    en:"VENOM",   initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員、またはシチズン3人の脱落", effect:"反駁の猛毒：攻撃された時、相手に「1ダメージうける」か、「装備を自分に渡す」か選ばせる。" },
    { id:"SHA_V2", name:"ヴァンパイア", en:"VAMPIRE", initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員、またはシチズン3人の脱落", effect:"吸血：攻撃が成功した時にダメージを2回復する。" },
    { id:"SHA_V3", name:"ヴェンデッタ", en:"VENDETTA", initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員、またはシチズン3人の脱落", effect:"冥府の大鎌：攻撃する時は4面ダイスのみ使用する。" },
    { id:"SHA_W1", name:"ワイト",      en:"WIGHT",    initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員、またはシチズン3人の脱落", effect:"亡者の王：手番の最後に使用する。あと《脱落者数》回、追加で手番を行う。（1回のみ）" },
    { id:"SHA_W2", name:"ワルプルギス", en:"WALPURGIS", initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員、またはシチズン3人の脱落", effect:"重力の虹：攻撃する前に任意のプレイヤーと位置を交換できる。" },
    { id:"SHA_W3", name:"ワーウルフ",   en:"WEREWOLF", initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員、またはシチズン3人の脱落", effect:"反撃：攻撃を受けた時、そのプレイヤーをただちに攻撃できる。" },
  ];

  const ROLE_BY_ID = Object.fromEntries(ROLES.map(r => [r.id, r]));
  const POOL = {
    "シチズン": ROLES.filter(r => r.faction === "シチズン"),
    "レイダー": ROLES.filter(r => r.faction === "レイダー"),
    "シャドウ": ROLES.filter(r => r.faction === "シャドウ"),
  };

  const DEAL_RULE = {
    1: { "レイダー": 1, "シャドウ": 0, "シチズン": 0 },
    2: { "レイダー": 1, "シャドウ": 1, "シチズン": 0 },
    3: { "レイダー": 1, "シャドウ": 1, "シチズン": 1 },
    4: { "レイダー": 2, "シャドウ": 2, "シチズン": 0 },
    5: { "レイダー": 2, "シャドウ": 2, "シチズン": 1 },
    6: { "レイダー": 2, "シャドウ": 2, "シチズン": 2 },
    7: { "レイダー": 2, "シャドウ": 2, "シチズン": 3 },
    8: { "レイダー": 3, "シャドウ": 3, "シチズン": 2 },
    9: { "レイダー": 3, "シャドウ": 3, "シチズン": 3 },
    10:{ "レイダー": 3, "シャドウ": 3, "シチズン": 4 },
    11:{ "レイダー": 4, "シャドウ": 4, "シチズン": 3 },
    12:{ "レイダー": 4, "シャドウ": 4, "シチズン": 4 },
  };

  const state = {
    userId: savedUserId,
    userName: null,
    roomCode: null,
    seatedTable: null,
    isHost: false,
    hands: {},
    room: {},
    spectating: false,
    currentRoomId: 0,
  };

  const mainEl = document.getElementById('main');
  const joinBox = document.getElementById('joinBox');
  const inputName = document.getElementById('userName');
  const inputCode = document.getElementById('roomCode');
  const btnJoin = document.getElementById('btnJoin');
  const lobby = document.getElementById('lobby');
  const roomInfo = document.getElementById('roomInfo');
  const lastAttackToMeHeader = document.getElementById('lastAttackToMeHeader');
  const attackRollResult = document.getElementById('attackRollResult');
  const roomInfoLobby = document.getElementById('roomInfoLobby');
  const copyLinkBtn = document.getElementById('copyLinkBtn');

  const seatPopBackdrop = document.getElementById('seatPopBackdrop');
  const seatCountBadge = document.getElementById('seatCountBadge');
  const tileGrid = document.getElementById('tileGrid');
  const startWarn = document.getElementById('startWarn');
  const btnSpectate = document.getElementById('btnSpectate');

  const gameArea = document.getElementById('gameArea');


  let preloadImagesStarted = false;
  function collectImageAssetsForPreload(){
    const fromDeck = [...WHITE_DECK, ...BLACK_DECK]
      .map(card => cardImageFileFromName(card?.name || ""))
      .filter(Boolean);
    const fromRole = ROLES
      .map(role => `${encodeURI(`${safeText(role?.initial || "").trim()}${safeText(role?.name || "").trim()}`)}.jpg`)
      .filter(v => v && v !== '.jpg');
    return [...new Set([
      ...fromDeck,
      ...fromRole,
      'maemain.jpg','back.jpg','gear.jpg','hp.png','endgear.png',
      'greendeck.jpg','whitedeck.jpg','blackdeck.jpg','browncard.jpg','suiri.jpg',
      ...Array.from({length:7}, (_,i) => `room${i+1}.jpg`),
      '4d1.png','4d2.png','4d3.png','4d4.png','4da1.png','4da2.png','4da3.png',
      '6d1.png','6d2.png','6d3.png','6d4.png','6d5.png','6d6.png','6da1.png','6da2.png','6da3.png','6da4.png',
      'map.png'
    ])];
  }
  function startImagePreload(){
    if (preloadImagesStarted) return;
    preloadImagesStarted = true;
    const files = collectImageAssetsForPreload();
    files.forEach((file) => {
      const img = new Image();
      img.decoding = 'async';
      img.src = file;
    });
  }

  const myRoleDock = document.getElementById('myRoleDock');
  const myRoleCard = document.getElementById('myRoleCard');
  const roleHoldPreview = document.createElement('div');
  roleHoldPreview.className = 'role-hold-preview hidden';
  roleHoldPreview.setAttribute('aria-hidden', 'true');
  document.body.appendChild(roleHoldPreview);

  const kickDialog = document.getElementById('kickDialog');
  const kickMessage = document.getElementById('kickMessage');
  const btnKickYes = document.getElementById('btnKickYes');
  const btnKickNo = document.getElementById('btnKickNo');

  const hostSettingsBtn = document.getElementById('hostSettingsBtn');
  const actionChatBtn = document.getElementById('actionChatBtn');
  const actionChatBackdrop = document.getElementById('actionChatBackdrop');
  const actionChatBody = document.getElementById('actionChatBody');
  const actionChatCloseBtn = document.getElementById('actionChatCloseBtn');
  const startPop = document.getElementById('startPop');
  const btnStartPopClose = document.getElementById('btnStartPopClose');
  const btnGameStart = document.getElementById('btnGameStart');
  const btnHostDice = document.getElementById('btnHostDice');
  const btnResetRoom = document.getElementById('btnResetRoom');
  const startBadge = document.getElementById('startBadge');

  const helpBtn = document.getElementById('helpBtn');
  const roomGuideBtn = document.getElementById('roomGuideBtn');
  const helpBackdrop = document.getElementById('helpBackdrop');
  const equipExpandBackdrop = document.getElementById('equipExpandBackdrop');
  const equipExpandBody = document.getElementById('equipExpandBody');
  const helpBody = document.getElementById('helpBody');

  function teamColor(f){
    if (f === "レイダー")  return "#c21d1d";
    if (f === "シャドウ")  return "#0b2a6a";
    if (f === "シチズン") return "#eab308";
    return "#111";
  }
  function cardImageUrl(role){
    const initial = safeText(role?.initial || "").trim();
    const roleName = safeText(role?.name || "").trim();
    const safe = encodeURI(`${initial}${roleName}`.trim());
    return safe ? `url('${safe}.jpg')` : "none";
  }
  function currentPlayerCountForWinText(){
    const startedCount = Number(state?.room?.playerCountAtStart || 0);
    if (startedCount > 0) return startedCount;
    return latestPlayers.length;
  }
  function resolveRoleWinText(role){
    if (!role) return "";
    if (role.id !== "CIT_D3") return role.win || "";
    const n = currentPlayerCountForWinText();
    if (n <= 5) return "終了時に最もダメージが多い。";
    if (n >= 6) return "自分以外のシチズンが勝利する。";
    return role.win || "";
  }
  function resolveRoleEffectHtml(role){
    const effect = String(role?.effect || "");
    const [abilityName, ...rest] = effect.split("：");
    const effectBody = rest.join("：").trim() || effect;

    if (role?.id === "SHA_U1"){
      return `<p class="row ulrich-effect-row">${effectBody}</p>`;
    }

    return `<p class="row"><span class="tag">${abilityName || "技名"}</span>${effectBody}</p>`;
  }
  function createIdentityCard(role){
    const team = teamColor(role.faction);
    const en = (role.en || "").trim() || (role.name || "").trim();
    const chars = Array.from(en);
    const ini = (role.initial && String(role.initial)) || (chars[0] || "");
    const enSub = chars.length >= 2 ? chars.slice(1).join("") : "";

    const teamLabel = (role.faction === "レイダー") ? "RAIDER"
                  : (role.faction === "シャドウ") ? "SHADOW"
                  : (role.faction === "シチズン") ? "CITIZEN"
                  : String(role.faction || "");

    const card = document.createElement('div');
    card.className = 'id72';
    card.style.setProperty('--team', team);
    card.style.backgroundImage = cardImageUrl(role);

    card.innerHTML = `
      <div class="initial"><span>${ini}</span></div>
      <svg class="team-arc" viewBox="0 0 22 10" aria-hidden="true">
        <path id="teamPath" d="M0,3 Q11,9 22,3" fill="none"></path>
        <text>
          <textPath href="#teamPath" startOffset="50%" text-anchor="middle">${teamLabel}</textPath>
        </text>
      </svg>
      <div class="eng-sub">${enSub}</div>
      <div class="name">${role.name || ""}</div>
      <div class="hp-badge" aria-label="HP ${role.hp ?? ""}">
        <div class="label">HP</div>
        <div class="val">${role.hp ?? ""}</div>
      </div>
      <div class="effect${role.id === "CIT_D2" ? " david-all-text" : ""}">
        <p class="row"><span class="tag">勝利条件</span>${resolveRoleWinText(role)}</p>
        ${resolveRoleEffectHtml(role)}
      </div>
    `;
    return card;
  }

  function renderHelpList(){
    helpBody.innerHTML = '';
    const sortedRoles = [...ROLES].sort((a,b) => {
      const order = { "レイダー": 0, "シャドウ": 1, "シチズン": 2 };
      const ao = order[a.faction] ?? 9;
      const bo = order[b.faction] ?? 9;
      if (ao !== bo) return ao - bo;
      if (a.initial !== b.initial) return safeText(a.initial).localeCompare(safeText(b.initial), 'ja');
      return safeText(a.name).localeCompare(safeText(b.name), 'ja');
    });

    const byInitial = new Map();
    sortedRoles.forEach((r) => {
      const key = safeText(r.initial || "?");
      if (!byInitial.has(key)) byInitial.set(key, []);
      byInitial.get(key).push(r);
    });

    function isEquipCard(cardObj){
      const txt = safeText(cardObj?.effect || "").trim();
      return txt.startsWith("装備");
    }
    function sortDeckForHelp(deck){
      return [...(deck || [])].sort((a,b) => {
        const ae = isEquipCard(a) ? 0 : 1;
        const be = isEquipCard(b) ? 0 : 1;
        if (ae !== be) return ae - be;
        return safeText(a?.name || a?.text || "").localeCompare(safeText(b?.name || b?.text || ""), 'ja');
      });
    }

    function makeSection(title){
      const sec = document.createElement('section');
      sec.className = 'help-section';
      const h = document.createElement('h3');
      h.className = 'help-section-title';
      h.textContent = title;
      sec.appendChild(h);
      return sec;
    }

    const currentCount = Number(latestPlayers.length || 0);
    const currentRule = DEAL_RULE[currentCount] || null;
    const roleTitle = currentRule
      ? `正体カードリスト（🔴${Number(currentRule["レイダー"] || 0)}　🔵${Number(currentRule["シャドウ"] || 0)}　🟡${Number(currentRule["シチズン"] || 0)}）`
      : '正体カードリスト';
    const roleSec = makeSection(roleTitle);
    for (const group of byInitial.values()){
      const row = document.createElement('div');
      row.className = 'help-role-row';
      group.forEach((r) => {
        const cardWrap = document.createElement('div');
        cardWrap.className = 'role-card-wrap';
        const roleCard = createIdentityCard(r);
        roleCard.style.cursor = 'pointer';
        if (isTestPlayer()){
          roleCard.addEventListener('click', async (e) => {
            e.stopPropagation();
            await replaceMyRoleCardForTest(r);
          });
        } else {
          roleCard.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = captureSelectionRestoreAction();
            openZoomFromCard(roleCard, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
            setZoomOverPanel(true);
            if (action){
              setZoomPassthrough(false);
              zoomDismissHandler = async () => {
                await restoreSelectionAction(action);
              };
            }
          });
        }
        cardWrap.appendChild(roleCard);
        if (isTestPlayer()){
          cardWrap.title = 'クリックで自分の正体カードをこのカードに変更（能力使用状況はリセット）';
        }
        row.appendChild(cardWrap);
      });
      roleSec.appendChild(row);
    }
    helpBody.appendChild(roleSec);

    function appendDeckSection(title, deck, theme, toCardObj){
      const sec = makeSection(title);
      const grid = document.createElement('div');
      grid.className = 'help-card-grid';
      sortDeckForHelp(deck).forEach((cardData) => {
        const cardObj = toCardObj(cardData);
        const slot = document.createElement('div');
        slot.className = 'help-card-slot';
        const card = document.createElement('div');
        card.className = `card72 wb-front ${theme === 'black' ? 'wb-black' : theme === 'green' ? 'wb-green' : 'wb-white'}`;
        card.innerHTML = buildWbFrontHTML(cardObj, theme);
        adjustCardNameFont(card);
        card.style.cursor = 'pointer';
        card.addEventListener('click', async (e) => {
          e.stopPropagation();
          if (isTestPlayer() && isEquipCard(cardObj)){
            await grantEquipmentToMe(cardObj, theme);
            return;
          }
          if (isTestPlayer() && (theme === 'white' || theme === 'black')){
            await setDeckToSingleCardForTest(theme, cardObj);
            return;
          }
          const action = captureSelectionRestoreAction();
          openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
          setZoomOverPanel(true);
          if (action){
            setZoomPassthrough(false);
            zoomDismissHandler = async () => {
              await restoreSelectionAction(action);
            };
          }
        });
        slot.appendChild(card);
        grid.appendChild(slot);
      });
      sec.appendChild(grid);
      helpBody.appendChild(sec);
    }

    appendDeckSection('白カードリスト', WHITE_DECK, 'white', (c) => c);
    appendDeckSection('黒カードリスト', BLACK_DECK, 'black', (c) => c);
    appendDeckSection('推理カードリスト', GREEN_DECK, 'green', (c) => {
      const text = safeText(c?.text || '').replace(/^推理カード：/, '').trim();
      return { name:'推理カード', effect:text };
    });
  }
  function openHelp(){
    renderHelpList();
    helpBackdrop.classList.remove('hidden');
  }
  async function replaceMyRoleCardForTest(role){
    if (!isTestPlayer()) return;
    if (!state.roomCode || !state.userId || !role?.id) return;
    const prev = state.hands?.[state.userId] || {};
    await update(ref(db, `rooms/${state.roomCode}`), {
      [`hands/${state.userId}`]: {
        ...prev,
        roleId: role.id,
        testReplacedAt: Date.now()
      },
      [`equipment/${state.userId}/identity`]: null
    });
    await resetAllAbilityUsageForUids([state.userId]);
  }
  function closeHelp(){ helpBackdrop.classList.add('hidden'); }
  function renderEquipExpandBody(){
    if (!equipExpandBody || !equipBody) return;
    equipExpandBody.innerHTML = equipBody.innerHTML;
  }
  function findEquipBodyCardFromDataset(cardEl){
    if (!cardEl || !equipBody) return null;
    const ownerUid = safeText(cardEl.dataset.ownerUid || "");
    const sourceKey = safeText(cardEl.dataset.sourceKey || "");
    const roleId = safeText(cardEl.dataset.roleId || "");
    if (ownerUid && sourceKey){
      return equipBody.querySelector(`.card72.wb-front[data-owner-uid="${ownerUid}"][data-source-key="${sourceKey}"], .id72[data-owner-uid="${ownerUid}"][data-source-key="${sourceKey}"]`);
    }
    if (ownerUid && roleId){
      return equipBody.querySelector(`.id72[data-owner-uid="${ownerUid}"][data-role-id="${roleId}"]`);
    }
    return null;
  }
  function openEquipSelectionTempZoom(cardEl, action){
    if (!cardEl || !action) return;
    greenShareDock?.classList.add("hidden");
    openZoomFromCard(cardEl, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
    setZoomOverPanel(true);
    setZoomPassthrough(false);
    zoomDismissHandler = async () => {
      restorePendingEquipSelection(action);
    };
  }
  function openEquipExpand(){
    if (!equipDock?.classList.contains('visible')) return;
    renderEquipExpandBody();
    equipExpandBackdrop?.classList.remove('hidden');
  }
  function closeEquipExpand(){
    equipExpandBackdrop?.classList.add('hidden');
    if (isEquipSelectionLockActive() && zoomBackdrop?.classList.contains('hidden')){
      restorePendingEquipSelection();
    }
  }
  function closeEquipExpandIfOpen(){
    if (!equipExpandBackdrop || equipExpandBackdrop.classList.contains('hidden')) return;
    closeEquipExpand();
  }
  function toggleRoomGuideOverlay(){
    roomGuideVisible = !roomGuideVisible;
    roomGuideBtn.classList.toggle('active', roomGuideVisible);
    renderRoomGuideLayer();
  }
  helpBtn.addEventListener('click', () => {
    if (!joinBox.classList.contains('hidden')) return;
    if (helpBackdrop.classList.contains('hidden')) openHelp();
    else closeHelp();
  });
  roomGuideBtn.addEventListener('click', () => {
    if (isIdentityPromptInteractionLockActive()) return;
    if (joinBox.classList.contains('hidden')) toggleRoomGuideOverlay();
  });
  helpBackdrop.addEventListener('click', (e) => {
    if (!helpBackdrop.classList.contains('hidden') && !e.target.closest('.help-pop')) closeHelp();
  });
  equipExpandBackdrop?.addEventListener('click', (e) => {
    if (!equipExpandBackdrop.classList.contains('hidden') && !e.target.closest('.equip-expand-pop')) closeEquipExpand();
  });
  equipExpandBody?.addEventListener('click', (e) => {
    const card = e.target.closest('.card72.wb-front, .id72');
    if (!card) return;
    e.stopPropagation();

    const action = captureSelectionRestoreAction();
    const ownerUid = safeText(card.dataset.ownerUid || "");
    const sourceKey = safeText(card.dataset.sourceKey || "");

    if (action?.kind === 'equip' && action?.type === 'oliver_target' && (!card.classList.contains('equip-steal-pulse') || !ownerUid || ownerUid === state.userId || !sourceKey)){
      openEquipSelectionTempZoom(card, action);
      return;
    }
    if (action?.kind === 'equip' && action?.type === 'banana_give' && (ownerUid !== state.userId || !sourceKey)){
      openEquipSelectionTempZoom(card, action);
      return;
    }

    const linked = findEquipBodyCardFromDataset(card);
    if (linked){
      equipSelectionStartedFromExpand = true;
      linked.click();
      return;
    }
    if (action){
      greenShareDock?.classList.add("hidden");
      openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
      setZoomOverPanel(true);
      setZoomPassthrough(false);
      zoomDismissHandler = async () => {
        await restoreSelectionAction(action);
      };
      return;
    }
    openZoomFromCard(card, { closeOnBackdrop:true, showCloseButton:false, closeOnAnyClick:true });
    setZoomOverPanel(true);
    setZoomPassthrough(false);
  });

  const SEAT_COLORS = [
    "#ef4444", // 赤
    "#3b82f6", // 青
    "#111111", // 黒
    "#ec4899", // ピンク
    "#1e3a8a", // ネイビー
    "#16a34a", // 緑
    "#facc15", // 黄
    "#67e8f9", // 水色
    "#630d23", // 茶
    "#fb923c", // オレンジ
    "#ffffff", // 白
    "#9b72b0"  // パープル
  ];

  const seatKey = (room)=>`bbSeat_${room}_${state.userId}`;
  const attackResolutionKey = (room)=>`bbAttackResolution_${room}_${state.userId}`;

  function isGameStarted(){
    return !!(state.room && (state.room.gameStarted || state.room.startedAt));
  }


  async function resetAllAbilityUsageForUids(uids){
    if (!state.roomCode) return;
    const targets = [...new Set((uids || []).map(uid => safeText(uid)).filter(Boolean))];
    if (!targets.length) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    await runTransaction(roomRef, (cur) => {
      if (!cur || !cur.abilityUsage) return cur;
      for (const usageMap of Object.values(cur.abilityUsage || {})){
        if (!usageMap || typeof usageMap !== 'object') continue;
        for (const uid of targets){
          if (Object.prototype.hasOwnProperty.call(usageMap, uid)){
            delete usageMap[uid];
          }
        }
      }
      return cur;
    });
  }

  function moveAbilityUsageUid(cur, fromUid, toUid){
    if (!cur || typeof cur !== 'object') return;
    for (const value of Object.values(cur)){
      if (!value || typeof value !== 'object') continue;
      if (Object.prototype.hasOwnProperty.call(value, fromUid)){
        value[toUid] = value[fromUid];
        delete value[fromUid];
      }
      moveAbilityUsageUid(value, fromUid, toUid);
    }
  }

  async function syncMySeatNameIfNeeded(){
    if (!state.roomCode || !state.userId || !state.userName) return;
    const seat = Number(state.seatedTable || 0);
    if (!seat) return;

    const seatRef = ref(db, `rooms/${state.roomCode}/tables/${seat}`);
    const snap = await get(seatRef);
    const row = snap.val() || null;
    if (!row || row.playerId !== state.userId) return;

    const nextName = safeText(state.userName || '名無し') || '名無し';
    const nextColor = SEAT_COLORS[seat - 1] || null;
    if (safeText(row.playerName || '') === nextName && (row.color || null) === nextColor) return;

    await update(seatRef, {
      playerName: nextName,
      color: nextColor,
      renamedAt: Date.now()
    });

    const markerRef = ref(db, `rooms/${state.roomCode}/markers/${state.userId}`);
    const markerSnap = await get(markerRef);
    const marker = markerSnap.val() || null;
    if (marker){
      await update(markerRef, {
        initial: firstChar(nextName || "") || safeText(marker.initial || ""),
        color: nextColor || safeText(marker.color || "#ddd"),
        updatedAt: Date.now()
      });
    }
  }
  function isSeated(){ return state.seatedTable != null; }

  function showSeatPop(){ seatPopBackdrop.classList.remove('hidden'); }
  function hideSeatPop(){
    if (!isGameStarted()) return;
    seatPopBackdrop.classList.add('hidden');
  }
  function updateSeatBoardVisibility(){
    const started = isGameStarted();
    const seated = isSeated();
    let shouldShow = false;

    if (!state.roomCode) shouldShow = false;
    else if (!started) shouldShow = !state.spectating;
    else shouldShow = (!seated) && (!state.spectating);

    if (shouldShow) showSeatPop(); else hideSeatPop();
  }

  btnSpectate.addEventListener('click', () => {
    state.spectating = true;
    if (isGameStarted()) hideSeatPop();
  });

  function generateRoomCode(length = 6){
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
    return code;
  }

  function refreshRoomLabels(){
    if (!state.roomCode || !state.userName) return;
    const label = state.isHost ? '（ホスト）' : '';
    const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
    roomInfo.textContent = infoText;
    roomInfoLobby.textContent = infoText;
  }

  function didAttackRollSucceed(d6, d4, options = {}){
    if (options.masamuneMode || options.vendettaMode) return true;
    return (Number(d6) || 0) !== (Number(d4) || 0);
  }

  // TODO: デバッグ用表示。後で消すときは #attackRollResult / .attack-roll-result-debug を非表示にする。
  function setAttackRollResultLabel(isSuccess){
    if (!attackRollResult) return;
    attackRollResult.textContent = isSuccess ? '攻撃成功' : '攻撃失敗';
  }

  function renderLastAttackToMeHeader(){
    if (!lastAttackToMeHeader) return;
    const me = latestPlayers.find(p => p.id === state.userId);
    const seat = Number(me?.lastattacktome || 0);
    if (!seat){
      lastAttackToMeHeader.textContent = '';
      return;
    }
    const names = latestPlayers
      .filter(p => p.seatIndex === seat)
      .map(p => safeText(p.name || ''))
      .filter(Boolean);
    const nameLabel = names.length ? names.join(' / ') : '（空席）';
    lastAttackToMeHeader.textContent = `lastattacktome: ${nameLabel}`;
  }

  async function recordLastAttackToMe(targetUids){
    if (!state.roomCode) return;
    const attackerSeat = Number(latestPlayers.find(p => p.id === state.userId)?.seatIndex || state.seatedTable || 0);
    if (!attackerSeat) return;
    const updates = {};
    for (const uid of [...new Set(targetUids || [])]){
      const targetSeat = Number(latestPlayers.find(p => p.id === safeText(uid))?.seatIndex || 0);
      if (!targetSeat) continue;
      updates[`tables/${targetSeat}/lastattacktome`] = attackerSeat;
    }
    if (!Object.keys(updates).length) return;
    await update(ref(db, `rooms/${state.roomCode}`), updates);
  }

  function updateHostUI(){
    refreshRoomLabels();
    const showActionChat = state.isHost && isNpcActionChatMode();
    if (state.isHost){
      hostSettingsBtn.classList.add('visible');
      roomGuideBtn.classList.remove('visible');
      roomGuideBtn.classList.remove('host-position');
    } else {
      hostSettingsBtn.classList.remove('visible');
      startPop.classList.add('hidden');
      roomGuideBtn.classList.add('visible');
      roomGuideBtn.classList.remove('host-position');
    }
    actionChatBtn?.classList.toggle('visible', showActionChat);
    if (!showActionChat) actionChatBackdrop?.classList.add('hidden');
    helpBtn.classList.add('visible');
  }

  function subscribeRoom(){
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    onValue(roomRef, snap => {
      state.room = snap.val() || {};
      updateHostUI();
      restorePendingAttackResolutionFromRoom();
      restoreAttackLootPendingFromRoom();
      if (isGameStarted() && !currentTurnPlayerId() && state.isHost){
        ensureTurnInitialized();
      }
      renderSeatTiles();
      refreshStartBadge();
      renderHands();
      updateSeatBoardVisibility();
      renderEquipmentDock();
      renderHpBoard();
      renderPositionLine();
      renderTurnEndButton();
      renderCounterAbilityPrompt();
      syncPersistentVenomOverlay();
      syncDavidOverlayFloatingButtons();
      ensureDavidOverlayVisibleForAll();
      renderMarkers();
      renderActionChatLog();
      syncPendingMoveChoiceOwnership();
      restorePendingMoveChoiceFromSeat();
      updateCardInteractivity();
      maybeAutoRollMoveDiceOnTurnStart();
      runNpcTurnIfNeeded();
      resolveNpcCounterPromptsIfNeeded().catch(() => {});
      syncAutoIdentityRevealTimer();
      evaluateAutoIdentityRevealTrigger();
      syncTurnStartBoard();
      tryResolveDeferredTurnEnd().catch(() => {});
    });
  }

  function subscribeHostState(){
    const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
    onValue(hostRef, snap => {
      const hostId = snap.val();
      state.isHost = (hostId === state.userId);
      updateHostUI();
    });
  }

  function subscribeHands(){
    const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
    onValue(handsRef, snap => {
      state.hands = snap.val() || {};
      for (const [uid, hand] of Object.entries(state.hands || {})){
        const rid = safeText(hand?.roleId || "");
        const rname = safeText(ROLE_BY_ID?.[rid]?.name || "");
        if (rname) lastKnownRoleNameByUid[safeText(uid)] = rname;
      }
      renderHands();
      tryRestorePendingGreenSession();
      tryRestorePendingCardTargetSession().catch(() => {});
      evaluateAutoIdentityRevealTrigger();
    });
  }


  function subscribeGreenInbox(){
    const inboxRef = ref(db, `rooms/${state.roomCode}/greenInbox/${state.userId}`);
    onValue(inboxRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!greenInboxInitialized){
        greenInboxInitialized = true;
        greenInboxSeenAt = at || 0;
        return;
      }

      if (!msg || !msg.card || !at) return;
      if (at <= greenInboxSeenAt) return;
      greenInboxSeenAt = at;
      openZoomFromDeckCard(msg.card, "green", { closeOnBackdrop:false, showCloseButton:false });
      openGreenAnswerDock(msg);
    });
  }

  function applyGreenResponseToWaitingSession(msg){
    const at = Number(msg?.at || 0);
    if (!msg || !at) return false;
    const requestId = safeText(msg.requestId || "");
    if (!pendingGreenRequestId || requestId !== pendingGreenRequestId) return false;
    greenReplySeenAt = Math.max(greenReplySeenAt, at);
    setGreenDockMeta({ title:"回答が届きました", subtitle:safeText(msg.answerLabel || "") });
    const reveal = greenRevealByRequestId[requestId];
    if (reveal?.roleId){
      showGreenRevealPanel(reveal.roleId, reveal.responderId);
    }
    greenShareActions?.classList.remove("hidden");
    const responder = playerById(safeText(msg.to || ""));
    appendGreenHistoryLogFromResponse(msg);
    setGreenSessionState({
      phase:"confirm",
      card: greenShareCard || msg.card || null,
      requestId,
      toUid: safeText(msg.to || ""),
      toName: safeText(responder?.name || ""),
      toInitial: firstChar(responder?.name || ""),
      toColor: safeText(responder?.color || ""),
      answerLabel: safeText(msg.answerLabel || "")
    }).catch(() => {});
    return true;
  }

  function subscribeGreenResponses(){
    const resRef = ref(db, `rooms/${state.roomCode}/greenResponses/${state.userId}`);
    onValue(resRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!greenReplyInitialized){
        greenReplyInitialized = true;
        const handledOnInit = applyGreenResponseToWaitingSession(msg);
        greenReplySeenAt = handledOnInit ? Math.max(greenReplySeenAt, at || 0) : (at || 0);
        return;
      }

      if (!msg || !at) return;
      if (at <= greenReplySeenAt) return;
      applyGreenResponseToWaitingSession(msg);
    });
  }

  function tryRestorePendingGreenSession(){
    const entry = pendingGreenSessionEntry;
    if (!entry) return;
    const phase = safeText(entry?.phase || "");
    if (!phase){
      pendingGreenSessionEntry = null;
      return;
    }
    const needsPlayers = phase !== "answering";
    if (phase === "answering" && !myRoleInfo()) return;
    if (needsPlayers){
      if (latestPlayers.length === 0) return;
      const mySeatReady = latestPlayers.some(p => p.id === state.userId);
      if (!mySeatReady) return;
    }
    restoreGreenSessionUI(entry);
    pendingGreenSessionEntry = null;
  }

  function subscribeGreenSessionState(){
    const gsRef = ref(db, `rooms/${state.roomCode}/greenSessions/${state.userId}`);
    onValue(gsRef, snap => {
      const data = snap.val() || null;
      const at = Number(data?.at || 0);

      if (!greenSessionInitialized){
        greenSessionInitialized = true;
        greenSessionSeenAt = at || 0;
        if (data){
          pendingGreenSessionEntry = data;
          tryRestorePendingGreenSession();
        }
        return;
      }

      if (!data){
        pendingGreenSessionEntry = null;
        if (pendingGreenAnswerMsg || pendingGreenRequestId || (greenShareCard && !greenShareDock?.classList.contains("hidden"))){
          hideGreenShareDock();
          closeZoom();
        }
        return;
      }
      if (!at) return;
      if (at <= greenSessionSeenAt) return;
      greenSessionSeenAt = at;
      pendingGreenSessionEntry = data;
      tryRestorePendingGreenSession();
    });
  }


  async function tryRestorePendingCardTargetSession(){
    const entry = pendingCardTargetSessionEntry;
    if (!entry) return;
    const phase = safeText(entry?.phase || "");
    if (!phase){
      pendingCardTargetSessionEntry = null;
      await setCardTargetSessionState(null);
      return;
    }
    if (latestPlayers.length === 0) return;
    const mySeatReady = latestPlayers.some(p => p.id === state.userId);
    if (!mySeatReady) return;

    pendingCardTargetSessionEntry = null;
    cardTargetSessionRestoring = true;
    try {
      if (phase === "resolving"){
        await resolveCardTargetSessionEntry(entry);
      } else {
        await openPersistentCardTargetSelection(entry.card || null, { restore:true });
      }
    } finally {
      cardTargetSessionRestoring = false;
    }
  }

  function subscribeRoleAbilitySelectionState(){
    const selectionRef = ref(db, `rooms/${state.roomCode}/roleAbilitySelection`);
    onValue(selectionRef, snap => {
      const data = snap.val() || null;
      const at = Number(data?.at || 0);
      if (!roleAbilitySelectionInitialized){
        roleAbilitySelectionInitialized = true;
        roleAbilitySelectionSeenAt = at || 0;
        if (data) openRoleAbilitySelectionUI(data);
        return;
      }
      if (!data){
        activeRoleAbilitySelection = null;
        if (pendingEquipAction?.type === "benjamin_give"){
          pendingEquipAction = null;
          setSeatEquipSelectionState(null).catch(() => {});
          renderEquipmentDock();
        }
        cardPlayerSelectActive = false;
        greenShareDock?.classList.add("hidden");
        renderTurnEndButton();
        updateCardInteractivity();
        if (!zoomBackdrop?.classList.contains("hidden")) closeZoom();
        return;
      }
      if (!at || at <= roleAbilitySelectionSeenAt) return;
      roleAbilitySelectionSeenAt = at;
      openRoleAbilitySelectionUI(data);
    });
  }

  function subscribeCardTargetSessionState(){
    const sessionRef = ref(db, `rooms/${state.roomCode}/cardTargetSessions/${state.userId}`);
    onValue(sessionRef, snap => {
      const data = snap.val() || null;
      const at = Number(data?.at || 0);

      if (!cardTargetSessionInitialized){
        cardTargetSessionInitialized = true;
        cardTargetSessionSeenAt = at || 0;
        if (data){
          pendingCardTargetSessionEntry = data;
          tryRestorePendingCardTargetSession().catch(() => {});
        }
        return;
      }

      if (!data){
        pendingCardTargetSessionEntry = null;
        pendingCardTargetSelection = null;
        cardPlayerSelectActive = false;
        updateCardInteractivity();
        greenShareDock?.classList.add("hidden");
        closeZoom();
        renderTurnEndButton();
        return;
      }
      if (!at) return;
      if (at <= cardTargetSessionSeenAt) return;
      cardTargetSessionSeenAt = at;
      pendingCardTargetSessionEntry = data;
      tryRestorePendingCardTargetSession().catch(() => {});
    });
  }

  function subscribeSeatEquipSelectionState(){
    const seat = Number(state.seatedTable || 0);
    if (seatEquipSelectionUnsubscribe && subscribedSeatEquipSelectionIndex !== seat){
      seatEquipSelectionUnsubscribe();
      seatEquipSelectionUnsubscribe = null;
      subscribedSeatEquipSelectionIndex = null;
    }
    if (!state.roomCode || !seat){
      if (isEquipSelectionLockActive()){
        pendingEquipAction = null;
        greenShareDock?.classList.add("hidden");
        closeZoom();
        renderEquipmentDock();
        renderTurnEndButton();
      }
      return;
    }
    if (seatEquipSelectionUnsubscribe && subscribedSeatEquipSelectionIndex === seat) return;

    subscribedSeatEquipSelectionIndex = seat;
    const selectionRef = ref(db, `rooms/${state.roomCode}/seatEquipSelectionState/${seat}`);
    seatEquipSelectionUnsubscribe = onValue(selectionRef, (snap) => {
      const data = snap.val() || null;
      if (!data){
        if (isEquipSelectionLockActive()){
          pendingEquipAction = null;
          greenShareDock?.classList.add("hidden");
          closeZoom();
          renderEquipmentDock();
          renderTurnEndButton();
        }
        return;
      }
      restoreSeatEquipSelection(data);
    });
  }

  function subscribeSeatPromptState(){
    const seat = Number(state.seatedTable || 0);
    if (seatPromptUnsubscribe && subscribedSeatPromptIndex !== seat){
      seatPromptUnsubscribe();
      seatPromptUnsubscribe = null;
      subscribedSeatPromptIndex = null;
    }
    if (!state.roomCode || !seat){
      const wasOpen = !identityPromptPop?.classList.contains("hidden");
      hideIdentityPrompt();
      if (wasOpen) closeZoom();
      return;
    }
    if (seatPromptUnsubscribe && subscribedSeatPromptIndex === seat) return;

    subscribedSeatPromptIndex = seat;
    const seatPromptRef = ref(db, `rooms/${state.roomCode}/seatPromptState/${seat}`);
    seatPromptUnsubscribe = onValue(seatPromptRef, (snap) => {
      const data = snap.val() || null;
      if (!data || safeText(data.type || "") !== "identity_prompt"){
        const wasOpen = !identityPromptPop?.classList.contains("hidden");
        hideIdentityPrompt();
        if (wasOpen) closeZoom();
        return;
      }
      const cardName = safeText(data.cardName || "");
      const resolver = buildIdentityPromptResolver(cardName);
      const payload = identityPromptPayloadFromCard(cardName);
      if (!resolver || !payload) return;
      restoringSeatIdentityPrompt = true;
      try {
        showIdentityPromptPop({
          message: safeText(data.message || payload.message),
          canReveal: !!data.canReveal,
          cardObj: cardByName(cardName) || { name: cardName },
          cardTheme: safeText(data.cardTheme || payload.cardTheme || "white") || "white",
          openZoom: true,
          onYes: resolver
        });
      } finally {
        restoringSeatIdentityPrompt = false;
      }
    });
  }
  function subscribeGreenReveals(){
    const revealRef = ref(db, `rooms/${state.roomCode}/greenReveals`);
    onValue(revealRef, snap => {
      greenRevealByRequestId = snap.val() || {};
      const pendingReveal = greenRevealByRequestId[safeText(pendingGreenRequestId || "")];
      if (pendingReveal?.roleId){
        showGreenRevealPanel(pendingReveal.roleId, pendingReveal.responderId);
        return;
      }
      const answerReveal = greenRevealByRequestId[safeText(pendingGreenAnswerMsg?.requestId || "")];
      if (answerReveal?.roleId){
        showGreenRevealPanel(answerReveal.roleId, answerReveal.responderId);
        return;
      }
      hideGreenRevealPanel();
    });
  }


  function subscribeGreenCloseSignals(){
    const closeRef = ref(db, `rooms/${state.roomCode}/greenCloseSignals/${state.userId}`);
    onValue(closeRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!pendingGreenCloseInitialized){
        pendingGreenCloseInitialized = true;
        pendingGreenCloseSeenAt = at || 0;
        return;
      }

      if (!msg || !at) return;
      if (at <= pendingGreenCloseSeenAt) return;
      pendingGreenCloseSeenAt = at;

      const requestId = safeText(msg.requestId || "");
      if (!requestId) return;
      const pendingAnswerRequest = safeText(pendingGreenAnswerMsg?.requestId || "");
      const pendingShareRequest = safeText(pendingGreenRequestId || "");
      if (requestId !== pendingAnswerRequest && requestId !== pendingShareRequest) return;

      pendingGreenAnswerMsg = null;
      remove(ref(db, `rooms/${state.roomCode}/greenReplyBubbles/${requestId}`)).catch(() => {});
      hideGreenShareDock();
      closeZoom();
      setGreenSessionState(null).catch(() => {});
    });
  }

  function subscribePlayers(){
    const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
    onValue(tablesRef, snap => {
      const wasSeated = state.seatedTable != null;
      const data = snap.val() || {};
      const players = Object.entries(data)
        .map(([seatIndex, t]) => (t && t.playerId ? {
          id: t.playerId,
          name: t.playerName || '名無し',
          seatIndex: Number(seatIndex),
          color: t.color || null,
          lastattacktome: Number(t.lastattacktome || 0)
        } : null))
        .filter(Boolean)
        .sort((a,b) => a.seatIndex - b.seatIndex);

      latestPlayers = players;
      for (const p of players){
        const uid = safeText(p.id || "");
        if (!uid) continue;
        const name = safeText(p.name || "");
        if (name) lastKnownNameByUid[uid] = name;
      }
      updateHostUI();
      tryRestorePendingGreenSession();
      tryRestorePendingCardTargetSession().catch(() => {});
      if (activeRoleAbilitySelection){
        openRoleAbilitySelectionUI(activeRoleAbilitySelection);
      }

      const mySeat = players.find(p => p.id === state.userId);
      if (mySeat) {
        state.seatedTable = mySeat.seatIndex;
        sessionStorage.setItem(seatKey(state.roomCode), String(mySeat.seatIndex));
      } else {
        state.seatedTable = null;
        if (wasSeated){
          state.spectating = false;
          hideGreenShareDock();
          hideIdentityPrompt();
          closeZoom();
        }
        sessionStorage.removeItem(seatKey(state.roomCode));
      }

      subscribeSeatPromptState();
      subscribeSeatEquipSelectionState();
      renderSeatTiles();
      refreshStartBadge();
      updateSeatBoardVisibility();
      renderEquipmentDock();
      renderHpBoard();
      renderPositionLine();
      renderLastAttackToMeHeader();
      evaluateAutoIdentityRevealTrigger();
    });
  }

  function effectiveSeatCount(){
    const mp = Number(state.room.maxPlayers || 0);
    return (mp >= 2) ? mp : SEAT_COLORS.length;
  }
  function occupiedCount(){ return latestPlayers.length; }

  let pendingSeatIndexToSteal = null;
  let pendingSeatPlayerIdToSteal = null;
  let pendingMode = "prestart";

  function renderSeatTiles(){
    if (!state.roomCode) return;

    const started = isGameStarted();
    const N = effectiveSeatCount();
    seatCountBadge.textContent = `${occupiedCount()} / ${N}`;

    tileGrid.innerHTML = '';

    for(let i=1;i<=N;i++){
      const color = SEAT_COLORS[i-1] || "#ddd";
      const seatIndex = i;

      const tile = document.createElement('button');
      tile.type = 'button';
      tile.className = 'seat-tile empty';
      tile.style.background = color;
      tile.setAttribute('aria-label', `席 ${seatIndex}`);

      const taken = latestPlayers.find(p => p.seatIndex === seatIndex);
      if (taken){
        tile.classList.remove('empty');
        tile.classList.add('taken');
        const initial = document.createElement('div');
        initial.className = 'seat-initial';
        initial.style.color = textColorFor(color);
        initial.textContent = firstChar(taken.name);
        tile.appendChild(initial);
      }

      if (state.seatedTable === seatIndex) tile.classList.add('me');

      tile.addEventListener('click', async () => {
        if (!state.roomCode) return;

        const startedNow = isGameStarted();

        if (startedNow){
          if (isSeated()) return;
          if (!taken){
            alert("ゲーム開始後は空席に座れません。席を奪取してください。");
            return;
          }
          pendingMode = "started";
          pendingSeatIndexToSteal = seatIndex;
          pendingSeatPlayerIdToSteal = taken.id;

          kickMessage.textContent = `「${taken.name}」を追い出しますか？`;
          kickDialog.classList.remove('hidden');
          return;
        }

        if (state.seatedTable !== null){
          if (seatIndex === state.seatedTable) return;
          if (taken) return;
          await moveSeatToEmpty(seatIndex);
          return;
        }

        if (!taken){
          await sitToSeat(seatIndex);
          state.spectating = true;
          return;
        }

        pendingMode = "prestart";
        pendingSeatIndexToSteal = seatIndex;
        pendingSeatPlayerIdToSteal = taken.id;

        kickMessage.textContent = `「${taken.name}」を追い出して、この色の席を奪取しますか？`;
        kickDialog.classList.remove('hidden');
      });

      tileGrid.appendChild(tile);
    }

    startWarn.textContent = started
      ? "※ゲーム開始済み（再入室には座席をクリックして追い出してください。）"
      : "※ホストが「スタート」を押すと配布されます";
  }

  async function sitToSeat(seatIndex){
    const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
    await set(tRef, {
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[seatIndex-1] || null,
      seatedAt: Date.now()
    });
    state.seatedTable = seatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(seatIndex));
  }

  async function moveSeatToEmpty(newSeatIndex){
    if (!state.roomCode) return;
    const oldSeatIndex = state.seatedTable;
    if (oldSeatIndex == null) return;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap = await get(roomRef);
    const roomData = snap.val() || {};
    if (roomData.gameStarted || roomData.startedAt) return;

    const tables = roomData.tables || {};
    const oldSeat = tables[String(oldSeatIndex)];
    const newSeat = tables[String(newSeatIndex)];

    if (!oldSeat || oldSeat.playerId !== state.userId) return;
    if (newSeat && newSeat.playerId) return;

    const updates = {};
    updates[`tables/${oldSeatIndex}`] = null;
    updates[`tables/${newSeatIndex}`] = {
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[newSeatIndex-1] || null,
      seatedAt: Date.now(),
      movedFrom: oldSeatIndex,
      movedAt: Date.now()
    };

    await update(roomRef, updates);

    state.seatedTable = newSeatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(newSeatIndex));
  }

  async function stealSeatPrestart(seatIndex, previousPlayerId){
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    if (roomData.gameStarted || roomData.startedAt) return;

    await sitToSeat(seatIndex);

    const updates = {};
    const markers = roomData.markers || {};
    const prevMarker = previousPlayerId ? markers[previousPlayerId] : null;
    if (prevMarker){
      updates[`markers/${state.userId}`] = {
        ...prevMarker,
        color: SEAT_COLORS[seatIndex-1] || null,
        initial: firstChar(state.userName || "") || safeText(prevMarker.initial || ""),
        updatedAt: Date.now(),
        inheritedFrom: previousPlayerId
      };
      updates[`markers/${previousPlayerId}`] = null;
    }

    if (Object.keys(updates).length){
      await update(roomRef, updates);
      await resetAllAbilityUsageForUids([state.userId, previousPlayerId]);
    }

    if (roomData.hostId && previousPlayerId && roomData.hostId === previousPlayerId) {
      await update(roomRef, { hostId: state.userId });
    }

    state.spectating = true;
  }

  async function stealSeatStarted(seatIndex, previousPlayerId){
    if (!state.roomCode) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap = await get(roomRef);
    const roomData = snap.val() || {};

    if (!(roomData.gameStarted || roomData.startedAt)) return;

    const tables = roomData.tables || {};
    const alreadySeated = Object.values(tables).some(t => t && t.playerId === state.userId);
    if (alreadySeated) return;

    const cur = tables[String(seatIndex)];
    if (!cur || cur.playerId !== previousPlayerId) return;

    const updates = {};
    updates[`tables/${seatIndex}`] = {
      ...(cur || {}),
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[seatIndex-1] || null,
      seatedAt: Date.now(),
      stolenFrom: previousPlayerId,
      stolenAt: Date.now()
    };

    const hands = roomData.hands || {};
    const prevHand = hands[previousPlayerId] || null;
    if (prevHand){
      updates[`hands/${state.userId}`] = { ...prevHand, inheritedAt: Date.now(), inheritedFrom: previousPlayerId };
      updates[`hands/${previousPlayerId}`] = null;
    }

    const markers = roomData.markers || {};
    const prevMarker = markers[previousPlayerId] || null;
    if (prevMarker){
      updates[`markers/${state.userId}`] = {
        ...prevMarker,
        color: SEAT_COLORS[seatIndex-1] || null,
        initial: firstChar(state.userName || "") || safeText(prevMarker.initial || ""),
        updatedAt: Date.now(),
        inheritedFrom: previousPlayerId
      };
      updates[`markers/${previousPlayerId}`] = null;
    }

    const equipment = roomData.equipment || {};
    const prevEquipment = equipment[previousPlayerId] || null;
    if (prevEquipment){
      const nextEquipment = JSON.parse(JSON.stringify(prevEquipment));
      if (nextEquipment.identity && nextEquipment.identity.kind === "identity" && nextEquipment.identity.roleId){
        nextEquipment.identity.inheritedAt = Date.now();
        nextEquipment.identity.inheritedFrom = previousPlayerId;
      }
      updates[`equipment/${state.userId}`] = nextEquipment;
      updates[`equipment/${previousPlayerId}`] = null;
    }

    const turn = roomData.turn || null;
    const isTurnOwnerStolen = !!turn && safeText(turn.currentPlayerId || "") === safeText(previousPlayerId || "");
    const nextTurnUpdatedAt = isTurnOwnerStolen ? Date.now() : Number(turn?.updatedAt || 0);
    if (isTurnOwnerStolen) {
      updates[`turn/currentPlayerId`] = state.userId;
      updates[`turn/updatedAt`] = nextTurnUpdatedAt;
    }

    const positionOrder = Array.isArray(roomData.positionOrder) ? roomData.positionOrder : null;
    if (positionOrder && previousPlayerId){
      let replaced = false;
      const nextOrder = positionOrder.map((uid) => {
        if (safeText(uid || "") === safeText(previousPlayerId || "")){
          replaced = true;
          return state.userId;
        }
        return uid;
      });
      if (replaced){
        updates[`positionOrder`] = nextOrder;
      }
    }

    if (safeText(roomData.startPlayerId || "") === safeText(previousPlayerId || "")){
      updates[`startPlayerId`] = state.userId;
    }
    if (roomData.hostId && previousPlayerId && roomData.hostId === previousPlayerId){
      updates[`hostId`] = state.userId;
    }

    const damage = roomData.damage || {};
    if (Object.prototype.hasOwnProperty.call(damage, previousPlayerId)){
      updates[`damage/${state.userId}`] = clampDamage(Number(damage[previousPlayerId] || 0));
      updates[`damage/${previousPlayerId}`] = null;
    }

    const guardShields = roomData.guardianAngelShield || {};
    if (Object.prototype.hasOwnProperty.call(guardShields, previousPlayerId)){
      updates[`guardianAngelShield/${state.userId}`] = !!guardShields[previousPlayerId];
      updates[`guardianAngelShield/${previousPlayerId}`] = null;
    }

    const migrateGreenStateBySeatSteal = (room, fromUid, toUid, outUpdates) => {
      const prevUid = safeText(fromUid || "");
      const nextUid = safeText(toUid || "");
      if (!prevUid || !nextUid || prevUid === nextUid) return;

      const migratedAt = Date.now();
      const copy = (v) => JSON.parse(JSON.stringify(v));
      const deepReplaceUid = (value) => {
        if (value == null) return value;
        if (typeof value === "string"){
          return safeText(value) === prevUid ? nextUid : value;
        }
        if (Array.isArray(value)) return value.map(deepReplaceUid);
        if (typeof value === "object"){
          const next = {};
          for (const [k, v] of Object.entries(value)){
            next[k] = deepReplaceUid(v);
          }
          return next;
        }
        return value;
      };

      const sameJson = (a, b) => JSON.stringify(a) === JSON.stringify(b);
      const touchAt = (entry) => {
        if (!entry || typeof entry !== "object") return entry;
        return { ...entry, at: migratedAt };
      };
      const answeredRequestIds = new Set(
        Object.values(room.greenResponses || {})
          .map((row) => safeText(row?.requestId || ""))
          .filter(Boolean)
      );

      const migrateUidNode = (nodeName, shouldTouchAt = false) => {
        const node = room[nodeName] || {};
        if (!node || typeof node !== "object") return;

        if (Object.prototype.hasOwnProperty.call(node, prevUid)){
          const original = node[prevUid];
          const requestId = safeText(original?.requestId || "");
          const skipAnsweredInbox = nodeName === "greenInbox" && requestId && answeredRequestIds.has(requestId);
          if (skipAnsweredInbox){
            outUpdates[`${nodeName}/${prevUid}`] = null;
          } else {
            const migrated = deepReplaceUid(copy(original));
            outUpdates[`${nodeName}/${nextUid}`] = shouldTouchAt ? touchAt(migrated) : migrated;
            outUpdates[`${nodeName}/${prevUid}`] = null;
          }
        }

        for (const [key, value] of Object.entries(node)){
          if (value == null || safeText(key || "") === prevUid) continue;
          const rewritten = deepReplaceUid(copy(value));
          if (sameJson(rewritten, value)) continue;
          outUpdates[`${nodeName}/${key}`] = shouldTouchAt ? touchAt(rewritten) : rewritten;
        }
      };

      migrateUidNode("greenInbox", true);
      migrateUidNode("greenResponses", true);
      migrateUidNode("greenCloseSignals", true);
      migrateUidNode("greenSessions", true);
      migrateUidNode("cardTargetSessions", true);

      const migrateRequestNode = (nodeName, shouldTouchAt = false) => {
        const node = room[nodeName] || {};
        if (!node || typeof node !== "object") return;
        for (const [rowId, row] of Object.entries(node)){
          if (!row || typeof row !== "object") continue;
          const rewritten = deepReplaceUid(copy(row));
          if (sameJson(rewritten, row)) continue;
          outUpdates[`${nodeName}/${rowId}`] = shouldTouchAt ? touchAt(rewritten) : rewritten;
        }
      };

      migrateRequestNode("greenRequests", true);
      migrateRequestNode("greenReplyBubbles", true);
      migrateRequestNode("greenReveals", true);
    };

    migrateGreenStateBySeatSteal(roomData, previousPlayerId, state.userId, updates);

    const roleAbilitySelection = roomData.roleAbilitySelection || null;
    if (roleAbilitySelection && safeText(roleAbilitySelection.actorUid || "") === safeText(previousPlayerId || "")){
      updates[`roleAbilitySelection`] = {
        ...roleAbilitySelection,
        actorUid: state.userId,
        at: Date.now()
      };
    }

    const attackResolutionPending = roomData.attackResolutionPending || {};
    if (Object.prototype.hasOwnProperty.call(attackResolutionPending, previousPlayerId)){
      const pending = attackResolutionPending[previousPlayerId] || {};
      const prevTurnKey = safeText(pending.turnKey || "");
      const expectedOldTurnKey = turn ? `${safeText(previousPlayerId || "")}:${Number(turn.updatedAt || 0)}` : "";
      const nextTurnKey = (isTurnOwnerStolen && prevTurnKey === expectedOldTurnKey)
        ? `${safeText(state.userId || "")}:${nextTurnUpdatedAt}`
        : prevTurnKey;
      updates[`attackResolutionPending/${state.userId}`] = {
        ...pending,
        uid: state.userId,
        turnKey: nextTurnKey
      };
      updates[`attackResolutionPending/${previousPlayerId}`] = null;
    }

    const attackLootPending = roomData.attackLootPending || {};
    if (Object.prototype.hasOwnProperty.call(attackLootPending, previousPlayerId)){
      const pending = attackLootPending[previousPlayerId] || {};
      updates[`attackLootPending/${state.userId}`] = {
        ...pending,
        uid: state.userId,
        at: Date.now()
      };
      updates[`attackLootPending/${previousPlayerId}`] = null;
    }

    if (roomData.abilityUsage){
      const abilityUsageCopy = JSON.parse(JSON.stringify(roomData.abilityUsage));
      moveAbilityUsageUid(abilityUsageCopy, previousPlayerId, state.userId);
      updates[`abilityUsage`] = abilityUsageCopy;
    }

    await update(roomRef, updates);

    state.seatedTable = seatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(seatIndex));

    state.spectating = true;
    hideSeatPop();
  }

  kickDialog.addEventListener('click', (e) => { if (e.target === kickDialog) closeKickDialog(); });
  btnKickNo.addEventListener('click', (e) => { e.stopPropagation(); closeKickDialog(); });
  btnKickYes.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (pendingSeatIndexToSteal == null || !state.roomCode) { closeKickDialog(); return; }

    if (pendingMode === "started"){
      await stealSeatStarted(pendingSeatIndexToSteal, pendingSeatPlayerIdToSteal);
    } else {
      await stealSeatPrestart(pendingSeatIndexToSteal, pendingSeatPlayerIdToSteal);
    }
    closeKickDialog();
  });
  function closeKickDialog(){
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
    pendingMode = "prestart";
  }

  function showRoleHoldPreview(role){
    if (!role || !roleHoldPreview) return;
    roleHoldPreview.innerHTML = "";
    roleHoldPreview.appendChild(createIdentityCard(role));
    roleHoldPreview.classList.remove("hidden");
  }

  function hideRoleHoldPreview(){
    if (!roleHoldPreview) return;
    roleHoldPreview.classList.add("hidden");
    roleHoldPreview.innerHTML = "";
  }

  function bindMyRoleCardInteraction(cardEl, role){
    if (!cardEl || !role) return;
    cardEl.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      if (!e.isPrimary || e.button !== 0) return;
      if (activeRoleAbilitySelection && safeText(activeRoleAbilitySelection.actorUid || "") === safeText(state.userId || "")) return;
      if (isGreenInteractionActive()){
        showRoleHoldPreview(role);
        return;
      }
      const action = captureSelectionRestoreAction();
      openZoomFromRole(role, { enableRevealPop:true, showCloseButton:false });
      if (action){
        setZoomPassthrough(false);
        zoomDismissHandler = async () => {
          await restoreSelectionAction(action);
        };
      }
    });
  }

  /* =========================================================
     ★④右下：正体カードは「裏面(browncard.jpg)」で表示し、
        クリックで「オモテ(拡大)」を表示
     ========================================================= */
  function renderMyRoleCard(role){
    myRoleCard.innerHTML = '';
    const isSeatedNow = latestPlayers.some(p => p.id === state.userId && Number(p.seatIndex || 0) > 0);
    if (!isSeatedNow || !role){
      hideRoleHoldPreview();
      myRoleDock.classList.remove('visible');
      renderEquipmentDock();
      return;
    }

    const identity = equipCache?.[state.userId]?.identity;
    const isIdentityRevealed = !!(identity && identity.kind === 'identity' && identity.roleId === role.id);

    if (isIdentityRevealed){
      const face = createIdentityCard(role);
      face.title = "公開済みの正体カード";
      face.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));
      bindMyRoleCardInteraction(face, role);
      myRoleCard.appendChild(face);
    } else {
      const back = document.createElement('div');
      back.className = 'role-back';
      back.style.backgroundImage = `url('browncard.jpg')`;
      back.title = "クリックで拡大表示";
      back.classList.toggle('eliminated-dim', isPlayerEliminated(state.userId));
      bindMyRoleCardInteraction(back, role);
      myRoleCard.appendChild(back);
    }

    myRoleDock.classList.add('visible');
    renderEquipmentDock();
  }

  document.addEventListener('pointerup', () => {
    hideRoleHoldPreview();
  }, true);
  document.addEventListener('pointercancel', () => {
    hideRoleHoldPreview();
  }, true);
  window.addEventListener('blur', () => {
    hideRoleHoldPreview();
  });

  function renderHands(){
    const started = isGameStarted();
    updateSeatBoardVisibility();

    const my = state.hands[state.userId];
    if (my && my.roleId && ROLE_BY_ID[my.roleId]){
      renderMyRoleCard(ROLE_BY_ID[my.roleId]);
    } else {
      renderMyRoleCard(null);
    }

    startWarn.textContent = started
      ? "※ゲーム開始済み（未着席は席を奪取して参加できます）"
      : "※ホストが「スタート」を押すと配布されます";
  }

  function pickUnique(pool, k){
    const s = shuffle(pool);
    return s.slice(0, Math.max(0, k));
  }
  function pickNpcName(usedNames = new Set()){
    const pool = shuffle(NPC_FOREIGN_NAMES.slice());
    for (const base of pool){
      const trimmed = safeText(base || "").trim();
      if (!trimmed || usedNames.has(trimmed)) continue;
      usedNames.add(trimmed);
      return trimmed;
    }
    const fallback = `NPC${usedNames.size + 1}`;
    usedNames.add(fallback);
    return fallback;
  }
  function buildComputerModeTables(baseTables = {}, targetCount = 5){
    const tables = { ...(baseTables || {}) };
    const occupiedSeats = new Set();
    const usedNames = new Set();
    let humanCount = 0;

    for (const [seatIndex, row] of Object.entries(tables)){
      const seat = Number(seatIndex || 0);
      if (!row || !row.playerId || !seat) continue;
      occupiedSeats.add(seat);
      usedNames.add(safeText(row.playerName || ""));
      if (!row.isNpc) humanCount++;
    }

    const needNpc = Math.max(0, targetCount - humanCount);
    if (needNpc <= 0) return { tables, addedNpcCount:0 };

    let added = 0;
    for (let seat = 1; seat <= SEAT_COLORS.length && added < needNpc; seat++){
      if (occupiedSeats.has(seat)) continue;
      const npcId = `npc_${Date.now()}_${seat}_${Math.random().toString(16).slice(2,8)}`;
      tables[String(seat)] = {
        playerId: npcId,
        playerName: pickNpcName(usedNames),
        color: SEAT_COLORS[seat - 1] || null,
        seatedAt: Date.now(),
        isNpc: true
      };
      occupiedSeats.add(seat);
      added++;
    }
    return { tables, addedNpcCount:added };
  }
  function buildDeckByPlayerCount(n){
    const rule = DEAL_RULE[n];
    if (!rule) throw new Error(`対応外の人数: ${n}`);

    const deck = [];
    deck.push(...pickUnique(POOL["レイダー"], rule["レイダー"]));
    deck.push(...pickUnique(POOL["シャドウ"], rule["シャドウ"]));
    deck.push(...pickUnique(POOL["シチズン"], rule["シチズン"]));

    if (deck.length !== n){
      throw new Error(`デッキ枚数が一致しません（n=${n}, deck=${deck.length}）`);
    }
    return shuffle(deck);
  }

  async function dealIdentityCards(){
    if (!state.roomCode) return;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};

    if (roomData.gameStarted || roomData.startedAt) return;

    let tables = roomData.tables || {};
    const humanCount = Object.values(tables).filter((row) => !!row?.playerId && !row?.isNpc).length;
    const useComputerMode = humanCount >= 0 && humanCount <= 3;
    if (useComputerMode){
      const filled = buildComputerModeTables(tables, 5);
      tables = filled.tables;
    }

    const players = Object.entries(tables)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        seatIndex: Number(seatIndex),
        name: String(t.playerName || "")
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    const n = players.length;
    if (n < 1 || n > 10) return;

    const deck = buildDeckByPlayerCount(n);

    const hands = {};
    for (let i=0;i<n;i++){
      hands[players[i].id] = { roleId: deck[i].id, dealtAt: Date.now() };
    }

    const positionOrder = shuffle(players.map(p => p.id));
    const startPlayerId = positionOrder[Math.floor(Math.random()*positionOrder.length)] || null;
    const freshDeckState = {
      green: { order: shuffle(toGreenOrder()), idx: 0 },
      white: { order: shuffle(toWhiteOrder()), idx: 0 },
      black: { order: shuffle(toBlackOrder()), idx: 0 },
      reveal: { slot3: null, slot5: null },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };

    const markers = { ...(roomData.markers || {}) };
    for (const p of players){
      if (safeText(p.name).trim().toLowerCase() !== "test") continue;
      const pt = randomPointInRoom(4, 14);
      if (!pt) continue;
      const color = SEAT_COLORS[(Number(p.seatIndex) || 1) - 1] || "#ddd";
      const initial = firstChar(p.name || "T");
      markers[p.id] = {
        x: pt.x,
        y: pt.y,
        color,
        initial,
        roomId: 4,
        updatedAt: Date.now(),
        forcedSpawn: true
      };
    }

    await update(roomRef, {
      hands,
      deckState: freshDeckState,
      guardianAngelShield: null,
      erikaSealedTargets: null,
      autoIdentityReveal: null,
      gameStarted: true,
      startedAt: Date.now(),
      playerCountAtStart: n,
      computerMode: useComputerMode,
      markers,
      tables,
      positionOrder,
      startPlayerId,
      turn: {
        currentPlayerId: startPlayerId,
        moveDone: false,
        attackDone: false,
        deckDrawDone: false,
        drawnTypes: { green:false, white:false, black:false },
        movedByDiceRoomId: null,
        room3ActionUsed: false,
        room4StealUsed: false,
        repeatTurnRemaining: 0,
        repeatTurnTotal: 0,
        sealWisdomBonus: false,
        updatedAt: Date.now()
      }
    });

    await initDamageAllToZero(players);
  }

  function refreshStartBadge(){
    const n = latestPlayers.length;
    startBadge.textContent = `参加人数：${n}`;
    if (state.isHost){
      const rule = DEAL_RULE[n];
      if (rule){
        startBadge.textContent = `参加人数：${n}（R${rule["レイダー"]}/S${rule["シャドウ"]}/C${rule["シチズン"]}）`;
      }
    }
  }

  hostSettingsBtn.addEventListener('click', () => {
    if (!state.isHost) return;
    startPop.classList.toggle('hidden');
  });
  actionChatBtn?.addEventListener('click', () => {
    if (!state.isHost || !isNpcActionChatMode()) return;
    renderActionChatLog();
    actionChatBackdrop?.classList.remove('hidden');
  });
  actionChatCloseBtn?.addEventListener('click', () => actionChatBackdrop?.classList.add('hidden'));
  actionChatBackdrop?.addEventListener('click', (e) => {
    if (e.target !== actionChatBackdrop) return;
    actionChatBackdrop.classList.add('hidden');
  });
  btnStartPopClose.addEventListener('click', () => startPop.classList.add('hidden'));
  btnHostDice?.addEventListener('click', async () => {
    if (!state.isHost) return;
    await runCornerD6D4Roll();
    const cleanupTimer = setTimeout(() => {
      diceRollOverlay.innerHTML = '';
      clearDiceRollTimers();
    }, 2000);
    diceRollTimers.push(cleanupTimer);
  });

  btnGameStart.addEventListener('click', async () => {
    if (!state.isHost) return;
    await dealIdentityCards();
    startPop.classList.add('hidden');
  });

  btnResetRoom.addEventListener('click', async () => {
    if (!state.isHost || !state.roomCode) return;

    const base = `rooms/${state.roomCode}`;
    await Promise.all([
      remove(ref(db, `${base}/tables`)),
      remove(ref(db, `${base}/hands`)),
      remove(ref(db, `${base}/maxPlayers`)),
      remove(ref(db, `${base}/gameStarted`)),
      remove(ref(db, `${base}/startedAt`)),
      remove(ref(db, `${base}/playerCountAtStart`)),
      remove(ref(db, `${base}/computerMode`)),
      remove(ref(db, `${base}/markers`)),
      remove(ref(db, `${base}/deckState`)),
      remove(ref(db, `${base}/equipment`)),
      remove(ref(db, `${base}/guardianAngelShield`)),
      remove(ref(db, `${base}/damage`)),
      remove(ref(db, `${base}/positionOrder`)),
      remove(ref(db, `${base}/startPlayerId`)),
      remove(ref(db, `${base}/greenInbox`)),
      remove(ref(db, `${base}/greenResponses`)),
      remove(ref(db, `${base}/greenReplyBubbles`)),
      remove(ref(db, `${base}/npcSpeech`)),
      remove(ref(db, `${base}/greenReveals`)),
      remove(ref(db, `${base}/greenRequests`)),
      remove(ref(db, `${base}/actionChatLog`)),
      remove(ref(db, `${base}/roleAbilitySelection`)),
      remove(ref(db, `${base}/turn`)),
      remove(ref(db, `${base}/attackResolutionPending`)),
      remove(ref(db, `${base}/attackLootPending`)),
      remove(ref(db, `${base}/counterPromptState`)),
      remove(ref(db, `${base}/erikaSealedTargets`)),
      remove(ref(db, `${base}/autoIdentityReveal`)),
    ]);

    deckCache = null;
    equipCache = {};
    damageCache = {};
    if (autoIdentityRevealTimer){
      clearTimeout(autoIdentityRevealTimer);
      autoIdentityRevealTimer = null;
    }
    autoIdentityRevealTimerKey = "";

    state.seatedTable = null;
    state.spectating = false;
    sessionStorage.removeItem(seatKey(state.roomCode));
    sessionStorage.removeItem(attackResolutionKey(state.roomCode));
    startPop.classList.add('hidden');

    renderSeatTiles();
    renderHands();
    updateSeatBoardVisibility();

    renderDeckRowFromRoom();
    renderEquipmentDock();
    buildHpCells();
    renderHpBoard();

    updateEquipDockTop();
  });

  async function tryOpenEmmaSelectionOnEndAttempt(){
    if (!isMyRole("RAI_E3") || !isMyIdentityRevealed()) return false;
    if (isMyAbilitySealed()) return false;
    const check = emmaAbilityAvailability();
    if (!check.ok) return false;
    await setRoleAbilitySelectionState({ roleId:"RAI_E3", actorUid: state.userId, privateToActor:true, endTurnAfterResolve:true });
    return true;
  }

  async function doEndTurn(expectedCurrentPlayerId = ""){
    lastAttackWatch = null;
    await requestAttackLootAutoEndForCurrentTurn({ syncPending:true });
    attackTurnEndChoicePending = false;
    pendingAttackResolution = null;
    pendingAttackResultMeta = null;
    ulsterExtraAttackPending = 0;
    attackFlowUiLockActive = false;
    suppressEndTurnButton = false;
    resetAttackAbilityUsageTurnState();
    cachePendingAttackResolution(null);
    const ownerUid = safeText(expectedCurrentPlayerId || currentTurnPlayerId() || "");
    const advanced = await advanceTurnToNextPlayer(expectedCurrentPlayerId);
    if (!advanced && ownerUid && ownerUid === safeText(state.userId || "") && hasDeferredTurnEndBlockers(state.room || {}, ownerUid)){
      deferredTurnEndRequest = {
        ownerUid,
        requestedAt: Date.now()
      };
    }
    hideAttackPop();
    hideAttackResultPop();
    clearAttackResultDice();
    hideEndTurnConfirm();
    renderTurnEndButton();
  }

  btnEndTurn?.addEventListener('click', async () => {
    if (!canShowEndTurnButton()) return;
    if (!turnState()?.attackDone){
      showEndTurnConfirm({ message:"本当に終了しますか。" });
      return;
    }
    const openedEmma = await tryOpenEmmaSelectionOnEndAttempt();
    if (openedEmma) return;
    await doEndTurn();
  });

  btnEndTurnNo?.addEventListener('click', () => {
    hideEndTurnConfirm();
  });

  btnEndTurnYes?.addEventListener('click', async () => {
    if (!canShowEndTurnButton()){
      hideEndTurnConfirm();
      return;
    }
    hideEndTurnConfirm();
    const openedEmma = await tryOpenEmmaSelectionOnEndAttempt();
    if (openedEmma) return;
    await doEndTurn();
  });

  const urlParams = new URLSearchParams(window.location.search);
  const roomFromUrl = urlParams.get('room');
  if(roomFromUrl) inputCode.value = roomFromUrl;

  const cachedUserName = localStorage.getItem(USER_NAME_CACHE_KEY);
  if (cachedUserName != null) inputName.value = cachedUserName;

  inputName.addEventListener("input", () => {
    localStorage.setItem(USER_NAME_CACHE_KEY, inputName.value || "");
  });

  btnJoin.addEventListener('click', async () => {
    startImagePreload();
    state.userName = (inputName.value || '名無し').slice(0,4);
    localStorage.setItem(USER_NAME_CACHE_KEY, state.userName);
    state.roomCode = inputCode.value.trim() || generateRoomCode();
    state.spectating = false;
    state.currentRoomId = 0;

    await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
      name: state.userName,
      joinedAt: Date.now()
    });

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val();

    if(!roomData || !roomData.hostId){
      await update(roomRef, { hostId: state.userId });
      state.isHost = true;
    } else {
      state.isHost = (roomData.hostId === state.userId);
    }

    updateHostUI();

    mainEl.classList.remove('prejoin');
    mainEl.classList.add('joined');

    joinBox.classList.add('hidden');
    lobby.classList.remove('hidden');
    lobby.classList.add('entered');

    gameArea.classList.remove('hidden');

    renderRoomShape();
    buildHpCells();

    await ensureRoomDeckState();
    subscribeDeckState();
    renderDeckRowFromRoom();

    const cachedSeat = sessionStorage.getItem(seatKey(state.roomCode));
    if (cachedSeat) state.seatedTable = Number(cachedSeat) || null;
    restorePendingAttackResolutionFromSession();
    await syncMySeatNameIfNeeded();

    subscribeRoom();
    subscribeHostState();
    subscribePlayers();
    subscribeHands();
    subscribeGreenInbox();
    subscribeGreenResponses();
    subscribeGreenSessionState();
    subscribeCardTargetSessionState();
    subscribeRoleAbilitySelectionState();
    subscribeGreenReveals();
    subscribeGreenCloseSignals();
    subscribeGreenReplyBubbles();
    subscribeNpcSpeech();
    subscribeMarkers();
    subscribeEquipment();
    subscribeDamage();
    subscribeDiceEvents();
    subscribeRoleFlashEvents();
    subscribeHpSwapEvents();
    subscribeWalpurgisSwapEvents();
    subscribeIdentityZoomEvents();

    renderSeatTiles();
    refreshStartBadge();
    renderHands();
    updateSeatBoardVisibility();

    updateCardInteractivity();
    renderEquipmentDock();
    renderHpBoard();

    requestAnimationFrame(() => {
      updateEquipDockTop();
      applyEquipCols();
    });
  });

  copyLinkBtn.addEventListener('click', async () => {
    const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
    try {
      await navigator.clipboard.writeText(url);
      copyLinkBtn.classList.add('copied');
      copyLinkBtn.textContent = 'COPIED';
      inputCode.value = state.roomCode;
      setTimeout(()=>{
        copyLinkBtn.classList.remove('copied');
        copyLinkBtn.textContent='COPY';
      },1500);
    } catch {
      prompt('コピーできません。手動でコピーしてください', url);
    }
  });
</script>

</body>
</html>
