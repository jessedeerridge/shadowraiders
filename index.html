<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>テンプレ（右に六角＋6部屋 / 中央にデッキ5枚）</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:1200; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn.danger{background:#ef4444;color:#fff;border-color:#ef4444;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:hidden;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;
    z-index:700;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}

  /* 公開確認ポップ */
  .confirm-pop{
    position:fixed;
    left:0; top:0;
    transform:translate(-50%,-10px);
    background:#fff;
    border:1px solid rgba(0,0,0,.18);
    border-radius:12px;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    padding:10px 10px 10px;
    z-index:10050;
    min-width:210px;
  }
  .confirm-pop.hidden{display:none;}
  .confirm-pop .msg{font-size:13px;line-height:1.45;margin:0 0 10px;}
  .confirm-pop .actions{display:flex;justify-content:flex-end;gap:8px;flex-wrap:wrap;}
  .confirm-pop .caret{
    position:absolute;
    left:50%; top:-7px;
    width:12px; height:12px;
    background:#fff;
    border-left:1px solid rgba(0,0,0,.18);
    border-top:1px solid rgba(0,0,0,.18);
    transform:translateX(-50%) rotate(45deg);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:1000;cursor:pointer;
    z-index:2000;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:2010;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(560px, calc(100% - 0px));
    max-height:min(74vh, 700px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:1000;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(74vh - 48px);}

  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;border-bottom:1px solid rgba(0,0,0,.06);
  }
  .role-row:last-child{border-bottom:none;}
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:1000;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}
  .role-desc .meta{font-size:12px;opacity:.8;margin-top:6px;white-space:pre-wrap;}

  .seat-pop-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:900;
    padding:16px;
  }
  .seat-pop-backdrop.hidden{display:none;}

  .seat-board{
    width:min(420px, calc(100% - 32px));
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.22);
    padding:12px 12px 14px;
    position:relative;
    margin:0;
  }
  .seat-board-title{
    font-weight:1000;
    font-size:13px;
    opacity:.9;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin:0 0 10px;
  }
  .seat-count-badge{
    font-size:12px;
    font-weight:900;
    background:#111;
    color:#fff;
    padding:4px 8px;
    border-radius:999px;
    white-space:nowrap;
  }
  .tile-grid{
    display:grid;
    grid-template-columns:repeat(4, 54px);
    grid-auto-rows:54px;
    gap:10px;
    justify-content:center;
    padding:4px 0 2px;
  }
  .seat-tile{
    width:54px;height:54px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.12);
    box-shadow:0 6px 16px rgba(0,0,0,.16);
    cursor:pointer;
    position:relative;
    overflow:hidden;
    outline:none;
  }
  .seat-tile:focus{box-shadow:0 0 0 3px rgba(37,99,235,.25), 0 6px 16px rgba(0,0,0,.16);}
  .seat-tile.me::after{ display:none; }
  .seat-initial{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    font-weight:1000;
    font-size:16px;
    line-height:1;
    color:#111;
    pointer-events:none;
    user-select:none;
  }
  .seat-tile.empty{opacity:.95;}
  .seat-tile.taken{opacity:1;}
  .seat-tile .seat-num{
    position:absolute;right:6px;bottom:6px;
    font-size:11px;font-weight:1000;
    color:rgba(0,0,0,.55);
    background:rgba(255,255,255,.7);
    border:1px solid rgba(0,0,0,.08);
    padding:2px 6px;border-radius:999px;
    pointer-events:none;
  }

  .warn{
    font-size:12px;
    opacity:.75;
    text-align:center;
    margin-top:10px;
  }

  .seat-board-actions{
    display:flex;
    justify-content:flex-end;
    margin-top:10px;
    gap:8px;
    flex-wrap:wrap;
  }

  :root{
    --outer:#0b3b2e;
    --gold:#d6b35a;
    --brown:#5a4032;
    --team:#c21d1d;
    --black:#111;
    --paper:#f7f4ee;
    --effect:#ffd9a3;
    --inner-gap:-0.5px;
    --inner-w:1px;
    --inner-r:9px;
    --ini-stroke:0.3px;
    --ini-stroke-shadow:0.3px;
    --ini-y:-0.4px;

    /* =========================================================
       ★HPボード：各ルーム（damage 15→0）の高さを個別調整
       ========================================================= */
    --hp-r15: 25px;
    --hp-r14: 29px;
    --hp-r13: 23px;
    --hp-r12: 21px;
    --hp-r11: 24px;
    --hp-r10: 23px;
    --hp-r9:  23px;
    --hp-r8:  21px;
    --hp-r7:  22px;
    --hp-r6:  22px;
    --hp-r5:  22px;
    --hp-r4:  23px;
    --hp-r3:  22px;
    --hp-r2:  22px;
    --hp-r1:  20px;
    --hp-r0:  28px;

    /* HPセルの左右余白（高さを変えたくない場合は縦paddingを0推奨） */
    --hp-cell-pad-x: 6px;
    --hp-cell-pad-y: 0px;
  }

  .my-role-dock{
    position:fixed;
    right:16px;
    bottom:16px;
    z-index:260;
    display:none;
  }
  .my-role-dock.visible{ display:block; }

  /* =========================
     装備枠（★カードパネル直下まで上に伸ばす）
     ========================= */
  .equip-dock{
    position:fixed;
    left:16px;
    right:calc(6px + 72px + 12px);
    top:var(--equip-top, auto);
    bottom:16px;
    z-index:259;
    display:none;
    min-height:120px;
  }
  .equip-dock.visible{ display:block; }

  .equip-board{
    background:rgba(255,255,255,.90);
    border:1px solid rgba(0,0,0,.10);
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.18);
    padding:10px;
    height:100%;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
  }

  .equip-body{
    flex:1 1 auto;
    min-height:0;
    overflow-y:auto;
    overflow-x:hidden;
    padding-right:2px;
  }

  .equip-row{
    display:flex;
    align-items:flex-start;
    gap:5px;
    padding:8px 0;
    border-top:1px solid rgba(0,0,0,.06);
  }
  .equip-row:first-child{ border-top:none; padding-top:0; }

  .equip-tag{
    width:18px;height:18px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.35);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:12px;
    line-height:1;
    user-select:none;
    flex:0 0 auto;
  }
  .equip-cards{
    display:grid;
    grid-template-columns:repeat(var(--equip-cols, 6), 72px);
    grid-auto-rows:108px;
    gap:5px;
    align-items:start;
    justify-content:start;
    overflow-x:hidden;
    padding-bottom:2px;
    flex:1 1 auto;
  }

  .id72{
    width:72px;height:108px;
    background-color: var(--paper);
    background-image: none;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    border:1.4px solid var(--outer);
    border-radius:10px;
    box-sizing:border-box;
    position:relative;
    overflow:hidden;
    cursor:pointer;
  }
  .id72::before{
    content:"";
    position:absolute;
    left:var(--inner-gap);right:var(--inner-gap);
    top:var(--inner-gap);bottom:var(--inner-gap);
    border:var(--inner-w) solid var(--gold);
    border-radius:var(--inner-r);
    pointer-events:none;
    z-index:1;
    opacity:1;
  }
  .id72 .initial{
    position:absolute;top:1px;left:1px;
    width:16px;height:16px;
    border:1px solid var(--black);
    border-radius:999px;
    display:grid;place-items:center;
    font-weight:900;font-size:13px;
    background:var(--team);
    line-height:1;z-index:5;
  }
  .id72 .initial span{
    display:inline-block;line-height:1;
    color:var(--black);
    transform: translateY(var(--ini-y));
    -webkit-text-stroke: var(--ini-stroke) var(--gold);
    text-stroke: var(--ini-stroke) var(--gold);
    text-shadow:
      0 0 0 var(--gold),
      0 var(--ini-stroke-shadow) 0 var(--gold),
      0 calc(var(--ini-stroke-shadow) * -1) 0 var(--gold),
      var(--ini-stroke-shadow) 0 0 var(--gold),
      calc(var(--ini-stroke-shadow) * -1) 0 0 var(--gold);
  }
  .id72 .team-arc{
    position:absolute;left:2px;top:18px;
    width:16px;height:10px;
    z-index:6;pointer-events:none;overflow:visible;
  }
  .id72 .team-arc text{
    font-weight:600;font-size:6px;letter-spacing:.40px;
    fill:var(--team);
  }
  .id72 .eng-sub{
    position:absolute;top:3px;left:15px;
    padding:1px 3px 1px 3px;
    background:var(--black);color:var(--gold);
    border:1px solid var(--gold);
    border-radius:0 6px 6px 0;
    font-weight:900;letter-spacing:.2px;
    font-size:10px;line-height:1;
    box-sizing:border-box;z-index:4;
  }
  .id72 .name{
    position:absolute;top:48px;left:2px;right:4px;
    text-align:left;padding:0px 4px;
    background:var(--black);color:var(--gold);
    border:1px solid var(--gold);
    border-radius:6px;
    font-weight:900;font-size:9px;
    letter-spacing:.3px;
    box-sizing:border-box;z-index:2;
  }
  .id72 .hp-badge{
    position:absolute;top:46px;right:1px;
    width:18px;height:18px;border-radius:999px;
    background:var(--brown);
    border:1px solid var(--gold);
    box-sizing:border-box;z-index:3;
    display:flex;flex-direction:column;
    align-items:center;justify-content:center;
    gap:0;padding-top:1px;
  }
  .id72 .hp-badge .label{
    font-size:5px;font-weight:900;line-height:0.5;
    color:var(--gold);letter-spacing:.2px;opacity:.98;
  }
  .id72 .hp-badge .val{
    font-size:12px;font-weight:1000;line-height:1;
    color:var(--gold);
    transform:translateY(-1px);
  }
  .id72 .effect{
    position:absolute;left:3px;right:3px;bottom:2px;top:64px;
    background:var(--effect);
    border-radius:4px;
    padding:1px 1px;
    box-sizing:border-box;
    font-size:5.5px;line-height:1.25;
    color:var(--black);
    overflow:hidden;z-index:2;
  }
  .id72 .tag{
    display:inline-block;
    background:var(--black);
    color:#fff;
    font-weight:900;
    padding:1px 2px;
    border-radius:3px;
    margin-right:1px;
    font-size:5.5px;
    letter-spacing:.2px;
    line-height:1;
    vertical-align:baseline;
  }
  .id72 .row{ margin:0 0 1px 0; }
  .id72 .row:last-child{ margin-bottom:0; }
  .role-card-wrap{ flex:0 0 auto; }

  .host-settings-btn{
    position:fixed;
    left:16px;
    bottom:66px;
    width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;
    z-index:2000;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;
    left:16px;
    bottom:120px;
    background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:1600;min-width:280px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:900;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}
  .start-badge{
    display:inline-flex;align-items:center;gap:6px;
    font-size:12px;font-weight:900;
    padding:4px 10px;border-radius:999px;
    border:1px solid rgba(0,0,0,.12);
    background:#f8f8f8;
  }

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    min-height:calc(100vh - 60px);
    padding-top:12px;
    gap:12px;
  }

  .game-area{
    width:min(980px, calc(100% - 24px));
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:center;
    justify-content:flex-start;
    padding-bottom:18px;
  }
  .top-row{
    width:100%;
    display:flex;
    gap:14px;
    align-items:flex-start;
    justify-content:center;
    margin-top:-10px;
  }

  /* パネル共通 */
  .panel{
    background:rgba(255,255,255,.78);
    border:1px solid rgba(0,0,0,.08);
    border-radius:16px;
    box-shadow:0 12px 28px rgba(0,0,0,.10);
    padding:12px;
    box-sizing:border-box;
  }

  .left-panel{
    width:170px;
    padding:0px;
    display:flex;
    align-items:stretch;
    justify-content:stretch;

    aspect-ratio: 2 / 4.5;
    height:auto;
    min-height:0;
  }

  /* =========================================================
     ★①左図形：枠/セル線/背景を透明（画像だけ表示）
     ========================================================= */
  .hp-board{
    width:100%;
    height:100%;
    min-height:0;

    border:none;                 /* 枠なし */
    border-radius:12px;

    overflow:hidden;
    position:relative;
    display:grid;

    grid-template-rows:
      var(--hp-r15) var(--hp-r14) var(--hp-r13) var(--hp-r12)
      var(--hp-r11) var(--hp-r10) var(--hp-r9)  var(--hp-r8)
      var(--hp-r7)  var(--hp-r6)  var(--hp-r5)  var(--hp-r4)
      var(--hp-r3)  var(--hp-r2)  var(--hp-r1)  var(--hp-r0);

    background-image:url('hp.png'); /* 画像だけ */
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    transform:none;
  }
  .hp-cell{
    position:relative;
    min-height:0;
    overflow:hidden;

    display:flex;
    align-items:center;
    justify-content:flex-start;
    flex-wrap:nowrap;
    gap:6px;

    padding:var(--hp-cell-pad-y) var(--hp-cell-pad-x);
    box-sizing:border-box;

    background:transparent; /* セル背景も透明 */
  }
  .hp-cell::after{ display:none; } /* セル線を消す */

  .chip16{
    width:16px;height:16px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.35);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:11px;
    line-height:1;
    user-select:none;
    box-shadow:0 4px 10px rgba(0,0,0,.12);
    flex:0 0 auto;
  }

  .right-panel{
    width:min(520px, 52vw);
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:10px;
  }
/* 自分のマーカーだけ、丸い点線リング */
.mark-me-ring{
  fill: none;
  stroke: rgba(17,17,17,.95);
  stroke-width: 2;
  stroke-dasharray: 3.5 3.5;
  stroke-linecap: round;
  vector-effect: non-scaling-stroke;
}

  /* =========================================================
     ★②右図形：図形外の背景を透明（パネルの白背景/枠/影を消す）
     ========================================================= */
  .map-panel{
    width:110%;
    height:min(62vh, 340px);
    display:flex;
    justify-content:center;
    align-items:center;
    padding:0;
    overflow:hidden;

    background:transparent !important;
    border:none !important;
    box-shadow:none !important;
  }

  .position-line{
    min-height:16px;
    display:flex;
    flex-wrap:wrap;
    align-items:flex-start;
    justify-content:center;
    gap:4px;
  }
  .position-item{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
    position:relative;
  }
  .position-answer-bubble{
    position:absolute;
    bottom:100%;
    left:50%;
    transform:translate(-50%, -4px);
    background:#111;
    color:#fff;
    font-size:10px;
    font-weight:700;
    line-height:1.2;
    padding:3px 6px;
    border-radius:999px;
    white-space:nowrap;
    max-width:140px;
    overflow:hidden;
    text-overflow:ellipsis;
    pointer-events:none;
    z-index:3;
  }
  .position-answer-bubble::after{
    content:"";
    position:absolute;
    top:100%;
    left:50%;
    transform:translateX(-50%);
    border:4px solid transparent;
    border-top-color:#111;
  }
  .starter-mark{
    min-height:10px;
    font-size:10px;
    font-weight:900;
    line-height:1;
    color:#111;
  }
  .position-line.hidden{ display:none; }
  .position-arrow{
    font-size:12px;
    font-weight:900;
    line-height:1;
    color:#111;
    user-select:none;
    margin-top:2px;
  }

  :root{
    --card-w:72px;
    --card-h:108px;
    --card-gap:8px;

    --wb-black:#111;
    --wb-gold:#caa44a;
    --wb-gold2:#f3dc8a;
    --wb-gray:#e5e5e5;

    --green-dark:#0b3b2e;
    --green-soft:#e9fff4;
  }

  /* =========================================================
     ★③カードテーブル：背景を半透明に
     ========================================================= */
  .cards-panel{
    width:100%;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    padding:6px 12px;
    overflow-x:auto;
    overflow-y:hidden;
    -webkit-overflow-scrolling:touch;

    background:rgba(255,255,255,.45);     /* ←ここ */
    border:1px solid rgba(0,0,0,.08);
    box-shadow:0 12px 28px rgba(0,0,0,.10);
    border-radius:16px;
  }

  .empty-cards-row{
    display:flex;
    gap:var(--card-gap);
    justify-content:flex-start;
    align-items:flex-start;
    flex-wrap:nowrap;
    width:max-content;
    padding:0;
  }

  .room-svg{width:100%;height:100%;display:block;}
  .shape{fill:#f7f7f7;stroke:#111;stroke-width:2;vector-effect:non-scaling-stroke;}
  .roomhit{fill:transparent;cursor:pointer;}
  .roomhit:hover{fill:rgba(0,0,0,.06);}

  .mark-rect{stroke:#111;stroke-width:1;vector-effect:non-scaling-stroke;}
  .mark-text{font-weight:1000;font-size:10px;dominant-baseline:middle;text-anchor:middle;user-select:none;pointer-events:none;}

  .card72{
    width:var(--card-w);
    height:var(--card-h);
    border-radius:10px;
    box-sizing:border-box;
    background:rgba(255,255,255,.92);
    border:1.4px solid rgba(17,17,17,.55);
    position:relative;
    overflow:hidden;
    flex:0 0 auto;
    user-select:none;
  }
  .card72.deck{
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    cursor:pointer;
  }

  /* 既存の「薄くする」ロック */
  .card72.locked{
    opacity:.35;
    filter:grayscale(.55);
    cursor:default !important;
    pointer-events:none;
  }

  /* ★追加：薄くしないがクリック不可（白表 / 黒オモテ用） */
  .card72.blocked{
    opacity:1;
    filter:none;
    cursor:default !important;
    pointer-events:none;
  }

  .count-tag{
    position:absolute;
    top:4px;
    right:4px;
    background:rgba(235,235,235,.95);
    color:#111;
    font-weight:1000;
    font-size:12px;
    line-height:1;
    padding:4px 7px;
    border-radius:999px;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 6px 16px rgba(0,0,0,.12);
    z-index:5;
    pointer-events:none;
  }

  .card72.wb-front{
    border:1px solid var(--wb-black);
    border-radius:10px;
    background:#fff;
    cursor:pointer;
  }
  .card72.wb-front.wb-white{ background:#fff; }
  .card72.wb-front.wb-black{ background:#000; }
  .card72.wb-front.wb-green{ background:var(--green-soft); border-color:#0b3b2e; }

  .card72.wb-front .wb-name{
    position:absolute;
    left:2px; right:2px; top:2px;
    height:18px;
    border:2px solid var(--wb-gold);
    border-radius:8px;
    background:#000;
    display:flex;align-items:center;justify-content:center;
    box-sizing:border-box;
    padding:0 4px;
    z-index:3;
  }
  .card72.wb-front.wb-green .wb-name{
    background:var(--green-dark);
    border-color:#d6b35a;
  }
  .card72.wb-front .wb-name span{
    font-size:8px;
    line-height:1;
    font-weight:900;
    letter-spacing:.04em;
    color:var(--wb-gold);
    text-shadow:0 1px 0 rgba(255,255,255,.08);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    width:100%;
    text-align:center;
  }
  .card72.wb-front .wb-circle{
    position:absolute;
    top:14px;
    left:50%;
    transform:translateX(-50%);
    width:60px;height:60px;
    border-radius:50%;
    border:transparent;
    background: radial-gradient(circle at 30% 30%, rgba(243,220,138,.45), rgba(0,0,0,0) 55%);
    box-sizing:border-box;
    overflow:hidden;
    z-index:2;
  }
  .card72.wb-front.wb-green .wb-circle{
    background: radial-gradient(circle at 30% 30%, rgba(34,197,94,.25), rgba(0,0,0,0) 60%);
  }
  .card72.wb-front .wb-circle img{
    width:100%;
    height:100%;
    display:block;
    object-fit:cover;
  }
  .card72.wb-front .wb-effect{
    position:absolute;
    left:2px; right:2px; bottom:2px;
    top:69px;
    background:var(--wb-gray);
    border-radius:6px;
    padding:2px;
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    gap:4px;
    overflow:hidden;
    z-index:2;
  }
  .card72.wb-front.wb-green .wb-effect{
    background:rgba(34,197,94,.12);
    border:1px solid rgba(11,59,46,.18);
  }
  .card72.wb-front .wb-desc{
    font-size:6px;
    line-height:1.25;
    font-weight:700;
    color:#111;
    overflow:hidden;
    white-space:pre-wrap;
  }
  .card72.wb-front.wb-black .wb-desc{ color:#111; }
  .card72.wb-front .wb-desc .inline-tag{
    display:inline-block;
    background:#000;
    color:#fff;
    font-weight:900;
    font-size:6px;
    line-height:1;
    padding:2px 4px;
    border-radius:4px;
    margin-right:2px;
    vertical-align:baseline;
  }

  /* ★追加：0枚（空）のときは枠なし */
  .card72.noframe{
    background:transparent;
    border:none !important;
  }

  /* ★④ 正体カード（右下）：裏面表示用 */
  .role-back{
    width:72px;height:108px;
    border-radius:10px;
    border:1.4px solid rgba(17,17,17,.55);
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    cursor:pointer;
    box-shadow:0 10px 26px rgba(0,0,0,.18);
  }

  .zoom-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.55);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:9999;
    padding:18px;
  }
  .zoom-backdrop.hidden{ display:none; }
  .zoom-stage{
    position:relative;
    width:72px;
    height:108px;
    transform:scale(var(--zoom, 4));
    transform-origin:center;
    will-change:transform;
  }
  .zoom-stage .card72,
  .zoom-stage .id72{
    box-shadow:0 18px 50px rgba(0,0,0,.45);
  }
  .zoom-close{
    position:fixed;
    right:14px;
    top:14px;
    z-index:10000;
    width:40px;
    height:40px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.55);
    background:rgba(17,17,17,.7);
    color:#fff;
    font-size:20px;
    font-weight:900;
    cursor:pointer;
  }
  .zoom-close.hidden{ display:none; }

  .green-share-dock{
    position:fixed;
    left:50%;
    bottom:140px;
    transform:translateX(-50%);
    z-index:10001;
    width:min(380px, calc(100vw - 40px));
    background:rgba(255,255,255,.96);
    border:1px solid rgba(0,0,0,.12);
    border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.26);
    padding:10px;
  }
  .green-share-dock.hidden{ display:none; }
  .green-share-title{
    font-size:13px;
    font-weight:900;
    margin:0 0 8px;
  }
  .green-share-subtitle{
    font-size:12px;
    margin:0 0 8px;
    color:#333;
    line-height:1.4;
  }
  .green-share-list{
    display:grid;
    grid-template-columns:repeat(3, minmax(0, 1fr));
    gap:8px;
  }
  .green-share-btn{
    border:1px solid rgba(0,0,0,.15);
    border-radius:999px;
    background:#fff;
    width:100%;
    padding:4px 8px;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    font-weight:700;
  }
  .green-share-btn.answer{
    justify-content:center;
    border-radius:8px;
    border-color:#111;
    background:#111;
    color:#fff;
  }
  .green-share-btn.answer:disabled{
    opacity:1;
    background:#b8b8b8;
    border-color:#b8b8b8;
    color:#fff;
  }
  .green-share-btn:disabled{
    opacity:.45;
    cursor:default;
  }
  .green-share-btn.waiting-selected:disabled{
    opacity:1;
  }
</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="gameArea" class="game-area hidden" aria-label="ゲーム面">
      <div class="top-row">
        <div class="panel left-panel">
          <div id="hpBoard" class="hp-board" aria-label="HPボード"></div>
        </div>

        <div class="right-panel">
          <div class="panel map-panel">
            <svg id="roomSvg" class="room-svg" viewBox="-170 -170 340 340" preserveAspectRatio="xMidYMid meet" aria-label="部屋マップ">
              <g id="roomG"></g>
            </svg>
          </div>
          <div id="positionLine" class="position-line hidden" aria-label="位置列"></div>
        </div>
      </div>

      <div class="panel cards-panel" id="cardsPanel" aria-label="デッキ">
        <div class="empty-cards-row">
          <div id="slot1" class="card72"></div>
          <div id="slot2" class="card72"></div>
          <div id="slot3" class="card72"></div>
          <div id="slot4" class="card72"></div>
          <div id="slot5" class="card72"></div>
        </div>
      </div>
    </div>
  </div>
</main>

<!-- 拡大表示 -->
<div id="zoomBackdrop" class="zoom-backdrop hidden" aria-label="拡大表示">
  <button id="zoomCloseBtn" class="zoom-close hidden" aria-label="閉じる">×</button>
  <div id="zoomStage" class="zoom-stage" style="--zoom:2"></div>
  <div id="greenShareDock" class="green-share-dock hidden" aria-label="緑カード共有">
    <p class="green-share-title">誰に渡しますか。</p>
    <p id="greenShareSubtitle" class="green-share-subtitle hidden"></p>
    <div id="greenShareList" class="green-share-list"></div>
  </div>
</div>

<!-- 公開確認ポップ -->
<div id="revealPop" class="confirm-pop hidden" role="dialog" aria-label="公開確認">
  <div class="caret" aria-hidden="true"></div>
  <p class="msg" id="revealMsg">公開しますか？</p>
  <div class="actions">
    <button class="btn ghost" id="btnRevealNo">キャンセル</button>
    <button class="btn primary" id="btnRevealYes">はい</button>
  </div>
</div>

<div id="seatPopBackdrop" class="seat-pop-backdrop hidden" aria-label="座席カラータイル">
  <div class="seat-board" id="seatBoard">
    <div class="seat-board-title">
      <span>プレイヤーカラーを選択してください。</span>
      <span class="seat-count-badge" id="seatCountBadge">0 / 12</span>
    </div>
    <div id="tileGrid" class="tile-grid"></div>
    <div class="warn" id="startWarn">※ホストが「スタート」を押すと配布されます</div>

    <div class="seat-board-actions">
      <button id="btnSpectate" class="btn ghost">観戦</button>
    </div>
  </div>
</div>

<!-- 装備枠 -->
<div id="equipDock" class="equip-dock" aria-label="装備枠">
  <div class="equip-board">
    <div class="equip-body" id="equipBody"></div>
  </div>
</div>

<div id="myRoleDock" class="my-role-dock" aria-label="自分の正体カード">
  <div id="myRoleCard"></div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn danger" id="btnKickYes">はい</button>
      <button class="btn ghost" id="btnKickNo">キャンセル</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード（一覧）</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    <span class="start-badge" id="startBadge">参加人数：0</span><br>
    「スタート」で参加人数に応じた構成で、全員に正体カードを1枚配布。<br>
    「リセット」で席・正体をリセットします。<br>
    <span class="small">開始後は座席変更できません。</span>
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, set, get, update, onValue, remove, runTransaction } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
    authDomain: "timebomb-3b0c7.firebaseapp.com",
    databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
    projectId: "timebomb-3b0c7",
    storageBucket: "timebomb-3b0c7.firebasestorage.app",
    messagingSenderId: "532935786630",
    appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
    measurementId: "G-K8NRR8K64Y"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
  sessionStorage.setItem('bbUserId', savedUserId);

  function setHpRowHeights(map){
    const root = document.documentElement;
    for (let i=0;i<=15;i++){
      const key = `--hp-r${i}`;
      if (map && Object.prototype.hasOwnProperty.call(map, i)) {
        root.style.setProperty(key, String(map[i]));
      }
    }
  }

  const equipDock = document.getElementById("equipDock");
  const cardsPanel = document.getElementById("cardsPanel");

  function updateEquipDockTop(){
    if (!equipDock || !cardsPanel) return;
    const rect = cardsPanel.getBoundingClientRect();
    if (!Number.isFinite(rect.bottom) || rect.bottom <= 0) return;
    const gap = 6;
    const top = Math.round(rect.bottom + gap);
    const minTop = 80;
    equipDock.style.setProperty('--equip-top', `${Math.max(minTop, top)}px`);
  }
  window.addEventListener('resize', () => { updateEquipDockTop(); });

  const GREEN_DECK = [
    { text:"推理カード：正体カードを見せよ。" },
    { text:"推理カード：あなたは D / F / G / V / W ?（HP12以上）だったら2ダメージ受けよ。" },
    { text:"推理カード：あなたは A / B / C / E / U ?（HP11以下）だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら2ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シャドウ？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら1ダメージ受けよ。" },
    { text:"推理カード：あなたは レイダー？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か シャドウ？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン か レイダー？だったら装備を渡すか、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン？だったら❿に移動せよ。既に➓にいる場合、1ダメージ受けよ。" },
    { text:"推理カード：あなたは シチズン？だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。" },
  ];

  const WHITE_DECK = [
    { name:"銀のロザリオ", effect:"装備、ダイスの攻撃によって倒したPLの全ての装備を奪う。" },
    { name:"虹色のパラソル", effect:"装備、攻撃する代わりに攻撃レンジのPLに推理カードを渡す。" },
    { name:"エクスカリバー", effect:"装備、あなたがレイダーなら、攻撃ダメージが 2 上がる。" },
    { name:"神秘のコンパス", effect:"装備、移動の時にダイスを二回振って、選ぶことができる。" },
    { name:"幸運のブローチ", effect:"装備、市庁舎(8)の効果ダメージを受けない。" },
    { name:"賢者のローブ", effect:"装備、与える攻撃ダメージ、受ける攻撃ダメージが 1 減少する。" },
    { name:"いにしえの聖杯", effect:"装備、三つ目の黒犬,吸血コウモリ,呪いの人形の効果を受けない。" },
    { name:"光臨", effect:"あなたがレイダーなら、全ダメージを回復する。" },
    { name:"守護天使", effect:"次の自分の手番の始めまで、攻撃ダメージを受けない。" },
    { name:"封印の知恵", effect:"この手番の終了後、もう1手番を行う。" },
    { name:"応急手当", effect:"任意のPL（自分も可）を選び、そのPLのダメージを7にする。" },
    { name:"人魚の涙", effect:"最もダメージが多い人を 3 回復する。" },
    { name:"幸せのクッキー", effect:"あなたが A または U なら、HPを全回復する。" },
    { name:"闇を祓う鏡", effect:"あなたがシャドウ陣営でウルリッヒでないなら、必ず正体カードを公開する。" },
    { name:"いやしの聖水", effect:"自分のダメージを 2 回復する。" },
    { name:"裁きの閃光", effect:"自分以外のPL全員に 2 ダメージ与える。" },
    { name:"恩恵", effect:"自分以外のPLを選び、6面ダイスを振る。目の数回復する。" },
  ];

  const BLACK_DECK = [
    { name:"サーベル", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"拳銃R", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"拳銃L", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"クロスボウガン", effect:"装備、攻撃ダメージが 1 増加する。" },
    { name:"妖刀マサムネ", effect:"装備、攻撃レンジにPLがいれば必ず攻撃を行う。4面ダイスだけを使う。" },
    { name:"ガトリング", effect:"装備、攻撃レンジのPL全員に攻撃する。" },
    { name:"死神スコープ", effect:"装備、攻撃レンジが 1 増加する。" },
    { name:"オリバーの子分", effect:"任意のPLを選んで、装備を1つ奪う。" },
    { name:"吸血コウモリ", effect:"自分以外のPL1人に2ダメージ与え,自分は1回復する。" },
    { name:"三つ目の黒犬", effect:"自分と選んだPL1人に2ダメージ与える。" },
    { name:"暴動", effect:"ダイスを2つ振り、目のエリアにいるPL全員に3ダメージ与える。" },
    { name:"バナナの皮", effect:"装備を1つ誰かに渡す。なければ 1 ダメージ受ける。" },
    { name:"呪いの人形", effect:"PLを1人選び6面ダイスを振る。1-4なら選んだPLに、5-6なら自分に3ダメージ与える。" },
  ];

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  function safeText(s){ return String(s ?? ""); }
  function escHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function cardImageFileFromName(cardName){
    const safe = encodeURI(String(cardName || "").trim());
    return safe ? `${safe}.jpg` : "";
  }
  function rgbFromHex(hex){
    const h = String(hex||"").trim();
    if(!h.startsWith("#") || (h.length!==7 && h.length!==4)) return {r:0,g:0,b:0};
    if(h.length===4){
      const r = parseInt(h[1]+h[1],16);
      const g = parseInt(h[2]+h[2],16);
      const b = parseInt(h[3]+h[3],16);
      return {r,g,b};
    }
    const r = parseInt(h.slice(1,3),16);
    const g = parseInt(h.slice(3,5),16);
    const b = parseInt(h.slice(5,7),16);
    return {r,g,b};
  }
  function textColorFor(bgHex){
    const {r,g,b} = rgbFromHex(bgHex);
    const L = (0.2126*r + 0.7152*g + 0.0722*b)/255;
    return (L < 0.55) ? "#fff" : "#111";
  }
  function firstChar(name){
    if(!name) return '';
    return Array.from(name.trim())[0] || '';
  }
  function isEquipCard(cardObj){
    const eff = safeText(cardObj?.effect || "").trim();
    if (!eff) return false;
    if (eff === "装備") return true;
    const prefixes = ["装備、","装備,","装備：","装備:","装備 "];
    return prefixes.some(p => eff.startsWith(p));
  }

  const ROOM_ALLOW = {
    1: ["white"],
    2: ["black"],
    5: ["green"],
    6: ["green","white","black"],
  };
  function allowedTypesByRoom(roomId){ return ROOM_ALLOW[roomId] || []; }
  function canClickType(type){
    const allowed = allowedTypesByRoom(state.currentRoomId);
    return allowed.includes(type);
  }
  function applyLocked(el, locked, {noDim=false} = {}){
    if (!el) return;
    el.classList.toggle("locked", !!locked && !noDim);
    el.classList.toggle("blocked", !!locked && !!noDim);
    if (!locked){
      el.classList.remove("locked","blocked");
    }
  }

  function ensureCountTag(el){
    let tag = el.querySelector('.count-tag');
    if (!tag){
      tag = document.createElement('div');
      tag.className = 'count-tag';
      el.appendChild(tag);
    }
    return tag;
  }

  function setSlotAsDeck(slotEl, imgUrl, count, { disabled=false, type=null } = {}){
    slotEl.className = 'card72 deck' + (disabled ? ' disabled' : '');
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = `url('${imgUrl}')`;
    slotEl.innerHTML = '';
    const tag = ensureCountTag(slotEl);
    tag.textContent = String(count);
    slotEl.dataset.cardType = type || "";
  }

  function buildWbFrontHTML(cardObj, theme){
    const name = safeText(cardObj?.name || "（なし）").trim();
    const img  = cardImageFileFromName(name);

    let eff = safeText(cardObj?.effect || "");
    let showEquip = false;

    const trimmed = eff.trim();
    const prefixes = ["装備、","装備,","装備：","装備:","装備 "];
    for (const p of prefixes){
      if (trimmed.startsWith(p)){
        showEquip = true;
        eff = trimmed.slice(p.length).trim();
        break;
      }
    }
    if (!showEquip && trimmed === "装備"){
      showEquip = true;
      eff = "";
    }

    const tagHtml = showEquip ? `<span class="inline-tag">装備</span>` : "";
    const effHtml = escHtml(eff);

    return `
      <div class="wb-name"><span>${escHtml(name)}</span></div>
      <div class="wb-circle" aria-label="card image circle">
        ${img ? `<img src="${escHtml(img)}" alt="${escHtml(name)}">` : ``}
      </div>
      <div class="wb-effect">
        <div class="wb-desc">${tagHtml}${effHtml}</div>
      </div>
    `;
  }

  function setSlotAsWbFront(slotEl, cardObj, theme){
    slotEl.className = `card72 wb-front ${theme === 'black' ? 'wb-black' : theme === 'green' ? 'wb-green' : 'wb-white'}`;
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = buildWbFrontHTML(cardObj, theme);
    slotEl.dataset.cardType = theme || "";
  }

  function setSlotEmpty(slotEl){
    slotEl.className = 'card72';
    slotEl.classList.remove("noframe");
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = '';
    slotEl.dataset.cardType = "";
  }

  function setSlotEmptyNoFrame(slotEl){
    slotEl.className = 'card72 noframe';
    slotEl.style.backgroundImage = '';
    slotEl.innerHTML = '';
    slotEl.dataset.cardType = "";
  }

  const zoomBackdrop = document.getElementById("zoomBackdrop");
  const zoomStage = document.getElementById("zoomStage");
  const zoomCloseBtn = document.getElementById("zoomCloseBtn");
  const greenShareDock = document.getElementById("greenShareDock");
  const greenShareList = document.getElementById("greenShareList");
  const greenShareSubtitle = document.getElementById("greenShareSubtitle");
  let zoomCloseOnBackdrop = true;
  let greenShareCard = null;
  let greenInboxSeenAt = 0;
  let greenInboxInitialized = false;
  let greenReplySeenAt = 0;
  let greenReplyInitialized = false;
  let greenZoomLocked = false;
  let pendingGreenRequestId = "";
  let greenReplyBubble = null;

  const revealPop = document.getElementById("revealPop");
  const btnRevealYes = document.getElementById("btnRevealYes");
  const btnRevealNo  = document.getElementById("btnRevealNo");

  function showRevealPopAt(clientX, clientY){
    const pad = 10;
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    revealPop.classList.remove("hidden");
    const r = revealPop.getBoundingClientRect();

    let x = clientX;
    let y = clientY;

    const halfW = r.width / 2;
    if (x - halfW < pad) x = pad + halfW;
    if (x + halfW > vw - pad) x = (vw - pad) - halfW;

    let top = y + 18;
    if (top + r.height > vh - pad) top = y - r.height - 18;
    top = Math.max(pad, Math.min(top, vh - pad - r.height));

    revealPop.style.left = x + "px";
    revealPop.style.top  = top + "px";
  }
  function hideRevealPop(){ revealPop.classList.add("hidden"); }


  function myRoleInfo(){
    const my = state.hands?.[state.userId];
    return my && my.roleId ? (ROLE_BY_ID[my.roleId] || null) : null;
  }

  function hasAnyEquipment(uid){
    const obj = equipCache?.[uid] || {};
    return Object.keys(obj).some(k => k !== "identity");
  }

  function greenCardConditionMatched(cardObj){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const role = myRoleInfo();
    if (!role) return null;

    if (text.includes("A / B / C / E / U")) return ["A","B","C","E","U"].includes(role.initial) && Number(role.hp) <= 11;
    if (text.includes("D / F / G / V / W")) return ["D","F","G","V","W"].includes(role.initial) && Number(role.hp) >= 12;
    if (text.includes("シチズン か シャドウ")) return role.faction === "シチズン" || role.faction === "シャドウ";
    if (text.includes("シチズン か レイダー")) return role.faction === "シチズン" || role.faction === "レイダー";
    if (text.includes("シャドウ？")) return role.faction === "シャドウ";
    if (text.includes("レイダー？")) return role.faction === "レイダー";
    if (text.includes("シチズン？")) return role.faction === "シチズン";

    return null;
  }

  function greenAnswerOptions(cardObj){
    const text = safeText(cardObj?.effect || cardObj?.text || "");
    const matched = greenCardConditionMatched(cardObj);
    const canJudge = matched !== null;

    if (text.includes("装備を渡すか、1ダメージ受けよ")){
      const canEquip = hasAnyEquipment(state.userId);
      return [
        { id:"take_damage", label:"ダメージを1うける", enabled: canJudge ? !!matched : true },
        { id:"give_equip", label:"装備をわたす", enabled: canJudge ? (!!matched && canEquip) : canEquip },
        { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
      ];
    }

    return [
      { id:"yes", label:"はい", enabled: canJudge ? !!matched : true },
      { id:"no", label:"いいえ", enabled: canJudge ? !matched : true }
    ];
  }

  function setGreenDockMeta({ title="", subtitle="" } = {}){
    const titleEl = greenShareDock?.querySelector(".green-share-title");
    if (titleEl) titleEl.textContent = title;
    if (greenShareSubtitle){
      greenShareSubtitle.textContent = subtitle || "";
      greenShareSubtitle.classList.toggle("hidden", !subtitle);
    }
  }

  function openGreenShareDock(cardObj){
    greenReplyBubble = null;
    renderPositionLine();
    greenShareCard = cardObj || null;
    if (!greenShareCard || !greenShareDock || !greenShareList){
      greenShareDock?.classList.add("hidden");
      return;
    }

    setGreenDockMeta({ title:"誰に渡しますか。", subtitle:"" });
    greenShareList.innerHTML = "";
    const players = latestPlayers
      .filter(p => p.id !== state.userId)
      .sort((a,b) => Number(a.seatIndex||999)-Number(b.seatIndex||999));

    for (const p of players){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn";
      btn.title = `${safeText(p.name)} に渡す`;

      const chip = buildChipFor(p.id);
      const name = document.createElement("span");
      name.textContent = safeText(p.name || "名無し");
      btn.appendChild(chip);
      btn.appendChild(name);

      btn.addEventListener("click", async () => {
        if (!greenShareCard || !state.roomCode || !p?.id) return;
        const requestId = `${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        const payload = {
          from: state.userId,
          to: p.id,
          requestId,
          card: greenShareCard,
          at: Date.now()
        };
        await set(ref(db, `rooms/${state.roomCode}/greenInbox/${p.id}`), payload);

        pendingGreenRequestId = requestId;
        greenShareList.innerHTML = "";
        const selected = btn.cloneNode(true);
        selected.classList.add("waiting-selected");
        selected.disabled = true;
        greenShareList.appendChild(selected);
        setGreenDockMeta({ title:"回答待ち...", subtitle:"" });
      });

      greenShareList.appendChild(btn);
    }
    greenShareDock.classList.remove("hidden");
  }

  function openGreenAnswerDock(msg){
    if (!greenShareDock || !greenShareList || !msg?.card) return;
    greenShareCard = msg.card;
    setGreenDockMeta({ title:"回答を選んでください", subtitle:safeText(msg.card.effect || "") });
    greenShareList.innerHTML = "";
    for (const opt of greenAnswerOptions(msg.card)){
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "green-share-btn answer";
      btn.textContent = opt.label;
      btn.disabled = !opt.enabled;
      btn.addEventListener("click", async () => {
        if (!state.roomCode || !msg?.from || !msg?.requestId) return;
        await set(ref(db, `rooms/${state.roomCode}/greenResponses/${msg.from}`), {
          from: msg.from,
          to: state.userId,
          requestId: msg.requestId,
          answerId: opt.id,
          answerLabel: opt.label,
          card: msg.card,
          at: Date.now()
        });
        closeZoom();
      });
      greenShareList.appendChild(btn);
    }
    greenShareDock.classList.remove("hidden");
  }

  function hideGreenShareDock(){
    greenShareCard = null;
    pendingGreenRequestId = "";
    greenReplyBubble = null;
    if (greenShareList) greenShareList.innerHTML = "";
    setGreenDockMeta({ title:"誰に渡しますか。", subtitle:"" });
    greenShareDock?.classList.add("hidden");
    renderPositionLine();
  }

  function openZoomContent(contentEl, { closeOnBackdrop=true, showCloseButton=true } = {}){
    zoomStage.innerHTML = "";
    zoomCloseOnBackdrop = !!closeOnBackdrop;
    greenZoomLocked = !showCloseButton;
    zoomCloseBtn.classList.toggle("hidden", !showCloseButton);
    zoomStage.appendChild(contentEl);
    zoomBackdrop.classList.remove("hidden");
  }
  function openZoomFromCard(cardEl, options){
    const clone = cardEl.cloneNode(true);
    clone.classList.remove("locked","blocked");
    clone.style.pointerEvents = "auto";
    openZoomContent(clone, options);
  }
  function openZoomFromRole(role){
    if (!role) return;
    const cardEl = createIdentityCard(role);
    openZoomContent(cardEl);
  }
  function openZoomFromDeckCard(cardObj, theme, options){
    if (!cardObj) return;
    const cardEl = document.createElement("div");
    cardEl.className = `card72 wb-front ${theme === "black" ? "wb-black" : theme === "green" ? "wb-green" : "wb-white"}`;
    cardEl.innerHTML = buildWbFrontHTML(cardObj, theme);
    cardEl.dataset.cardType = theme || "";
    openZoomContent(cardEl, options);
  }
  function closeZoom(){
    zoomBackdrop.classList.add("hidden");
    zoomStage.innerHTML = "";
    zoomCloseBtn.classList.add("hidden");
    zoomCloseOnBackdrop = true;
    greenZoomLocked = false;
    hideGreenShareDock();
    hideRevealPop();
  }
  zoomCloseBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    if (greenZoomLocked) return;
    closeZoom();
  });
  zoomBackdrop.addEventListener("click", (e) => {
    if (e.target === zoomBackdrop && zoomCloseOnBackdrop) closeZoom();
  });

  let slot1 = document.getElementById('slot1');
  let slot2 = document.getElementById('slot2');
  const slot3 = document.getElementById('slot3');
  let slot4 = document.getElementById('slot4');
  const slot5 = document.getElementById('slot5');

  function updateCardInteractivity(){
    const s1 = document.getElementById('slot1');
    const s2 = document.getElementById('slot2');
    const s3 = document.getElementById('slot3');
    const s4 = document.getElementById('slot4');
    const s5 = document.getElementById('slot5');

    const types = [
      [s1, s1?.dataset.cardType],
      [s2, s2?.dataset.cardType],
      [s3, s3?.dataset.cardType],
      [s4, s4?.dataset.cardType],
      [s5, s5?.dataset.cardType],
    ];

    for (const [el, t] of types){
      if (!el || !t){
        applyLocked(el, false);
        continue;
      }

      const shouldLock = !canClickType(t);

      const noDim =
        (el === slot3 && t === "white") ||
        (el === slot5 && t === "black");

      applyLocked(el, shouldLock, { noDim });
    }
  }

  let equipCache = {};
  const equipBody = document.getElementById("equipBody");

  function subscribeEquipment(){
    const eRef = ref(db, `rooms/${state.roomCode}/equipment`);
    onValue(eRef, snap => {
      equipCache = snap.val() || {};
      renderEquipmentDock();
    });
  }
  function isIdentityEquipItem(v){
    return v && (v.kind === "identity") && !!v.roleId;
  }
  function listEquipForUid(uid){
    const obj = equipCache?.[uid] || {};
    const arr = Object.entries(obj).map(([k,v]) => ({ key:k, ...(v||{}) }));
    arr.sort((a,b) => {
      const ai = isIdentityEquipItem(a) ? 0 : 1;
      const bi = isIdentityEquipItem(b) ? 0 : 1;
      if (ai !== bi) return ai - bi;
      return Number(a.at||0) - Number(b.at||0);
    });
    return arr;
  }

  function buildEquipTag(colorHex, initial){
    const d = document.createElement("div");
    d.className = "equip-tag";
    d.style.background = String(colorHex || "#ddd");
    d.style.color = textColorFor(colorHex || "#ddd");
    d.textContent = String(initial || "").slice(0,1);
    return d;
  }

  function buildEquipCard(item){
    if (isIdentityEquipItem(item)){
      const role = ROLE_BY_ID[item.roleId];
      if (!role) return document.createElement("div");
      return createIdentityCard(role);
    }
    const theme = safeText(item.theme || "white");
    const cardObj = { name: safeText(item.name), effect: safeText(item.effect) };
    const el = document.createElement("div");
    el.className = `card72 wb-front ${theme === "black" ? "wb-black" : theme === "green" ? "wb-green" : "wb-white"}`;
    el.innerHTML = buildWbFrontHTML(cardObj, theme);
    el.dataset.cardType = theme || "";
    return el;
  }

  let latestPlayers = [];

  function orderedPlayersForEquip(){
    const me = latestPlayers.find(p => p.id === state.userId) || null;
    const others = latestPlayers.filter(p => p.id !== state.userId).sort((a,b) => a.seatIndex - b.seatIndex);
    const arr = [];
    if (me) arr.push(me);
    arr.push(...others);
    return arr;
  }

  function getEquipCols(){
    const body = equipBody;
    const dock = equipDock;
    const w = (body?.clientWidth || dock?.clientWidth || 0);
    const cardW = 72;
    const gap = 8;
    const usable = Math.max(0, w);
    const cols = Math.floor((usable + gap) / (cardW + gap));
    return Math.max(2, Math.min(10, cols || 6));
  }
  function applyEquipCols(){
    const cols = getEquipCols();
    equipBody?.style.setProperty('--equip-cols', String(cols));
  }
  window.addEventListener('resize', () => applyEquipCols());

  function renderEquipmentDock(){
    if (!state.roomCode) { equipDock.classList.remove("visible"); return; }

    updateEquipDockTop();

    const players = orderedPlayersForEquip();
    const rows = [];
    for (const p of players){
      const list = listEquipForUid(p.id);
      if (!list || list.length === 0) continue;
      rows.push({ p, list });
    }

    equipBody.innerHTML = "";

    if (rows.length === 0){
      equipDock.classList.remove("visible");
      return;
    }

    equipDock.classList.add("visible");
    applyEquipCols();

    for (const {p, list} of rows){
      const row = document.createElement("div");
      row.className = "equip-row";

      const tag = buildEquipTag(p.color || "#ddd", firstChar(p.name));
      row.appendChild(tag);

      const cards = document.createElement("div");
      cards.className = "equip-cards";
      for (const it of list){
        cards.appendChild(buildEquipCard(it));
      }
      row.appendChild(cards);
      equipBody.appendChild(row);
    }
  }

  async function grantEquipmentToMe(cardObj, theme){
    if (!state.roomCode) return;
    if (!cardObj) return;
    if (!isEquipCard(cardObj)) return;

    const key = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${state.userId}/${key}`);
    await set(eRef, {
      theme: theme || "white",
      name: safeText(cardObj.name),
      effect: safeText(cardObj.effect),
      at: Date.now()
    });
  }

  async function revealMyIdentityToEquipment(){
    if (!state.roomCode) return;
    const my = state.hands?.[state.userId];
    if (!my || !my.roleId) return;

    const eRef = ref(db, `rooms/${state.roomCode}/equipment/${state.userId}/identity`);
    await set(eRef, {
      kind: "identity",
      roleId: String(my.roleId),
      at: 0,
      revealedAt: Date.now()
    });
  }

  function isMyIdentityRevealed(){
    const v = equipCache?.[state.userId]?.identity;
    return !!(v && v.kind === "identity" && v.roleId);
  }

  zoomStage.addEventListener("click", (e) => {
    const idCard = e.target.closest(".id72");
    if (!idCard) return;

    const my = state.hands?.[state.userId];
    if (!my || !my.roleId) return;
    if (isMyIdentityRevealed()) return;

    e.stopPropagation();
    showRevealPopAt(e.clientX, e.clientY);
  });

  document.addEventListener("click", (e) => {
    if (revealPop.classList.contains("hidden")) return;
    if (e.target.closest("#revealPop")) return;
    hideRevealPop();
  }, true);

  btnRevealNo.addEventListener("click", (e) => {
    e.stopPropagation();
    hideRevealPop();
  });
  btnRevealYes.addEventListener("click", async (e) => {
    e.stopPropagation();
    await revealMyIdentityToEquipment();
    hideRevealPop();
  });

  equipBody.addEventListener("click", (e) => {
    const card = e.target.closest(".card72.wb-front, .id72");
    if (!card) return;
    openZoomFromCard(card);
  });

  const hpBoard = document.getElementById("hpBoard");
  const positionLine = document.getElementById("positionLine");
  let damageCache = {};

  function clampDamage(v){
    const n = Number(v);
    if (!Number.isFinite(n)) return 0;
    return Math.max(0, Math.min(15, Math.floor(n)));
  }

  function buildHpCells(){
    hpBoard.innerHTML = "";
    for (let row=15; row>=0; row--){
      const cell = document.createElement("div");
      cell.className = "hp-cell";
      cell.dataset.damage = String(row);
      hpBoard.appendChild(cell);
    }
  }

  function playerById(uid){
    return latestPlayers.find(p => p.id === uid) || null;
  }

  function buildChipFor(uid){
    const p = playerById(uid);
    const color = p?.color || "#ddd";
    const initial = firstChar(p?.name || "");
    const d = document.createElement("div");
    d.className = "chip16";
    d.style.background = color;
    d.style.color = textColorFor(color);
    d.textContent = initial || "";
    d.title = p ? p.name : "";
    return d;
  }

  function renderHpBoard(){
    if (!hpBoard) return;
    if (!state.roomCode) return;

    if (!hpBoard.firstChild) buildHpCells();

    const cells = Array.from(hpBoard.querySelectorAll(".hp-cell"));
    for (const c of cells){
      c.querySelectorAll(".chip16").forEach(x => x.remove());
    }

    const entries = Object.entries(damageCache || {}).map(([uid, lvl]) => ({
      uid, lvl: clampDamage(lvl)
    }));

    const started = isGameStarted();
    if (started && entries.length === 0 && latestPlayers.length > 0){
      for (const p of latestPlayers){
        entries.push({ uid: p.id, lvl: 0 });
      }
    }

    const byLvl = new Map();
    for (const e of entries){
      const arr = byLvl.get(e.lvl) || [];
      arr.push(e.uid);
      byLvl.set(e.lvl, arr);
    }

    for (const [lvl, uids] of byLvl.entries()){
      uids.sort((a,b) => {
        const pa = playerById(a);
        const pb = playerById(b);
        return Number(pa?.seatIndex||999) - Number(pb?.seatIndex||999);
      });
      byLvl.set(lvl, uids);
    }

    for (const cell of cells){
      const lvl = Number(cell.dataset.damage);
      const uids = byLvl.get(lvl) || [];
      for (const uid of uids){
        cell.appendChild(buildChipFor(uid));
      }
    }
  }

  function renderPositionLine(){
    if (!positionLine) return;

    const started = isGameStarted();
    const order = Array.isArray(state.room?.positionOrder) ? state.room.positionOrder : [];
    const startPlayerId = safeText(state.room?.startPlayerId || "");

    let players = [];
    if (started && order.length > 0){
      players = order
        .map(uid => latestPlayers.find(p => p.id === uid) || null)
        .filter(Boolean);
      const rest = latestPlayers
        .filter(p => !order.includes(p.id))
        .sort((a,b) => Number(a.seatIndex || 999) - Number(b.seatIndex || 999));
      players.push(...rest);
    } else {
      players = latestPlayers
        .slice()
        .sort((a,b) => Number(a.seatIndex || 999) - Number(b.seatIndex || 999));
    }

    positionLine.innerHTML = "";
    if (!started || players.length === 0){
      positionLine.classList.add("hidden");
      return;
    }

    players.forEach((p, idx) => {
      if (idx > 0){
        const arrow = document.createElement("span");
        arrow.className = "position-arrow";
        arrow.textContent = "▶";
        positionLine.appendChild(arrow);
      }
      const item = document.createElement("div");
      item.className = "position-item";

      if (greenReplyBubble && p.id === greenReplyBubble.uid && greenReplyBubble.text){
        const bubble = document.createElement("div");
        bubble.className = "position-answer-bubble";
        bubble.textContent = greenReplyBubble.text;
        item.appendChild(bubble);
      }

      item.appendChild(buildChipFor(p.id));

      const marker = document.createElement("div");
      marker.className = "starter-mark";
      marker.textContent = (started && p.id === startPlayerId) ? "△" : "";
      item.appendChild(marker);

      positionLine.appendChild(item);
    });

    positionLine.classList.remove("hidden");
  }

  function subscribeDamage(){
    const dRef = ref(db, `rooms/${state.roomCode}/damage`);
    onValue(dRef, snap => {
      damageCache = snap.val() || {};
      renderHpBoard();
    });
  }

  async function initDamageAllToZero(players){
    if (!state.roomCode) return;
    const baseRef = ref(db, `rooms/${state.roomCode}/damage`);
    const obj = {};
    for (const p of players){
      obj[p.id] = 0;
    }
    await set(baseRef, obj);
  }

  function toGreenOrder(){
    return GREEN_DECK.map(x => {
      const text = safeText(x?.text||"").replace(/^推理カード：/,"").trim();
      return { name:"推理カード", effect:text };
    });
  }
  function toWhiteOrder(){ return WHITE_DECK.map(x => ({ name:safeText(x.name), effect:safeText(x.effect) })); }
  function toBlackOrder(){ return BLACK_DECK.map(x => ({ name:safeText(x.name), effect:safeText(x.effect) })); }
  function remainingCount(d){
    const o = Array.isArray(d?.order) ? d.order.length : 0;
    const i = Number(d?.idx||0);
    return Math.max(0, o - i);
  }

  let deckCache = null;
  function subscribeDeckState(){
    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    onValue(dsRef, snap => {
      deckCache = snap.val() || null;
      renderDeckRowFromRoom();
      updateEquipDockTop();
    });
  }

  async function ensureRoomDeckState(){
    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    await runTransaction(dsRef, (cur) => {
      if (cur && cur.green && cur.white && cur.black) return cur;

      const green = { order: shuffle(toGreenOrder()), idx: 0 };
      const white = { order: shuffle(toWhiteOrder()), idx: 0 };
      const black = { order: shuffle(toBlackOrder()), idx: 0 };

      return {
        green, white, black,
        reveal: { slot3: null, slot5: null },
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };
    });
  }

  async function drawFromSharedDeck(type){
    if (!state.roomCode) return;
    if (!canClickType(type)) return;

    const dsRef = ref(db, `rooms/${state.roomCode}/deckState`);
    let drawn = null;

    await runTransaction(dsRef, (cur) => {
      if (!cur || !cur[type] || !Array.isArray(cur[type].order)) return cur;

      const d = cur[type];
      const idx = Number(d.idx || 0);
      if (idx >= d.order.length) return cur;

      drawn = d.order[idx];
      d.idx = idx + 1;

      cur.reveal = cur.reveal || { slot3:null, slot5:null };
      if (type === "black"){
        cur.reveal.slot5 = { theme:"black", card: drawn, at: Date.now() };
      } else if (type === "white"){
        cur.reveal.slot3 = { theme:"white", card: drawn, at: Date.now() };
      }
      cur.updatedAt = Date.now();
      return cur;
    });

    if (drawn && (type === "white" || type === "black")){
      await grantEquipmentToMe(drawn, type);
    } else if (drawn && type === "green"){
      openZoomFromDeckCard(drawn, "green", { closeOnBackdrop:false, showCloseButton:false });
      openGreenShareDock(drawn);
    }
  }

  function renderDeckRowFromRoom(){
    if (!deckCache || !deckCache.green || !deckCache.white || !deckCache.black){
      setSlotAsDeck(slot1, 'greendeck.jpg', 0, { disabled:true, type:"green" });
      setSlotAsDeck(slot2, 'whitedeck.jpg', 0, { disabled:true, type:"white" });
      setSlotEmptyNoFrame(slot3);
      setSlotAsDeck(slot4, 'blackdeck.jpg', 0, { disabled:true, type:"black" });
      setSlotEmptyNoFrame(slot5);
      bindDeckClicksShared();
      updateCardInteractivity();
      return;
    }

    const gLeft = remainingCount(deckCache.green);
    const wLeft = remainingCount(deckCache.white);
    const bLeft = remainingCount(deckCache.black);

    setSlotAsDeck(slot1, 'greendeck.jpg', gLeft, { disabled: gLeft===0, type:"green" });
    setSlotAsDeck(slot2, 'whitedeck.jpg', wLeft, { disabled: wLeft===0, type:"white" });
    setSlotAsDeck(slot4, 'blackdeck.jpg', bLeft, { disabled: bLeft===0, type:"black" });

    const r3 = deckCache?.reveal?.slot3;
    const r5 = deckCache?.reveal?.slot5;

    if (r3 && r3.card){
      setSlotAsWbFront(slot3, r3.card, r3.theme || "white");
    } else {
      setSlotEmptyNoFrame(slot3);
    }

    if (r5 && r5.card){
      setSlotAsWbFront(slot5, r5.card, "black");
    } else {
      setSlotEmptyNoFrame(slot5);
    }

    bindDeckClicksShared();
    updateCardInteractivity();
  }

  function bindDeckClicksShared(){
    const s1 = slot1.cloneNode(true);
    slot1.parentNode.replaceChild(s1, slot1);
    slot1 = s1;
    slot1.dataset.cardType = "green";
    slot1.style.backgroundImage = `url('greendeck.jpg')`;
    ensureCountTag(slot1);

    const s2 = slot2.cloneNode(true);
    slot2.parentNode.replaceChild(s2, slot2);
    slot2 = s2;
    slot2.dataset.cardType = "white";
    slot2.style.backgroundImage = `url('whitedeck.jpg')`;
    ensureCountTag(slot2);

    const s4 = slot4.cloneNode(true);
    slot4.parentNode.replaceChild(s4, slot4);
    slot4 = s4;
    slot4.dataset.cardType = "black";
    slot4.style.backgroundImage = `url('blackdeck.jpg')`;
    ensureCountTag(slot4);

    slot1.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.green);
      if (!canClickType("green")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("green");
    });
    slot2.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.white);
      if (!canClickType("white")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("white");
    });
    slot4.addEventListener('click', async () => {
      const left = remainingCount(deckCache?.black);
      if (!canClickType("black")) return;
      if (left <= 0) return;
      await drawFromSharedDeck("black");
    });
  }

  const cardsPanelEl = document.getElementById("cardsPanel");
  cardsPanelEl.addEventListener("click", (e) => {
    const card = e.target.closest(".card72.wb-front");
    if (!card) return;
    if (card.classList.contains("locked") || card.classList.contains("blocked")) return;
    openZoomFromCard(card);
  });

  const roomSvg = document.getElementById('roomSvg');
  const roomG   = document.getElementById('roomG');

  function svgEl(name, attrs={}, parent=roomG){
    const n = document.createElementNS('http://www.w3.org/2000/svg', name);
    for(const k in attrs) n.setAttribute(k, attrs[k]);
    parent.appendChild(n);
    return n;
  }
  function ptsToStr(pts){ return pts.map(p=>`${p[0]},${p[1]}`).join(' '); }
  function poly(pts, cls, parent=roomG){ return svgEl('polygon', {points: ptsToStr(pts), class: cls}, parent); }

  function hexFlat(cx, cy, s){
    const rt3 = Math.sqrt(3);
    const h = (rt3/2)*s;
    return [
      [cx+s,   cy],
      [cx+s/2, cy+h],
      [cx-s/2, cy+h],
      [cx-s,   cy],
      [cx-s/2, cy-h],
      [cx+s/2, cy-h],
    ];
  }
  function buildStarRooms(cx, cy, s0, t, tip){
    const P = hexFlat(cx, cy, s0);

    const add=(a,b)=>[a[0]+b[0],a[1]+b[1]];
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
    const mul=(a,k)=>[a[0]*k,a[1]*k];
    const norm=(v)=>{ const L=Math.hypot(v[0],v[1])||1; return [v[0]/L,v[1]/L]; };

    function intersectRayRay(p,u,q,v){
      const det = u[0]*(-v[1]) - u[1]*(-v[0]);
      const b = sub(q,p);
      const s = ( b[0]*(-v[1]) - b[1]*(-v[0]) ) / det;
      return add(p, mul(u, s));
    }
    function outwardNormal(a,b){
      const u = norm(sub(b,a));
      return [u[1], -u[0]];
    }

    const lines = [];
    for(let i=0;i<6;i++){
      const a = P[i], b = P[(i+1)%6];
      const d = norm(sub(b,a));
      const n = outwardNormal(a,b);
      const p0 = add(a, mul(n, t));
      lines.push({ p:p0, d, n });
    }

    const Q = [];
    for(let i=0;i<6;i++){
      const L0 = lines[(i+5)%6];
      const L1 = lines[i];
      Q.push(intersectRayRay(L0.p, L0.d, L1.p, L1.d));
    }

    const T = [];
    for(let i=0;i<6;i++){
      const a = P[i], b = P[(i+1)%6];
      const mid = mul(add(a,b), 0.5);
      const n = lines[i].n;
      T.push(add(mid, mul(n, tip)));
    }

    const rooms = [];
    for(let i=0;i<6;i++){
      const i2 = (i+1)%6;
      rooms.push([ P[i], P[i2], Q[i2], T[i], Q[i] ]);
    }

    return { centerHex:P, rooms };
  }

  const cx  = 0,  cy  = 0;
  const s0  = 48;
  const t   = 26;
  const tip = 90;

  function fitRoomViewBox(margin = 2){
    const bb = roomG.getBBox();
    const x = bb.x - margin;
    const y = bb.y - margin;
    const w = bb.width + margin*2;
    const h = bb.height + margin*2;
    roomSvg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
  }

  let markerLayer = null;
  let markerCache = {};

  function getMyColor(){
    if (state.seatedTable != null){
      return SEAT_COLORS[state.seatedTable-1] || "#ddd";
    }
    return null;
  }
  function getMyInitial(){
    return firstChar(state.userName || "");
  }

  function ensureMarkerLayer(){
    if (markerLayer && markerLayer.isConnected) return markerLayer;
    markerLayer = svgEl('g', { id:"markerLayer" }, roomG);
    return markerLayer;
  }
  function clearMarkerLayer(){
    if (!markerLayer) return;
    while(markerLayer.firstChild) markerLayer.removeChild(markerLayer.firstChild);
  }
 function drawMarker({x,y,color,initial,uid}){
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  g.setAttribute("data-uid", uid || "");

  const size = 16;
  const rx = 3;

  // ★自分だけ丸い点線リング（四角マーカーの外側）
  if (uid && uid === state.userId){
    const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
    ring.setAttribute("cx", String(x));
    ring.setAttribute("cy", String(y));
    ring.setAttribute("r", String(size/2 + 5)); // ←リングの大きさ（必要なら調整）
    ring.setAttribute("class", "mark-me-ring");
    g.appendChild(ring);
  }

  const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
  rect.setAttribute("x", String(x - size/2));
  rect.setAttribute("y", String(y - size/2));
  rect.setAttribute("width", String(size));
  rect.setAttribute("height", String(size));
  rect.setAttribute("rx", String(rx));
  rect.setAttribute("class", "mark-rect");
  rect.setAttribute("fill", String(color || "#ddd"));

  const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
  txt.setAttribute("x", String(x));
  txt.setAttribute("y", String(y+0.5));
  txt.setAttribute("class","mark-text");
  txt.setAttribute("fill", textColorFor(color || "#ddd"));
  txt.textContent = String(initial || "").slice(0,1);

  g.appendChild(rect);
  g.appendChild(txt);
  markerLayer.appendChild(g);
}


  function renderMarkers(){
    ensureMarkerLayer();
    clearMarkerLayer();
    const entries = Object.entries(markerCache || {});
    for (const [uid, m] of entries){
      if (!m) continue;
      const x = Number(m.x);
      const y = Number(m.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
      drawMarker({
        uid,
        x, y,
        color: String(m.color || "#ddd"),
        initial: String(m.initial || "")
      });
    }
  }

  function clientToSvgPoint(svg, clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) return {x:0,y:0};
    const p = pt.matrixTransform(ctm.inverse());
    return { x: p.x, y: p.y };
  }

  async function writeMyMarker(x, y){
    if (!state.roomCode) return;
    const color = getMyColor();
    const initial = getMyInitial();
    if (!color || !initial) return;

    const mRef = ref(db, `rooms/${state.roomCode}/markers/${state.userId}`);
    await set(mRef, { x, y, color, initial, updatedAt: Date.now() });
  }

  function subscribeMarkers(){
    const mRef = ref(db, `rooms/${state.roomCode}/markers`);
    onValue(mRef, snap => {
      markerCache = snap.val() || {};
      renderMarkers();
    });
  }

  function setCurrentRoom(roomId){
    state.currentRoomId = roomId;
    updateCardInteractivity();
  }

  function renderRoomShape(){
    while(roomG.firstChild) roomG.removeChild(roomG.firstChild);

    const { centerHex, rooms } = buildStarRooms(cx, cy, s0, t, tip);

    poly(centerHex, 'shape');

    rooms.forEach((pts, idx)=>{
      poly(pts, 'shape');
      const hit = poly(pts, 'roomhit');
      const roomId = idx + 1;
      hit.dataset.roomId = String(roomId);

      hit.addEventListener('click', async (ev) => {
        setCurrentRoom(roomId);
        const p = clientToSvgPoint(roomSvg, ev.clientX, ev.clientY);
        await writeMyMarker(p.x, p.y);
      });
    });

    const centerHit = poly(centerHex, 'roomhit');
    centerHit.dataset.roomId = "7";
    centerHit.addEventListener('click', async (ev) => {
      setCurrentRoom(7);
      const p = clientToSvgPoint(roomSvg, ev.clientX, ev.clientY);
      await writeMyMarker(p.x, p.y);
    });

    ensureMarkerLayer();
    fitRoomViewBox(2);
  }

  const ROLES = [
    { id:"CIT_A1", name:"アリス",    en:"ALICE",    initial:"A", faction:"シチズン", hp:8,  win:"生存している", effect:"うさぎさんヒール：手番初めに使用。ダメージを全回復（1回）" },
    { id:"CIT_A2", name:"アンジェラ", en:"ANGELA",  initial:"A", faction:"シチズン", hp:8,  win:"右隣のプレイヤーが勝利する", effect:"移り気：勝利条件を「左隣のプレイヤーが勝利する」に変更（1回）" },
    { id:"CIT_A3", name:"アガサ",    en:"AGATHA",   initial:"A", faction:"シチズン", hp:8,  win:"自分の手番でゲーム終了", effect:"完全犯罪：手番最後にダイス2個を振り、出目エリアのPL全員に3ダメージ（1回）" },
    { id:"CIT_B1", name:"バイロン",  en:"BYRON",    initial:"B", faction:"シチズン", hp:10, win:"装備カードを5枚以上所持", effect:"念力の懐中時計：2以上の攻撃ダメージ時、代わりに装備を1つ奪う" },
    { id:"CIT_B2", name:"ベンジャミン", en:"BENJAMIN", initial:"B", faction:"シチズン", hp:10, win:"他PLが装備を5つ以上所持", effect:"太鼓持ち：手番最後に同じエリアのPLへ装備を1つ渡せる" },
    { id:"CIT_B3", name:"ブルース",  en:"BRUCE",    initial:"B", faction:"シチズン", hp:10, win:"攻撃でHP12以上のPLを脱落させる、または終了時にマス9にいる", effect:"国士無双：攻撃でHP11以下のPLを脱落させた時、自分の正体を公開" },
    { id:"CIT_C1", name:"クレイグ",  en:"CRAIG",    initial:"C", faction:"シチズン", hp:11, win:"2人脱落後に他PLを攻撃して脱落させる", effect:"死の饗宴：攻撃後、自分に2ダメージ与え再攻撃可" },
    { id:"CIT_C2", name:"キャロル",  en:"CAROL",    initial:"C", faction:"シチズン", hp:11, win:"最初に脱落する、または自分ともう1人だけ生存", effect:"聖痕：手番初めに2ダメージ回復" },
    { id:"CIT_C3", name:"クレア",    en:"CLAIRE",   initial:"C", faction:"シチズン", hp:11, win:"ゲーム終了時、自分のダメージが6～8", effect:"キャスリング：手番初めに自分と他PLのHPを入れ替える（1回）" },
    { id:"CIT_D1", name:"ダニエル",  en:"DANIEL",   initial:"D", faction:"シチズン", hp:13, win:"最初に脱落する、またはシャドウ全員脱落かつ生存", effect:"絶叫：最初に他PLが脱落した時、正体カードを公開" },
    { id:"CIT_D2", name:"デーヴィッド", en:"DAVID",  initial:"D", faction:"シチズン", hp:13, win:"「いにしえの聖杯」「神秘のコンパス」「幸運のブローチ」「銀のロザリオ」のうち3種を所持", effect:"グレイブディガー：手番初めに脱落者の装備カードから任意1枚獲得" },
    { id:"CIT_D3", name:"デボラ",    en:"DEBORAH",  initial:"D", faction:"シチズン", hp:13, win:"5人戦：終了時に最もダメージが多い／6人戦：自分以外のシチズンが勝利", effect:"献身的な愛：手番初めに勝利条件を「脱落する」に変更" },
    { id:"RAI_E1", name:"エミ",      en:"EMI",      initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"テレポート：移動時、出目エリアまたは両隣エリアに移動可" },
    { id:"RAI_E2", name:"エリカ",    en:"ERIKA",    initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"癒しの光：手番終了時に4面ダイスを振り、出目分他PLを回復" },
    { id:"RAI_E3", name:"エマ",      en:"EMMA",     initial:"E", faction:"レイダー", hp:10, win:"シャドウ全員の脱落", effect:"封印の鎖：手番初めに他PL1人の特殊能力をゲーム終了まで封印（1回）" },
    { id:"RAI_F1", name:"フェリックス", en:"FELIX", initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"アストラル・メイス：手番初めに他PL1人へ6面ダイス攻撃（1回）" },
    { id:"RAI_F2", name:"フェリシア", en:"FELICIA", initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"スラム街の天使：手番初めに任意のPLのダメージを7にする（1回）" },
    { id:"RAI_F3", name:"フレディ",  en:"FREDDIE",  initial:"F", faction:"レイダー", hp:12, win:"シャドウ全員の脱落", effect:"ドラゴンアタック：正体公開中のPLへの攻撃成功時 +2ダメージ" },
    { id:"RAI_G1", name:"ゴードン",  en:"GORDON",   initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"絶対無敵バリア：手番終了時に使用。次の自分の手番初めまで全ダメージ無効（1回）" },
    { id:"RAI_G2", name:"ガラハド",  en:"GALAHAD",  initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"魔剣の伝承者：エクスカリバー所持時に攻撃失敗ならダイス振り直し" },
    { id:"RAI_G3", name:"ゴドウィン", en:"GODWIN",  initial:"G", faction:"レイダー", hp:14, win:"シャドウ全員の脱落", effect:"蘇生装置TYPE-G：自分脱落時、既に脱落しているPL1人をダメージ7で復活" },
    { id:"SHA_U1", name:"ウルリッヒ", en:"ULRICH",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員またはシチズン3人の脱落", effect:"推理カードを受け取った時、ウソをついてよい" },
    { id:"SHA_U2", name:"ウラヌス",   en:"URANUS",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員またはシチズン3人の脱落", effect:"メテオストライク：手番初めにエリア4-5,10にいるPL1人へ3ダメージ" },
    { id:"SHA_U3", name:"アルスター", en:"ULSTER",  initial:"U", faction:"シャドウ", hp:11, win:"レイダー全員またはシチズン3人の脱落", effect:"デル・フリス：2回攻撃できる" },
    { id:"SHA_V1", name:"ヴェノム",    en:"VENOM",   initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員またはシチズン3人の脱落", effect:"反駁の猛毒：攻撃者は1ダメージ受けるか装備を渡すか選択" },
    { id:"SHA_V2", name:"ヴァンパイア", en:"VAMPIRE", initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員またはシチズン3人の脱落", effect:"吸血：攻撃成功時、ダメージを2回復" },
    { id:"SHA_V3", name:"ヴェンデッタ", en:"VENDETTA", initial:"V", faction:"シャドウ", hp:13, win:"レイダー全員またはシチズン3人の脱落", effect:"冥府の大鎌：攻撃は4面ダイスのみ使用" },
    { id:"SHA_W1", name:"ワイト",      en:"WIGHT",    initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員またはシチズン3人の脱落", effect:"亡者の王：手番終了後、脱落者の数だけ追加手番（1回）" },
    { id:"SHA_W2", name:"ワルプルギス", en:"WALPURGIS", initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員またはシチズン3人の脱落", effect:"重力の虹：攻撃時、任意のPL1人と位置を交換可" },
    { id:"SHA_W3", name:"ワーウルフ",   en:"WEREWOLF", initial:"W", faction:"シャドウ", hp:14, win:"レイダー全員またはシチズン3人の脱落", effect:"反撃：攻撃を受けた時、そのPLをただちに攻撃" },
  ];

  const ROLE_BY_ID = Object.fromEntries(ROLES.map(r => [r.id, r]));
  const POOL = {
    "シチズン": ROLES.filter(r => r.faction === "シチズン"),
    "レイダー": ROLES.filter(r => r.faction === "レイダー"),
    "シャドウ": ROLES.filter(r => r.faction === "シャドウ"),
  };

  const DEAL_RULE = {
    1: { "レイダー": 1, "シャドウ": 0, "シチズン": 0 },
    2: { "レイダー": 1, "シャドウ": 1, "シチズン": 0 },
    3: { "レイダー": 1, "シャドウ": 1, "シチズン": 1 },
    4: { "レイダー": 2, "シャドウ": 2, "シチズン": 0 },
    5: { "レイダー": 2, "シャドウ": 2, "シチズン": 1 },
    6: { "レイダー": 2, "シャドウ": 2, "シチズン": 2 },
    7: { "レイダー": 2, "シャドウ": 2, "シチズン": 3 },
    8: { "レイダー": 3, "シャドウ": 3, "シチズン": 2 },
    9: { "レイダー": 3, "シャドウ": 3, "シチズン": 3 },
    10:{ "レイダー": 3, "シャドウ": 3, "シチズン": 4 },
  };

  const state = {
    userId: savedUserId,
    userName: null,
    roomCode: null,
    seatedTable: null,
    isHost: false,
    hands: {},
    room: {},
    spectating: false,
    currentRoomId: 0,
  };

  const mainEl = document.getElementById('main');
  const joinBox = document.getElementById('joinBox');
  const inputName = document.getElementById('userName');
  const inputCode = document.getElementById('roomCode');
  const btnJoin = document.getElementById('btnJoin');
  const lobby = document.getElementById('lobby');
  const roomInfo = document.getElementById('roomInfo');
  const roomInfoLobby = document.getElementById('roomInfoLobby');
  const copyLinkBtn = document.getElementById('copyLinkBtn');

  const seatPopBackdrop = document.getElementById('seatPopBackdrop');
  const seatCountBadge = document.getElementById('seatCountBadge');
  const tileGrid = document.getElementById('tileGrid');
  const startWarn = document.getElementById('startWarn');
  const btnSpectate = document.getElementById('btnSpectate');

  const gameArea = document.getElementById('gameArea');

  const myRoleDock = document.getElementById('myRoleDock');
  const myRoleCard = document.getElementById('myRoleCard');

  const kickDialog = document.getElementById('kickDialog');
  const kickMessage = document.getElementById('kickMessage');
  const btnKickYes = document.getElementById('btnKickYes');
  const btnKickNo = document.getElementById('btnKickNo');

  const hostSettingsBtn = document.getElementById('hostSettingsBtn');
  const startPop = document.getElementById('startPop');
  const btnStartPopClose = document.getElementById('btnStartPopClose');
  const btnGameStart = document.getElementById('btnGameStart');
  const btnResetRoom = document.getElementById('btnResetRoom');
  const startBadge = document.getElementById('startBadge');

  const helpBtn = document.getElementById('helpBtn');
  const helpBackdrop = document.getElementById('helpBackdrop');
  const btnHelpClose = document.getElementById('btnHelpClose');
  const helpBody = document.getElementById('helpBody');

  function teamColor(f){
    if (f === "レイダー")  return "#c21d1d";
    if (f === "シャドウ")  return "#0b2a6a";
    if (f === "シチズン") return "#eab308";
    return "#111";
  }
  function cardImageUrl(roleName){
    const safe = encodeURI(String(roleName || "").trim());
    return safe ? `url('${safe}.jpg')` : "none";
  }
  function createIdentityCard(role){
    const team = teamColor(role.faction);
    const en = (role.en || "").trim() || (role.name || "").trim();
    const chars = Array.from(en);
    const ini = (role.initial && String(role.initial)) || (chars[0] || "");
    const enSub = chars.length >= 2 ? chars.slice(1).join("") : "";

    const teamLabel = (role.faction === "レイダー") ? "RAIDER"
                  : (role.faction === "シャドウ") ? "SHADOW"
                  : (role.faction === "シチズン") ? "CITIZEN"
                  : String(role.faction || "");

    const card = document.createElement('div');
    card.className = 'id72';
    card.style.setProperty('--team', team);
    card.style.backgroundImage = cardImageUrl(role.name);

    card.innerHTML = `
      <div class="initial"><span>${ini}</span></div>
      <svg class="team-arc" viewBox="0 0 22 10" aria-hidden="true">
        <path id="teamPath" d="M0,3 Q11,9 22,3" fill="none"></path>
        <text>
          <textPath href="#teamPath" startOffset="50%" text-anchor="middle">${teamLabel}</textPath>
        </text>
      </svg>
      <div class="eng-sub">${enSub}</div>
      <div class="name">${role.name || ""}</div>
      <div class="hp-badge" aria-label="HP ${role.hp ?? ""}">
        <div class="label">HP</div>
        <div class="val">${role.hp ?? ""}</div>
      </div>
      <div class="effect">
        <p class="row"><span class="tag">勝利条件</span>${role.win || ""}</p>
        <p class="row"><span class="tag">${(String(role.effect||"").split("：")[0] || "技名")}</span>${(String(role.effect||"").split("：").slice(1).join("：") || "").trim() || String(role.effect||"")}</p>
      </div>
    `;
    return card;
  }

  function renderHelpList(){
    helpBody.innerHTML = '';
    const sorted = [...ROLES].sort((a,b) => {
      const order = { "レイダー": 0, "シャドウ": 1, "シチズン": 2 };
      const ao = order[a.faction] ?? 9;
      const bo = order[b.faction] ?? 9;
      if (ao !== bo) return ao - bo;
      return a.name.localeCompare(b.name, 'ja');
    });

    sorted.forEach((r) => {
      const row = document.createElement('div');
      row.className = 'role-row';

      const cardWrap = document.createElement('div');
      cardWrap.className = 'role-card-wrap';
      cardWrap.appendChild(createIdentityCard(r));

      const desc = document.createElement('div');
      desc.className = 'role-desc';
      desc.innerHTML = `
        <div class="name">${r.name} <span class="small" style="margin-left:6px;">(${r.faction})</span></div>
        <div class="text">${r.effect}</div>
        <div class="meta">HP：${r.hp}\n勝利条件：${r.win}</div>
      `;

      row.appendChild(cardWrap);
      row.appendChild(desc);
      helpBody.appendChild(row);
    });
  }
  function openHelp(){
    renderHelpList();
    helpBackdrop.classList.remove('hidden');
  }
  function closeHelp(){ helpBackdrop.classList.add('hidden'); }
  helpBtn.addEventListener('click', () => {
    if (joinBox.classList.contains('hidden')) openHelp();
  });
  btnHelpClose.addEventListener('click', closeHelp);
  helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

  const SEAT_COLORS = [
    "#ef4444", "#f97316", "#f59e0b", "#eab308",
    "#22c55e", "#10b981", "#06b6d4", "#3b82f6",
    "#6366f1", "#8b5cf6", "#ec4899", "#f43f5e"
  ];

  const seatKey = (room)=>`bbSeat_${room}_${state.userId}`;

  function isGameStarted(){
    return !!(state.room && (state.room.gameStarted || state.room.startedAt));
  }
  function isSeated(){ return state.seatedTable != null; }

  function showSeatPop(){ seatPopBackdrop.classList.remove('hidden'); }
  function hideSeatPop(){
    if (!isGameStarted()) return;
    seatPopBackdrop.classList.add('hidden');
  }
  function updateSeatBoardVisibility(){
    const started = isGameStarted();
    const seated = isSeated();
    let shouldShow = false;

    if (!state.roomCode) shouldShow = false;
    else if (!started) shouldShow = !state.spectating;
    else shouldShow = (!seated) && (!state.spectating);

    if (shouldShow) showSeatPop(); else hideSeatPop();
  }

  btnSpectate.addEventListener('click', () => {
    state.spectating = true;
    if (isGameStarted()) hideSeatPop();
  });

  function generateRoomCode(length = 6){
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
    return code;
  }

  function refreshRoomLabels(){
    if (!state.roomCode || !state.userName) return;
    const label = state.isHost ? '（ホスト）' : '';
    const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
    roomInfo.textContent = infoText;
    roomInfoLobby.textContent = infoText;
  }

  function updateHostUI(){
    refreshRoomLabels();
    if (state.isHost){
      hostSettingsBtn.classList.add('visible');
    } else {
      hostSettingsBtn.classList.remove('visible');
      startPop.classList.add('hidden');
    }
    helpBtn.classList.add('visible');
  }

  function subscribeRoom(){
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    onValue(roomRef, snap => {
      state.room = snap.val() || {};
      renderSeatTiles();
      refreshStartBadge();
      renderHands();
      updateSeatBoardVisibility();
      renderEquipmentDock();
      renderHpBoard();
      renderPositionLine();
    });
  }

  function subscribeHostState(){
    const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
    onValue(hostRef, snap => {
      const hostId = snap.val();
      state.isHost = (hostId === state.userId);
      updateHostUI();
    });
  }

  function subscribeHands(){
    const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
    onValue(handsRef, snap => {
      state.hands = snap.val() || {};
      renderHands();
    });
  }


  function subscribeGreenInbox(){
    const inboxRef = ref(db, `rooms/${state.roomCode}/greenInbox/${state.userId}`);
    onValue(inboxRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!greenInboxInitialized){
        greenInboxInitialized = true;
        greenInboxSeenAt = at || 0;
        return;
      }

      if (!msg || !msg.card || !at) return;
      if (at <= greenInboxSeenAt) return;
      greenInboxSeenAt = at;
      openZoomFromDeckCard(msg.card, "green", { closeOnBackdrop:false, showCloseButton:false });
      openGreenAnswerDock(msg);
    });
  }

  function subscribeGreenResponses(){
    const resRef = ref(db, `rooms/${state.roomCode}/greenResponses/${state.userId}`);
    onValue(resRef, snap => {
      const msg = snap.val() || null;
      const at = Number(msg?.at || 0);

      if (!greenReplyInitialized){
        greenReplyInitialized = true;
        greenReplySeenAt = at || 0;
        return;
      }

      if (!msg || !at) return;
      if (at <= greenReplySeenAt) return;
      if (!pendingGreenRequestId || safeText(msg.requestId || "") !== pendingGreenRequestId) return;
      greenReplySeenAt = at;
      pendingGreenRequestId = "";
      greenReplyBubble = {
        uid: safeText(msg.to || ""),
        text: safeText(msg.answerLabel || "")
      };
      setGreenDockMeta({ title:"回答が届きました", subtitle:safeText(msg.answerLabel || "") });
      zoomCloseBtn.classList.remove("hidden");
      greenZoomLocked = false;
      renderPositionLine();
    });
  }

  function subscribePlayers(){
    const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
    onValue(tablesRef, snap => {
      const data = snap.val() || {};
      const players = Object.entries(data)
        .map(([seatIndex, t]) => (t && t.playerId ? {
          id: t.playerId,
          name: t.playerName || '名無し',
          seatIndex: Number(seatIndex),
          color: t.color || null
        } : null))
        .filter(Boolean)
        .sort((a,b) => a.seatIndex - b.seatIndex);

      latestPlayers = players;

      const mySeat = players.find(p => p.id === state.userId);
      if (mySeat) {
        state.seatedTable = mySeat.seatIndex;
        sessionStorage.setItem(seatKey(state.roomCode), String(mySeat.seatIndex));
      } else {
        state.seatedTable = null;
        sessionStorage.removeItem(seatKey(state.roomCode));
      }

      renderSeatTiles();
      refreshStartBadge();
      updateSeatBoardVisibility();
      renderEquipmentDock();
      renderHpBoard();
      renderPositionLine();
    });
  }

  function effectiveSeatCount(){
    const mp = Number(state.room.maxPlayers || 0);
    return (mp >= 2) ? mp : SEAT_COLORS.length;
  }
  function occupiedCount(){ return latestPlayers.length; }

  let pendingSeatIndexToSteal = null;
  let pendingSeatPlayerIdToSteal = null;
  let pendingMode = "prestart";

  function renderSeatTiles(){
    if (!state.roomCode) return;

    const started = isGameStarted();
    const N = effectiveSeatCount();
    seatCountBadge.textContent = `${occupiedCount()} / ${N}`;

    tileGrid.innerHTML = '';

    for(let i=1;i<=N;i++){
      const color = SEAT_COLORS[i-1] || "#ddd";
      const seatIndex = i;

      const tile = document.createElement('button');
      tile.type = 'button';
      tile.className = 'seat-tile empty';
      tile.style.background = color;
      tile.setAttribute('aria-label', `席 ${seatIndex}`);

      const taken = latestPlayers.find(p => p.seatIndex === seatIndex);
      if (taken){
        tile.classList.remove('empty');
        tile.classList.add('taken');
        const initial = document.createElement('div');
        initial.className = 'seat-initial';
        initial.textContent = firstChar(taken.name);
        tile.appendChild(initial);
      }

      const num = document.createElement('div');
      num.className = 'seat-num';
      num.textContent = seatIndex;
      tile.appendChild(num);

      if (state.seatedTable === seatIndex) tile.classList.add('me');

      tile.addEventListener('click', async () => {
        if (!state.roomCode) return;

        const startedNow = isGameStarted();

        if (startedNow){
          if (isSeated()) return;
          if (!taken){
            alert("ゲーム開始後は空席に座れません。席を奪取してください。");
            return;
          }
          pendingMode = "started";
          pendingSeatIndexToSteal = seatIndex;
          pendingSeatPlayerIdToSteal = taken.id;

          kickMessage.textContent = `「${taken.name}」を追い出しますか？`;
          kickDialog.classList.remove('hidden');
          return;
        }

        if (state.seatedTable !== null){
          if (seatIndex === state.seatedTable) return;
          if (taken) return;
          await moveSeatToEmpty(seatIndex);
          return;
        }

        if (!taken){
          await sitToSeat(seatIndex);
          state.spectating = true;
          return;
        }

        pendingMode = "prestart";
        pendingSeatIndexToSteal = seatIndex;
        pendingSeatPlayerIdToSteal = taken.id;

        kickMessage.textContent = `「${taken.name}」を追い出して、この色の席を奪取しますか？`;
        kickDialog.classList.remove('hidden');
      });

      tileGrid.appendChild(tile);
    }

    startWarn.textContent = started
      ? "※ゲーム開始済み（再入室には座席をクリックして追い出してください。）"
      : "※ホストが「スタート」を押すと配布されます";
  }

  async function sitToSeat(seatIndex){
    const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
    await set(tRef, {
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[seatIndex-1] || null,
      seatedAt: Date.now()
    });
    state.seatedTable = seatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(seatIndex));
  }

  async function moveSeatToEmpty(newSeatIndex){
    if (!state.roomCode) return;
    const oldSeatIndex = state.seatedTable;
    if (oldSeatIndex == null) return;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap = await get(roomRef);
    const roomData = snap.val() || {};
    if (roomData.gameStarted || roomData.startedAt) return;

    const tables = roomData.tables || {};
    const oldSeat = tables[String(oldSeatIndex)];
    const newSeat = tables[String(newSeatIndex)];

    if (!oldSeat || oldSeat.playerId !== state.userId) return;
    if (newSeat && newSeat.playerId) return;

    const updates = {};
    updates[`tables/${oldSeatIndex}`] = null;
    updates[`tables/${newSeatIndex}`] = {
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[newSeatIndex-1] || null,
      seatedAt: Date.now(),
      movedFrom: oldSeatIndex,
      movedAt: Date.now()
    };

    await update(roomRef, updates);

    state.seatedTable = newSeatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(newSeatIndex));
  }

  async function stealSeatPrestart(seatIndex, previousPlayerId){
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    if (roomData.gameStarted || roomData.startedAt) return;

    await sitToSeat(seatIndex);

    const updates = {};
    const markers = roomData.markers || {};
    const prevMarker = previousPlayerId ? markers[previousPlayerId] : null;
    if (prevMarker){
      updates[`markers/${state.userId}`] = { ...prevMarker, updatedAt: Date.now(), inheritedFrom: previousPlayerId };
      updates[`markers/${previousPlayerId}`] = null;
    }

    if (Object.keys(updates).length){
      await update(roomRef, updates);
    }

    if (roomData.hostId && previousPlayerId && roomData.hostId === previousPlayerId) {
      await update(roomRef, { hostId: state.userId });
    }

    state.spectating = true;
  }

  async function stealSeatStarted(seatIndex, previousPlayerId){
    if (!state.roomCode) return;
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const snap = await get(roomRef);
    const roomData = snap.val() || {};

    if (!(roomData.gameStarted || roomData.startedAt)) return;

    const tables = roomData.tables || {};
    const alreadySeated = Object.values(tables).some(t => t && t.playerId === state.userId);
    if (alreadySeated) return;

    const cur = tables[String(seatIndex)];
    if (!cur || cur.playerId !== previousPlayerId) return;

    const updates = {};
    updates[`tables/${seatIndex}`] = {
      playerId: state.userId,
      playerName: state.userName || '名無し',
      color: SEAT_COLORS[seatIndex-1] || null,
      seatedAt: Date.now(),
      stolenFrom: previousPlayerId,
      stolenAt: Date.now()
    };

    const hands = roomData.hands || {};
    const prevHand = hands[previousPlayerId] || null;
    if (prevHand){
      updates[`hands/${state.userId}`] = { ...prevHand, inheritedAt: Date.now(), inheritedFrom: previousPlayerId };
      updates[`hands/${previousPlayerId}`] = null;
    }

    const markers = roomData.markers || {};
    const prevMarker = markers[previousPlayerId] || null;
    if (prevMarker){
      updates[`markers/${state.userId}`] = { ...prevMarker, updatedAt: Date.now(), inheritedFrom: previousPlayerId };
      updates[`markers/${previousPlayerId}`] = null;
    }

    await update(roomRef, updates);

    state.seatedTable = seatIndex;
    sessionStorage.setItem(seatKey(state.roomCode), String(seatIndex));

    state.spectating = true;
    hideSeatPop();
  }

  kickDialog.addEventListener('click', (e) => { if (e.target === kickDialog) closeKickDialog(); });
  btnKickNo.addEventListener('click', (e) => { e.stopPropagation(); closeKickDialog(); });
  btnKickYes.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (pendingSeatIndexToSteal == null || !state.roomCode) { closeKickDialog(); return; }

    if (pendingMode === "started"){
      await stealSeatStarted(pendingSeatIndexToSteal, pendingSeatPlayerIdToSteal);
    } else {
      await stealSeatPrestart(pendingSeatIndexToSteal, pendingSeatPlayerIdToSteal);
    }
    closeKickDialog();
  });
  function closeKickDialog(){
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
    pendingMode = "prestart";
  }

  /* =========================================================
     ★④右下：正体カードは「裏面(browncard.jpg)」で表示し、
        クリックで「オモテ(拡大)」を表示
     ========================================================= */
  function renderMyRoleCard(role){
    myRoleCard.innerHTML = '';
    if (!role){
      myRoleDock.classList.remove('visible');
      renderEquipmentDock();
      return;
    }

    const back = document.createElement('div');
    back.className = 'role-back';
    back.style.backgroundImage = `url('browncard.jpg')`;
    back.title = "クリックで拡大表示";

    back.addEventListener('click', (e) => {
      e.stopPropagation();
      openZoomFromRole(role); // 拡大はオモテ（id72）
    });

    myRoleCard.appendChild(back);
    myRoleDock.classList.add('visible');
    renderEquipmentDock();
  }

  function renderHands(){
    const started = isGameStarted();
    updateSeatBoardVisibility();

    const my = state.hands[state.userId];
    if (my && my.roleId && ROLE_BY_ID[my.roleId]){
      renderMyRoleCard(ROLE_BY_ID[my.roleId]);
    } else {
      renderMyRoleCard(null);
    }

    startWarn.textContent = started
      ? "※ゲーム開始済み（未着席は席を奪取して参加できます）"
      : "※ホストが「スタート」を押すと配布されます";
  }

  function pickUnique(pool, k){
    const s = shuffle(pool);
    return s.slice(0, Math.max(0, k));
  }
  function buildDeckByPlayerCount(n){
    const rule = DEAL_RULE[n];
    if (!rule) throw new Error(`対応外の人数: ${n}`);

    const deck = [];
    deck.push(...pickUnique(POOL["レイダー"], rule["レイダー"]));
    deck.push(...pickUnique(POOL["シャドウ"], rule["シャドウ"]));
    deck.push(...pickUnique(POOL["シチズン"], rule["シチズン"]));

    if (deck.length !== n){
      throw new Error(`デッキ枚数が一致しません（n=${n}, deck=${deck.length}）`);
    }
    return shuffle(deck);
  }

  async function dealIdentityCards(){
    if (!state.roomCode) return;

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};

    if (roomData.gameStarted || roomData.startedAt) return;

    const tables = roomData.tables || {};
    const players = Object.entries(tables)
      .map(([seatIndex, t]) => (t && t.playerId ? { id: t.playerId, seatIndex: Number(seatIndex) } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    const n = players.length;
    if (n < 1 || n > 10) return;

    const deck = buildDeckByPlayerCount(n);

    const hands = {};
    for (let i=0;i<n;i++){
      hands[players[i].id] = { roleId: deck[i].id, dealtAt: Date.now() };
    }

    const positionOrder = shuffle(players.map(p => p.id));
    const startPlayerId = positionOrder[Math.floor(Math.random()*positionOrder.length)] || null;

    await update(roomRef, {
      hands,
      gameStarted: true,
      startedAt: Date.now(),
      playerCountAtStart: n,
      positionOrder,
      startPlayerId,
    });

    await initDamageAllToZero(players);
  }

  function refreshStartBadge(){
    const n = latestPlayers.length;
    startBadge.textContent = `参加人数：${n}`;
    if (state.isHost){
      const rule = DEAL_RULE[n];
      if (rule){
        startBadge.textContent = `参加人数：${n}（R${rule["レイダー"]}/S${rule["シャドウ"]}/C${rule["シチズン"]}）`;
      }
    }
  }

  hostSettingsBtn.addEventListener('click', () => {
    if (!state.isHost) return;
    startPop.classList.toggle('hidden');
  });
  btnStartPopClose.addEventListener('click', () => startPop.classList.add('hidden'));
  btnGameStart.addEventListener('click', async () => {
    if (!state.isHost) return;
    await dealIdentityCards();
    startPop.classList.add('hidden');
  });

  btnResetRoom.addEventListener('click', async () => {
    if (!state.isHost || !state.roomCode) return;

    const base = `rooms/${state.roomCode}`;
    await Promise.all([
      remove(ref(db, `${base}/tables`)),
      remove(ref(db, `${base}/hands`)),
      remove(ref(db, `${base}/maxPlayers`)),
      remove(ref(db, `${base}/gameStarted`)),
      remove(ref(db, `${base}/startedAt`)),
      remove(ref(db, `${base}/playerCountAtStart`)),
      remove(ref(db, `${base}/markers`)),
      remove(ref(db, `${base}/deckState`)),
      remove(ref(db, `${base}/equipment`)),
      remove(ref(db, `${base}/damage`)),
      remove(ref(db, `${base}/positionOrder`)),
      remove(ref(db, `${base}/startPlayerId`)),
      remove(ref(db, `${base}/greenInbox`)),
      remove(ref(db, `${base}/greenResponses`)),
    ]);

    deckCache = null;
    equipCache = {};
    damageCache = {};

    state.seatedTable = null;
    state.spectating = false;
    sessionStorage.removeItem(seatKey(state.roomCode));
    startPop.classList.add('hidden');

    renderSeatTiles();
    renderHands();
    updateSeatBoardVisibility();

    renderDeckRowFromRoom();
    renderEquipmentDock();
    buildHpCells();
    renderHpBoard();

    updateEquipDockTop();
  });

  const urlParams = new URLSearchParams(window.location.search);
  const roomFromUrl = urlParams.get('room');
  if(roomFromUrl) inputCode.value = roomFromUrl;

  btnJoin.addEventListener('click', async () => {
    state.userName = (inputName.value || '名無し').slice(0,4);
    state.roomCode = inputCode.value.trim() || generateRoomCode();
    state.spectating = false;
    state.currentRoomId = 0;

    await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
      name: state.userName,
      joinedAt: Date.now()
    });

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val();

    if(!roomData || !roomData.hostId){
      await update(roomRef, { hostId: state.userId });
      state.isHost = true;
    } else {
      state.isHost = (roomData.hostId === state.userId);
    }

    updateHostUI();

    mainEl.classList.remove('prejoin');
    mainEl.classList.add('joined');

    joinBox.classList.add('hidden');
    lobby.classList.remove('hidden');
    lobby.classList.add('entered');

    gameArea.classList.remove('hidden');

    renderRoomShape();
    buildHpCells();

    await ensureRoomDeckState();
    subscribeDeckState();
    renderDeckRowFromRoom();

    const cachedSeat = sessionStorage.getItem(seatKey(state.roomCode));
    if (cachedSeat) state.seatedTable = Number(cachedSeat) || null;

    subscribeRoom();
    subscribeHostState();
    subscribePlayers();
    subscribeHands();
    subscribeGreenInbox();
    subscribeGreenResponses();
    subscribeMarkers();
    subscribeEquipment();
    subscribeDamage();

    renderSeatTiles();
    refreshStartBadge();
    renderHands();
    updateSeatBoardVisibility();

    updateCardInteractivity();
    renderEquipmentDock();
    renderHpBoard();

    requestAnimationFrame(() => {
      updateEquipDockTop();
      applyEquipCols();
    });
  });

  copyLinkBtn.addEventListener('click', async () => {
    const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
    try {
      await navigator.clipboard.writeText(url);
      copyLinkBtn.classList.add('copied');
      copyLinkBtn.textContent = 'COPIED';
      inputCode.value = state.roomCode;
      setTimeout(()=>{
        copyLinkBtn.classList.remove('copied');
        copyLinkBtn.textContent='COPY';
      },1500);
    } catch {
      prompt('コピーできません。手動でコピーしてください', url);
    }
  });
</script>

</body>
</html>
