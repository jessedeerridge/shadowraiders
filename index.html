<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>オンラインルーム（チャット無し＋図形②＋山札＋ダイス）</title>
<style>
  :root { --gap:10px; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
  header{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid #eee}
  h1{margin:0;font-size:18px}
  .small{font-size:12px;opacity:.85}
  .right{margin-left:auto}
  .code-link{ text-decoration: underline; cursor: pointer; }
  main{padding:14px;display:grid;gap:16px;max-width:1100px;margin:0 auto}

  /* レイアウト：左=SVGキャンバス / 右=デッキ欄 */
  .stage{display:flex;gap:16px;align-items:flex-start}
  .canvas-wrap{flex:1;min-width:420px}
  .sidebar{width:120px;display:flex;flex-direction:column;gap:12px}

  /* 図形（②） */
  html,body{height:100%}
  #art{display:block;margin:auto;max-width:96vmin;height:auto}
  .shape{fill:#fff;stroke:#111;stroke-width:0.8;stroke-linejoin:round;stroke-linecap:round}

  /* 左長方形内のユーザーアイコン（維持） */
  .usericon rect{fill:#fff;stroke:#111;stroke-width:0.8;rx:6;ry:6}
  .usericon text{font-size:12px;font-weight:700;dominant-baseline:middle;text-anchor:middle}
  .usericon{cursor:grab}
  .usericon.dragging{cursor:grabbing;opacity:.85}

  /* 右側の席アイコン（部屋クリックで生成） */
  .seaticon rect{fill:#fff;stroke:#111;stroke-width:0.8;rx:6;ry:6}
  .seaticon text{font-size:12px;font-weight:700;dominant-baseline:middle;text-anchor:middle}

  /* 7部屋のヒット領域（通常は透明、クリック時だけフラッシュ） */
  .roomhit{fill:transparent;stroke:none;pointer-events:auto}
  .roomhit.flash{fill:#eee;transition:fill 60ms}

  /* 山札UI（右サイド） */
  .deck{display:flex;flex-direction:column;align-items:center;gap:6px}
  .card-box{
    width:70px;height:100px;border:1px solid #111;border-radius:10px;display:flex;
    align-items:center;justify-content:center;font-weight:700;color:#111;user-select:none;
  }
  .deck-back{cursor:pointer}
  .deck-back.green{background:#c7f5c1;}
  .deck-back.white{background:#ffffff;}
  .deck-back.black{background:#cfcfcf;} /* 真っ黒にするなら #000;color:#fff; */
  .deck-face{background:#fff;font-size:20px}
  .deck-label{font-size:12px;opacity:.8}
  .deck.disabled .deck-back{opacity:.4;cursor:not-allowed}

  /* ダイス（SVG内で描画するが見た目用の共通色） */
  .dice-box{fill:#fff;stroke:#111;stroke-width:0.8;rx:8;ry:8}
  .dice-text{font-size:16px;font-weight:800;text-anchor:middle;dominant-baseline:middle}
  .dice-label{font-size:10px;text-anchor:middle;dominant-baseline:middle;opacity:.8}
</style>
</head>
<body>
<header>
  <h1>オンラインルーム</h1>
  <div class="small right">
    ルームコード：<span id="roomCode" class="code-link">—</span>　
    <span id="copyHint" class="small"></span>
  </div>
  <div class="small">あなた：<span id="selfNameHdr">—</span>　|　<span id="myRoomBadge">部屋：未選択</span></div>
</header>

<main>
  <!-- 入室 -->
  <section id="joinPanel" class="join-box">
    <input id="nameInput" placeholder="名前（1文字）" maxlength="1" inputmode="text" />
    <input id="codeInput" placeholder="ルームコード（例: 1234）" maxlength="12" inputmode="numeric" />
    <button id="btnJoin" class="btn">入室</button>
  </section>

  <!-- ステージ：左=図形 / 右=デッキ -->
  <section id="roomPanel" class="hidden">
    <div class="stage">
      <div class="canvas-wrap">
        <svg id="art" viewBox="-220 -230 620 520" aria-label="左に長方形・右に星形＋ダイス"></svg>
      </div>

      <!-- 右サイド：山札3種（緑・白・黒） -->
      <aside id="sidebar" class="sidebar" aria-label="山札（右に配置）">
        <!-- JSで deck 要素を生成 -->
      </aside>
    </div>
  </section>
</main>

<!-- Firebase（v9 モジュール） -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import {
    getDatabase, ref, set, onValue, onDisconnect, remove, get, update
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  /* Firebase 設定 */
  const firebaseConfig = {
    apiKey: "AIzaSyASUJcPyybcD9q77XDatI5bCzZxDvsBH_o",
    authDomain: "shadowraiders-a2dbc.firebaseapp.com",
    projectId: "shadowraiders-a2dbc",
    storageBucket: "shadowraiders-a2dbc.firebasestorage.app",
    messagingSenderId: "577276689873",
    appId: "1:577276689873:web:9a13faf90c3d6a791e34f0",
    measurementId: "G-PKNEPDBVSS"
  };

  // --- 初期化 ---
  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // --- DOM ---
  const joinPanel     = document.getElementById('joinPanel');
  const nameInput     = document.getElementById('nameInput');
  const codeInput     = document.getElementById('codeInput');
  const btnJoin       = document.getElementById('btnJoin');
  const roomPanel     = document.getElementById('roomPanel');
  const art           = document.getElementById('art');
  const sidebarEl     = document.getElementById('sidebar');

  const roomCodeEl    = document.getElementById('roomCode');
  const copyHintEl    = document.getElementById('copyHint');
  const selfNameHdrEl = document.getElementById('selfNameHdr');
  const myRoomBadge   = document.getElementById('myRoomBadge');

  // --- 状態 ---
  const state = {
    uid: crypto.randomUUID(),
    name: "",
    code: "",
    joined: false,
    unsub: [],
    rectBBox: null,       // 左長方形の座標
    draggingUid: null,
    isPointerDown: false,
    dragOffset: {x:0,y:0},
    myRoomNo: null        // 自分がいる部屋番号（1..7）
  };

  // --- ユーティリティ ---
  function randomLetter(){ return String.fromCharCode(65 + Math.floor(Math.random()*26)); }
  function random4(){ return String(Math.floor(Math.random()*10000)).padStart(4, '0'); }
  const NAME_RE = /^[A-Za-z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]$/;
  function normalizeName(raw){
    const t = (raw || "").trim(); if (!t) return randomLetter();
    const c = t[0]; return NAME_RE.test(c) ? c : randomLetter();
  }
  function show(el, yes){ el.classList.toggle('hidden', !yes); }
  function buildRoomLink(code){
    const url = new URL(location.href);
    url.searchParams.set('room', code);
    return url.toString();
  }

  // ===== 図形②＋ダイス =====
  function drawFigure2(){
    const svg = art;
    if (!svg) return;
    svg.innerHTML = '';
    const rt3 = Math.sqrt(3);

    // ---- パラメータ ----
    const s0 = 48;   // 中央六角形の一辺
    const s1 = 82;   // 中間六角形の一辺（五角形の根元）
    const rectScale = 0.40;
    const gap = 20;

    function hexFlat(cx, cy, s){
      const h = (rt3/2)*s;
      return [
        [cx+s,   cy],
        [cx+s/2, cy+h],
        [cx-s/2, cy+h],
        [cx-s,   cy],
        [cx-s/2, cy-h],
        [cx+s/2, cy-h],
      ];
    }
    const add=(a,b)=>[a[0]+b[0],a[1]+b[1]];
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
    const mul=(a,k)=>[a[0]*k,a[1]*k];
    const norm=(v)=>{ const L=Math.hypot(v[0],v[1])||1; return [v[0]/L,v[1]/L]; };
    function intersectRayRay(p,u,q,v){
      const A = [[u[0], -v[0]], [u[1], -v[1]]];
      const b = sub(q,p);
      const det = A[0][0]*A[1][1] - A[0][1]*A[1][0];
      const t = ( b[0]*A[1][1] - b[1]*A[0][1]) / det;
      return add(p, mul(u, t));
    }

    // 星本体（表示用）
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('id','star');
    svg.appendChild(g);

    function poly(pts, cls='shape', parent=g){
      const el = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      el.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
      el.setAttribute('class', cls);
      parent.appendChild(el);
      return el;
    }

    const H0 = hexFlat(0,0,s0);
    const H1 = hexFlat(0,0,s1);

    // 中央六角形（表示）
    poly(H0);

    // 外周五角形（表示）
    const pentPoints = [];
    for(let i=0;i<6;i++){
      const ip=(i+5)%6, inx=(i+1)%6, inx2=(i+2)%6;
      const a0=H0[i], b0=H0[inx], a1=H1[i], b1=H1[inx];
      const dirFromA1=norm(sub(H1[i],H1[ip]));
      const dirFromB1=norm(sub(H1[inx2],H1[inx]));
      const tip=intersectRayRay(a1,dirFromA1,b1,dirFromB1);
      const p = [a0,b0,b1,tip,a1];
      pentPoints.push(p);
      poly(p);
    }

    // 左の長方形（クリック可・範囲内ドラッグ用）
    const starBox = g.getBBox();
    const rectH = starBox.height;
    const rectW = rectH * rectScale;
    const rectX = starBox.x - gap - rectW;
    const rectY = starBox.y;

    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', rectX);
    rect.setAttribute('y', rectY);
    rect.setAttribute('width', rectW);
    rect.setAttribute('height', rectH);
    rect.setAttribute('class','shape');
    rect.setAttribute('id','leftRect');
    svg.appendChild(rect);

    // 左長方形内アイコン用レイヤ
    const iconsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    iconsLayer.setAttribute('id','icons');
    svg.appendChild(iconsLayer);

    // === 7部屋ヒット層 ===
    const roomsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    roomsLayer.setAttribute('id','rooms');
    svg.appendChild(roomsLayer);

    // 中央六角形（room 1）
    const hitHex = poly(H0, 'roomhit', roomsLayer);
    hitHex.dataset.room = '1';
    hitHex.addEventListener('click', onRoomClick);

    // 外周五角形（room 2〜7）
    for(let i=0;i<6;i++){
      const hitPent = poly(pentPoints[i], 'roomhit', roomsLayer);
      hitPent.dataset.room = String(2 + i); // 2..7
      hitPent.addEventListener('click', onRoomClick);
    }

    // 席アイコン用レイヤ
    const seatsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    seatsLayer.setAttribute('id','seats');
    svg.appendChild(seatsLayer);

    // ===== ダイス（左長方形の「下」に配置） =====
    const diceLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    diceLayer.setAttribute('id','diceLayer');
    svg.appendChild(diceLayer);

    const diceGap = 10;
    const baseY  = rectY + rectH + 18;  // 長方形の少し下
    const dW = 60, dH = 44;

    function makeDice(id, x, y, label){
      const gD = document.createElementNS('http://www.w3.org/2000/svg','g');
      gD.setAttribute('data-dice', id);

      const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
      box.setAttribute('x', x); box.setAttribute('y', y);
      box.setAttribute('width', dW); box.setAttribute('height', dH);
      box.setAttribute('class','dice-box');
      gD.appendChild(box);

      const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
      txt.setAttribute('x', x + dW/2); txt.setAttribute('y', y + dH/2);
      txt.setAttribute('class','dice-text'); txt.textContent = '-';
      txt.setAttribute('id', id + '_v');
      gD.appendChild(txt);

      const cap = document.createElementNS('http://www.w3.org/2000/svg','text');
      cap.setAttribute('x', x + dW/2); cap.setAttribute('y', y + dH + 10);
      cap.setAttribute('class','dice-label'); cap.textContent = label;
      gD.appendChild(cap);

      gD.style.cursor = 'pointer';
      gD.addEventListener('click', ()=> rollDice(id));

      diceLayer.appendChild(gD);
    }

    makeDice('d6', rectX,                 baseY, 'D6');
    makeDice('d4', rectX + dW + diceGap,  baseY, 'D4');

    // viewBox 調整（ダイス分も含めるため余白広め）
    (function fit(){
      const pad=18, box=svg.getBBox();
      svg.setAttribute('viewBox',[box.x-pad, box.y-pad, box.width+pad*2, box.height+pad*2].join(' '));
    })();

    // 左長方形の矩形を保持（ドラッグ範囲クランプ用）
    state.rectBBox = { x: rectX, y: rectY, w: rectW, h: rectH };

    // 左長方形クリックで自分アイコンを1回だけ作成
    rect.addEventListener('click', onRectClickOnce);
  }

  // ===== 山札 =====
  const DECKS_DEF = {
    green: { label:'緑', colorClass:'green', cards:['あ','か','た','ら','わ','は'] },
    white: { label:'白', colorClass:'white', cards:['し','き','に','み','ぎ','ち'] },
    black: { label:'黒', colorClass:'black', cards:['ろ','も','こ','ど','そ','ぼ'] },
  };

  // 自分の部屋から使用可否を判定
  function canUseDeck(deckId, roomNo){
    if (!roomNo) return false;
    if (deckId==='green') return (roomNo===6 || roomNo===7);
    if (deckId==='white') return (roomNo===7 || roomNo===1);
    if (deckId==='black') return (roomNo===7 || roomNo===2);
    return false;
  }

  // 右サイドのデッキUI生成＆購読
  function setupDecks(){
    sidebarEl.innerHTML = '';
    ['green','white','black'].forEach(deckId=>{
      const def = DECKS_DEF[deckId];

      const wrap = document.createElement('div');
      wrap.className = 'deck';
      wrap.dataset.deck = deckId;

      const back = document.createElement('div');
      back.className = `card-box deck-back ${def.colorClass}`;
      back.textContent = '裏';
      back.title = `${def.label}デッキをめくる`;
      back.addEventListener('click', ()=> {
        if (!canUseDeck(deckId, state.myRoomNo)) return;
        advanceDeck(deckId);
      });

      const face = document.createElement('div');
      face.className = 'card-box deck-face';
      face.dataset.role = 'face';
      face.textContent = ''; // 初期は空

      const label = document.createElement('div');
      label.className = 'deck-label';
      label.textContent = `${def.label}デッキ`;

      wrap.appendChild(back);
      wrap.appendChild(face);
      wrap.appendChild(label);
      sidebarEl.appendChild(wrap);
    });

    // DB同期購読（インデックス→表面に反映）
    const decksRef = ref(db, `rooms/${state.code}/decks`);
    const off = onValue(decksRef, (snap)=>{
      const v = snap.val() || {};
      ['green','white','black'].forEach(id=>{
        const idx = (v[id]?.idx ?? -1);
        const faceEl = sidebarEl.querySelector(`.deck[data-deck="${id}"] .deck-face`);
        const card = (idx >= 0) ? DECKS_DEF[id].cards[idx % DECKS_DEF[id].cards.length] : '';
        if (faceEl) faceEl.textContent = card;
      });
      // 使用可否の見た目更新
      refreshDeckLocks();
    });
    state.unsub.push(off);

    refreshDeckLocks();
  }

  function refreshDeckLocks(){
    ['green','white','black'].forEach(id=>{
      const wrap = sidebarEl.querySelector(`.deck[data-deck="${id}"]`);
      if (!wrap) return;
      const allow = canUseDeck(id, state.myRoomNo);
      wrap.classList.toggle('disabled', !allow);
    });
  }

  // デッキを1枚進める（ルーム同期）
  async function advanceDeck(deckId){
    const def = DECKS_DEF[deckId];
    const deckPath = ref(db, `rooms/${state.code}/decks/${deckId}`);
    const snap = await get(deckPath);
    const curIdx = snap.exists() && typeof snap.val().idx === 'number' ? snap.val().idx : -1;
    const nextIdx = (curIdx + 1) % def.cards.length;
    await set(deckPath, { idx: nextIdx, at: Date.now(), by: state.uid });
  }

  // ===== ダイス（クリックで振る→DB同期） =====
  async function rollDice(kind){
    const sides = (kind==='d6'?6:4);
    const v = 1 + Math.floor(Math.random()*sides);
    await set(ref(db, `rooms/${state.code}/dice/${kind}`), { value:v, at:Date.now(), by: state.uid });
    // onValueで全員に反映
  }

  // ダイス購読→SVG表示更新
  function setupDiceSubscribe(){
    const dRef = ref(db, `rooms/${state.code}/dice`);
    const off = onValue(dRef, (snap)=>{
      const v = snap.val() || {};
      const v6 = document.getElementById('d6_v');
      const v4 = document.getElementById('d4_v');
      if (v6 && v.d6?.value != null) v6.textContent = String(v.d6.value);
      if (v4 && v.d4?.value != null) v4.textContent = String(v.d4.value);
    });
    state.unsub.push(off);
  }

  // ===== 部屋クリック：席アイコン（最大1つ）＋部屋番号バッジ更新 =====
  async function onRoomClick(ev){
    const svg = art;
    const el = ev.currentTarget;
    const roomNo = Number(el.dataset.room || 0);

    // フラッシュ
    el.classList.add('flash');
    setTimeout(()=> el.classList.remove('flash'), 140);

    // クリック座標（SVG座標）
    const p = toSvgCoords(svg, ev.clientX, ev.clientY);

    // 自分の席を DB に保存（同じ uid のデータを上書き → 常に最大1つ）
    await set(ref(db, `rooms/${state.code}/seats/${state.uid}`), {
      name: state.name, room: roomNo, x: p.x - 14, y: p.y - 10, at: Date.now()
    });

    // ローカル表示も即更新
    myRoomBadge.textContent = `部屋：${roomNo}`;
    state.myRoomNo = roomNo;
    refreshDeckLocks();
  }

  // SVG座標に変換
  function toSvgCoords(svg, clientX, clientY){
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const m = svg.getScreenCTM(); if (!m) return {x:0,y:0};
    const sp = pt.matrixTransform(m.inverse());
    return {x: sp.x, y: sp.y};
  }

  // 右側の席アイコン：生成＆更新
  function renderOrUpdateSeat(uid, data){
    const layer = document.getElementById('seats');
    if (!layer || !data) return;

    let g = layer.querySelector(`g[data-uid="${uid}"]`);
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','seaticon');
      g.setAttribute('data-uid', uid);

      const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
      box.setAttribute('width', 28);
      box.setAttribute('height', 20);
      g.appendChild(box);

      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', 14);
      label.setAttribute('y', 10);
      label.textContent = (data.name || '?');
      g.appendChild(label);

      layer.appendChild(g);
    }
    const text = g.querySelector('text');
    if (text && text.textContent !== (data.name || '?')) text.textContent = (data.name || '?');
    g.setAttribute('transform', `translate(${data.x},${data.y})`);
  }

  // ===== 左長方形（維持） =====
  function clampToRect(x, y){
    const r = state.rectBBox;
    const w = 28, h = 20;
    const minX = r.x + 4;
    const maxX = r.x + r.w - w - 4;
    const minY = r.y + 4;
    const maxY = r.y + r.h - h - 4;
    return { x: Math.min(maxX, Math.max(minX, x)), y: Math.min(maxY, Math.max(minY, y)) };
  }

  // 左長方形クリック：自分のアイコンを1回だけ作成
  async function onRectClickOnce(ev){
    const rectEl = document.getElementById('leftRect');
    if (!art || !rectEl) return;

    const myIconRef = ref(db, `rooms/${state.code}/icons/${state.uid}`);
    const snap = await get(myIconRef);
    if (snap.exists()) return; // 2回目以降は無視

    const p = toSvgCoords(art, ev.clientX, ev.clientY);
    const pos = clampToRect(p.x - 14, p.y - 10);
    await set(myIconRef, { name: state.name, x: pos.x, y: pos.y, placedAt: Date.now() });
  }

  function renderOrUpdateIcon(uid, data){
    const layer = document.getElementById('icons');
    if (!layer || !data) return;

    let g = layer.querySelector(`g[data-uid="${uid}"]`);
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','usericon');
      g.setAttribute('data-uid', uid);

      const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
      box.setAttribute('width', 28);
      box.setAttribute('height', 20);
      g.appendChild(box);

      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', 14);
      label.setAttribute('y', 10);
      label.textContent = (data.name || '?');
      g.appendChild(label);

      // ドラッグ（誰でも可）
      art.addEventListener('pointermove', throttle((e)=>{
        if (!state.isPointerDown || state.draggingUid !== uid) return;
        const p = toSvgCoords(art, e.clientX, e.clientY);
        const pos = clampToRect(p.x - state.dragOffset.x, p.y - state.dragOffset.y);
        g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
        g.setAttribute('data-x', pos.x);
        g.setAttribute('data-y', pos.y);
        update(ref(db, `rooms/${state.code}/icons/${uid}`), { x: pos.x, y: pos.y });
      }, 40), { passive: true });

      g.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        state.isPointerDown = true;
        state.draggingUid = uid;
        g.classList.add('dragging');
        const p = toSvgCoords(art, e.clientX, e.clientY);
        const gx = parseFloat(g.getAttribute('data-x') || data.x || 0);
        const gy = parseFloat(g.getAttribute('data-y') || data.y || 0);
        state.dragOffset.x = p.x - gx;
        state.dragOffset.y = p.y - gy;
        g.setPointerCapture(e.pointerId);
      });
      g.addEventListener('pointerup', (e)=>{
        if (!state.isPointerDown) return;
        state.isPointerDown = false;
        g.classList.remove('dragging');
        g.releasePointerCapture(e.pointerId);
      });
      g.addEventListener('pointercancel', ()=>{
        state.isPointerDown = false;
        g.classList.remove('dragging');
      });

      layer.appendChild(g);
    }

    const text = g.querySelector('text');
    if (text && text.textContent !== (data.name || '?')) text.textContent = (data.name || '?');
    if (!(state.isPointerDown && state.draggingUid === uid)) {
      g.setAttribute('transform', `translate(${data.x},${data.y})`);
      g.setAttribute('data-x', data.x);
      g.setAttribute('data-y', data.y);
    }
  }

  function throttle(fn, ms){
    let t = 0, lastArgs = null, tid = null;
    return function(...args){
      const now = Date.now();
      if (now - t >= ms){ t = now; fn.apply(this, args); }
      else {
        lastArgs = args; clearTimeout(tid);
        tid = setTimeout(()=>{ t = Date.now(); fn.apply(this, lastArgs); lastArgs = null; }, ms - (now - t));
      }
    };
  }

  // --- 入室処理（参加者登録＋図形＋左長方形アイコン同期＋席同期＋山札同期＋ダイス同期） ---
  async function join(){
    const name = normalizeName(nameInput.value);
    const code = (codeInput.value || "").trim() || random4();

    state.name = name;
    state.code = code;

    // 在室登録
    const meRef = ref(db, `rooms/${code}/participants/${state.uid}`);
    await set(meRef, { name, at: Date.now() });
    onDisconnect(meRef).remove();

    // ヘッダー表示
    selfNameHdrEl.textContent = name;
    roomCodeEl.textContent = code;
    roomCodeEl.onclick = ()=>{
      const link = buildRoomLink(code);
      if (navigator.clipboard){
        navigator.clipboard.writeText(link).then(()=>{
          copyHintEl.textContent = '招待リンクをコピーしました';
          setTimeout(()=> copyHintEl.textContent='', 1400);
        });
      } else {
        prompt('コピーできない場合はこのテキストをコピーしてください', link);
      }
    };

    show(joinPanel, false);
    show(roomPanel, true);

    // 図形（左長方形・部屋ヒット領域・席・ダイス）
    drawFigure2();

    // 左長方形アイコンの同期
    const iconsRef = ref(db, `rooms/${code}/icons`);
    const offIcons = onValue(iconsRef, (snap)=>{
      const data = snap.val() || {};
      Object.entries(data).forEach(([uid, icon])=> renderOrUpdateIcon(uid, icon));
      const layer = document.getElementById('icons');
      if (layer){
        [...layer.querySelectorAll('g.usericon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          if (!(uid in data)) el.remove();
        });
      }
    });
    state.unsub.push(offIcons);

    // 席アイコン同期＋自分の部屋更新
    const seatsRef = ref(db, `rooms/${code}/seats`);
    const offSeats = onValue(seatsRef, (snap)=>{
      const data = snap.val() || {};
      Object.entries(data).forEach(([uid, seat])=> renderOrUpdateSeat(uid, seat));
      // 削除反映
      const layer = document.getElementById('seats');
      if (layer){
        [...layer.querySelectorAll('g.seaticon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          if (!(uid in data)) el.remove();
        });
      }
      // 自分の部屋
      const mine = data[state.uid];
      state.myRoomNo = mine?.room ?? null;
      myRoomBadge.textContent = mine ? `部屋：${mine.room}` : '部屋：未選択';
      refreshDeckLocks();
    });
    state.unsub.push(offSeats);

    // ダイス購読
    setupDiceSubscribe();

    // デッキUI＆購読
    setupDecks();

    state.joined = true;
  }

  // 離脱時に在室削除（席/山札/ダイスの状態は残す運用）
  window.addEventListener('beforeunload', ()=>{
    if (state.joined) remove(ref(db, `rooms/${state.code}/participants/${state.uid}`));
  });

  // 事件
  btnJoin.onclick = join;

  // 事前入力（任意）
  try{
    const qs = new URLSearchParams(location.search);
    const qRoom = (qs.get('room')||'').trim();
    const qName = (qs.get('name')||'').trim();
    if (qRoom) codeInput.value = qRoom.slice(0, 12);
    if (qName) nameInput.value = qName.slice(0, 1);
  }catch(_e){}
</script>
</body>
</html>
