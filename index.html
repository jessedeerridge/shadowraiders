
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>シャドウ・レイダーズ</title>
<style>
  :root { --gap:10px; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:12px;
  border-bottom:1px solid #eee;
  gap:12px;

  /* 追加：ヘッダーを最前面にしてモーダルより上に */
  position: sticky;     /* または relative でも可 */
  top: 0;               /* sticky の場合 */
  z-index: 2147483610;  /* .modal(2147483602)より上 */
  background: #fff;     /* モーダルの半透明黒の上でも可読に */
}
  h1{margin:0;font-size:18px}
  .small{font-size:12px;opacity:.85;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .copybtn{padding:6px 10px;border:1px solid #ddd;border-radius:10px;background:#f7f7f7;cursor:pointer}
  main{padding:14px;display:grid;gap:16px;max-width:980px;margin:0 auto}
  .join-box{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .join-box input{padding:10px;border:1px solid #ddd;border-radius:8px;font-size:16px}
  .btn{padding:10px 14px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  .hidden{display:none !important}

  /* 図形（②） */
  html,body{height:100%}
  #art{
    display:block;margin:auto;max-width:96vmin;height:auto;
    touch-action: none; /* ★ 追加：ブラウザのパン/ズーム既定動作を無効化 */
  }
  .shape{fill:#fff;stroke:#111;stroke-width:0.8;stroke-linejoin:round;stroke-linecap:round}

  /* 左長方形内のユーザーアイコン（正方形＋角丸） */
  .usericon rect{fill:#fff;stroke:#111;stroke-width:0.8;rx:6;ry:6}
  .usericon text{font-size:12px;font-weight:700;dominant-baseline:middle;text-anchor:middle}
  .usericon{cursor:grab}
  .usericon.dragging{cursor:grabbing;opacity:.85}

  /* 右側の席アイコン（正方形＋角丸） */
  .seaticon rect{fill:#fff;stroke:#111;stroke-width:0.8;rx:6;ry:6}
  .seaticon text{font-size:12px;font-weight:700;dominant-baseline:middle;text-anchor:middle}

  /* 7部屋のヒット領域（通常は透明、クリック時だけフラッシュ） */
  .roomhit{fill:transparent;stroke:none;pointer-events:auto}
  .roomhit.flash{fill:#eee;transition:fill 60ms}

  
/* 山札UI（右図形の真下に横並び） */
.decks-wrap{display:flex;justify-content:flex-end}
.decks{
  display:flex;
  gap:16px;
  justify-content:flex-end;
  align-items:flex-start;
  margin-top:10px;   /* ← 元は -30px、正の値にして間隔を空ける */
  margin-right:24px;
}
  .deck{display:flex;flex-direction:column;align-items:center;gap:8px}
  .deck-back,.deck-face{
    width:80px;height:110px;border:1px solid #111;border-radius:10px;
    display:flex;align-items:center;justify-content:center;font-weight:700;color:#111;user-select:none;
  }
  .deck-back{cursor:pointer}
  .deck-back.disabled{opacity:.35;cursor:not-allowed;filter:grayscale(1)}
  .deck-back.green{background:#c7f5c1;}
  .deck-back.white{background:#ffffff;}
  .deck-back.black{background:#000;color:#fff;}
  .deck-label{font-size:12px;opacity:.8}
.deck-face.white{ background:#ffffff; color:#111; }
.deck-face.black{ background:#000000; color:#ffffff; }
.deck-face.green{ background:#c7f5c1; color:#111; }
.deck-count {
  font-size: 11px;
  opacity: 0.7;
}
.deck-back.blank {
  border: 2px dashed #999;  /* 点線の枠線 */
  background: transparent;  /* 背景透明 */
  color: transparent;       /* 文字も非表示 */
}

  /* ダイス欄 */
.dicebar{
  display:flex;
  gap:8px;
  align-items:center;
  margin-top:6px;
  justify-content:flex-end; /* 黒デッキの表と同じ右寄せ */
  margin-right:24px;        /* 黒デッキと同じ右余白 */
  flex-wrap:wrap;
}

  .dicebtn{padding:8px 10px;border:1px solid #ddd;border-radius:10px;background:#fafafa;cursor:pointer}
  .diceres{font-weight:700}

  /* ホスト用 設定マーク（左下固定） */
#hostGear{position:fixed;left:14px;bottom:14px;z-index:2147483605;
  width:44px;height:44px;border-radius:50%;border:1px solid #ddd;background:#fff;box-shadow:0 4px 14px rgba(0,0,0,.12);
  display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:20px}

#hostPanel{position:fixed;left:66px;bottom:14px;z-index:2147483606;
  border:1px solid #111;border-radius:12px;background:#fff;box-shadow:0 6px 20px rgba(0,0,0,.16);
  padding:10px;display:flex;gap:10px;align-items:center}
  #hostPanel button{padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}

  /* 汎用モーダル */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:2147483602}
  .modal-panel{background:#fff;border:1px solid #111;border-radius:14px;box-shadow:0 10px 26px rgba(0,0,0,.2);padding:16px}

   /* 色選択ポップ */
  #colorModal .color-grid{display:grid;grid-template-columns:repeat(5, 64px);gap:10px;justify-content:center}
  .color-tile{width:64px;height:64px;border:1px solid #111;border-radius:10px;position:relative;cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700}
  .color-tile .label{position:absolute;left:6px;bottom:4px;font-size:11px;background:rgba(255,255,255,.7);padding:1px 4px;border-radius:6px}
  /* ▼ 右下合計表示 */
  #colorModal .color-grid .color-tile .label:empty{
  display:none;
  padding:0;
}
  #colorModal .color-foot{margin-top:8px;display:flex;justify-content:flex-end;font-size:12px;opacity:.8}
  .color-tile .owner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:900}
  .color-tile.mine{outline:3px solid #111}

  /* 自分用：配られたカード（右下に小さな黒裏） */
  #myDealMini{position:fixed;right:16px;bottom:16px;width:60px;height:90px;border-radius:10px;border:1px solid #000;background:#000;color:#fff;
    display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:2147483600}
#dealViewer .deal-card{
  width:240px;     /* ←固定幅 */
  height:360px;    /* ←固定高さ */
  border:1px solid #111;
  border-radius:14px;
  background:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:42px;
  font-weight:900;
  padding:20px;
  box-sizing:border-box; /* paddingを含めて計算 */
  text-align:center;     /* 文字が長くても中央寄せ */
  word-break:break-word; /* 長文は折り返す */
}

  /* ホスト削除ポップ（既存） */
  .popover{
    position:fixed;z-index:2147483600;background:#fff;border:1px solid #111;border-radius:10px;
    padding:6px 10px;box-shadow:0 6px 16px rgba(0,0,0,.12);display:flex;gap:10px;align-items:center
  }
  .popover button{padding:6px 10px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}

@media (max-width:600px){
  .deck-back,.deck-face{width:50px;height:69px}
  .color-tile{width:44px;height:44px}
  #hostGear{width:36px;height:36px;font-size:16px}
  #myDealMini{width:40px;height:60px;font-size:12px}
  h1{font-size:14px; margin-right:4px;}   /* タイトル小さめ */
  header{gap:6px; padding:8px;}          /* スペース縮小 */
  .small{font-size:10px; gap:4px;}       /* 補助テキストをさらに小さく */
  #myRoomBadge{white-space:nowrap;}      /* 強制的に改行しない */
  #headerInfo{flex-wrap:nowrap;}         /* ボタン類も折り返し防止 */  
#dealViewer .deal-card{ width:180px; height:260px; font-size:28px; }
}

/* ▼ 装備所持エリア（通常フロー） */
.equipbar{
  display:flex; gap:12px; flex-wrap:wrap; align-items:center;
  background:#fff; border:1px solid #111; border-radius:12px; padding:8px 10px;
  margin-top:12px;           /* 山札との間に余白 */
}
/* ▼ 緑カード履歴（装備とは独立して常時表示） */
#greenHistory{
  margin-top:10px;
  border:1px solid #111;
  border-radius:12px;
  padding:8px 10px;
  background:#fff;
  max-height:140px;     /* 必要に応じて調整 */
  overflow:auto;
  font-size:12px;
  line-height:1.4;
}
/* ★ 追加：中身が空（白紙）のときは表示しない */
#greenHistory:empty{
  display:none !important;
}
#greenHistory .row{
  display:flex; gap:8px; align-items:center;
  padding:4px 0; border-bottom:1px dashed #ddd;
}
#greenHistory .row:last-child{ border-bottom:none; }

#greenHistory .tag{ font-weight:700; }
  
/* ▼ 緑カードQ&A履歴 */
.history{
  background:#fff; border:1px solid #111; border-radius:12px;
  padding:8px 10px; margin-top:10px; font-size:12px;
}
.history-item{ display:flex; gap:6px; align-items:center; padding:2px 0; }
.history-item .q{ font-weight:700; }
.history-item .sep{ opacity:.6; }

/* 所持者1人分のボックス */
.equip-holder{
  display:flex; gap:8px; align-items:center;
  padding:6px 8px; border:1px solid #ddd; border-radius:10px;
}

/* 所持者の色付き小アイコン（名前1文字） */
.equip-icon{
  width:24px; height:24px;
  border:1px solid #111; border-radius:6px;
  display:flex; align-items:center; justify-content:center; font-weight:700;
}

/* 装備カード：サイズを“カードと同じ”に合わせる */
.equip-card{
  width:60px; height:86px;         /* ← デスクトップのカードサイズに合わせる */
  border:1px solid #111; border-radius:6px;
  display:flex; align-items:center; justify-content:center;
  font-size:14px; font-weight:700;
}

.diceimg{
  width:65px;       /* 必要に応じて調整 */
  height:auto;
  cursor:pointer;
  user-select:none;
  image-rendering:-webkit-optimize-contrast;
}

  
/* 既存のモバイル用カードサイズに追従（例：@media内のdeckサイズが50x69なら同じ） */
@media (max-width:600px){
  .equip-card{ width:50px; height:69px; font-size:12px; }
}

  

</style>
</head>
<body>
<header>
  <h1>オンラインルーム</h1>
  <div class="small" id="headerInfo"></div>
  <div class="small" id="myRoomBadge">部屋：未選択</div>
</header>

<main>
  <!-- 入室 -->
  <section id="joinPanel" class="join-box">
    <input id="nameInput" placeholder="名前（1文字）" maxlength="1" inputmode="text" />
    <input id="codeInput" placeholder="ルームコード（例: 1234）" maxlength="12" inputmode="numeric" />
    <button id="btnJoin" class="btn">入室</button>
  </section>

  <!-- ルーム -->
  <section id="roomPanel" class="hidden">
    <div style="margin-top:10px;">
      <!-- 図形②：左に狭い長方形＋右に星形（中央六角形＋外周五角形6） -->
      <svg id="art" viewBox="-220 -230 440 460" aria-label="左に長方形・右に星形"></svg>
    </div>

    <!-- ▼ 右図形の真下：山札 -->
    <div class="decks-wrap"><div id="decks" class="decks" aria-label="山札（左から緑・白・黒）"></div></div>


    <!-- ダイス（左長方形の下／ローカル表示） -->
<div class="dicebar" id="diceBar">
   <!-- d6 ダイス（初期 6d1.png） -->
  <img id="roll6dImg" class="diceimg" src="6d1.png" alt="d6" role="button" />
 <!-- d4 ダイス（初期 4d1.png） -->
  <img id="roll4dImg" class="diceimg" src="4d1.png" alt="d4" role="button" />

  </section>
</main>


  <!-- 装備所持バー（※ 上に移動） -->
<div id="equipBar" class="equipbar hidden" aria-label="装備所持者一覧"></div>

<!-- 緑カードQ&A履歴 -->
<div id="greenHistory" aria-label="緑カードの履歴"></div>

<!-- ホスト設定マークとパネル -->
<button id="hostGear" class="hidden" title="設定">⚙️</button>
<div id="hostPanel" class="hidden">
  <span>ホスト設定</span>
  <button id="btnStart">スタート</button>
</div>

<!-- 自分用 ミニカード（配布後） -->
<div id="myDealMini" class="hidden" title="カードを開く">裏</div>


  
<!-- 装備所持バー -->
<div id="equipBar" class="equipbar hidden" aria-label="装備所持者一覧"></div>

<!-- ☆ 修正：正体カード公開ポップ（黒背景、公開するのみ） -->
<div id="revealPopover" class="hidden"
     style="position:fixed; z-index:2147483607;
            background:#000; color:#fff;
            border-radius:10px; padding:12px 18px;
            box-shadow:0 4px 12px rgba(0,0,0,.4);
            display:flex; align-items:center; justify-content:center;">
  <button id="btnReveal"
          style="padding:10px 20px; border:none; border-radius:8px;
                 background:#fff; color:#000; font-weight:700; cursor:pointer;">
    公開する
  </button>
</div>

<!-- 奪うポップ -->
<div id="stealPopover" class="hidden"
     style="position:fixed; z-index:2147483607;
            background:#fff; color:#000;
            border:1px solid #111; border-radius:10px;
            padding:8px 12px; box-shadow:0 6px 16px rgba(0,0,0,.12);
            display:flex; align-items:center; justify-content:center;">
  <button id="btnSteal"
          style="padding:8px 14px; border:1px solid #ddd; border-radius:8px;
                 background:#111; color:#fff; font-weight:700; cursor:pointer;">
    奪う
  </button>
</div>


  
<!-- カード拡大ビューア -->
<div id="dealViewer" class="modal hidden" role="dialog" aria-modal="true">
  <div class="modal-panel">
    <div class="deal-card" id="dealCardFace">？</div>
  </div>
</div>


<!-- 色選択モーダル -->
<div id="colorModal" class="modal hidden" role="dialog" aria-modal="true">
  <div class="modal-panel">
    <h2 style="margin:0 0 12px;font-size:16px">色を選んでください。</h2>
    <div class="color-grid" id="colorGrid"></div>
    <div style="margin-top:10px;font-size:12px;opacity:.8">※スタートまで待ってください。</div>
    <!-- ▼ 追加：右下の合計表示 -->
    <div class="color-foot"><span id="colorCount">プレイヤー数：0</span></div>
  </div>
</div>


<!-- Firebase（v9 モジュール） -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, onValue, onDisconnect, remove, get, update, runTransaction, push,
  query, orderByChild, limitToLast
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  /* Firebase 設定 */
  const firebaseConfig = {
    apiKey: "AIzaSyASUJcPyybcD9q77XDatI5bCzZxDvsBH_o",
    authDomain: "shadowraiders-a2dbc.firebaseapp.com",
    projectId: "shadowraiders-a2dbc",
    storageBucket: "shadowraiders-a2dbc.firebasestorage.app",
    messagingSenderId: "577276689873",
    appId: "1:577276689873:web:9a13faf90c3d6a791e34f0",
    measurementId: "G-PKNEPDBVSS"
  };

  // --- 初期化 ---
  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // --- DOM ---
  const headerInfo    = document.getElementById('headerInfo');
  const myRoomBadge   = document.getElementById('myRoomBadge');
  const joinPanel     = document.getElementById('joinPanel');
  const nameInput     = document.getElementById('nameInput');
  const codeInput     = document.getElementById('codeInput');
  const btnJoin       = document.getElementById('btnJoin');
  const roomPanel     = document.getElementById('roomPanel');
  const decksEl       = document.getElementById('decks');
const roll4dImg     = document.getElementById('roll4dImg'); // ← 新規
const roll6dImg     = document.getElementById('roll6dImg'); // ← 新規

// ---- d6 画像クリックでアニメ→結果表示 ----
const sixDAnimFrames = ['6da1.png','6da2.png','6da3.png'];
let sixDRolling = false;

// プリロード
[...sixDAnimFrames,'6d1.png','6d2.png','6d3.png','6d4.png','6d5.png','6d6.png'].forEach(src=>{
  const img=new Image(); img.src=src;
});

function play6dAnimationThenResult(){
  if (sixDRolling) return;
  sixDRolling = true;

  const start = Date.now();
  let idx = 0;

  const iv = setInterval(()=>{
    roll6dImg.src = sixDAnimFrames[idx % sixDAnimFrames.length];
    idx++;
    if (Date.now() - start >= 500){ // 1秒
      clearInterval(iv);
      const result = 1 + Math.floor(Math.random() * 6);
      roll6dImg.src = `6d${result}.png`;
      sixDRolling = false;
    }
  },80);
}

if (roll6dImg){
  if (!roll6dImg.getAttribute('src')) roll6dImg.src = '6d1.png';
  roll6dImg.addEventListener('click', rollBothDice);
}

  
// ---- d4 画像クリックでアニメ→結果表示 ----
const fourDAnimFrames = ['4da1.png','4da2.png','4da3.png']; // アニメ用
let fourDRolling = false;

// 画像プリロード（任意）
[...fourDAnimFrames, '4d1.png','4d2.png','4d3.png','4d4.png'].forEach(src=>{
  const img = new Image(); img.src = src;
});

function play4dAnimationThenResult(){
  if (fourDRolling) return; // 連打防止
  fourDRolling = true;

  const start = Date.now();
  let idx = 0;

  // 高速で3枚を入れ替え（約80ms間隔）
  const iv = setInterval(()=>{
    roll4dImg.src = fourDAnimFrames[idx % fourDAnimFrames.length];
    idx++;
    if (Date.now() - start >= 500){ // 1秒経過で停止
      clearInterval(iv);

      // 1～4 の結果をランダム表示（4d1.png ～ 4d4.png）
      const result = 1 + Math.floor(Math.random() * 4);
      roll4dImg.src = `4d${result}.png`;

      fourDRolling = false;
    }
  }, 80);
}

if (roll4dImg){
  // 初期画像（安全のため再設定：タイプミス防止）
  if (!roll4dImg.getAttribute('src')) roll4dImg.src = '4d1.png';
  roll4dImg.addEventListener('click', rollBothDice);
}

// ---- 同時起動ハンドラ（連打ロックつき）----
let bothRolling = false;
function rollBothDice(){
  if (bothRolling) return;
  bothRolling = true;

  // 個別のガード(fourDRolling / sixDRolling)は各関数内で有効
  play4dAnimationThenResult();   // 0.5秒で止まる
  play6dAnimationThenResult();   // 1.0秒で止まる

  // 最長の方に合わせて少し余裕を見てロック解除
  setTimeout(async ()=>{
    bothRolling = false;

    // ★ 追加：ダイスを振ったことを共有（誰が・いつ）
    try{
      await update(ref(db), {
        [`rooms/${state.code}/dice/lastRollAt`]: Date.now(),
        [`rooms/${state.code}/dice/lastRoller`]: state.uid,
      });
    }catch(e){ console.error('dice write failed', e); }

    // ★ 自分の画面では “自分が振った” 場合にだけ1回分を付与
    if (typeof setDeckQuota === 'function') setDeckQuota(1);
  }, 1200);
}

  

  const hostGear      = document.getElementById('hostGear');
  const hostPanel     = document.getElementById('hostPanel');
  const btnStart      = document.getElementById('btnStart');

  const colorModal    = document.getElementById('colorModal');
  const colorGrid     = document.getElementById('colorGrid');

  const myDealMini    = document.getElementById('myDealMini');
  const dealViewer    = document.getElementById('dealViewer');
  const dealCardFace  = document.getElementById('dealCardFace');

// --- 状態 ---
const state = {
  uid: crypto.randomUUID(),
  name: "",
  code: "",
  joined: false,
  unsub: [],
  rectBBox: null,
  draggingUid: null,
  isPointerDown: false,
  dragOffset: {x:0,y:0},
  isHost: false,
  started: false,
  lockScrollOnRect: false,   // ← 追加：左長方形内タッチ中はスクロール禁止
  localMoveVer: {},          // ★ 追加：自分の移動バージョン管理（uid→ver）
  dragSettleGuardUid: null,  // ★ 追加：ドロップ直後のエコー抑止
  dragSettleGuardUntil: 0,   // ★ 追加：抑止の期限(ms)
  deckClicksLeft: 0,         // ★ 追加：ダイス後に山札（裏）をめくれる残回数（ローカル）
};


  // --- ユーティリティ ---
  // --- ユーティリティ ---
  function randomLetter(){ return String.fromCharCode(65 + Math.floor(Math.random()*26)); }
  function random4(){ return String(Math.floor(Math.random()*10000)).padStart(4, '0'); }
  const NAME_RE = /^[A-Za-z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]$/;
  function normalizeName(raw){
    const t = (raw || "").trim(); if (!t) return randomLetter();
    const c = t[0]; return NAME_RE.test(c) ? c : randomLetter();
  }
  function show(el, yes){ el.classList.toggle('hidden', !yes); }

// カード配色ユーティリティ（表・拡大・装備で共通使用）
function applyDeckTheme(el, deckId){
  if (!el) return;
  // いったんリセット
  el.style.background = '';
  el.style.color = '';
  if (deckId === 'white'){ el.style.background = '#ffffff'; el.style.color = '#111'; }
  else if (deckId === 'black'){ el.style.background = '#000000'; el.style.color = '#fff'; }
  else if (deckId === 'green'){ el.style.background = '#c7f5c1'; el.style.color = '#111'; }
}

// 任意のカード名に対して dealViewer の見た目を適切に設定するヘルパ
function colorizeDealFaceByCardName(cardName){
  // まず完全リセット
  dealCardFace.style.background = '';
  dealCardFace.style.color = '';

  // 1) デッキ出自（装備カードなど）：白／黒／緑
  if (DECKS_DEF.white.cards.includes(cardName)) {
    applyDeckTheme(dealCardFace,'white');
    return;
  }
  if (DECKS_DEF.black.cards.includes(cardName)) {
    applyDeckTheme(dealCardFace,'black');
    return;
  }
  if (DECKS_DEF.green.cards.includes(cardName)) {
    applyDeckTheme(dealCardFace,'green');
    return;
  }

  // 2) 正体カード：役職ごとの3色
  if (ROLE_CARDS.shadow.includes(cardName)) {
    dealCardFace.style.background = '#1e88e5'; // シャドウ＝青
    dealCardFace.style.color = '#fff';
    return;
  }
  if (ROLE_CARDS.raider.includes(cardName)) {
    dealCardFace.style.background = '#e53935'; // レイダー＝赤
    dealCardFace.style.color = '#fff';
    return;
  }
  if (ROLE_CARDS.citizen.includes(cardName)) {
    dealCardFace.style.background = '#fdd835'; // シチズン＝黄
    dealCardFace.style.color = '#111';
    return;
  }

  // 3) どれにも該当しない場合は白
  dealCardFace.style.background = '#fff';
  dealCardFace.style.color = '#111';
}


// 拡大カード共通クリック（文脈で分岐）
dealCardFace.addEventListener('click', ()=>{
  const ctx = state.expandedContext || null;
  const card = (dealCardFace.textContent || '').trim();

  if (!ctx || ctx.source !== 'equip') return; // 装備欄からじゃなければ無視
  if (ctx.ownerUid === state.uid) return;     // 自分の装備は無視
  if (isRoleCard(card)) return;              // 正体カードは禁止

  const pop = document.getElementById('stealPopover');
  if (!pop) return;
  pop.classList.remove('hidden');

  const r = dealCardFace.getBoundingClientRect();
  pop.style.left = (r.left + r.width/2 - 60) + 'px';
  pop.style.top  = (r.top + r.height/2 - 25) + 'px';

  // 外側クリックで閉じる
  setTimeout(()=>{
    const onDocClick = (e)=>{
      if (pop.contains(e.target)) return;
      pop.classList.add('hidden');
      document.removeEventListener('click', onDocClick, true);
    };
    document.addEventListener('click', onDocClick, true);
  }, 0);
});


  const btnSteal = document.getElementById('btnSteal');
if (btnSteal){
  btnSteal.onclick = async ()=>{
    const ctx = state.expandedContext || null;
    const card = (dealCardFace.textContent || '').trim();
    if (!ctx || ctx.source !== 'equip') return;
    if (!card || isRoleCard(card)) return;  // 正体カードは禁止
    if (ctx.ownerUid === state.uid) return; // 自分の装備は対象外

    try{
      const updates = {};
      updates[`rooms/${state.code}/equipment/${ctx.ownerUid}/${card}`] = null;
      updates[`rooms/${state.code}/equipment/${state.uid}/${card}`] = true;
      updates[`rooms/${state.code}/equipment_at`] = Date.now();
      await update(ref(db), updates);

      const pop = document.getElementById('stealPopover');
      if (pop) pop.classList.add('hidden');
      show(dealViewer, false);
      state.expandedContext = null;
    }catch(e){
      console.error('steal failed', e);
    }
  };
}

  
  // ===== 同名引継ぎ：旧UIDから「色」と「右下カード」を移す =====
  async function onlySelfHasThisName(){
    const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
    const ps = psSnap.val() || {};
    const same = Object.entries(ps).filter(([,v]) => (v?.name||'') === state.name);
    return same.length === 1 && same[0][0] === state.uid;
  }

  async function findOrphanUidBySameName(){
    const candidates = new Set();

    // colors から同名の旧UID候補
    const cSnap = await get(ref(db, `rooms/${state.code}/colors`));
    const colors = cSnap.val() || {};
    for (const [, claim] of Object.entries(colors)){
      if ((claim?.name||'') === state.name && claim?.uid && claim.uid !== state.uid){
        candidates.add(claim.uid);
      }
    }

    // deal/v1/cards から旧UID候補
    const dSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards`));
    const deal = dSnap.val() || {};
    for (const uid of Object.keys(deal)){
      if (uid !== state.uid) candidates.add(uid);
    }

    // participants に居ないUIDのみ（＝孤児）
    const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
    const ps = psSnap.val() || {};
    for (const oldUid of candidates){
      if (!ps[oldUid]) return oldUid;
    }
    return null;
  }

  async function inheritBySameName(){
    // 仕様：同名在室者が自分だけのときのみ発動
    if (!(await onlySelfHasThisName())) return;

    const oldUid = await findOrphanUidBySameName();
    if (!oldUid) return;

    const updates = {};

    // 色（colors）を自分に移す＋participants の color 反映
    const colorsRef = ref(db, `rooms/${state.code}/colors`);
    const cSnap = await get(colorsRef);
    const colors = cSnap.val() || {};
    for (const [colorId, claim] of Object.entries(colors)){
      if (claim?.uid === oldUid && (claim?.name||'') === state.name){
        // colors の所有者を自分に
        updates[`rooms/${state.code}/colors/${colorId}`] =
          { uid: state.uid, name: state.name, at: Date.now() };
        // 参加者にも色を保存（既存実装に合わせ label で保存）
        // ＊labelは曖昧になるので、厳密化したければ colorId を保存する実装に変えてOK
        const label = (COLOR_LIST.find(c => c.id === colorId)?.name) || colorId;
        updates[`rooms/${state.code}/participants/${state.uid}/color`] = label;
      }
    }

// 装備（equipment）
const oldEquipSnap = await get(ref(db, `rooms/${state.code}/equipment/${oldUid}`));
const myEquipSnap  = await get(ref(db, `rooms/${state.code}/equipment/${state.uid}`));
const oldEquip = oldEquipSnap.val();
const myEquip  = myEquipSnap.val();
if (oldEquip && !myEquip){
  updates[`rooms/${state.code}/equipment/${state.uid}`] = oldEquip;
  updates[`rooms/${state.code}/equipment/${oldUid}`] = null;
}

// 右下の最初の配布カード（myDeal）
const myDealSnap  = await get(ref(db, `rooms/${state.code}/deal/v1/cards/${state.uid}`));
const oldDealSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards/${oldUid}`));
const myHasCard   = !!myDealSnap.val();
const oldCard     = oldDealSnap.val();
if (!myHasCard && oldCard){
  updates[`rooms/${state.code}/deal/v1/cards/${state.uid}`] = oldCard;
  updates[`rooms/${state.code}/deal/v1/cards/${oldUid}`] = null;
}


    if (Object.keys(updates).length){
      await update(ref(db), updates);
    }
  }



  // ===== ヘッダ表示・コピー =====
  function updateHeader(){
    headerInfo.innerHTML = '';
    const spanRoom = document.createElement('span');
    spanRoom.textContent = `コード：${state.code || '-'}`;
    const spanMe = document.createElement('span');
    spanMe.textContent = `あなた：${state.name || '-'}`;
    const btn = document.createElement('button');
    btn.className = 'copybtn';
    btn.textContent = 'リンクコピー';
    btn.onclick = ()=>{
      const url = new URL(location.href);
      url.searchParams.set('room', state.code);
      navigator.clipboard.writeText(url.toString());
      btn.textContent = 'コピー済み！';
      setTimeout(()=> btn.textContent='リンクコピー', 1200);
    };
    headerInfo.appendChild(spanRoom);
    headerInfo.appendChild(spanMe);
    headerInfo.appendChild(btn);
  }

  // === 図形②：左長方形＋右星形（7部屋ヒット領域付き） ===
  function drawFigure2(){
    const svg = document.getElementById('art');
    if (!svg) return;
    svg.innerHTML = '';
    const rt3 = Math.sqrt(3);

    // ---- パラメータ ----
    const s0 = 48;   // 中央六角形の一辺
    const s1 = 82;   // 中間六角形の一辺（五角形の根元）
    const rectScale = 0.40;
    const gap = 20;

    function hexFlat(cx, cy, s){
      const h = (rt3/2)*s;
      return [
        [cx+s,   cy],
        [cx+s/2, cy+h],
        [cx-s/2, cy+h],
        [cx-s,   cy],
        [cx-s/2, cy-h],
        [cx+s/2, cy-h],
      ];
    }
    const add=(a,b)=>[a[0]+b[0],a[1]+b[1]];
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
    const mul=(a,k)=>[a[0]*k,a[1]*k];
    const norm=(v)=>{ const L=Math.hypot(v[0],v[1])||1; return [v[0]/L,v[1]/L]; };
    function intersectRayRay(p,u,q,v){
      const A = [[u[0], -v[0]], [u[1], -v[1]]];
      const b = sub(q,p);
      const det = A[0][0]*A[1][1] - A[0][1]*A[1][0];
      const t = ( b[0]*A[1][1] - b[1]*A[0][1]) / det;
      return add(p, mul(u, t));
    }

    // 星本体（表示用）
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('id','star');
    svg.appendChild(g);

    function poly(pts, cls='shape', parent=g){
      const el = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      el.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
      el.setAttribute('class', cls);
      parent.appendChild(el);
      return el;
    }

    const H0 = hexFlat(0,0,s0);
    const H1 = hexFlat(0,0,s1);

    // 中央六角形（表示）
    poly(H0);

    // 外周五角形（表示）
    const pentPoints = [];
    for(let i=0;i<6;i++){
      const ip=(i+5)%6, inx=(i+1)%6, inx2=(i+2)%6;
      const a0=H0[i], b0=H0[inx], a1=H1[i], b1=H1[inx];
      const dirFromA1=norm(sub(H1[i],H1[ip]));
      const dirFromB1=norm(sub(H1[inx2],H1[inx]));
      const tip=intersectRayRay(a1,dirFromA1,b1,dirFromB1);
      const p = [a0,b0,b1,tip,a1];
      pentPoints.push(p);
      poly(p);
    }

    // 左の長方形
    const starBox = g.getBBox();
    const rectH = starBox.height;
    const rectW = rectH * rectScale;
    const rectX = starBox.x - gap - rectW;
    const rectY = starBox.y;

    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', rectX);
    rect.setAttribute('y', rectY);
    rect.setAttribute('width', rectW);
    rect.setAttribute('height', rectH);
    rect.setAttribute('class','shape');
    rect.setAttribute('id','leftRect');
    svg.appendChild(rect);

    // 左長方形内のアイコン用レイヤ
    const iconsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    iconsLayer.setAttribute('id','icons');
    svg.appendChild(iconsLayer);

    // 7部屋ヒット層
    const roomsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    roomsLayer.setAttribute('id','rooms');
    svg.appendChild(roomsLayer);

    // 中央六角形（room 1）
    const hitHex = poly(H0, 'roomhit', roomsLayer);
    hitHex.dataset.room = '1';
    hitHex.addEventListener('click', onRoomClick);

    // 外周五角形（room 2〜7）
    for(let i=0;i<6;i++){
      const hitPent = poly(pentPoints[i], 'roomhit', roomsLayer);
      hitPent.dataset.room = String(2 + i); // 2..7
      hitPent.addEventListener('click', onRoomClick);
    }

    // 席アイコン用レイヤ
    const seatsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    seatsLayer.setAttribute('id','seats');
    svg.appendChild(seatsLayer);

    // viewBox 調整
    (function fit(){
      const pad=14, box=svg.getBBox();
      svg.setAttribute('viewBox',[box.x-pad, box.y-pad, box.width+pad*2, box.height+pad*2].join(' '));
    })();

    // 左長方形の矩形を保持（ドラッグ範囲クランプ用）
    state.rectBBox = { x: rectX, y: rectY, w: rectW, h: rectH };

    // 左長方形クリック：同名が既に存在すれば新規出現しない
    rect.addEventListener('click', onRectClickWithDupCheck);
  }

// ===== 山札 =====
 const DECKS_DEF = {
  green: { 
    label:'緑', 
    colorClass:'green', 
    // ★ 正体質問カード群
    cards:[
      'あなたは シチズン か シャドウ？',
      '正体カードを見せよ',
      'あなたは  D / F / G / V / W ?（HP12以上）',
      'あなたは  A / B / C / E / U ?（HP11以下）',
      'あなたは レイダー か シャドウ？',
      'あなたは レイダー か シャドウ？',
      'あなたは レイダー？',
      'あなたは レイダー？',
      'あなたは レイダー？',
      'あなたは レイダー？',
      'あなたは シャドウ？',
      'あなたは シャドウ？',
      'あなたは シャドウ？',
      'あなたは シャドウ？',
      'あなたは シチズン か シャドウ？',
      'あなたは シチズン？',
      'あなたは シチズン？',
      'あなたは シャドウ？',
      'あなたは シチズン か レイダー？',
      'あなたは シチズン か レイダー？'
    ]
  },
white: {
  label:'白',
  colorClass:'white',
  cards:[
    '幸せのクッキー','光臨','いにしえの聖杯','恩恵','闇を祓う鏡',
    'いやしの聖水','いやしの聖水 ','いやしの聖水  ',
    '銀のロザリオ','銀のロザリオ ',
    '幸運のブローチ','裁きの閃光','賢者のローブ','人魚の涙',
    'エクスカリバー','守護天使','神秘のコンパス','虹色のパラソル',
    '封印の知恵','応急手当'
  ],
 equipNames:['いにしえの聖杯','銀のロザリオ','銀のロザリオ ','幸運のブローチ','賢者のローブ','エクスカリバー','神秘のコンパス','虹色のパラソル']
},
  black: {
  label:'黒',
  colorClass:'black',
  cards:[
    '妖刀マサムネ','吸血コウモリ','吸血コウモリ ','吸血コウモリ  ',
    '拳銃R','拳銃L','暴動','バナナの皮',
    'クロスボウガン','死神スコープ','死神スコープ ',
    '三つ目の黒犬','三つ目の黒犬','呪いの人形',
    'サーベル','ガトリング',
    'オリバーの子分','オリバーの子分','オリバーの子分 ',
    '戦慄の闇儀式'
  ],
  equipNames:[
    '拳銃R','拳銃L','ガトリング','妖刀マサムネ',
    'クロスボウガン','死神スコープ','死神スコープ ','サーベル'  ]
},
};

function setupDecks(){
  decksEl.innerHTML = '';

  // ★ 並び順を明示：「緑裏 → 白裏 → 白表 → 黒裏 → 黒表」
  const order = [
    { deck:'green', type:'back' },
    { deck:'white', type:'back' },
    { deck:'white', type:'face' },
    { deck:'black', type:'back' },
    { deck:'black', type:'face' },
  ];

  // クリック用ヘルパ
  function attachFaceClick(faceEl, deckId){
    faceEl.addEventListener('click', async ()=>{
      if (deckId === 'green'){
        // 緑表は共有しない：自分だけ参照
        const snap = await get(ref(db, `rooms/${state.code}/decks/${deckId}`));
        const idx = (snap.val()?.idx ?? -1);
        if (idx >= 0){
          const card = DECKS_DEF[deckId].cards[idx % DECKS_DEF[deckId].cards.length];
          dealCardFace.textContent = card;
          applyDeckTheme(dealCardFace, 'green');
          show(dealViewer, true);
        }
      }else{
        // 白・黒の表は faceEl のテキストを拡大
        if (faceEl.textContent){
          dealCardFace.textContent = faceEl.textContent;
          applyDeckTheme(dealCardFace, deckId);
          show(dealViewer, true);
        }
      }
    });
  }

  // 要素を順番に配置
  order.forEach(({deck:deckId, type})=>{
    const def = DECKS_DEF[deckId];

if (type === 'back'){
  const back = document.createElement('div');
  back.className = `deck-back ${def.colorClass}`;
  back.dataset.deck = deckId;     // ★識別
  back.dataset.role = 'back';
  back.textContent = '裏';
  back.title = `${def.label}デッキをめくる`;
back.addEventListener('click', (ev)=>{
  // ブランクなら「山札を作る（シャッフル）」ポップ
  if (back.classList.contains('blank')) {
    showShufflePopover(back, deckId, ev);
    return;
  }
  // 通常時は既存の山札めくり
  advanceDeckGuarded(deckId, state.uid);
});
  // ★ 追加：残り枚数表示用
  const count = document.createElement('div');
  count.className = 'deck-count';
  count.dataset.deck = deckId;
  count.textContent = `${def.cards.length}`;

  // ★ 追加：deckコンテナでまとめる
  const wrapper = document.createElement('div');
  wrapper.className = 'deck';
  wrapper.appendChild(back);
  wrapper.appendChild(count);

  decksEl.appendChild(wrapper);
}else{
  // type === 'face'
  const face = document.createElement('div');
  face.className = 'deck-face';
      face.dataset.deck = deckId;     // ★識別
      face.dataset.role = 'face';
      face.textContent = '';
      attachFaceClick(face, deckId);
      decksEl.appendChild(face);
    }
  });

  // ★ 緑の「表」は作らない（orderに含めない）＝表示されない

  // DB同期購読（face要素のテキストを更新）
  const decksRef = ref(db, `rooms/${state.code}/decks`);
const off = onValue(decksRef, (snap)=>{
  const v = snap.val() || {};

  // 白の表
// 白の表（order対応）
{
  const idx = (v.white?.idx ?? -1);
  const order = Array.isArray(v.white?.order) ? v.white.order : null;
  const faceEl = decksEl.querySelector('.deck-face[data-deck="white"][data-role="face"]');
  if (faceEl){
    if (idx >= 0){
      const actual = order ? order[idx % order.length] : (idx % DECKS_DEF.white.cards.length);
      faceEl.textContent = DECKS_DEF.white.cards[actual];
    }else{
      faceEl.textContent = '';
    }
    applyDeckTheme(faceEl, 'white');
  }
}
// 黒の表（order対応）
{
  const idx = (v.black?.idx ?? -1);
  const order = Array.isArray(v.black?.order) ? v.black.order : null;
  const faceEl = decksEl.querySelector('.deck-face[data-deck="black"][data-role="face"]');
  if (faceEl){
    if (idx >= 0){
      const actual = order ? order[idx % order.length] : (idx % DECKS_DEF.black.cards.length);
      faceEl.textContent = DECKS_DEF.black.cards[actual];
    }else{
      faceEl.textContent = '';
    }
    applyDeckTheme(faceEl, 'black');
  }
}

  // 緑は表共有なし（face自体を置いていない）

  // ★ 追加：残り枚数更新
  function updateCount(deckId){
    const idx = (v[deckId]?.idx ?? -1);
    const def = DECKS_DEF[deckId];
    const remain = def.cards.length - (idx + 1);
    const countEl = decksEl.querySelector(`.deck-count[data-deck="${deckId}"]`);
    const backEl  = decksEl.querySelector(`.deck-back[data-deck="${deckId}"]`);

    if (countEl){
      countEl.textContent = remain >= 0 ? remain : def.cards.length;
    }
if (backEl){
  if (remain <= 0){
    backEl.textContent = '';                 // 裏の文字は消す
    backEl.classList.add('blank');           // ★ 点線枠
    backEl.classList.remove('disabled');     // disabled は不要
  }else{
    backEl.textContent = '裏';
    backEl.classList.remove('blank');        // 通常枠に戻す
  }
}

  }
  updateCount('white');
  updateCount('black');
  updateCount('green');

  refreshDeckEnable();
});


  // ★ 追加：ダイスの共有イベント購読
  const diceRef = ref(db, `rooms/${state.code}/dice`);
  const offDice = onValue(diceRef, (snap)=>{
    const v = snap.val() || {};
    const lastRoller = v.lastRoller || null;

    // 誰かがダイスを振った → まず全員のローカル残回数を0に
    if (typeof setDeckQuota === 'function') setDeckQuota(0);

    // その上で「自分がローラーだった」場合のみ 1 を付与
    if (lastRoller && lastRoller === state.uid){
      if (typeof setDeckQuota === 'function') setDeckQuota(1);
    }
  });

  state.unsub.push(off);
  state.unsub.push(offDice);
}



  // ルーム制限に従ってクリック可否を判定
  function canFlip(deckId, myRoom){
    if (!myRoom) return false;
    switch(deckId){
      case 'green': return (myRoom===6 || myRoom===7);
      case 'white': return (myRoom===7 || myRoom===2);
      case 'black': return (myRoom===7 || myRoom===3);
      default: return false;
    }
  }

  // ★ 追加：残回数セット＋UI反映
  function setDeckQuota(n){
    state.deckClicksLeft = Math.max(0, Number(n || 0));
    refreshDeckEnable();
  }

  // ★ 置換：山札「裏」のクリック許可＝部屋制限 × 残回数
  function refreshDeckEnable(){
    const backs = decksEl.querySelectorAll('.deck-back'); // 裏のみ
    backs.forEach(back=>{

   // ★追加: ブランク（0枚）のときは常にクリック可能
    const isBlank = back.classList.contains('blank');
    if (isBlank){
      back.classList.remove('disabled');
      back.style.pointerEvents = 'auto';
      back.title = '山札を作る';
      return;
    }
      
      const deckId = back.dataset.deck;
      const roomOk = canFlip(deckId, state.myRoomNumber || null);
      const quotaOk = (state.deckClicksLeft > 0);
      const enabled = roomOk && quotaOk;

      back.classList.toggle('disabled', !enabled);
      back.style.pointerEvents = enabled ? 'auto' : 'none';
      back.title = enabled ? `${DECKS_DEF[deckId].label}デッキをめくる` : 'ダイスを振ると再びめくれます';
    });
    // 表（拡大用）は制限しない
  }

async function advanceDeckGuarded(deckId, flipperUid){
  // ★ 自分のクリック以外ではローカル残回数を消費しない
  if (flipperUid === state.uid){
    if (typeof state.deckClicksLeft === 'number' && state.deckClicksLeft <= 0) return;
  }

  const ok = canFlip(deckId, state.myRoomNumber || null);
  if (!ok) return; // 禁止

  // ★ 自分がクリックした時にだけ1消費し、即UI反映
  if (flipperUid === state.uid && typeof state.deckClicksLeft === 'number'){
    state.deckClicksLeft = Math.max(0, state.deckClicksLeft - 1);
    if (typeof refreshDeckEnable === 'function') refreshDeckEnable();
  }

  await advanceDeck(deckId, flipperUid);

  if (deckId === 'green' && flipperUid === state.uid){
    const deckPath = ref(db, `rooms/${state.code}/decks/${deckId}`);
    const snap = await get(deckPath);
    const idx = (snap.val()?.idx ?? -1);
    if (idx >= 0){
      const card = DECKS_DEF[deckId].cards[idx % DECKS_DEF[deckId].cards.length];

      // ★ ピン留め（外側タップで閉じない）
      state.pinDealViewer = true;

      dealCardFace.textContent = card;
      applyDeckTheme(dealCardFace, 'green');      // ★ 追加
      show(dealViewer, true);
      dealCardFace.onclick = ()=> showParticipantSelectPopup(card);
    }
  }
}




async function advanceDeck(deckId, flipperUid){
  const def = DECKS_DEF[deckId];
  const deckPath = ref(db, `rooms/${state.code}/decks/${deckId}`);
  const snap = await get(deckPath);
  const v = snap.val() || {};
  const curIdx = (typeof v.idx === 'number') ? v.idx : -1;
  const nextIdx = (curIdx + 1) % def.cards.length;

  // ★ 追加：保存された order があれば、その順番で“実カード番号”を決める
  const order = Array.isArray(v.order) ? v.order : null;
  const actualCardIndex = order ? order[nextIdx] : nextIdx;
  const cardName = def.cards[actualCardIndex];

  // 進行を保存（orderは維持）
  await set(deckPath, { idx: nextIdx, order: order || null, at: Date.now() });

  if ((deckId === 'white' || deckId === 'black') && flipperUid){
    const eqList = Array.isArray(def.equipNames) ? def.equipNames : [];
    // 末尾・先頭空白の差を吸収して判定だけ厳密化（キーは実カード名をそのまま使う）
    const eqSetTrim = new Set(eqList.map(s => String(s).trim()));
    if (eqSetTrim.has(String(cardName).trim())){
      const updates = {};
      updates[`rooms/${state.code}/equipment/${flipperUid}/${cardName}`] = true;
     updates[`rooms/${state.code}/equipment_at`] = Date.now();
      await update(ref(db), updates);
    }
  }
}

// ★ 追加：ブランク時の「山札を作る（シャッフル）」ポップ
function showShufflePopover(targetEl, deckId, ev){
  // 既存を消す
  const old = document.getElementById('shufflePopover');
  if (old) old.remove();

  const pop = document.createElement('div');
  pop.id = 'shufflePopover';
  pop.className = 'popover';

  // 位置（カードの少し上）
  const r = targetEl.getBoundingClientRect();
  pop.style.left = `${r.left + r.width/2}px`;
  pop.style.top  = `${Math.max(8, r.top - 10)}px`;
  pop.style.transform = 'translate(-50%, -100%)';

  // ボタンだけのシンプルUI
  const btn = document.createElement('button');
  btn.textContent = '山札を作る（シャッフル）';
  btn.onclick = async ()=>{
    await rebuildDeck(deckId);   // idx を初期化
    pop.remove();
  };

  pop.appendChild(btn);
  document.body.appendChild(pop);

  // 外側クリックで閉じる
  const closer = (e)=>{
    if (!pop.contains(e.target)) { pop.remove(); document.removeEventListener('mousedown', closer, true); }
  };
  setTimeout(()=> document.addEventListener('mousedown', closer, true), 0);
}

// ★ 追加：デッキ再構築（idx を -1 に戻す）
async function rebuildDeck(deckId){
  const deckPath = ref(db, `rooms/${state.code}/decks/${deckId}`);
  const order = makeShuffledOrder(deckId);
  await set(deckPath, { idx: -1, order, at: Date.now() });
}


  
  // ===== 右側：部屋クリック =====
  async function onRoomClick(ev){
    const svg = document.getElementById('art');
    const el = ev.currentTarget;
    const roomNo = Number(el.dataset.room || 0);

    el.classList.add('flash');
    setTimeout(()=> el.classList.remove('flash'), 140);

    // 既存の同名席があれば“引き継ぎ”（新規生成しない）
    const seatsSnap = await get(ref(db, `rooms/${state.code}/seats`));
    const seats = seatsSnap.val() || {};
    let sameNameUid = null, sameData = null;
    for (const [uid, data] of Object.entries(seats)){
      if ((data?.name||'') === state.name){
        sameNameUid = uid; sameData = data; break;
      }
    }
    if (sameNameUid && sameNameUid !== state.uid){
      // 所有を自分に移す（位置はそのまま）
      await set(ref(db, `rooms/${state.code}/seats/${state.uid}`), { ...sameData, name: state.name, at: Date.now() });
      await remove(ref(db, `rooms/${state.code}/seats/${sameNameUid}`));
      return; // 位置変更は行わない
    }

    // 新規または自分の既存を更新
    const p = toSvgCoords(svg, ev.clientX, ev.clientY);
    await set(ref(db, `rooms/${state.code}/seats/${state.uid}`), {
      name: state.name,
      room: roomNo,
      x: p.x - 12,  // 正方形中心補正
      y: p.y - 12,
      at: Date.now()
    });
  }

  // SVG座標変換
function toSvgCoords(svg, clientX, clientY){
  const pt = svg.createSVGPoint();
  pt.x = clientX; pt.y = clientY;
  const m = svg.getScreenCTM(); if (!m) return {x:0,y:0};
  const sp = pt.matrixTransform(m.inverse());
  return {x: sp.x, y: sp.y};
}

/* ← 追加：タッチ点が左長方形(state.rectBBox)内かを判定 */
function isInLeftRect(clientX, clientY){
  const svg = document.getElementById('art');
  if (!svg || !state.rectBBox) return false;
  const p = toSvgCoords(svg, clientX, clientY);
  const r = state.rectBBox;
  return (p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h);
}

  // ===== 席アイコン描画（色反映） =====
function applyFillAndText(elGroup, colorName){
  const box = elGroup.querySelector('rect');
  const label = elGroup.querySelector('text');
  const {bg, text} = colorToStyle(colorName);
  if (box){ box.style.fill = bg; }     // ← inline style は CSS より強い
  if (label){ label.style.fill = text; }
}


  function renderOrUpdateSeat(uid, data, userColorsMap){
    const svg = document.getElementById('art');
    const layer = document.getElementById('seats');
    if (!svg || !layer || !data) return;

    let g = layer.querySelector(`g[data-uid="${uid}"]`);
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','seaticon');
      g.setAttribute('data-uid', uid);

const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
box.setAttribute('width', 24);
box.setAttribute('height', 24);
box.setAttribute('rx', 10);   // ← 角丸を属性で付与（スマホでも確実）
box.setAttribute('ry', 10);
g.appendChild(box);


      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', 12);
      label.setAttribute('y', 12);
      label.textContent = (data.name || '?');
      g.appendChild(label);

      // ホスト削除ポップ
      g.addEventListener('click', (e)=> maybeShowDeletePopover(e, 'seat', uid));

      layer.appendChild(g);
    }

    // 名前更新
    const text = g.querySelector('text');
    if (text && text.textContent !== (data.name || '?')) text.textContent = (data.name || '?');

    // 色適用（参加者カラー）
    const colorName = userColorsMap?.[uid] || null;
    if (colorName) applyFillAndText(g, colorName);

    // 位置更新
    g.setAttribute('transform', `translate(${data.x},${data.y})`);
  }

  // ===== 左長方形：クランプ =====
  function clampToRect(x, y){
    const r = state.rectBBox;
    const w = 24, h = 24;
    const minX = r.x + 4;
    const maxX = r.x + r.w - w - 4;
    const minY = r.y + 4;
    const maxY = r.y + r.h - h - 4;
    return {
      x: Math.min(maxX, Math.max(minX, x)),
      y: Math.min(maxY, Math.max(minY, y))
    };
  }

  // 左長方形クリック：同名が存在すれば新規出現しない
  async function onRectClickWithDupCheck(ev){
    const svg = document.getElementById('art');
    const myIconRef = ref(db, `rooms/${state.code}/icons/${state.uid}`);

    // 左長方形内で同名が既にあるかチェック
    const allIconsSnap = await get(ref(db, `rooms/${state.code}/icons`));
    const allIcons = allIconsSnap.val() || {};
    const dup = Object.values(allIcons).some(ic => (ic?.name||'') === state.name);
    if (dup) return; // 同名があれば新規出現しない

    // 自分は未配置なら作成、配置済なら無視
    const snap = await get(myIconRef);
    if (snap.exists()) return;

    const p = toSvgCoords(svg, ev.clientX, ev.clientY);
    const pos = clampToRect(p.x - 12, p.y - 12);

await set(myIconRef, { name: state.name, x: pos.x, y: pos.y, placedAt: Date.now(), ver: 1 });
state.localMoveVer[state.uid] = 1; // ★ 自分の初期verを合わせる
  }

  function renderOrUpdateIcon(uid, data, userColorsMap){
    const svg = document.getElementById('art');
    const layer = document.getElementById('icons');
    if (!svg || !layer || !data) return;

    let g = layer.querySelector(`g[data-uid="${uid}"]`);
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','usericon');
      g.setAttribute('data-uid', uid);

const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
box.setAttribute('width', 24);
box.setAttribute('height', 24);
box.setAttribute('rx', 10);   // ← こちらにも同様に
box.setAttribute('ry', 10);
g.appendChild(box);


      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', 12);
      label.setAttribute('y', 12);
      label.textContent = (data.name || '?');
      g.appendChild(label);

      // ドラッグ
      g.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        state.isPointerDown = true;
        state.draggingUid = uid;
        g.classList.add('dragging');
        const p = toSvgCoords(svg, e.clientX, e.clientY);
        const gx = parseFloat(g.getAttribute('data-x') || data.x || 0);
        const gy = parseFloat(g.getAttribute('data-y') || data.y || 0);
        state.dragOffset.x = p.x - gx;
        state.dragOffset.y = p.y - gy;
        g.setPointerCapture(e.pointerId);
 　　　 g.dataset.dragMoved = '0';              // ★ 追加：ドラッグ判定をリセット

        // ★ キックガード：DBのエコーで元位置に“戻る”のを短時間だけ無視
        state.dragKickGuardUid = uid;
        state.dragKickGuardUntil = Date.now() + 180; // 180ms（環境次第で 150〜300ms）

        installGlobalPointerMove(); // ← 全体リスナーを用意
      });
g.addEventListener('pointerup', (e)=>{
  if (!state.isPointerDown) return;
  state.isPointerDown = false;

  // ★ ドロップ直後だけリモートの古いスナップショットを無視
  state.dragSettleGuardUid = uid;
  state.dragSettleGuardUntil = Date.now() + 200; // 200ms程度でOK(環境で調整可)

  state.draggingUid = null;            // ★ 解除
  g.classList.remove('dragging');
  g.releasePointerCapture(e.pointerId);
});

      g.addEventListener('pointercancel', ()=>{
        state.isPointerDown = false;
        state.draggingUid = null;            // ★ 追加：必ず解除
        g.classList.remove('dragging');
      });
      // （以下続く）

      // （削除）svg.addEventListener('pointermove', ...) は削除して、
      // グローバル installGlobalPointerMove のみに一本化する

      // ホスト削除ポップ
// 左長方形内アイコン：クリックで「上に1個ぶん移動」
// ただし直前にドラッグが走っていた場合は何もしない
g.addEventListener('click', async (e)=>{
  if (g.dataset.dragMoved === '1') {      // ← ドラッグ直後なら無視
    g.dataset.dragMoved = '0';            // リセット
    return;
  }
  const curX = parseFloat(g.getAttribute('data-x') || data.x || 0);
  const curY = parseFloat(g.getAttribute('data-y') || data.y || 0);
  const step = 24;                        // アイコン1個ぶんの高さ
  const pos  = clampToRect(curX, curY - step);

  const nextVer = (state.localMoveVer[uid] || 0) + 1;
  state.localMoveVer[uid] = nextVer;

  await update(ref(db, `rooms/${state.code}/icons/${uid}`), {
    x: pos.x,
    y: pos.y,
    ver: nextVer
  });
});

layer.appendChild(g);

    }

    // 名前更新
    const text = g.querySelector('text');
    if (text && text.textContent !== (data.name || '?')) text.textContent = (data.name || '?' );

    // 色適用（参加者カラー）
    const colorName = userColorsMap?.[uid] || null;
    if (colorName) applyFillAndText(g, colorName);

    // 自分がドラッグ中はリモート更新を抑止＋開始直後の“戻り”も抑止
const now = Date.now();
const draggingNow = (state.isPointerDown && state.draggingUid === uid);
const kickGuard = (state.dragKickGuardUid === uid) && (now < (state.dragKickGuardUntil || 0));
const settleGuard = (state.dragSettleGuardUid === uid) && (now < (state.dragSettleGuardUntil || 0));

// ★ リモート/ローカルのバージョン比較（自分のアイコンのみ適用）
const remoteVer = Number(data.ver || 0);
const localVer  = Number(state.localMoveVer[uid] || 0);
const isStaleForMe = (uid === state.uid) && (remoteVer < localVer);

if (!(draggingNow || kickGuard || settleGuard) && !isStaleForMe) {
  g.setAttribute('transform', `translate(${data.x},${data.y})`);
  g.setAttribute('data-x', data.x);
  g.setAttribute('data-y', data.y);
}

  }

  function throttle(fn, ms){

    let t = 0, lastArgs = null, tid = null;
    return function(...args){
      const now = Date.now();
      if (now - t >= ms){ t = now; fn.apply(this, args); }
      else {
        lastArgs = args; clearTimeout(tid);
        tid = setTimeout(()=>{ t = Date.now(); fn.apply(this, lastArgs); lastArgs = null; }, ms - (now - t));
      }
    };
  }

    // --- グローバルに1回だけ pointermove をインストール ---
  let pointerMoveInstalled = false;
  function installGlobalPointerMove(){
    if (pointerMoveInstalled) return;
    pointerMoveInstalled = true;

const svg = document.getElementById('art');
svg.addEventListener('pointermove', (e)=>{
  if (!state.isPointerDown || !state.draggingUid) return;

  const layer = document.getElementById('icons');
  const g = layer && layer.querySelector(`g[data-uid="${state.draggingUid}"]`);
  if (!g) return;

  const p = toSvgCoords(svg, e.clientX, e.clientY);
  const pos = clampToRect(p.x - state.dragOffset.x, p.y - state.dragOffset.y);
  g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
  g.setAttribute('data-x', pos.x);
  g.setAttribute('data-y', pos.y);

  g.dataset.dragMoved = '1';              // ★ 追加：実移動＝ドラッグ発生

  const uid = state.draggingUid;
  const nextVer = (state.localMoveVer[uid] || 0) + 1;
  state.localMoveVer[uid] = nextVer;


update(ref(db, `rooms/${state.code}/icons/${uid}`), {
  x: pos.x,
  y: pos.y,
  ver: nextVer               // ★ 連番でエコー順序を担保
});
    }, { passive: true });
  }

  // ====== 色選択 ======
  const COLOR_LIST = [
    { id:'red',     name:'',    bg:'#e53935' },
    { id:'blue',    name:'',    bg:'#1e88e5' },
    { id:'black',   name:'',    bg:'#000000' },
    { id:'green1',  name:'',    bg:'#43a047' },
    { id:'white',   name:'',    bg:'#ffffff', border:'#111' },
    { id:'green2',  name:'',    bg:'#43a047' }, // 指示通り2つ目の緑
    { id:'purple',  name:'',    bg:'#8e24aa' },
    { id:'cyan',    name:'',  bg:'#26c6da' },
    { id:'orange',  name:'', bg:'#fb8c00' },
    { id:'yellow',  name:'',  bg:'#fdd835' },
  ];
  function colorToStyle(colorName){
    // 背景と文字色の組合せ規定
    const darkText = ['赤','青','黒','緑','紫']; // これらは白文字
    const item = COLOR_LIST.find(c => c.name===colorName || c.id===colorName) || null;
    const bg = item?.bg || '#fff';
    const label = item?.name || '';
    const needWhite = darkText.includes(label) || ['red','blue','black','green1','green2','purple'].includes(item?.id);
    return { bg, text: needWhite ? '#fff' : '#111' };
  }

/* === 4a: 装備所持用の小アイコンを作る === */
function makeEquipIcon(name, colorName){
  const div = document.createElement('div');
  div.className = 'equip-icon';
  const { bg, text } = colorToStyle(colorName || '');
  div.style.background = bg;
  div.style.color = text;
  div.textContent = name || '?';
  return div;
}

  
  function renderColorGrid(claims){
    colorGrid.innerHTML = '';
    COLOR_LIST.forEach(c=>{
      const tile = document.createElement('div');
      tile.className = 'color-tile';
      
          // ★ 追加：背景と文字色を両方適用
    const { bg, text } = colorToStyle(c.id);
    tile.style.background = bg;
    tile.style.color = text;
      
      if (c.border) tile.style.borderColor = c.border;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = c.name;
      tile.appendChild(label);

      const claim = claims?.[c.id] || null;
      if (claim){
        const o = document.createElement('div');
        o.className = 'owner';
        o.textContent = claim.name || '?';
        tile.appendChild(o);
        if (claim.uid !== state.uid){
          tile.classList.add('taken-by-others');
        }else{
          tile.classList.add('mine');
        }
      }

      tile.addEventListener('click', async ()=>{
        if (state.started) return;
        // 既に他者が取っていれば何もしない
        const snap = await get(ref(db, `rooms/${state.code}/colors/${c.id}`));
        const cur = snap.val();
        if (cur && cur.uid && cur.uid !== state.uid) return;

        // 自分が持っている別色の解放
        const colorsSnap = await get(ref(db, `rooms/${state.code}/colors`));
        const all = colorsSnap.val() || {};
        const mine = Object.entries(all).find(([id, v])=> v?.uid === state.uid);
        if (mine) await remove(ref(db, `rooms/${state.code}/colors/${mine[0]}`));

        // この色にセット
        await set(ref(db, `rooms/${state.code}/colors/${c.id}`), { uid: state.uid, name: state.name, at: Date.now() });
        // 参加者カラーにも保存
        await update(ref(db, `rooms/${state.code}/participants/${state.uid}`), { color: c.name });
      });

      colorGrid.appendChild(tile);
    });

    // ▼ 追加：色を選択済みの「ユニークUID数」を合計として右下に表示
    const countEl = document.getElementById('colorCount');
    if (countEl){
      const uidSet = new Set(
        Object.values(claims || {}).map(v => v && v.uid).filter(Boolean)
      );
      countEl.textContent = `ゲーム参加者合計：${uidSet.size}`;
    }
  }


  function observeColors(){
    const colorsRef = ref(db, `rooms/${state.code}/colors`);
    const off = onValue(colorsRef, (snap)=>{
      const claims = snap.val() || {};
      renderColorGrid(claims);
    });
    state.unsub.push(off);
  }

  // ▼ 装備一覧の描画（自分の行が先頭に来る）
  function renderEquipments(equipData, participants){
    const equipBar = document.getElementById('equipBar');
    equipBar.innerHTML = '';

    // 並べ替え：自分(uid)を先頭に
    const entries = Object.entries(equipData || {});
    entries.sort(([uidA],[uidB])=>{
      if (uidA === state.uid) return -1;
      if (uidB === state.uid) return 1;
      return 0;
    });

    entries.forEach(([uid, cards])=>{
      const holder = document.createElement('div');
      holder.className = 'equip-holder';

      // 名前＋色アイコン
      const p = participants?.[uid] || {};
      holder.appendChild(makeEquipIcon(p.name, p.color));

      // 装備カード群
// 装備カード群
Object.keys(cards).forEach(cardName=>{
  const cardDiv = document.createElement('div');
  cardDiv.className = 'equip-card';
  cardDiv.textContent = cardName;

  // ① このカードが「誰の装備欄にあるか」を覚えておく
  cardDiv.dataset.ownerUid = uid;
  cardDiv.dataset.source   = 'equip';

  // ② クリックで拡大ビューを開く（配色も適用）
  cardDiv.onclick = ()=>{
    dealCardFace.textContent = String(cardName);
    colorizeDealFaceByCardName(cardName); // 既存ヘルパーを使って色付け :contentReference[oaicite:2]{index=2}

    // ③ この拡大が「装備欄から来た」ことを覚える（奪う判定に使用）
    state.expandedContext = { source:'equip', ownerUid: uid, cardName };

    show(dealViewer, true);
  };

  holder.appendChild(cardDiv);
});

      
      equipBar.appendChild(holder);
    });

    show(equipBar, entries.length > 0);
  }

  // ▼ 装備購読
  function observeEquipments(){
    const equipRef = ref(db, `rooms/${state.code}/equipment`);
    const off = onValue(equipRef, (snap)=>{
      const equipData = snap.val() || {};
      renderEquipments(equipData, state.participants);
    });
    state.unsub.push(off);
  }
  

// ====== 正体カード定義 ======
const ROLE_CARDS = {
  raider: [
    'Eエミ','Eエマ','Eエリカ',
    'Fフェリックス','Fフレディ','Fフェリシア',
    'Gゴードン','Gゴドウィン','Gグラハド'
  ],
  shadow: [
    'Uウルリッヒ','Uウラヌス','Uアルスター',
    'Vヴァンパイア','Vヴェンデッタ','Vヴェノム',
    'Wワーウルフ','Wワイト','Wワルプルギス'
  ],
  citizen: [
    'Aアリス','Aアンジェラ','Aアガサ',
    'Bバイロン','Bベンジャミン','Bブルース',
    'Cクレイグ','Cクレア','Cキャロル',
    'Dダニエル','Dデーヴィッド','Dデボラ'
  ],
};
function isRoleCard(cardName){
  return ROLE_CARDS.shadow.includes(cardName)
      || ROLE_CARDS.raider.includes(cardName)
      || ROLE_CARDS.citizen.includes(cardName);
}

// 人数ごとの役職割り当て
const ROLE_DISTRIBUTION = {
  1: { raider:0, shadow:0, citizen:1 },
  2: { raider:1, shadow:1, citizen:0 },
  3: { raider:2, shadow:1, citizen:0 },
  4: { raider:2, shadow:2, citizen:0 },
  5: { raider:2, shadow:2, citizen:1 },
  6: { raider:2, shadow:2, citizen:2 },
  7: { raider:2, shadow:2, citizen:3 },
  8: { raider:3, shadow:3, citizen:2 },
  9: { raider:3, shadow:3, citizen:3 },
 10: { raider:3, shadow:3, citizen:4 },
};

// 追加：デッキ順インデックス作成（フィッシャー–イェーツ）
function makeShuffledOrder(deckId){
  const def = DECKS_DEF[deckId];
  const order = Array.from({length: def.cards.length}, (_, i)=> i);
  for (let i = order.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [order[i], order[j]] = [order[j], order[i]];
  }
  return order;
}
  
async function hostStartIfNotStarted(){
  const startedRef = ref(db, `rooms/${state.code}/game/started`);
  const startedSnap = await get(startedRef);
  if (startedSnap.val()) return;

  // 参加者
  const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
  const ps = psSnap.val() || {};
  const uids = Object.keys(ps);
  if (uids.length === 0) return;

  const dist = ROLE_DISTRIBUTION[uids.length];
  if (!dist) return;

  // 各役職ごとにシャッフル（既存）
  function shuffle(arr){ return [...arr].sort(()=>Math.random()-0.5); }
  const raiders  = shuffle(ROLE_CARDS.raider).slice(0, dist.raider);
  const shadows  = shuffle(ROLE_CARDS.shadow).slice(0, dist.shadow);
  const citizens = shuffle(ROLE_CARDS.citizen).slice(0, dist.citizen);
  const selected = shuffle([...raiders, ...shadows, ...citizens]);

  // 参加者に割り当て（既存）
  const assign = {};
  uids.forEach((uid, i)=>{ assign[uid] = selected[i]; });

  // ★ ここから追加：3デッキを「idx:-1 & 新order」で初期化（＝シャッフル）
  const now = Date.now();
  const decksInit = (id)=> ({ idx: -1, order: makeShuffledOrder(id), at: now });

  const updates = {};
  // 正体カード
  updates[`rooms/${state.code}/deal/v1/cards`] = assign;
  updates[`rooms/${state.code}/deal/v1/at`] = now;
  updates[`rooms/${state.code}/game/started`] = true;

  // ★ デッキ3種の初期化（シャッフル結果を同期保存）
  updates[`rooms/${state.code}/decks/green`] = decksInit('green');
  updates[`rooms/${state.code}/decks/white`] = decksInit('white');
  updates[`rooms/${state.code}/decks/black`] = decksInit('black');

  await update(ref(db), updates);
}


  
  // 自分のカード購読
function observeMyDeal(){
  const myRef = ref(db, `rooms/${state.code}/deal/v1/cards/${state.uid}`);
  const off = onValue(myRef, (snap)=>{
    const val = snap.val();
    const has = !!val;
    show(myDealMini, has);
    if (has){
      myDealMini.onclick = ()=>{
// 自分のカード表示
dealCardFace.textContent = String(val);

// ★ 正体カードの色分け（拡大ビュー用）
if (ROLE_CARDS.shadow.includes(val)) {
  dealCardFace.style.background = '#1e88e5'; // 青
  dealCardFace.style.color = '#fff';
} else if (ROLE_CARDS.raider.includes(val)) {
  dealCardFace.style.background = '#e53935'; // 赤
  dealCardFace.style.color = '#fff';
} else if (ROLE_CARDS.citizen.includes(val)) {
  dealCardFace.style.background = '#fdd835'; // 黄
  dealCardFace.style.color = '#111';
} else {
  // その他カードは白背景に戻す
  dealCardFace.style.background = '#fff';
  dealCardFace.style.color = '#111';
}

show(dealViewer, true);


        // ☆ 追加：拡大カードを押すと「公開する」ポップ表示
dealCardFace.onclick = ()=>{
  const val = (dealCardFace.textContent || '').trim();
  if (DECKS_DEF.green.cards.includes(val)){
    // ★ 緑カード用：参加者選択ポップを開く
    showParticipantSelectPopup(val);
    return;
  }

  // ▼ それ以外（正体カードなど）は従来の「公開する」ポップ
  const pop = document.getElementById('revealPopover');
  if (!pop) return;
  pop.classList.remove('hidden');          const r = dealCardFace.getBoundingClientRect();
          // 拡大カードの中央に重ねる
          pop.style.left = (r.left + r.width/2 - 60) + 'px';
          pop.style.top  = (r.top + r.height/2 - 25) + 'px';

          // ☆ 追加：クリックアウェイ（他所をタップでポップを閉じる）
          // キャプチャ段階で拾い、同一タップで即閉じを防ぐため setTimeout
          setTimeout(()=>{
            const onDocClick = (e)=>{
              // ポップ内を押したら閉じない
              if (pop.contains(e.target)) return;
              pop.classList.add('hidden');
              document.removeEventListener('click', onDocClick, true);
            };
            document.addEventListener('click', onDocClick, true);
          }, 0);
        };
      };

    }else{
      myDealMini.onclick = null;
      dealCardFace.onclick = null;
    }
  });
  state.unsub.push(off);
}



  

// ☆ 追加：公開ボタンの挙動（1秒間の公開→装備欄の左へ固定）
const btnReveal = document.getElementById('btnReveal');
if (btnReveal){
  btnReveal.onclick = async ()=>{
    const val = (dealCardFace.textContent || '').trim();
    if (!val) return;

    // 1) 全員に1秒だけ拡大画像を共有
    await set(ref(db, `rooms/${state.code}/reveal/${state.uid}`), { card: val, at: Date.now() });
    setTimeout(()=> remove(ref(db, `rooms/${state.code}/reveal/${state.uid}`)), 1000);

    // 2) 装備所持データに追加（左端に来るよう render 側も修正する）
    const updates = {};
    // 既存のカードを壊さずマージしたいので、軽く read→write でもOKだが
    // ここでは単純にこのカードフラグを true で立てる
    updates[`rooms/${state.code}/equipment/${state.uid}/${val}`] = true;
    updates[`rooms/${state.code}/equipment_at`] = Date.now();
    await update(ref(db), updates);

    // 閉じる
    const pop = document.getElementById('revealPopover');
    if (pop) pop.classList.add('hidden');
    show(dealViewer, false);
  };
}

// ☆ 追加：公開購読（全員の画面で1秒だけ拡大カードを表示）
function observeReveals(){
  const refAll = ref(db, `rooms/${state.code}/reveal`);
  const off = onValue(refAll, (snap)=>{
    const all = snap.val() || {};
    const any = Object.values(all)[0];
    if (!any) return;

    // 表示内容
    dealCardFace.textContent = any.card || '？';

// 配色（デッキ色優先 → 役職カード → それ以外は白）
if (DECKS_DEF.white.cards.includes(any.card)) {
  applyDeckTheme(dealCardFace,'white');
} else if (DECKS_DEF.black.cards.includes(any.card)) {
  applyDeckTheme(dealCardFace,'black');
} else if (DECKS_DEF.green.cards.includes(any.card)) {
  applyDeckTheme(dealCardFace,'green');
} else if (ROLE_CARDS.shadow.includes(any.card)) {
  dealCardFace.style.background = '#1e88e5'; // 青
  dealCardFace.style.color = '#fff';
} else if (ROLE_CARDS.raider.includes(any.card)) {
  dealCardFace.style.background = '#e53935'; // 赤
  dealCardFace.style.color = '#fff';
} else if (ROLE_CARDS.citizen.includes(any.card)) {
  dealCardFace.style.background = '#fdd835'; // 黄
  dealCardFace.style.color = '#111';
} else {
  dealCardFace.style.background = '#fff';
  dealCardFace.style.color = '#111';
}


    // 外側タップで閉じない
    state.pinDealViewer = true;
    show(dealViewer, true);

    // 少しして自動クローズ（DB側は1秒で消す仕様）
    setTimeout(()=>{
      state.pinDealViewer = false;
      show(dealViewer,false);
    }, 1200);
  });
  state.unsub.push(off);
}

/// === 追加：緑拡大の“ピン留め”ガード ===
/// dealViewer配下のクリックは、ピン留め中は閉じ処理に届かないよう握りつぶす
function installDealViewerPinGuard(){
  if (state._pinGuardInstalled) return;
  state._pinGuardInstalled = true;

  document.addEventListener('click', (e)=>{
    const viewerOpen = dealViewer && !dealViewer.classList.contains('hidden');
    if (!viewerOpen || !state.pinDealViewer) return;

    // ★ ここを修正：dealViewer配下でも「カード本体(#dealCardFace)」クリックは通す
    const panel = dealViewer.querySelector('.modal-panel');
    const card  = document.getElementById('dealCardFace');

    const clickedInsideViewer = dealViewer.contains(e.target);
    const clickedOnCard       = card && (e.target === card || card.contains(e.target));

    // 背景やパネルをクリックした場合のみ、閉じ処理に届かないよう握り潰す
    if (clickedInsideViewer && !clickedOnCard){
      e.stopImmediatePropagation();
      e.stopPropagation();
      // 必要なら e.preventDefault();
    }
  }, true);
}



// === 緑カード共有：参加者選択ポップ ===
function showParticipantSelectPopup(cardText){
  const ex = document.getElementById('greenSharePopup');
  if (ex) ex.remove();

  const pop = document.createElement('div');
  pop.id = 'greenSharePopup';
  pop.style.cssText = `
    position:fixed; inset:0; z-index:2147483608;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.35);
  `;
  const panel = document.createElement('div');
  panel.className = 'modal-panel';
  panel.innerHTML = `<div style="font-weight:700;margin-bottom:8px">共有先を選んでください</div>`;
  const list = document.createElement('div');
  list.style.display = 'grid';
  list.style.gridTemplateColumns = 'repeat(3, 140px)';
  list.style.gap = '8px';

  panel.appendChild(list);
  pop.appendChild(panel);
  document.body.appendChild(pop);

  // 自分以外の参加者を列挙
  get(ref(db, `rooms/${state.code}/participants`)).then(snap=>{
    const ps = snap.val() || {};
    Object.entries(ps).forEach(([uid, info])=>{
      if (uid === state.uid) return;
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = (info?.name || '?');
      btn.style.width = '100%';
 btn.onclick = async ()=>{
  // 1) 相手に“共有”を書き込む
  await set(ref(db, `rooms/${state.code}/greenShare/${uid}`), {
    card: cardText, from: state.uid, at: Date.now()
  });

  // ※送信時は履歴に書かない（未回答は保存しない）

  // 2) ポップを閉じる
  pop.remove();
};

      list.appendChild(btn);
    });
  });

  // クリックアウェイで閉じる
  setTimeout(()=>{
    const onDocClick = (e)=>{
      if (panel.contains(e.target)) return;
      pop.remove();
      document.removeEventListener('click', onDocClick, true);
    };
    document.addEventListener('click', onDocClick, true);
  }, 0);
}

/// === 追加：受信者用「はい／いいえ」ポップ ===
function showYesNoPopoverForGreen(cardText, fromUid){
  const ex = document.getElementById('greenYesNo');
  if (ex) ex.remove();

  // --- 自分の正体を取得して判定 ---
  (async ()=>{
    // 自分の正体カード文字列（例: 'かかか' 等）を読む
    const myRoleCardSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards/${state.uid}`));
    const myRoleCard = myRoleCardSnap.val() || '';

    // ROLE_CARDS（既存定義）で役職を特定
    // どれにも該当しない場合は null
    let myRole = null;
    if (ROLE_CARDS.raider.includes(myRoleCard))   myRole = 'レイダー';
    else if (ROLE_CARDS.shadow.includes(myRoleCard))  myRole = 'シャドウ';
    else if (ROLE_CARDS.citizen.includes(myRoleCard)) myRole = 'シチズン';
    const isUrlich = (myRoleCard === 'Uウルリッヒ'); // ★ 追加：Uウルリッヒ特例フラグ

    // 質問文に含まれる語と一致するか
    const containsRaider  = cardText.includes('レイダー');
    const containsShadow  = cardText.includes('シャドウ');
    const containsCitizen = cardText.includes('シチズン');

    let shouldYes =
      (myRole === 'レイダー' && containsRaider) ||
      (myRole === 'シャドウ' && containsShadow) ||
      (myRole === 'シチズン' && containsCitizen);

const initial = String(myRoleCard).charAt(0).toUpperCase();

if (cardText.includes('D / F / G / V / W')) {
  shouldYes = ['D','F','G','V','W'].includes(initial);
} else if (cardText.includes('A / B / C / E / U')) {
  shouldYes = ['A','B','C','E','U'].includes(initial);
}
    
    // --- ポップ生成（片方のみ表示） ---
    const pop = document.createElement('div');
    pop.id = 'greenYesNo';
    pop.style.cssText = `
      position:fixed; inset:0; z-index:2147483610;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.4);
    `;
    const panel = document.createElement('div');
    panel.className = 'modal-panel';
    panel.innerHTML = `
      <div style="font-weight:800; margin-bottom:10px">回答してください</div>
      <div style="margin-bottom:8px; font-size:14px">${cardText}</div>
      <div id="ynBtns" style="display:flex; gap:10px; justify-content:center"></div>
    `;
    pop.appendChild(panel);
    document.body.appendChild(pop);

// ボタン生成：通常は役職一致で片方のみ／特例は常に「はい」だけ
const btnWrap = panel.querySelector('#ynBtns');
const yesBtn = document.createElement('button');
yesBtn.id = 'ansYes';
yesBtn.className = 'btn';
yesBtn.textContent = 'はい';

const noBtn = document.createElement('button');
noBtn.id = 'ansNo';
noBtn.className = 'btn';
noBtn.style.background = '#555';
noBtn.textContent = 'いいえ';

// ★ 追加：特例判定
const isRevealOrder = (cardText.trim() === '正体カードを見せよ');

  if (isRevealOrder){
    // 「正体カードを見せよ」のときは従来どおり「はい」だけ
    btnWrap.appendChild(yesBtn);
  }else if (isUrlich){
    // ★ Uウルリッヒ特例：その他の緑カードは常に「はい」「いいえ」両方
    btnWrap.appendChild(yesBtn);
    btnWrap.appendChild(noBtn);
  }else{
    // 従来どおり、質問内容と役職一致で片方のみ
    if (shouldYes) btnWrap.appendChild(yesBtn);
    else           btnWrap.appendChild(noBtn);
  }

async function finish(answer){
  await set(ref(db, `rooms/${state.code}/greenShareResult/${fromUid}`), {
    from: state.uid, answer, card: cardText, at: Date.now()
  });

  const h2Ref = ref(db, `rooms/${state.code}/greenHistory`);
  await set(ref(db, `rooms/${state.code}/greenHistory/${push(h2Ref).key}`), {
    type: 'answered',
    from: fromUid,
    to: state.uid,
    card: cardText,
    answer,
    at: Date.now()
  });

  await remove(ref(db, `rooms/${state.code}/greenShare/${state.uid}`));
  state.pinDealViewer = false;
  show(dealViewer, false);
  pop.remove();
}

yesBtn.onclick = ()=> finish('yes');
// ★ 追加：特例時は「いいえ」を付けない
if (!isRevealOrder){
  noBtn.onclick  = ()=> finish('no');
}


    // 外側クリックで閉じない（誤タップ防止／ピン留め継続）
  })();
}

  
// === 緑カード共有：受信者側購読（自分宛の共有が来たら拡大表示） ===
function observeGreenShare(){
  const myShareRef = ref(db, `rooms/${state.code}/greenShare/${state.uid}`);
  const off = onValue(myShareRef, (snap)=>{
    const rec = snap.val();
    if (rec?.card){
      // ★ ピン留め（外側タップで閉じない）
      state.pinDealViewer = true;

      dealCardFace.textContent = rec.card;
       applyDeckTheme(dealCardFace, 'green');      // ★ 追加
　　　 show(dealViewer, true);

      // ★ 拡大をクリック → はい/いいえポップ（送信者uidを渡す）
      dealCardFace.onclick = ()=> showYesNoPopoverForGreen(rec.card, rec.from || '');

      // 受信側はここでは greenShare を消さない（回答時に消す）
    }
  });
  state.unsub.push(off);
}

/// === 追加：送信者側 結果購読（相手の「はい／いいえ」受領で閉じる） ===
function observeGreenResult(){
  const myResultRef = ref(db, `rooms/${state.code}/greenShareResult/${state.uid}`);
  const off = onValue(myResultRef, async (snap)=>{
    const rec = snap.val();
    if (!rec) return;

    const isRevealOrder = (rec.card && rec.card.trim() === '正体カードを見せよ');
    const answeredYes   = (rec.answer === 'yes');

    if (isRevealOrder && answeredYes && rec.from){
      // ★ 相手（回答者）の正体カード文字列を取得
      const otherSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards/${rec.from}`));
      const otherCard = otherSnap.val() || '';

      // 表示内容
      dealCardFace.textContent = String(otherCard);

      // ★ 正体カードの色分け（拡大ビュー用）
      if (ROLE_CARDS.shadow.includes(otherCard)) {
        dealCardFace.style.background = '#1e88e5'; // 青
        dealCardFace.style.color = '#fff';
      } else if (ROLE_CARDS.raider.includes(otherCard)) {
        dealCardFace.style.background = '#e53935'; // 赤
        dealCardFace.style.color = '#fff';
      } else if (ROLE_CARDS.citizen.includes(otherCard)) {
        dealCardFace.style.background = '#fdd835'; // 黄
        dealCardFace.style.color = '#111';
      } else {
        dealCardFace.style.background = '#fff';
        dealCardFace.style.color = '#111';
      }

      // 送信者画面に1.2秒だけ拡大表示
      state.pinDealViewer = true;
      show(dealViewer, true);
      setTimeout(()=>{
        state.pinDealViewer = false;
        show(dealViewer, false);
      }, 1200);
    }else{
      // 従来挙動（閉じるだけ）
      state.pinDealViewer = false;
      show(dealViewer, false);
    }

    // 受領後掃除
    setTimeout(()=> remove(myResultRef), 0);
  });
  state.unsub.push(off);
}



// ★ 緑カード履歴購読（自分がめくった分のみ表示）→ #greenHistory に描画
function observeGreenHistory(){
  const box = document.getElementById('greenHistory');
  if (!box) return;

  const q = query(
    ref(db, `rooms/${state.code}/greenHistory`),
    orderByChild('at'),
    limitToLast(100)
  );

  const off = onValue(q, async (snap)=>{
    const all = snap.val() || {};

    // 1) 自分が「めくった」レコードだけに限定（from === state.uid）
    const mine = Object.values(all)
      .filter(r => r && r.from === state.uid)
      .sort((a,b)=> (a.at||0) - (b.at||0));

// 2) 参加者情報（名前・色）を取得
const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
const ps = psSnap.val() || {};

// 2.5) 全員の正体カードMap（uid → カード文字列）
const roleMapSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards`));
const roleMap = roleMapSnap.val() || {};

  // 3) 描画：通常は「質問文 → アイコン ：はい／いいえ」
//         特例（正体カードを見せよ）は「アイコン：正体カード」
box.innerHTML = '';
mine.forEach(r=>{
  const to = r.to || '';
  const p  = ps[to] || {};
  const name  = p.name  || '?';
  const color = p.color || '';

  const row = document.createElement('div');
  row.className = 'row';

  // 名前アイコン（共通）
  const iconWrap = document.createElement('span');
  iconWrap.style.display = 'inline-flex';
  iconWrap.style.alignItems = 'center';
  iconWrap.appendChild(makeEquipIcon(name, color));

const isRevealOrder = (r.card && r.card.trim() === '正体カードを見せよ');
if (isRevealOrder){
  // ▼ 特例表示：アイコン ＋ 回答者の正体カード（色付き）
  row.appendChild(iconWrap);

  const mini = document.createElement('div');      // equip-card を流用
  mini.className = 'equip-card';
  const cardName = String(roleMap[to] || '？');    // 回答者(to)の実カード
  mini.textContent = cardName;

  // 役職ごとの色分け
  if (ROLE_CARDS.shadow.includes(cardName)) {
    mini.style.background = '#1e88e5'; mini.style.color = '#fff';  // シャドウ＝青
  } else if (ROLE_CARDS.raider.includes(cardName)) {
    mini.style.background = '#e53935'; mini.style.color = '#fff';  // レイダー＝赤
  } else if (ROLE_CARDS.citizen.includes(cardName)) {
    mini.style.background = '#fdd835'; mini.style.color = '#111';  // シチズン＝黄
  } else {
    mini.style.background = '#fff'; mini.style.color = '#111';     // 不明時
  }

  row.appendChild(mini);
}else{

    // ▼ 従来表示
    const qSpan = document.createElement('span');
    qSpan.textContent = r.card;

    const arrow = document.createTextNode(' → ');

    const ansSpan = document.createElement('span');
    const ansText = (r.type === 'answered')
      ? (r.answer === 'yes' ? 'はい' : 'いいえ')
      : '…';
    ansSpan.textContent = `：${ansText}`;

    row.appendChild(qSpan);
    row.appendChild(arrow);
    row.appendChild(iconWrap);
    row.appendChild(ansSpan);
  }
  box.appendChild(row);
});

  });

  state.unsub.push(off);
}


  
  
/* === 4b: 装備所持バーのレンダラ＋購読 === */
function renderEquipmentBar(equipData, participants){
  const bar = document.getElementById('equipBar');
  if (!bar) return;
  bar.innerHTML = '';

const uids = Object.keys(equipData || {}).sort((a,b)=>{
  if (a === state.uid) return -1;
  if (b === state.uid) return 1;
  return 0;
});
  if (uids.length === 0){ bar.classList.add('hidden'); return; }

  uids.forEach(uid=>{
    const cardsObj = equipData[uid] || {};
    const ps = participants?.[uid] || {};
    const holder = document.createElement('div');
    holder.className = 'equip-holder';

    // 所持者アイコン
    holder.appendChild(makeEquipIcon(ps.name || '?', ps.color || ''));

// 装備カードたち
const cardNames = Object.keys(cardsObj);

// ▼ 正体カード群を先頭に、それ以外を後ろに
const roleCards = [...ROLE_CARDS.raider, ...ROLE_CARDS.shadow, ...ROLE_CARDS.citizen];
const roleCardsInHand = cardNames.filter(c => roleCards.includes(c));
const others = cardNames.filter(c => !roleCards.includes(c));
const ordered = [...roleCardsInHand, ...others];

// ▼ 先に役職カードを append → 常に一番左（= 所持者アイコンの直後）
ordered.forEach(cardName=>{
  const c = document.createElement('div');
  c.className = 'equip-card';
  c.textContent = cardName;

  // ★ 正体カードの色分け
  if (ROLE_CARDS.shadow.includes(cardName)) {
    c.style.background = '#1e88e5'; // シャドウ＝青
    c.style.color = '#fff';
  } else if (ROLE_CARDS.raider.includes(cardName)) {
    c.style.background = '#e53935'; // レイダー＝赤
    c.style.color = '#fff';
  } else if (ROLE_CARDS.citizen.includes(cardName)) {
    c.style.background = '#fdd835'; // シチズン＝黄
    c.style.color = '#111';
  }

  // 役職で未着色のカードは、デッキ色で配色（白／黒／緑）
  if (!c.style.background){
    if (DECKS_DEF.white.cards.includes(cardName)){
      c.style.background = '#ffffff'; c.style.color = '#111';
    } else if (DECKS_DEF.black.cards.includes(cardName)){
      c.style.background = '#000000'; c.style.color = '#fff';
    } else if (DECKS_DEF.green.cards.includes(cardName)){
      c.style.background = '#c7f5c1'; c.style.color = '#111';
    }
  }

  // ▼ クリックで拡大（装備カード＝出自デッキ色、正体カード＝3色のまま）
  c.addEventListener('click', ()=>{
    const name = (cardName || '').trim();
    if (!name) return;
  state.expandedContext = { source: 'equip', ownerUid: uid, cardName: name };

    // テキストを反映
    dealCardFace.textContent = name;

    // 色を統一ロジックで付与
    colorizeDealFaceByCardName(name);

    // 装備一覧からの拡大は“ピン留め”しない（外側クリックで閉じる）
    state.pinDealViewer = false;
    show(dealViewer, true);
  });

  
  holder.appendChild(c);
});



    bar.appendChild(holder);
  });

  // ★ equipBar の一番下に履歴表示用コンテナを（毎回存在を保証）
  let hist = document.getElementById('equipHistory');
  if (!hist){
    hist = document.createElement('div');
    hist.id = 'equipHistory';
    hist.className = 'equip-history';
    bar.appendChild(hist);
  }else if (bar.lastElementChild !== hist){
    bar.appendChild(hist); // 何かで順序が変わっても末尾へ戻す
  }

  bar.classList.remove('hidden');
}

function observeEquipment(){
  const equipRef = ref(db, `rooms/${state.code}/equipment`);
  const off = onValue(equipRef, async (snap)=>{
    const equipData = snap.val() || {};
    // 参加者（色・名前）を併せて取得
    const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
    const participants = psSnap.val() || {};
    renderEquipmentBar(equipData, participants);
  });
  state.unsub.push(off);
}
  
  // ===== ホスト管理 & 削除ポップ =====
async function becomeHostIfVacant(){
  const hostRef = ref(db, `rooms/${state.code}/host`);
  const nameRef = ref(db, `rooms/${state.code}/host_name`);

  // 空いていれば就任し、ホスト名を記録
  const res = await runTransaction(hostRef, cur => cur ?? state.uid);
  if (res.committed && (res.snapshot.val() === state.uid)){
    await set(nameRef, state.name);
  }

  // “同名復帰”の奪還：最後のホスト名と自分の名前が一致したら host を自分に上書き
  const [hostSnap, nameSnap] = await Promise.all([get(hostRef), get(nameRef)]);
  const curHost  = hostSnap.val();
  const hostName = nameSnap.val();
  if (hostName && hostName === state.name && curHost !== state.uid){
    await set(hostRef, state.uid);
  }

  const finalHostSnap = await get(hostRef);
  state.isHost = (finalHostSnap.val() === state.uid);
  show(hostGear, state.isHost);
}

  let popEl = null;
  function closePopover(){ if (popEl){ popEl.remove(); popEl=null; } }
  function maybeShowDeletePopover(ev, kind, uidTarget){
    if (!state.isHost) return;
    closePopover();
    popEl = document.createElement('div');
    popEl.className = 'popover';
    popEl.innerHTML = `<span>この${kind==='icon'?'アイコン':'席'}を削除</span>`;
    const b = document.createElement('button');
    b.textContent = '消す';
    b.onclick = async ()=>{
      if (kind==='icon') await remove(ref(db, `rooms/${state.code}/icons/${uidTarget}`));
      else await remove(ref(db, `rooms/${state.code}/seats/${uidTarget}`));
      closePopover();
    };
    popEl.appendChild(b);
    document.body.appendChild(popEl);
    const x = ev.clientX, y = ev.clientY;
    const r = popEl.getBoundingClientRect();
    popEl.style.left = Math.max(8, x - r.width/2) + 'px';
    popEl.style.top  = (y + 6) + 'px';
    setTimeout(()=>{
      document.addEventListener('click', clickAwayOnce, { once:true });
    },0);
    function clickAwayOnce(e){
      if (!popEl) return;
      if (!popEl.contains(e.target)) closePopover();
    }
  }

  // ===== 入室処理 =====
  async function join(){
    const name = normalizeName(nameInput.value);
    const code = (codeInput.value || "").trim() || random4();

    state.name = name;
    state.code = code;

    // 在室登録
    const meRef = ref(db, `rooms/${code}/participants/${state.uid}`);
    await set(meRef, { name, at: Date.now() });
    onDisconnect(meRef).remove();

    // ホスト就任（空いていれば）
    await becomeHostIfVacant();

    updateHeader();
    show(joinPanel, false);
    show(roomPanel, true);

    // 図形構築
    drawFigure2();

    // 左長方形アイコンの同期
    const iconsRef = ref(db, `rooms/${code}/icons`);
    const offIcons = onValue(iconsRef, async (snap)=>{
      const data = snap.val() || {};
      // 参加者カラーを取得して反映
      const psSnap = await get(ref(db, `rooms/${code}/participants`));
      const ps = psSnap.val() || {};
      const colorMap = Object.fromEntries(Object.entries(ps).map(([uid, v])=> [uid, v?.color || null]));
      Object.entries(data).forEach(([uid, icon])=> renderOrUpdateIcon(uid, icon, colorMap));
      const layer = document.getElementById('icons');
      if (layer){
        [...layer.querySelectorAll('g.usericon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          if (!(uid in data)) el.remove();
        });
      }
    });
    state.unsub.push(offIcons);

    // 席アイコンの同期＋自分の部屋/バッジ（色反映込み）
    const seatsRef = ref(db, `rooms/${code}/seats`);
    const offSeats = onValue(seatsRef, async (snap)=>{
      const data = snap.val() || {};
      // 参加者カラー
      const psSnap = await get(ref(db, `rooms/${code}/participants`));
      const ps = psSnap.val() || {};
      const colorMap = Object.fromEntries(Object.entries(ps).map(([uid, v])=> [uid, v?.color || null]));

      Object.entries(data).forEach(([uid, seat])=> renderOrUpdateSeat(uid, seat, colorMap));
      const layer = document.getElementById('seats');
      if (layer){
        [...layer.querySelectorAll('g.seaticon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          if (!(uid in data)) el.remove();
        });
      }
      const mine = data[state.uid];
      state.myRoomNumber = mine?.room ?? null;
      myRoomBadge.textContent = mine ? `部屋：${mine.room}` : '部屋：未選択';
      refreshDeckEnable();
    });
    state.unsub.push(offSeats);

    // 山札UI
    setupDecks();

    // 色選択の購読・表示
    observeColors();
    // スタート状態監視：モーダル制御
    const startedRef = ref(db, `rooms/${code}/game/started`);
    const offStarted = onValue(startedRef, (snap)=>{
      state.started = !!snap.val();
      show(colorModal, !state.started); // スタートまでは色ポップのまま
    });
    state.unsub.push(offStarted);

    // 自分の配布カード購読
    observeMyDeal();

    // ☆ 追加：公開の購読（全員に1秒共有を反映）
    observeReveals();
　　observeGreenHistory();
    // ★ 追加：緑カードの個別共有（自分宛）を受信
    observeGreenShare();
　　installDealViewerPinGuard();
　　observeGreenResult();
    // 装備所持の購読と描画
    observeEquipment();
    
    // ホスト設定UI
    hostGear.onclick = ()=>{
      hostPanel.classList.toggle('hidden');
    };

    btnStart.onclick = async ()=>{
      if (!state.isHost) return;
      await hostStartIfNotStarted();
      hostPanel.classList.add('hidden');
    };
    // カードビューア：外側クリックで閉じる
    dealViewer.addEventListener('click', (e)=>{
      if (e.target === dealViewer) show(dealViewer, false);
    });

    // ★ 同名引継ぎ（色／右下カード）
    try{
      await inheritBySameName();
    }catch(err){
      console.warn('inheritBySameName failed once', err);
    }
    // ★ onDisconnect が遅れて旧UIDが participants に残るケースへのフォロー
    setTimeout(()=>{ inheritBySameName().catch(()=>{}); }, 1200);

    state.joined = true;
  }



  // 離脱時
window.addEventListener('beforeunload', ()=>{
  // 1) すべての購読(onValue)を解除
  try {
    (state.unsub || []).forEach(fn => {
      try { typeof fn === 'function' && fn(); } catch {}
    });
  } catch {}

  // 2) 参加者リストから自分を削除（在室表示の掃除）
  try {
    if (state.joined) {
      remove(ref(db, `rooms/${state.code}/participants/${state.uid}`));
    }
  } catch {}
});


  btnJoin.onclick = join;

/* ← 追加：左長方形内タッチ中だけページスクロールを完全抑止 */
document.addEventListener('touchstart', (e)=>{
  const t = e.touches && e.touches[0];
  state.lockScrollOnRect = !!t && isInLeftRect(t.clientX, t.clientY);
}, { passive:true });

document.addEventListener('touchmove', (e)=>{
  if (state.lockScrollOnRect) e.preventDefault();   // iOS 対策：passive:false 必須
}, { passive:false });

document.addEventListener('touchend', ()=>{
  state.lockScrollOnRect = false;
}, { passive:true });

document.addEventListener('touchcancel', ()=>{
  state.lockScrollOnRect = false;
}, { passive:true });

  
  // 事前入力
  try{
    const qs = new URLSearchParams(location.search);
    const qRoom = (qs.get('room')||'').trim();
    const qName = (qs.get('name')||'').trim();
    if (qRoom) codeInput.value = qRoom.slice(0, 12);
    if (qName) nameInput.value = qName.slice(0, 1);
  }catch(_e){}
</script>
</body>
</html>
