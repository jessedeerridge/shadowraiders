<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>シャドウ・レイダーズ</title>
<style>
  :root { --gap:10px; }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fff;color:#111}
header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:8px;
  border-bottom:1px solid #eee;
  gap:8px;

  /* 追加：ヘッダーを最前面にしてモーダルより上に */
  position: sticky;     /* または relative でも可 */
  top: 0;               /* sticky の場合 */
  z-index: 2147483610;  /* .modal(2147483602)より上 */
  background: #fff;     /* モーダルの半透明黒の上でも可読に */
}
  h1{margin:0;font-size:18px}
  .small{font-size:14px;opacity:.85;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .copybtn{padding:4px 6px;border:1px solid #ddd;border-radius:10px;background:#f7f7f7;cursor:pointer}
  main{padding:14px;display:grid;gap:16px;max-width:980px;margin:0 auto}
  .join-box{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .join-box input{padding:10px;border:1px solid #ddd;border-radius:8px;font-size:16px}
  .btn{padding:10px 14px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}
  .hidden{display:none !important}

  /* 図形（②） */
  html,body{height:100%}
  #art{
    display:block;margin:auto;max-width:96vmin;height:auto;
    touch-action: none; /* ★ 追加：ブラウザのパン/ズーム既定動作を無効化 */
  }
  .shape{fill:transparent;stroke:transparent;stroke-width:0.8;stroke-linejoin:round;stroke-linecap:round}

  /* 左長方形内のユーザーアイコン（正方形＋角丸） */
  .usericon rect{fill:#fff;stroke:#111;stroke-width:0.8;rx:6;ry:6}
  .usericon text{font-size:12px;font-weight:700;dominant-baseline:middle;text-anchor:middle}
  .usericon{cursor:grab}
  .usericon.dragging{cursor:grabbing;opacity:.85}

  /* 右側の席アイコン（正方形＋角丸） */
  .seaticon rect{fill:#fff;stroke:#111;stroke-width:0.8;rx:6;ry:6}
  .seaticon text{font-size:12px;font-weight:700;dominant-baseline:middle;text-anchor:middle}

  /* 7部屋のヒット領域（通常は透明、クリック時だけフラッシュ） */
  .roomhit{fill:transparent;stroke:none;pointer-events:auto}
  .roomhit.flash{fill:#eee;transition:fill 60ms}

body {
  margin: 0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  background: url('back.jpg') no-repeat center center fixed;
  background-size: cover;  /* 画面全体に拡大・縮小 */
  color: #111;
}  
/* 山札UI（右図形の真下に横並び） */
.decks-wrap{display:flex;justify-content:flex-end}
.decks{
  display:flex;
  gap:16px;
  justify-content:flex-end;
  align-items:flex-start;
  margin-top:10px;   /* ← 元は -30px、正の値にして間隔を空ける */
  margin-right:24px;
}
  .deck{display:flex;flex-direction:column;align-items:center;gap:8px}
  .deck-back,.deck-face{
    width:80px;height:110px;border:1px solid #111;border-radius:6px;
    display:flex;align-items:center;justify-content:center;font-weight:700;color:#111;user-select:none;
  }
  .deck-back{cursor:pointer}
  .deck-back.disabled{opacity:.35;cursor:not-allowed;filter:grayscale(1)}
.deck-back.green{
  background: url('greendeck.jpg') center/cover no-repeat;
}
.deck-back.white{
  background: url('whitedeck.jpg') center/cover no-repeat;
}
.deck-back.black{
  background: url('blackdeck.jpg') center/cover no-repeat;
}
  .deck-label{font-size:12px;opacity:.8}
.deck-face.white{ background:#ffffff; color:#111; }
.deck-face.black{ background:#000000; color:#ffffff; }
.deck-face.green{ background:#005731; color:#111; }
.deck-count {
  font-size: 11px;
  opacity: 0.7;
}
.deck-back.blank {
  border: 2px dashed #999;  /* 点線の枠線 */
  background: transparent;  /* 背景透明 */
  color: transparent;       /* 文字も非表示 */
}

.deck-face.blank {
  border: 2px dashed #999;
  background: transparent !important;
  color: transparent !important;
}  
  /* ダイス欄 */
.dicebar{
  display:flex;
  gap:8px;
  align-items:center;
  margin-top:6px;
  justify-content:flex-end; /* 黒デッキの表と同じ右寄せ */
  margin-right:24px;        /* 黒デッキと同じ右余白 */
  flex-wrap:wrap;
}

.dicebar.large-players {
  display:flex;
  gap:8px;
  align-items:center;
  margin-top:50px;
  justify-content:flex-end; /* 黒デッキの表と同じ右寄せ */
  margin-right:24px;        /* 黒デッキと同じ右余白 */
  flex-wrap:wrap;
}

  .dicebtn{padding:8px 10px;border:1px solid #ddd;border-radius:10px;background:#fafafa;cursor:pointer}
  .diceres{font-weight:700}

  /* ホスト用 設定マーク（左下固定） */
#hostGear{position:fixed;left:14px;bottom:14px;z-index:2147483605;
  width:44px;height:44px;border-radius:50%;border:1px solid #ddd;background:#fff;box-shadow:0 4px 14px rgba(0,0,0,.12);
  display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:20px}

#hostPanel{position:fixed;left:66px;bottom:14px;z-index:2147483606;
  border:1px solid #111;border-radius:12px;background:#fff;box-shadow:0 6px 20px rgba(0,0,0,.16);
  padding:10px;display:flex;gap:10px;align-items:center}
  #hostPanel button{padding:8px 12px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}

/* 非ホスト向けヘルプ（左下の黒丸「？」） */
#helpBtn{
  position:fixed; left:14px; bottom:14px; z-index:2147483604;
  width:44px; height:44px; border-radius:50%;
  border:1px solid #111; background:#000; color:#fff;
  box-shadow:0 4px 14px rgba(0,0,0,.12);
  display:flex; align-items:center; justify-content:center;
  cursor:pointer; font-size:20px; font-weight:900; line-height:1;
}

/* 各部屋の上に出す点線枠のポップ（薄い灰・黒字、6文字ごと改行） */
.room-pop{
  position:fixed; z-index:2147483603;
  background:rgba(238,238,238,0.8); /* ← 半透明に変更 */
  color:#111;
  border:1px dashed #999; border-radius:10px;
  padding:6px 8px; font-size:12px; line-height:1.3; font-weight:700;
  white-space:pre-line;         /* \n を改行として表示 */
  pointer-events:none;          /* 下のUI操作を邪魔しない */
  transform:translate(-50%, -50%); /* 基準点：中央上 */
}
.room-pop.hidden{ display:none !important; }
  
  /* 汎用モーダル */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:2147483602}
  .modal-panel{background:#fff;border:1px solid #111;border-radius:14px;box-shadow:0 10px 26px rgba(0,0,0,.2);padding:16px}


#dealViewer .modal-panel{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
}

/* 念のため：カードの角でサブピクセルのにじみを抑える */
#dealViewer .deal-card{
  overflow: hidden;           /* 角丸の縁に白いにじみが出る場合の保険 */
}

   /* 色選択ポップ */
  #colorModal .color-grid{display:grid;grid-template-columns:repeat(5, 64px);gap:10px;justify-content:center}
  .color-tile{width:64px;height:64px;border:1px solid #111;border-radius:10px;position:relative;cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700}
  .color-tile .label{position:absolute;left:6px;bottom:4px;font-size:11px;background:rgba(255,255,255,.7);padding:1px 4px;border-radius:6px}
  /* ▼ 右下合計表示 */
#colorModal .color-grid .color-tile .label{
  display: none !important;
}
  #colorModal .color-foot{margin-top:8px;display:flex;justify-content:flex-end;font-size:12px;opacity:.8}
  .color-tile .owner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:20px;font-weight:900}
  .color-tile.mine{outline:3px solid #111}

  /* 自分用：配られたカード（右下に小さな黒裏） */
  #myDealMini{position:fixed;right:16px;bottom:16px;width:60px;height:90px;border-radius:10px;border:1px solid #000;background:#000;color:#fff;
    display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:2147483600}
#dealViewer .deal-card{
  width:240px;     /* ←固定幅 */
  height:360px;    /* ←固定高さ */
  border:1px solid #111;
  border-radius:14px;
  background:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:42px;
  font-weight:900;
  padding:20px;
  box-sizing:border-box; /* paddingを含めて計算 */
  text-align:center;     /* 文字が長くても中央寄せ */
  word-break:break-word; /* 長文は折り返す */
}



#dealViewer .deal-card.green-layout{
  display:flex;
  flex-direction:column;
  justify-content:flex-start; /* 上から詰める（テーブルは下に押し下げる） */
  gap:8px;
padding-top: 12px;
}

#dealViewer .deal-card.white-layout{
  display:flex;
  flex-direction:column;
  justify-content:flex-start;
  gap:0px;
  padding-top: 12px;
}

/* 拡大・黒カード用：上詰め */
#dealViewer .deal-card.black-layout{
  display:flex;
  flex-direction:column;
  justify-content:flex-start;
  gap:0;
  padding-top:12px;
}

#dealViewer .deal-card .green-table{
  width:100%;
  border-collapse:collapse;
  background:#eafbe6;          /* 薄い緑背景 */
  border:1px solid #a8d9a8;
  border-radius:8px;
  overflow:hidden;             /* 角丸を有効にするため */
}

#dealViewer .deal-card .green-table td{
  padding:8px 10px;
  font-size:15px;              /* ← 指定どおり20px */
  line-height:1.4;
  text-align:left;
}


#dealViewer .deal-card .green-title {
  font-size:20px;
  font-weight:900;
  text-align:center;

  /* ★ ここを追加 ★ */
  background:#000;        /* 黒いバー */
  color:#fff;             /* 白字（好みに応じて） */
  border:2px solid gold;  /* 金色の枠 */
  border-radius:6px;      /* 角を少し丸める */
  padding:4px 8px;        /* 余白 */
  display:inline-block;   /* 枠が文字に沿うように */
  width:90%;          /* 好きな割合やpx数に調整 */
  margin:0 auto;      /* 中央に配置 */
}

/* ▼ 白デッキカードのタイトル（緑と同じデザイン） ▼ */
#dealViewer .deal-card .white-title {
  font-size:20px;
  font-weight:900;
  text-align:center;

  background:#000;        /* 黒いバー */
  color: gold;                  /* 金色の文字 */
  border:2px solid gold;  /* 金枠 */
  border-radius:6px;
  padding:4px 8px;
  display:inline-block;
  width:90%;
  margin:0 auto;          /* 緑と同じ：中央寄せ、下余白なし */
}

#dealViewer .deal-card .white-table {
  width: 100%;
  background: #f2f2f2;     /* 薄グレー背景 */
  border: 2px solid #666;  /* 外枠：濃いグレー、太め */
  border-radius: 8px;
  border-collapse: separate;  /* ← collapseをやめる */
  border-spacing: 0;          /* 枠間隔をゼロに */
  overflow: hidden;
  /* 4行クランプ＋省略 */
  display: -webkit-box;

  overflow: hidden;
  text-overflow: ellipsis;

  /* 高さを4行分に固定 */
  height: 120px;       /* 8 * 1.25 * 4 */
  min-height: 120px;

  /* 縮み防止（縦フレックス内で潰れないように） */
  flex: 0 0 auto;


}

#dealViewer .deal-card .white-table td {
  padding:8px 10px;
  font-size:15px;          /* 緑と同じサイズ */
  line-height: 1.4;
  text-align: left;
}



/* ▼ 白カード：タイトルとテーブルの間に入れる画像 ▼ */
#dealViewer .deal-card .item-image{
  display:block;
  width:100%;
  max-height:180px;
  height:auto;
  margin:0px auto 0px;     /* タイトルとテーブルの間 */
  border:1px solid #666;   /* 濃いグレー枠 */
  border-radius:8px;
  object-fit:cover;        /* はみ出しをカットしつつフィット */
  border: none;       /* 枠を消す */

}


.condition {
  background:#000;
  color:#fff;
  padding:0px 2px;
  border-radius:2px;
  font-weight:bold;
}



  /* ホスト削除ポップ（既存） */
  .popover{
    position:fixed;z-index:2147483600;background:#fff;border:1px solid #111;border-radius:10px;
    padding:6px 10px;box-shadow:0 6px 16px rgba(0,0,0,.12);display:flex;gap:10px;align-items:center
  }
  .popover button{padding:6px 10px;border:1px solid #ddd;border-radius:10px;background:#111;color:#fff;cursor:pointer}


/* 小さい白カード（表）の2段レイアウト */
.deck-face[data-deck="white"][data-role="face"]{
  display:flex;
  flex-direction:column;
  justify-content:flex-start;  /* 上詰め */

  gap:0px;
  padding:3px;
  box-sizing:border-box;
  overflow:hidden;
}

.deck-face[data-deck="white"] .mini-title{
  font-weight: 700;
  font-size: 8px;
  line-height: 1.2;
  text-align: center;

  /* ▼ 黒バー＋金枠にする設定 */
  background: #000;             /* 黒背景 */
  color: gold;                  /* 金色の文字 */
  border: 2px solid gold;       /* 金色の枠線 */
  border-radius: 4px;           /* 少し角丸に（要らなければ消してOK） */
  padding: 2px 4px;             /* 内側余白 */
display: block;
  width: 100%;                /* カード幅いっぱいに広げる */
  box-sizing: border-box;     /* 枠線込みで100% */
}

.deck-face[data-deck="white"] .mini-effect {
  font-size: 7px;
  line-height: 1.25;

  background: #f9f9f9;         /* 内側の色（少し薄めのグレー） */
  border: 1px solid #ccc;      /* グレーの枠線を追加 */
  border-collapse: collapse;   /* テーブルっぽい感じに */
  border-radius: 4px;          /* 角丸は残すならそのまま */
  
  padding: 2px 4px;
  width: 100%;                 /* 枠いっぱいに広げる */
  box-sizing: border-box;

  overflow: hidden;
  display: -webkit-box;

  /* 4行クランプ＋省略 */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4;
  overflow: hidden;
  text-overflow: ellipsis;

  /* 高さを4行分に固定 */
  height: 40px;       /* 8 * 1.25 * 4 */
  min-height: 40px;

  /* 縮み防止（縦フレックス内で潰れないように） */
  flex: 0 0 auto;

}


.deck-face[data-deck="white"] .mini-image {
  width:90%;
  max-height:40px;
  margin:0 auto;
  object-fit:cover;
  border:none; border-radius:0;
}

#dealViewer .deal-card .black-table {
  width: 100%;
  background: #d3d3d3;     /* 黒ミニと同じ灰色 */
  border: 2px solid #666;
  border-radius: 8px;
  border-collapse: separate;
  border-spacing: 0;
  overflow: hidden;

  /* 4行クランプ＋省略 */
  display: -webkit-box;

  overflow: hidden;
  text-overflow: ellipsis;

  /* 高さを4行分に固定 */
  height: 120px;       /* 8 * 1.25 * 4 */
  min-height: 120px;

  /* 縮み防止（縦フレックス内で潰れないように） */
  flex: 0 0 auto;

}
#dealViewer .deal-card .black-table td {
  padding: 8px 10px;
  font-size: 15px;
  line-height: 1.4;
  text-align: left;
  color: #000;             /* 黒文字に固定 */
}

/* 小さい黒カード（表）の2段レイアウト —— 白と同じ */
.deck-face[data-deck="black"][data-role="face"]{
  display:flex;
  flex-direction:column;
  justify-content:flex-start;
  gap:0px;
  padding:3px;
  box-sizing:border-box;
  overflow:hidden;
}

.deck-face[data-deck="black"] .mini-title{
  font-weight:700;
  font-size:8px;
  line-height:1.2;
  text-align:center;
  background:#000;
  color:gold;
  border:2px solid gold;
  border-radius:4px;
  padding:2px 4px;
  display:block;
  width:100%;
  box-sizing:border-box;
}

.deck-face[data-deck="black"] .mini-effect{
  font-size:7px;
  line-height:1.25;
  background:#d3d3d3;
  color: #000;   /* ← ここで白文字を指定 */
  border:1px solid #ccc;
  border-radius:4px;
  padding:2px 4px;
  width:100%;
  box-sizing:border-box;
  overflow:hidden;
  display:-webkit-box;

  /* 4行クランプ＋省略 */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4;
  overflow: hidden;
  text-overflow: ellipsis;

  /* 高さを4行分に固定 */
  height: 40px;       /* 8 * 1.25 * 4 */
  min-height: 40px;

  /* 縮み防止（縦フレックス内で潰れないように） */
  flex: 0 0 auto;
}

.deck-face[data-deck="black"] .mini-image{
  width:90%;
  max-height:40px;
  margin:0 auto;
  object-fit:cover;
  border:none; border-radius:0;
}


/* 装備カード名の黒バー（金枠・金字） */
.equip-card .equip-title{
  display:block;
  width:93%;
  box-sizing:border-box;

  background:#000;          /* 黒バー */
  color:gold;               /* 金字 */
  border:2px solid gold;    /* 金枠 */
  border-radius:4px;
    padding:1px 2px;

  font-weight:900;
  font-size:8px;           /* 文字が長い想定で控えめ */
  line-height:1.15;
  text-align:center;

  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;

    border-width:1px;
 flex: 0 0 auto; 
}


.equip-card{
  width:60px; height:86px;         /* ← デスクトップのカードサイズに合わせる */
  border:1px solid #111; border-radius:6px;
  display:flex; align-items:center; justify-content:center;
  font-size:14px; font-weight:700;
  display: flex;           /* フレックス化（または既存の中央寄せを上書き） */
  flex-direction: column;  /* 上から縦積み */
  justify-content: flex-start; /* ← これで上詰め */
  padding-top: 2px;        /* 好みで余白。不要なら削除 */}

/* 装備一覧のカード画像 */
.equip-card .equip-image {
  display: block;
  width: 90%;             /* カード枠に収める */
  max-height: 30px;       /* 高さ制限（好みに調整） */
  margin: 0px auto;       /* タイトルの下に少し余白 */
  border: 1px solid #666; /* 枠線（必要なければ削除） */
  border-radius: 4px;     /* 角丸 */
  object-fit: cover;      /* はみ出しをカット */
  border: none;        /* ← 枠線を消す */
  border-radius: 0;    /* ← 角丸を消す */
}

/* === 役職カード拡大：レイアウト === */
#dealViewer .deal-card.role-layout{
  display:flex; flex-direction:column;
  justify-content:flex-start; gap:10px; padding:12px 14px;
  background:#fff; color:#111;
  display:flex;
  align-items:flex-start;      /* ← 上に詰める（中央→上） */
  justify-content:flex-start;  /* ← 左に詰める（中央→左） */
  padding:0 !important;        /* ← カード内の20pxパディングも消す */
}

/* 上段：左に丸（イニシャル＋下に陣営）、右に英名の残り（黒バー金字） */
.role-row{
  display:flex;
  align-items:flex-start;   /* 上に */
  justify-content:flex-start; /* 左に */
  gap:4px;
}

.role-initial{
  top:4px;    /* 上から4px下げる */
  left:4px;   /* 左から4px右へずらす */
  width:40px;
  height:40px;
  border-radius:50%;
  display:flex; align-items:center; justify-content:center;
  font-weight:900; font-size:20px; color:#000;
  border:2px solid #111;
  position:relative;
  margin:0;
  font-size:30px;   /* ← 20px → 26px にアップ（文字だけ大きく） */
  align-self:flex-start;  /* 左上端に固定 */
  border:2px solid gold;  
}
.role-faction{
  position:absolute;
  left:50%; transform:translateX(-50%);
  bottom:-14px;
  font-size:10px; font-weight:700; color:#111;
  white-space:nowrap; 
  color:gold; 
}


.role-center{
  position:relative;   /* ← ここを基準にする */
  display:flex;
  justify-content:flex-start; /* 名前は左寄せ */
  margin-top:150px;
  width:100%;
}


.role-rest{
  background:#000; color:gold; border:2px solid gold; border-radius:6px;
  padding:5px 12px; font-weight:900; font-size:20px; line-height:1;
  white-space:nowrap; max-width:120px; overflow:hidden; text-overflow:ellipsis;
  margin-top:10px;   /* ← 円より下げる量（お好みで 8px～16px） */
  margin-left:-28px;  /* ← 左に寄せたいならマイナス値で円に近づける */
}
/* 中段：カタカナ名（黒バー金字）と右のHP丸（こげ茶＋金字太字） */
.role-center{display:flex; align-items:center; justify-content:center; gap:10px
  margin-top:60px;   /* ← ここで全体を下げる */
}

.role-name{
  background:#000; color:gold; border:2px solid gold; border-radius:8px;
  padding:5px 12px;
 font-weight:900; font-size:22px; line-height:1;
  display:inline-block; max-width:70%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
width:77%; 
  max-width: none; 
 text-align:left;
}

.role-hp{
  position:absolute;
  width:56px; height:56px; border-radius:50%;
  background:#5a4032; /* こげ茶 */
  display:flex; align-items:center; justify-content:center;
  border:2px solid #3b2a20;
  width:40px;   /* ← 小さくする (元56px) */
  height:40px;
margin-right:7px;
 right:0px; 

}
.role-hp span{
  color:gold; font-weight:900; font-size:28px; line-height:1;
}

/* 陣営ごとの丸の塗りつぶし色（丸＝イニシャルの背景） */
.role-initial.citizen{ background:#e3ed1c; }  /* シチズン＝黄色 */
.role-initial.raider { background:#9e0d0d; }  /* レイダー＝赤   */
.role-initial.shadow { background:#3d3b80; }  /* シャドウ＝青   */







/* 正体カード用テーブル */
.role-table {
  width: 90%;
height: 90px;   
  border-collapse: collapse;
  border-radius: 8px;
  margin: 0px auto 0;
  font-size: 12px;
  text-align: left;
  overflow: hidden;
 color: #000; 
  margin-top: -5px; 
}
.role-table td {
  padding: 6px 8px;
  font-weight: 700;
 color: #000; 
  line-height: 1.5;   /* ← 行間を追加 */

}
.role-table.raider { background: pink; }
.role-table.shadow { background: lightblue; }
.role-table.citizen { background: #fff9c4; } /* 薄い黄色 */




@media (max-width:600px){
.role-center{
  position:relative;   /* ← ここを基準にする */
  display:flex;
  justify-content:flex-start; /* 名前は左寄せ */
  margin-top:100px;
  width:100%;}

.role-table {
  margin: 0px auto 0;
  width: 85%;
height: 70px;
   
}


 .role-initial{
    width: 28px;
    height: 28px;
    font-size: 18px;     /* 文字サイズ */
    top: 2px;            /* さらに上へ */
    left: 2px;
    border-width: 2px;
 z-index: 2; 
  }
  .role-faction{
    bottom: -12px;       /* 円の下の陣営ラベルも調整 */
    font-size: 7px;
  }

  /* ② イニシャル後（右側バー＝英名）のフォント小さく＆バーを細く */
  .role-rest{
    font-size: 14px;     /* フォント小さく */
    padding: 4px 8px;    /* バーを“細く”見せる（高さを抑える） */
    line-height: 1;
    margin-top: 6px;     /* 円より少し下げる量を控えめに */
    max-width: 100px;    /* 端末幅でつぶれない程度に */
   margin-left: -20px;      /* ← 円に“食い込むように”左寄せ */
    position: relative;
 z-index: 1;   }

  /* ③ 「名前」バーのフォント小さく＆全体を上へ */
  .role-center{
    margin-top: 40px;    /* 既存の100px→さらに上へ（上寄せ） */
  }
  .role-name{
    font-size: 16px;     /* 名前の文字を小さく */
    padding: 4px 8px;    /* バーの高さを控えめに */
    width: 70%;
   margin-left: 7px; 
   margin-top: 45px;
  }

  /* ④ HPの円を上に＆小さく＆フォントも小さく */
  .role-hp{
    width: 32px;
    height: 32px;
    top: 40px;           /* 上方向へ寄せる（.role-center が position:relative） */
    right: 0px;          /* 既存位置を維持しつつ微調整 */
    border-width: 2px;
  }
  .role-hp span{
    font-size: 20px;
  }

  /* （必要なら）正体テーブルも少しだけ詰める */
  .role-table{
    width: 92%;
    margin: 4px auto 0;
    font-size: 10px;
 margin-top: -5px; 
  }


}


/* ▼ 装備一覧：正体カードのミニ版（拡大レイアウトの縮小） */
.equip-card.role-mini{
  position: relative;
  width: 63px;
  height: 90.3px;
  border-radius: 6px;
  overflow: hidden;
  padding: 2px;
  box-sizing: border-box;
  display: block;              /* 子を自由配置 */
  background-size: cover;      /* 背景＝カード名.jpg を全面に */
  background-position: center;
}

/* 枠色：役職ごと */
.equip-card.role-mini.raider  { border: 2px solid #9e0d0d; } /* 赤 */
.equip-card.role-mini.shadow  { border: 2px solid #3d3b80; } /* 青 */
.equip-card.role-mini.citizen { border: 2px solid #e3ed1c; } /* 黄 */

/* 上段：イニシャル丸＋右に英名バー（縮小） */
.role-mini .mini-row-top{
  position: absolute; left: 2px; right: 2px; top: 0px; height: 14px;
  display:flex; align-items:center; gap: 2px;
}
.role-mini .mini-initial{
  width: 9px; height: 9px; border-radius: 50%;
  display:flex; align-items:center; justify-content:center;
  font-size: 6px; font-weight: 900; line-height:1;
  border: 1px solid gold; color:#000; background:#fff;
margin-top: 0; 
  z-index: 1;  
}
.role-mini.raider  .mini-initial{ background:#9e0d0d; color:#fff; }
.role-mini.shadow  .mini-initial{ background:#3d3b80; color:#fff; }
.role-mini.citizen .mini-initial{ background:#e3ed1c; color:#111; }

.role-mini .mini-rest{
 width: auto;  
margin-top: 0; 
  background:#000; color:gold;
  border:1px solid gold; border-radius:3px;
  font-size:6px; font-weight:900; line-height:1.1;
  padding:1px 2px; text-align:center;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  margin-left: -8.6px; 
  z-index: 0;  
}

/* 中段：名前バー＋HP丸（右寄せ） */
.role-mini .mini-center{
  position:absolute; left:2px; right:2px; top: 22px; height: 18px;
  display:flex; align-items:center;
}
.role-mini .mini-center{
  top: 28px;          /* ← ここを大きくすると “さらに下へ” 下がる（例: 56〜70px） */
  height: 28px;       /* お好みで */
  z-index: 3;         /* テーブルより前面に */
}


.role-mini .mini-name{
  flex:1 1 auto;
  background:#000; color:gold;
  border:1px solid gold; border-radius:4px;
  font-size:7px; font-weight:900; line-height:1.1;
  padding:1px 2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  text-align:left;
 width: 90%;       /* ← デフォルトflexで70%前後 → 長く */
  padding: 1px 2px; 
 z-index: 3;  
}

@media (max-width:600px){ 
.role-mini .mini-name{
  font-size:6px; 
  border-top-left-radius: 0 
  border-bottom-left-radius: 0 
  border-top-right-radius: 4px 
  border-bottom-right-radius: 4px 

}
}


.role-mini .mini-hp{
 position: absolute;
  right: 0px;
  width:16px; height:16px; border-radius:50%;
  background:#5a4032; border:1px solid #3b2a20;
  display:flex; align-items:center; justify-content:center;
  z-index: 4;  
}
.role-mini .mini-hp span{
  color:gold; font-weight:900; font-size:10px; line-height:1;
}

/* 下段：効果テーブル（色は役職ごと・4行クランプ） */
.role-mini .mini-table{
  position:absolute; left:2px; right:2px; bottom:2px; top: 50px;
  border-radius:4px; padding:2px 3px; font-size:6px; line-height:1.25;
  overflow:hidden; display:-webkit-box; -webkit-box-orient:vertical; -webkit-line-clamp:4;
  text-overflow:ellipsis; color:#000; box-sizing:border-box;
z-index: 1;  
}
.role-mini.raider  .mini-table{ background:pink; }
.role-mini.shadow  .mini-table{ background:lightblue; }
.role-mini.citizen .mini-table{ background:#fff9c4; }



@media (max-width:600px){ /*スマホサイズ*/
  .deck-face[data-deck="black"][data-role="face"]{ gap:1px; padding:2px; }
  .deck-face[data-deck="black"] .mini-title{ font-size:7px; padding:1px 2px; border-width:1px; }
  .deck-face[data-deck="black"] .mini-effect{ font-size:6px; -webkit-line-clamp:5; padding:1px 2px; }
  .deck-face[data-deck="black"] .mini-image{ max-width:70%; max-height:28px; margin:1px auto; }


  .deck-back,.deck-face{width:60px;height:86px}
  .color-tile{width:44px;height:44px}
  #hostGear{width:36px;height:36px;font-size:16px}
  #myDealMini{width:40px;height:60px;font-size:12px}
  h1{font-size:14px; margin-right:4px;}   /* タイトル小さめ */
  header{gap:4px; padding:8px;}          /* スペース縮小 */
  .small{font-size:8px; gap:4px;}       /* 補助テキストをさらに小さく */
  #myRoomBadge{white-space:nowrap;}  

 #headerInfo{flex-wrap:nowrap;}         /* ボタン類も折り返し防止 */  
  #dealViewer .deal-card{ width:180px; height:260px; font-size:15px; }
  #dealViewer .deal-card .green-table td { font-size: 11px;   /* モバイル時は小さめ */}

#dealViewer .deal-card .green-title {
  display:block; width:100%; box-sizing:border-box; margin:0;
  padding-left:8px; padding-right:8px; /* 余白で見た目を絞る */
}
#dealViewer .deal-card.green-layout{padding-top: 8px;
    gap: 5px;   }


  #greenSharePopup .list {
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 8px;  }
  #dealViewer .deal-card .green-title {    font-size: 12px;   /* 小さくする */  }

  #greenSharePopup .modal-panel {
    /* 横方向にはみ出さないように */
    width: 92vw;          /* 画面幅の92%以内 */
    max-width: 520px;     /* 上限（PCと共通感覚） */
    box-sizing: border-box;
    max-height: 80vh;     /* 縦にも収める */
    overflow: auto;       /* 多すぎるときはスクロール */  }
  
#dealViewer .deal-card .white-title {
font-size: 12px; 
  display:block; width:100%; box-sizing:border-box; margin:0;
  padding-left:5px; padding-right:5px; /* 余白で見た目を絞る */
}

#dealViewer .deal-card .white-table td {font-size:12px;          /* 緑と同じサイズ */}

#dealViewer .deal-card .black-table td {
font-size:12px; 
}

.deck-face[data-deck="white"][data-role="face"]{
  gap:1px;
  padding:2px;}


  /* タイトルバー */
  .deck-face[data-deck="white"] .mini-title {
    font-size: 7px;      /* ← 小さく */
    padding: 1px 2px;    /* ← 内側余白を減らす */
    border-width: 1px;   /* ← 枠線を細くする */
  }

  /* 効果欄 */
  .deck-face[data-deck="white"] .mini-effect {
    font-size: 6px;      /* ← 文字をさらに小さく */
    -webkit-line-clamp: 5; /* ← 行数制限を短く */
    padding: 1px 2px;
  }

  /* 画像 */
  .deck-face[data-deck="white"] .mini-image {
    max-width: 100%;   /* ← 横幅を縮小 */
    max-height: 30px; /* ← 高さを制限 */
    margin: 1px auto;
  }

  .deck-face[data-deck="black"] .mini-image {
    max-width: 100%;   /* ← 横幅を縮小 */
    max-height: 30px; /* ← 高さを制限 */
    margin: 1px auto;  }


  .equip-card{ font-size:8px;}

  .equip-card .equip-title{
    font-size:7px;
    border-width:1px;
    padding:1px 2px;

  }

/* 外枠 */
.deck-face[data-deck="white"][data-role="face"],
.deck-face[data-deck="black"][data-role="face"] {
  gap: 0;        /* スマホで復活する 1px を潰す */
}

/* タイトルと効果欄の上下余白を削除 */
.deck-face[data-deck="white"] .mini-title,
.deck-face[data-deck="white"] .mini-effect,
.deck-face[data-deck="black"] .mini-title,
.deck-face[data-deck="black"] .mini-effect {
  margin: 0;
  padding-top: 0;
  padding-bottom: 0;
}

/* 画像の上下マージンを削除 */
.deck-face[data-deck="white"] .mini-image,
.deck-face[data-deck="black"] .mini-image {
  margin: 0;
}


#dealViewer .deal-card .black-table {
  text-overflow: ellipsis;
  height: 70px;       /* 8 * 1.25 * 4 */
  min-height: 70px;
  /* 縮み防止（縦フレックス内で潰れないように） */
  flex: 0 0 auto;
}
#dealViewer .deal-card .white-table {
  text-overflow: ellipsis;
  height: 70px;       /* 8 * 1.25 * 4 */
  min-height: 70px;
  /* 縮み防止（縦フレックス内で潰れないように） */
  flex: 0 0 auto;
}


}/*スマホここまで*/



/* === トップ順アイコン === */
.top-icons{
  display:flex; justify-content:center; gap:10px;
  margin:8px 0 6px;
}
.top-icon{
  width:26px; height:26px; border-radius:8px; border:1px solid #111;
  display:flex; align-items:center; justify-content:center;
  font-weight:900; user-select:none;
  transform:scale(1); transition:transform 160ms ease;
  position:relative;
}


.top-icon.active{ transform:scale(1.5); z-index:1; }

dicebar{
  display:flex;
  gap:8px;
  align-items:center;
  margin-top:6px;
  justify-content:flex-start;  /* ← 左寄せに変更 */
  margin-right:24px;
  flex-wrap:wrap;
}

#topIconBar{
  margin-left:0;        /* 左寄せしたのでマイナスmarginは不要 */
  margin-right:60px;     /* サイコロとの間に少し余白を入れる */
}

@media (max-width:600px){
  .top-icon{ width:20px; height:20px; }
}



/* ▼ 装備一覧：効果テーブル（白/黒） */
.equip-card .equip-table{
  width: 92%;
  margin: 2px auto 0;
  border-collapse: separate;
  border-spacing: 0;
  border-radius: 4px;
  overflow: hidden;

  /* 4行クランプ＋省略 */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4;
  overflow: hidden;
  text-overflow: ellipsis;

  /* 高さを4行分に固定 */
  height: 40px;       /* 8 * 1.25 * 4 */
  min-height: 40px;

  /* 縮み防止（縦フレックス内で潰れないように） */
  flex: 0 0 auto;

}
.equip-card .equip-table.white{
  background: #f2f2f2; /* 白ミニのトーンに合わせる */
  border: 1px solid #ccc;
}
.equip-card .equip-table.black{
  background: #d3d3d3; /* 黒ミニのトーンに合わせる */
  border: 1px solid #999;
}
.equip-card .equip-table td{
  padding: 2px 3px;
  font-size: 6px;     /* ← 指定どおり 8px */
  line-height: 1.25;
  color: #000;
  text-align: left;
}


/* ▼ 装備所持エリア（通常フロー） */
.equipbar{
  display:flex; gap:12px; flex-wrap:wrap; align-items:center;
  background:#fff; border:1px solid #111; border-radius:12px; padding:8px 10px;
  margin-top:12px;           /* 山札との間に余白 */
  background: url('gear.jpg') center/cover no-repeat;

}
/* ▼ 緑カード履歴（装備とは独立して常時表示） */
#greenHistory{
  margin-top:10px;
  border:1px solid #111;
  border-radius:12px;
  padding:8px 10px;
  background:#fff;
  max-height:140px;     /* 必要に応じて調整 */
  overflow:auto;
  font-size:12px;
  line-height:1.4;
  display: flex;
  flex-direction: column-reverse;
}
/* ★ 追加：中身が空（白紙）のときは表示しない */
#greenHistory:empty{
  display:none !important;
}
#greenHistory .row{
  display:flex; gap:8px; align-items:center;
  padding:4px 0; border-bottom:1px dashed #ddd;
}
#greenHistory .row:last-child{ border-bottom:none; }

#greenHistory .tag{ font-weight:700; }
  
/* ▼ 緑カードQ&A履歴 */
.history{
  background:#fff; border:1px solid #111; border-radius:12px;
  padding:8px 10px; margin-top:10px; font-size:12px;
}
.history-item{ display:flex; gap:6px; align-items:center; padding:2px 0; }
.history-item .q{ font-weight:700; }
.history-item .sep{ opacity:.6; }

/* 所持者1人分のボックス */
.equip-holder{
  display:flex; gap:8px; align-items:center;
  padding:6px 8px; border:1px solid #ddd; border-radius:10px;
}

/* 所持者の色付き小アイコン（名前1文字） */
.equip-icon{
  width:24px; height:24px;
  border:1px solid #111; border-radius:6px;
  display:flex; align-items:center; justify-content:center; font-weight:700;
}

/* 装備カード：サイズを“カードと同じ”に合わせる */

.diceimg{
  width:65px;       /* 必要に応じて調整 */
  height:auto;
  cursor:pointer;
  user-select:none;
  image-rendering:-webkit-optimize-contrast;
}

  
/* 1) インライン transform を殺して“見かけの余白”を退治 */
#dealViewer .deal-card.white-layout .item-image{
  transform: none !important;
}

/* 2) wrapper 内の縦間隔も 0（.deal-card の gap だけでは足りない） */
#dealViewer .deal-card.white-layout > div{
  gap:0 !important;
  row-gap:0 !important;
}

/* 3) タイトル/セルの“内側の厚み”を上下だけ薄く（左右は維持） */
#dealViewer .deal-card.white-layout .white-title{
  display:block !important;
  padding-top:0 !important;
  padding-bottom:0 !important;
  line-height:1 !important;
}
#dealViewer .deal-card.white-layout .white-table td{
  padding-top:0 !important;
  padding-bottom:0 !important;
}

  
@media (max-width:600px){
  #dealViewer .deal-card.white-layout .white-title{
    padding-top:5px !important;
    padding-bottom:5px !important;
    line-height:1.2 !important;
  }


/* 所持者ボックス内のカードを折り返す */
.equip-holder{
  display: flex;
  flex-wrap: wrap;        /* ★ これを追加 */
  align-items: flex-start; /* 多段でも綺麗に揃える */
  gap: 8px;               /* 既存と同じでOK（row-gapを足しても可） */
  box-sizing: border-box; /* 幅計算の安定化 */
  max-width: 100%;        /* 親幅を超えない保険 */
}

/* カード幅は固定のまま“折り返しやすく” */
.equip-holder .equip-card{
  flex: 0 0 60px;         /* 幅60pxで折り返す（既存の width:60px を補強） */
}

/* スマホで段間の詰めを微調整（任意） */
@media (max-width:600px){
  .equip-holder{
    row-gap: 6px;         /* 段間を少し詰める（好みで） */
  }
}



/* 各部屋の上に出す点線枠のポップ（薄い灰・黒字、6文字ごと改行） */
.room-pop{
  position:fixed; z-index:2147483603;
  background:rgba(238,238,238,0.8);
  color:#111;
  border:1px dashed #999; border-radius:10px;
  padding:6px 8px; font-size:12px; line-height:1.3; font-weight:700;
  white-space:pre-line;
  pointer-events:none;
  transform:translate(-50%, -50%);
}
.room-pop.hidden{ display:none !important; }

/* ▼ ここから追加：ターン用ポップ（ベージュ + 太め点線） */
#turnPop{
  position:fixed;
  left:50%; top:72px;            /* ヘッダー下あたりに中央表示 */
  transform:translateX(-50%);
  z-index:2147483611;            /* ほぼ最前面（ヘッダーより上でもOKなら+） */
  background:#f5e6c8;            /* ベージュ */
  color:#111;
  border:2px dashed #9b8b6e;     /* 太め点線 */
  border-radius:12px;
  padding:10px 14px;
  font-weight:900;
  font-size:14px;
  box-shadow:0 6px 18px rgba(0,0,0,.12);
}
#turnPop.hidden{ display:none !important; }


#art { transform: translateY(-1px); }



/* 1列目=tag：幅を制限して中で折り返す（例：8em） */
#greenHistory .row > :nth-child(1){
  flex: 0 0 20em;               /* 固定ベース幅（調整可：7em～10emなど） */
  max-width: 20em;             /* 伸びすぎ防止（任意） */
  overflow-wrap: anywhere;     /* 長い語も折り返す */
  word-break: break-word;      /* 旧ブラウザ向け保険 */
}

.dice-pair{
  display:flex;
  gap:8px;           /* ダイス間の隙間。既存の .dicebar の gap と揃えてOK */
  flex:0 0 auto;     /* 伸縮させず、幅が無ければ行ごと折り返す */
  align-items:center;
}

/* topicons はスペースを優先的に使わせると、狭くなった時にダイス塊が下段へ落ちやすい */
#topIconBar{
  flex:1 1 auto;     /* 既存のマージン指定は残してOK。折り返し優先度だけ付与 */
  min-width:0;       /* 折り返し計算の保険 */
}


</style>
</head>
<body>
<header>
  <h1>シャドウ・レイダーズ</h1>
  <div class="small" id="headerInfo"></div>
<div class="small hidden" id="myRoomBadge">部屋：未選択</div>
</header>

<main>
  <!-- 入室 -->
  <section id="joinPanel" class="join-box">
    <input id="nameInput" placeholder="名前（1文字）" maxlength="1" inputmode="text" />
    <input id="codeInput" placeholder="ルームコード（例: 1234）" maxlength="12" inputmode="numeric" />
    <button id="btnJoin" class="btn">入室</button>
  </section>

  <!-- ルーム -->
  <section id="roomPanel" class="hidden">

    <div style="margin-top:0px;">

      <!-- 図形②：左に狭い長方形＋右に星形（中央六角形＋外周五角形6） -->
      <svg id="art" viewBox="-220 -230 440 460" aria-label="左に長方形・右に星形"></svg>
    </div>

    <!-- ▼ 右図形の真下：山札 -->
    <div class="decks-wrap"><div id="decks" class="decks" aria-label="山札（左から緑・白・黒）"></div></div>


    <!-- ダイス（左長方形の下／ローカル表示） -->
<div class="dicebar" id="diceBar">
  <div id="topIconBar" class="top-icons hidden" aria-label="ターン順アイコン"></div>

  <div class="dice-pair">
    <img id="roll6dImg" class="diceimg" src="6d1.png" alt="d6" role="button" />
    <img id="roll4dImg" class="diceimg" src="4d1.png" alt="d4" role="button" />
  </div>
</div>


  </section>
</main>


  <!-- 装備所持バー（※ 上に移動） -->
<div id="equipBar" class="equipbar hidden" aria-label="装備所持者一覧"></div>

<!-- 緑カードQ&A履歴 -->
<div id="greenHistory" aria-label="緑カードの履歴"></div>

<!-- ホスト設定マークとパネル -->
<button id="hostGear" class="hidden" title="設定">⚙️</button>
<div id="hostPanel" class="hidden">
  <span>ホスト設定</span>
  <button id="btnStart">スタート</button>
</div>

<!-- プレイヤーヘルプ（左下の黒丸「？」） -->
<button id="helpBtn" title="ヘルプ">？</button>
  
<!-- 自分用 ミニカード（配布後） -->
<div id="myDealMini" class="hidden" title="カードを開く"></div>

<div id="turnPop" class="hidden" aria-live="polite">YOUR TURN</div>
<audio id="turnSound" src="goblin.mp3" preload="auto"></audio>

<audio id="sfxDeck" src="cardopen.mp3" preload="auto"></audio>
<audio id="sfxDice" src="dice.mp3" preload="auto"></audio>
<audio id="sfxIcon" src="icontap.mp3" preload="auto"></audio>
<audio id="sfxTimer" src="timer.mp3" preload="auto" loop></audio>
<audio id="sfxRaider" src="raider.mp3" preload="auto"></audio>
<audio id="sfxShadow" src="shadow.mp3" preload="auto"></audio>
<audio id="sfxCitizen" src="citizen.mp3" preload="auto"></audio>

<!-- ☆ 修正：正体カード公開ポップ（黒背景、公開するのみ） -->
<div id="revealPopover" class="hidden"
     style="position:fixed; z-index:2147483607;
            background:#000; color:#fff;
            border-radius:10px; padding:12px 18px;
            box-shadow:0 4px 12px rgba(0,0,0,.4);
            display:flex; align-items:center; justify-content:center;">
  <button id="btnReveal"
          style="padding:10px 20px; border:none; border-radius:8px;
                 background:#fff; color:#000; font-weight:700; cursor:pointer;">
    公開する
  </button>
</div>

<!-- 奪うポップ -->
<div id="stealPopover" class="hidden"
     style="position:fixed; z-index:2147483607;
            background:#fff; color:#000;
            border:1px solid #111; border-radius:10px;
            padding:8px 12px; box-shadow:0 6px 16px rgba(0,0,0,.12);
            display:flex; align-items:center; justify-content:center;">
  <button id="btnSteal"
          style="padding:8px 14px; border:1px solid #ddd; border-radius:8px;
                 background:#111; color:#fff; font-weight:700; cursor:pointer;">
    奪う
  </button>
</div>


  
<!-- カード拡大ビューア -->
<div id="dealViewer" class="modal hidden" role="dialog" aria-modal="true">
  <div class="modal-panel">
    <div class="deal-card" id="dealCardFace">？</div>
  </div>
</div>


<!-- 色選択モーダル -->
<div id="colorModal" class="modal hidden" role="dialog" aria-modal="true">
  <div class="modal-panel">
    <h2 style="margin:0 0 12px;font-size:16px">色を選んでください。</h2>
    <div class="color-grid" id="colorGrid"></div>
    <div style="margin-top:10px;font-size:12px;opacity:.8">※スタートまで待ってください。</div>
    <!-- ▼ 追加：右下の合計表示 -->
    <div class="color-foot"><span id="colorCount">プレイヤー数：0</span></div>
  </div>
</div>


<!-- Firebase（v9 モジュール） -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, onValue, onDisconnect, remove, get, update, runTransaction, push,
  query, orderByChild, limitToLast
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  /* Firebase 設定 */
  const firebaseConfig = {
    apiKey: "AIzaSyASUJcPyybcD9q77XDatI5bCzZxDvsBH_o",
    authDomain: "shadowraiders-a2dbc.firebaseapp.com",
    projectId: "shadowraiders-a2dbc",
    storageBucket: "shadowraiders-a2dbc.firebasestorage.app",
    messagingSenderId: "577276689873",
    appId: "1:577276689873:web:9a13faf90c3d6a791e34f0",
    measurementId: "G-PKNEPDBVSS"
  };

  // --- 初期化 ---
  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // --- DOM ---
  const headerInfo    = document.getElementById('headerInfo');
  const myRoomBadge   = document.getElementById('myRoomBadge');
  const joinPanel     = document.getElementById('joinPanel');
  const nameInput     = document.getElementById('nameInput');
const savedName = localStorage.getItem("playerName");
if (savedName) {
  nameInput.value = savedName;
}

// --- 入力時に保存 ---
nameInput.addEventListener("input", () => {
  localStorage.setItem("playerName", nameInput.value);
});
  const codeInput     = document.getElementById('codeInput');
  const btnJoin       = document.getElementById('btnJoin');
  const roomPanel     = document.getElementById('roomPanel');
  const decksEl       = document.getElementById('decks');
const roll4dImg     = document.getElementById('roll4dImg'); // ← 新規
const roll6dImg     = document.getElementById('roll6dImg'); // ← 新規

// ---- d6 画像クリックでアニメ→結果表示 ----
const sixDAnimFrames = ['6da1.png','6da2.png','6da3.png'];
let sixDRolling = false;

// プリロード
[...sixDAnimFrames,'6d1.png','6d2.png','6d3.png','6d4.png','6d5.png','6d6.png'].forEach(src=>{
  const img=new Image(); img.src=src;
});

function play6dAnimationThenResult(){
  if (sixDRolling) return;
  sixDRolling = true;

  const start = Date.now();
  let idx = 0;

  const iv = setInterval(()=>{
    roll6dImg.src = sixDAnimFrames[idx % sixDAnimFrames.length];
    idx++;
    if (Date.now() - start >= 500){ // 1秒
      clearInterval(iv);
      const result = 1 + Math.floor(Math.random() * 6);
      roll6dImg.src = `6d${result}.png`;
      sixDRolling = false;
    }
  },80);
}

if (roll6dImg){
  if (!roll6dImg.getAttribute('src')) roll6dImg.src = '6d1.png';
  roll6dImg.addEventListener('click', rollBothDice);
}

  
// ---- d4 画像クリックでアニメ→結果表示 ----
const fourDAnimFrames = ['4da1.png','4da2.png','4da3.png']; // アニメ用
let fourDRolling = false;

// 画像プリロード（任意）
[...fourDAnimFrames, '4d1.png','4d2.png','4d3.png','4d4.png'].forEach(src=>{
  const img = new Image(); img.src = src;
});

function play4dAnimationThenResult(){
  if (fourDRolling) return; // 連打防止
  fourDRolling = true;

  const start = Date.now();
  let idx = 0;

  // 高速で3枚を入れ替え（約80ms間隔）
  const iv = setInterval(()=>{
    roll4dImg.src = fourDAnimFrames[idx % fourDAnimFrames.length];
    idx++;
    if (Date.now() - start >= 500){ // 1秒経過で停止
      clearInterval(iv);

      // 1～4 の結果をランダム表示（4d1.png ～ 4d4.png）
      const result = 1 + Math.floor(Math.random() * 4);
      roll4dImg.src = `4d${result}.png`;

      fourDRolling = false;
    }
  }, 80);
}

if (roll4dImg){
  // 初期画像（安全のため再設定：タイプミス防止）
  if (!roll4dImg.getAttribute('src')) roll4dImg.src = '4d1.png';
  roll4dImg.addEventListener('click', rollBothDice);
}

// ---- 同時起動ハンドラ（連打ロックつき）----
let bothRolling = false;
function rollBothDice(){
  if (bothRolling) return;
  bothRolling = true;

  // 全員で同じ時刻に始めるため少し先の時刻を指定
  const startAt   = Date.now() + 200;   // 200ms後にスタート
  const dur6      = 500;               // d6アニメ 1000ms
  const dur4      = 500;                // d4アニメ  500ms
  const result6   = 1 + Math.floor(Math.random() * 6);
  const result4   = 1 + Math.floor(Math.random() * 4);
  const payload = {
    startAt, dur6, dur4, result6, result4,
    roller: state.uid,
    nonce: crypto.randomUUID()
  };

  // DBへ「現在のロール」を書く（※上書きでOK）
  set(ref(db, `rooms/${state.code}/dice/current`), payload)
    .catch(e => console.error('dice write failed', e))
    .finally(()=>{ setTimeout(()=>{ bothRolling = false; }, 1200); });
}


  

  const hostGear      = document.getElementById('hostGear');
  const hostPanel     = document.getElementById('hostPanel');
  const btnStart      = document.getElementById('btnStart');
const helpBtn   = document.getElementById('helpBtn');

if (helpBtn) helpBtn.classList.add('hidden'); // 最初はクラスで隠す

const mo = new MutationObserver(() => {
  const joined = !roomPanel.classList.contains('hidden');
  helpBtn.classList.toggle('hidden', !joined);
});
mo.observe(roomPanel, { attributes: true, attributeFilter: ['class'] });
  
  const colorModal    = document.getElementById('colorModal');
  const colorGrid     = document.getElementById('colorGrid');

  const myDealMini    = document.getElementById('myDealMini');
  const dealViewer    = document.getElementById('dealViewer');
  const dealCardFace  = document.getElementById('dealCardFace');

// --- 状態 ---
const state = {
  uid: crypto.randomUUID(),
  name: "",
  code: "",
  joined: false,
  unsub: [],
  rectBBox: null,
  draggingUid: null,
  isPointerDown: false,
  dragOffset: {x:0,y:0},
  isHost: false,
  started: false,
  lockScrollOnRect: false,   // ← 追加：左長方形内タッチ中はスクロール禁止
  localMoveVer: {},          // ★ 追加：自分の移動バージョン管理（uid→ver）
  dragSettleGuardUid: null,  // ★ 追加：ドロップ直後のエコー抑止
  dragSettleGuardUntil: 0,   // ★ 追加：抑止の期限(ms)
  deckClicksLeft: 0,         // ★ 追加：ダイス後に山札（裏）をめくれる残回数（ローカル）
};


  // --- ユーティリティ ---
  // --- ユーティリティ ---
  function randomLetter(){ return String.fromCharCode(65 + Math.floor(Math.random()*26)); }
  function random4(){ return String(Math.floor(Math.random()*10000)).padStart(4, '0'); }
  const NAME_RE = /^[A-Za-z\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]$/;
  function normalizeName(raw){
    const t = (raw || "").trim(); if (!t) return randomLetter();
    const c = t[0]; return NAME_RE.test(c) ? c : randomLetter();
  }
  function show(el, yes){ el.classList.toggle('hidden', !yes); }
function playSfx(id){
  try{
    const a = document.getElementById(id);
    a && a.play && a.play().catch(()=>{});
  }catch(e){}
}


// ===== [SFX-UTIL] 全員同期再生ユーティリティ =====
let lastSfxNonce = null;

/** at(UTC ms) に id の <audio> を再生（微ズレは setTimeout で吸収） */
function scheduleSfxAt(id, at, nonce){
  if (!id || !at) return;

  // 同じイベントの二重再生防止
  if (nonce && lastSfxNonce === nonce) return;
  lastSfxNonce = nonce || null;

  const a = document.getElementById(id);
  if (!a) return;

  try { a.pause && a.pause(); a.currentTime = 0; } catch(e){}
  const delay = Math.max(0, at - Date.now());
  setTimeout(()=>{ a.play && a.play().catch(()=>{}); }, delay);
}

/** 役職カード名 → 再生ID */
function roleCardToSfxId(cardName){
  if (!cardName) return null;
  if (ROLE_CARDS?.raider?.includes(cardName))  return 'sfxRaider';
  if (ROLE_CARDS?.shadow?.includes(cardName))  return 'sfxShadow';
  if (ROLE_CARDS?.citizen?.includes(cardName)) return 'sfxCitizen';
  return null;
}

// カード配色ユーティリティ（表・拡大・装備で共通使用）

// ★ 追加：緑カード用タイマー音
function startTimerSfx(){
  try{
    const a = document.getElementById('sfxTimer');
    if (!a) return;
    a.loop = true;
    a.currentTime = 0;
    a.play && a.play().catch(()=>{});
  }catch(e){}
}
function stopTimerSfx(){
  try{
    const a = document.getElementById('sfxTimer');
    if (!a) return;
    a.pause && a.pause();
    a.currentTime = 0;
  }catch(e){}
}



// --- YOUR TURN ポップ＆サウンド（ローカル専用） ---
function showYourTurnOnce(){
  const pop = document.getElementById('turnPop');
  if (!pop) return;
  pop.classList.remove('hidden');
  setTimeout(()=> pop.classList.add('hidden'), 1000);  // 1秒だけ表示

  const audio = document.getElementById('turnSound');
  // 自分のみ再生（サイレント失敗は無視）
  try { audio && audio.play && audio.play().catch(()=>{}); } catch(e){}
}

// 現在の参加者・色クレームから「ターン順リスト（uid昇順ではなく色取得時刻順）」を作る
function getTurnOrderList(){
  const present = state.present || {};
  const claims  = state.colorClaims || {};
  return Object.values(claims)
    .filter(v => v && v.uid && present[v.uid])
    .sort((a,b) => (a.at || 0) - (b.at || 0));
}


function applyDeckTheme(el, deckId){
  if (!el) return;
  // いったんリセット
  el.style.background = '';
  el.style.color = '';
  if (deckId === 'white'){ el.style.background = '#ffffff'; el.style.color = '#111'; }
  else if (deckId === 'black'){ el.style.background = '#000000'; el.style.color = '#fff'; }
  else if (deckId === 'green'){ el.style.background = '#005731'; el.style.color = '#111'; }
}





// 任意のカード名に対して dealViewer の見た目を適切に設定するヘルパ
function colorizeDealFaceByCardName(cardName){
  // まず完全リセット
  dealCardFace.style.background = '';
  dealCardFace.style.color = '';

  // 1) デッキ出自（装備カードなど）：白／黒／緑
  if (DECKS_DEF.white.cards.includes(cardName)) {
    applyDeckTheme(dealCardFace,'white');
    return;
  }
  if (DECKS_DEF.black.cards.includes(cardName)) {
    applyDeckTheme(dealCardFace,'black');
    return;
  }
  if (DECKS_DEF.green.cards.includes(cardName)) {
    applyDeckTheme(dealCardFace,'green');
    return;
  }

  // 2) 正体カード：役職ごとの3色
  if (ROLE_CARDS.shadow.includes(cardName)) {
    dealCardFace.style.background = '#3d3b80'; // シャドウ＝青
    dealCardFace.style.color = '#fff';
    return;
  }
  if (ROLE_CARDS.raider.includes(cardName)) {
    dealCardFace.style.background = '#9e0d0d'; // レイダー＝赤
    dealCardFace.style.color = '#fff';
    return;
  }
  if (ROLE_CARDS.citizen.includes(cardName)) {
    dealCardFace.style.background = '#e3ed1c'; // シチズン＝黄
    dealCardFace.style.color = '#111';
    return;
  }

  // 3) どれにも該当しない場合は白
  dealCardFace.style.background = '#fff';
  dealCardFace.style.color = '#111';
}

// === 追加：白カードの効果文を返す共通関数（表/拡大 両対応） ===
function getWhiteEffectText(cardName){
  const raw = String(cardName || '');
  // 空白・全角空白を除去してマッチの揺れを吸収
  const norm = raw.replace(/\s+/g, '');

  // 名前→効果文 の対応表（必要に応じて増やす）
  const TABLE = [
    { key: '銀のロザリオ',   text: 'ダイスの攻撃によって倒したPLの全ての装備を奪う。' },
    { key: '銀のロザリオ ',   text: 'ダイスの攻撃によって倒したPLの全ての装備を奪う。' },
    { key: '虹色のパラソル', text: '攻撃する代わりに攻撃レンジのPLに推理カードを渡す。' },
    { key: 'エクスカリバー', text: 'あなたがレイダーなら、攻撃ダメージが 2 上がる。' },
    { key: '神秘のコンパス', text: '移動の時にダイスを二回振って、選ぶことができる。' },
    { key: '幸運のブローチ', text: '市庁舎(8)の効果ダメージを受けない。' },
    { key: '賢者のローブ',   text: '与える攻撃ダメージ、受ける攻撃ダメージが 1 減少する。' },
    { key: 'いにしえの聖杯', text: '三つ目の黒犬,吸血コウモリ,呪いの人形の効果を受けない。' },
    { key: '光臨',           text: 'あなたがレイダーなら、全ダメージを回復する。' },
    { key: '守護天使',       text: '次の自分の手番の始めまで、攻撃ダメージを受けない。' },
    { key: '封印の知恵',     text: 'この手番の終了後、もう1手番を行う。' },
    { key: '応急手当',       text: '任意のPL（自分も可）を選び、そのPLのダメージを7にする。' },
    { key: '人魚の涙',       text: '最もダメージが多い人を 3 回復する。' },
    { key: '幸せのクッキー', text: 'あなたが A または U なら、HPを全回復する。' },
    { key: '闇を祓う鏡',     text: 'あなたがシャドウ陣営でウルリッヒでないなら、必ず正体カードを公開する。' },
    { key: 'いやしの聖水',   text: '自分のダメージを 2 回復する。' },
    { key: 'いやしの聖水 ',   text: '自分のダメージを 2 回復する。' },
    { key: 'いやしの聖水  ',   text: '自分のダメージを 2 回復する。' },
    { key: '裁きの閃光',   text: '自分以外のPL全員に 2 ダメージ与える。' },
    { key: '恩恵',           text: '自分以外のPLを選び、6面ダイスを振る。目の数回復する。' },
  ];

  // norm同士で部分一致（includes）を取りにいく
  for (const row of TABLE){
    const k = row.key.replace(/\s+/g, '');
    if (norm.includes(k)) return row.text;
  }
  return '';
}


// === 追加：黒カードの効果文を返す共通関数（表/拡大 両対応） ===
function getBlackEffectText(cardName){
  const raw = String(cardName || '');
  const norm = raw.replace(/\s+/g, ''); // 半角/全角スペース吸収

const TABLE = [
  { key:'サーベル',        text:'攻撃ダメージが 1 増加する。' },
  { key:'拳銃R',           text:'攻撃ダメージが 1 増加する。' },
  { key:'拳銃L',           text:'攻撃ダメージが 1 増加する。' },
  { key:'クロスボウガン',  text:'攻撃ダメージが 1 増加する。' },
  { key:'妖刀マサムネ',    text:'攻撃レンジのPLに必ず攻撃を行う。4面ダイスだけを使う。' },
  { key:'ガトリング',      text:'攻撃レンジのPL全員に攻撃する。' },
  { key:'死神スコープ',    text:'攻撃レンジが 1 増加する。' },
  { key:'死神スコープ　',  text:'攻撃レンジが 1 増加する。' }, // 全角スペース対策
  { key:'オリバーの子分',  text:'任意のPLを選んで、装備を1つ奪う。' },
  { key:'オリバーの子分 ', text:'任意のPLを選んで、装備を1つ奪う。' }, // 半角スペース対策
  { key:'オリバーの子分　',text:'任意のPLを選んで、装備を1つ奪う。' }, // 全角スペース対策
  { key:'吸血コウモリ',    text:'自分以外のPLに2ダメージ与える。' },
  { key:'吸血コウモリ ',   text:'自分以外のPLに2ダメージ与える。' },
  { key:'吸血コウモリ　',  text:'自分以外のPLに2ダメージ与える。' },
  { key:'三つ目の黒犬',    text:'自分と選んだPLに2ダメージ与える。' },
  { key:'三つ目の黒犬 ',   text:'自分と選んだPLに2ダメージ与える。' },
  { key:'暴動',            text:'ダイスを2つ振り、目のエリアにいるPL全員に3ダメージ与える。' },
  { key:'バナナの皮',      text:'装備を1つ誰かに渡す。なければ 1 ダメージ受ける。' },
  { key:'呪いの人形',      text:'PLを一人選び、6面ダイスを振る。1-4なら選んだPLに、5-6なら自分に3ダメージ与える。' },
  { key:'戦慄の闇儀式',    text:'あなたがシャドウなら、全回復する。' }
];

  for (const row of TABLE){
    const k = row.key.replace(/\s+/g,'');
    if (norm.includes(k)) return row.text;
  }
  return '';
}



// === 装備カードの拡大ビューを、白/黒の“表”と同じUIで描画する ===
function showEquipExpanded(cardName){

  // 右下の拡大用フェイスを初期化
  dealCardFace.className = 'deal-card';
  dealCardFace.innerHTML = '';

  dealCardFace.removeAttribute('style');

  dealCardFace.style.background = '';
  dealCardFace.style.color = '';
  colorizeDealFaceByCardName(cardName); 

  // 白/黒デッキ判定（装備カードは白 or 黒）
  const isWhite = Array.isArray(DECKS_DEF?.white?.cards) && DECKS_DEF.white.cards.includes(cardName);
  const isBlack = Array.isArray(DECKS_DEF?.black?.cards) && DECKS_DEF.black.cards.includes(cardName);

  // ラッパー
  const wrapper = document.createElement('div');
  wrapper.style.flex = '1';
  wrapper.style.display = 'flex';
  wrapper.style.flexDirection = 'column';

  // タイトル（既存の黒バー金枠スタイルを流用：white-title）
  const title = document.createElement('div');
  title.textContent = cardName;
  title.className = 'white-title';
  wrapper.appendChild(title);

  // 画像（<カード名>.jpg）。無ければ消す
  const img = document.createElement('img');
  img.className = 'item-image';
  img.alt = cardName;
  img.src = `${cardName}.jpg`;
  img.addEventListener('error', () => img.remove());
  wrapper.appendChild(img);

  // 効果テーブル
  const table = document.createElement('table');
  table.className = isWhite ? 'white-table' : 'black-table';
  const tr = document.createElement('tr');
  const td = document.createElement('td');
  td.textContent = isWhite ? getWhiteEffectText(cardName) : getBlackEffectText(cardName);
  tr.appendChild(td);
  table.appendChild(tr);
  wrapper.appendChild(table);

  // 白カードは既存の拡大レイアウト調整を適用
  if (isWhite) dealCardFace.classList.add('white-layout');
if (isBlack) dealCardFace.classList.add('black-layout');

  dealCardFace.appendChild(wrapper);
}



// カード名からjpg画像のパスを作る（例：「銀のロザリオ」→「銀のロザリオ.jpg」）
function makeWhiteImageSrc(name){
  const t = (name || '').trim();  // 空白や余計なスペースを削除
  return `${t}.jpg`;              // 同じフォルダに置いた場合
  // return `white_imgs/${t}.jpg`; // サブフォルダに置くならこちら
}

// 拡大カード共通クリック（文脈で分岐）
dealCardFace.addEventListener('click', ()=>{
  const ctx = state.expandedContext || null;
  const card = ctx?.cardName || '';                        // ← ここを変更
  if (!ctx || ctx.source !== 'equip') return;
  if (ctx.ownerUid === state.uid) return;
  if (!card || isRoleCard(card)) return;                   // ← cardName で判定

  const pop = document.getElementById('stealPopover');
  if (!pop) return;
  pop.classList.remove('hidden');

  const r = dealCardFace.getBoundingClientRect();
  pop.style.left = (r.left + r.width/2 - 60) + 'px';
  pop.style.top  = (r.top + r.height/2 - 25) + 'px';

  // 外側クリックで閉じる
  setTimeout(()=>{
    const onDocClick = (e)=>{
      if (pop.contains(e.target)) return;
      pop.classList.add('hidden');
      document.removeEventListener('click', onDocClick, true);
    };
    document.addEventListener('click', onDocClick, true);
  }, 0);
});


  const btnSteal = document.getElementById('btnSteal');
if (btnSteal){
 btnSteal.onclick = async ()=>{
  const ctx = state.expandedContext;
  if (!ctx || ctx.source !== 'equip') return;
  const card = ctx.cardName;                                // ← ここを変更
  if (!card || isRoleCard(card)) return;
  if (ctx.ownerUid === state.uid) return;

    try{
      const updates = {};
      updates[`rooms/${state.code}/equipment/${ctx.ownerUid}/${card}`] = null;
      updates[`rooms/${state.code}/equipment/${state.uid}/${card}`] = true;
      updates[`rooms/${state.code}/equipment_at`] = Date.now();
      await update(ref(db), updates);

      const pop = document.getElementById('stealPopover');
      if (pop) pop.classList.add('hidden');
      show(dealViewer, false);
      state.expandedContext = null;
    }catch(e){
      console.error('steal failed', e);
    }
  };
}

  
  // ===== 同名引継ぎ：旧UIDから「色」と「右下カード」を移す =====
  async function onlySelfHasThisName(){
    const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
    const ps = psSnap.val() || {};
    const same = Object.entries(ps).filter(([,v]) => (v?.name||'') === state.name);
    return same.length === 1 && same[0][0] === state.uid;
  }

  async function findOrphanUidBySameName(){
    const candidates = new Set();

    // colors から同名の旧UID候補
    const cSnap = await get(ref(db, `rooms/${state.code}/colors`));
    const colors = cSnap.val() || {};
    for (const [, claim] of Object.entries(colors)){
      if ((claim?.name||'') === state.name && claim?.uid && claim.uid !== state.uid){
        candidates.add(claim.uid);
      }
    }

    // deal/v1/cards から旧UID候補
    const dSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards`));
    const deal = dSnap.val() || {};
    for (const uid of Object.keys(deal)){
      if (uid !== state.uid) candidates.add(uid);
    }

    // participants に居ないUIDのみ（＝孤児）
    const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
    const ps = psSnap.val() || {};
    for (const oldUid of candidates){
      if (!ps[oldUid]) return oldUid;
    }
    return null;
  }

  async function inheritBySameName(){
    // 仕様：同名在室者が自分だけのときのみ発動
    if (!(await onlySelfHasThisName())) return;

    const oldUid = await findOrphanUidBySameName();
    if (!oldUid) return;

    const updates = {};

    // 色（colors）を自分に移す＋participants の color 反映
    const colorsRef = ref(db, `rooms/${state.code}/colors`);
    const cSnap = await get(colorsRef);
    const colors = cSnap.val() || {};
    for (const [colorId, claim] of Object.entries(colors)){
      if (claim?.uid === oldUid && (claim?.name||'') === state.name){
        // colors の所有者を自分に
        updates[`rooms/${state.code}/colors/${colorId}`] =
          { uid: state.uid, name: state.name, at: Date.now() };
        // 参加者にも色を保存（既存実装に合わせ label で保存）
        // ＊labelは曖昧になるので、厳密化したければ colorId を保存する実装に変えてOK
        const label = (COLOR_LIST.find(c => c.id === colorId)?.name) || colorId;
        updates[`rooms/${state.code}/participants/${state.uid}/color`] = label;
      }
    }

// 装備（equipment）
const oldEquipSnap = await get(ref(db, `rooms/${state.code}/equipment/${oldUid}`));
const myEquipSnap  = await get(ref(db, `rooms/${state.code}/equipment/${state.uid}`));
const oldEquip = oldEquipSnap.val();
const myEquip  = myEquipSnap.val();
if (oldEquip && !myEquip){
  updates[`rooms/${state.code}/equipment/${state.uid}`] = oldEquip;
  updates[`rooms/${state.code}/equipment/${oldUid}`] = null;
}

// 右下の最初の配布カード（myDeal）— 原子的に移管
await runTransaction(ref(db, `rooms/${state.code}/deal/v1/cards`), (cards) => {
  cards = cards || {};

  // すでに新UIDがカードを持っていたら何もしない
  if (cards[state.uid]) return cards;

  // 旧UID（孤児）のカードがあれば、新UIDへ移し替え（旧UID分は削除）
  if (cards[oldUid]) {
    cards[state.uid] = cards[oldUid];
    delete cards[oldUid];
  }
  return cards;
});



    if (Object.keys(updates).length){
      await update(ref(db), updates);
    }
  }



  // ===== ヘッダ表示・コピー =====
  function updateHeader(){
    headerInfo.innerHTML = '';
    const spanRoom = document.createElement('span');
    spanRoom.textContent = `コード：${state.code || '-'}`;
    const spanMe = document.createElement('span');
    spanMe.textContent = `あなた：${state.name || '-'}`;
    const btn = document.createElement('button');
    btn.className = 'copybtn';
    btn.textContent = 'リンクコピー';
    btn.onclick = ()=>{
      const url = new URL(location.href);
      url.searchParams.set('room', state.code);
      navigator.clipboard.writeText(url.toString());
      btn.textContent = 'コピー済み！';
      setTimeout(()=> btn.textContent='リンクコピー', 1200);
    };
    headerInfo.appendChild(spanRoom);
    headerInfo.appendChild(spanMe);
    headerInfo.appendChild(btn);
  }

  // === 図形②：左長方形＋右星形（7部屋ヒット領域付き） ===
  function drawFigure2(){
    const svg = document.getElementById('art');
    if (!svg) return;
    svg.innerHTML = '';
    const rt3 = Math.sqrt(3);

    // ---- パラメータ ----
const s0 = 48  // 62.4
const s1 = 82   // 106.6
const rectScale = 0.3;  // 幅を小さめに
    const gap = 20;

    function hexFlat(cx, cy, s){
      const h = (rt3/2)*s;
      return [
        [cx+s,   cy],
        [cx+s/2, cy+h],
        [cx-s/2, cy+h],
        [cx-s,   cy],
        [cx-s/2, cy-h],
        [cx+s/2, cy-h],
      ];
    }
    const add=(a,b)=>[a[0]+b[0],a[1]+b[1]];
    const sub=(a,b)=>[a[0]-b[0],a[1]-b[1]];
    const mul=(a,k)=>[a[0]*k,a[1]*k];
    const norm=(v)=>{ const L=Math.hypot(v[0],v[1])||1; return [v[0]/L,v[1]/L]; };
    function intersectRayRay(p,u,q,v){
      const A = [[u[0], -v[0]], [u[1], -v[1]]];
      const b = sub(q,p);
      const det = A[0][0]*A[1][1] - A[0][1]*A[1][0];
      const t = ( b[0]*A[1][1] - b[1]*A[0][1]) / det;
      return add(p, mul(u, t));
    }

    // 星本体（表示用）
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('id','star');
    svg.appendChild(g);

    function poly(pts, cls='shape', parent=g){
      const el = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      el.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
      el.setAttribute('class', cls);
      parent.appendChild(el);
      return el;
    }

    const H0 = hexFlat(0,0,s0);
    const H1 = hexFlat(0,0,s1);

    // 中央六角形（表示）
    poly(H0);

    // 外周五角形（表示）
    const pentPoints = [];
    for(let i=0;i<6;i++){
      const ip=(i+5)%6, inx=(i+1)%6, inx2=(i+2)%6;
      const a0=H0[i], b0=H0[inx], a1=H1[i], b1=H1[inx];
      const dirFromA1=norm(sub(H1[i],H1[ip]));
      const dirFromB1=norm(sub(H1[inx2],H1[inx]));
      const tip=intersectRayRay(a1,dirFromA1,b1,dirFromB1);
      const p = [a0,b0,b1,tip,a1];
      pentPoints.push(p);
      poly(p);
    }

    // 左の長方形
    const starBox = g.getBBox();
const rectH = starBox.height + 85
  const rectW = 160
    const rectX = starBox.x - gap - rectW;
    const rectY = starBox.y;

    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', rectX);
    rect.setAttribute('y', rectY);
    rect.setAttribute('width', rectW);
    rect.setAttribute('height', rectH);
    rect.setAttribute('class','shape');
    rect.setAttribute('id','leftRect');
    svg.appendChild(rect);
rect.setAttribute('fill','none');

    // 左長方形内のアイコン用レイヤ
    const iconsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    iconsLayer.setAttribute('id','icons');
    svg.appendChild(iconsLayer);

    // 7部屋ヒット層
    const roomsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    roomsLayer.setAttribute('id','rooms');
    svg.appendChild(roomsLayer);

    // 中央六角形（room 1）
    const hitHex = poly(H0, 'roomhit', roomsLayer);
    hitHex.dataset.room = '1';
    hitHex.addEventListener('click', onRoomClick);

// === room1 に画像を入れる（白塗りの上に重ね、枠線は描き直す） ===
{
  // 六角形の外接矩形など
  const xs = H0.map(p => p[0]), ys = H0.map(p => p[1]);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const w = maxX - minX, h = maxY - minY;
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;

  // 4パラメータ：①倍率 ②x移動 ③y移動 ④角度（deg）
  const scale  = 1.0;   // 例: 1.2 で拡大
  const moveX  = 0;     // 右＋ / 左−（px）
  const moveY  = 0;     // 下＋ / 上−（px）
  const rotate = 0;     // 時計回り＋（deg）

  // clipPath 準備（ユーザー座標系で）
  const defs = svg.querySelector('defs') || (()=>{
    const d = document.createElementNS('http://www.w3.org/2000/svg','defs');
    svg.insertBefore(d, svg.firstChild);
    return d;
  })();
  let cp = svg.querySelector('#clip-room1');
  if(!cp){
    cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
    cp.setAttribute('id','clip-room1');
    cp.setAttribute('clipPathUnits','userSpaceOnUse'); // ←重要：座標ずれ防止
    const clipPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
    clipPoly.setAttribute('points', H0.map(p=>p.join(',')).join(' '));
    cp.appendChild(clipPoly);
    defs.appendChild(cp);
  }

  // 画像：白ポリゴンの「上」に来るように、roomsLayer の直前へ差し込む
  const newW = w * scale, newH = h * scale;
  const newX = cx - newW/2 + moveX;
  const newY = cy - newH/2 + moveY;

  const img = document.createElementNS('http://www.w3.org/2000/svg','image');
  // ファイル名は実ファイルに合わせて：'room1jpg' ならそのまま、拡張子ありなら 'room1.jpg'
  img.setAttributeNS('http://www.w3.org/1999/xlink','href','room1.jpg');
  img.setAttribute('x', String(newX));
  img.setAttribute('y', String(newY));
  img.setAttribute('width',  String(newW));
  img.setAttribute('height', String(newH));
  img.setAttribute('preserveAspectRatio','xMidYMid slice');
  img.setAttribute('clip-path','url(#clip-room1)');
  img.style.pointerEvents = 'none';

  // 画像の中心で回転
  const rotCx = newX + newW/2, rotCy = newY + newH/2;
  img.setAttribute('transform', `rotate(${rotate}, ${rotCx}, ${rotCy})`);

  // g（白ポリゴン群）の“上”に出す：roomsLayer の直前に入れる
  svg.insertBefore(img, roomsLayer);

  // 枠線を上に描き直す（fillは無し、strokeだけ）
  const outline = document.createElementNS('http://www.w3.org/2000/svg','polygon');
  outline.setAttribute('points', H0.map(p=>p.join(',')).join(' '));
  outline.setAttribute('fill', 'none');
  outline.setAttribute('stroke', '#111');
  outline.setAttribute('stroke-width', '0.8');
  outline.setAttribute('stroke-linejoin', 'round');
  outline.setAttribute('stroke-linecap', 'round');
  svg.insertBefore(outline, roomsLayer);
}


    // 外周五角形（room 2〜7）
    for(let i=0;i<6;i++){
      const hitPent = poly(pentPoints[i], 'roomhit', roomsLayer);
      hitPent.dataset.room = String(2 + i); // 2..7
      hitPent.addEventListener('click', onRoomClick);
      // ★ 追加：room6 のときだけ背景画像を“中にだけ”表示（はみ出しカット）
   
      
        if (2 + i === 2) {
    const xs = pentPoints[i].map(p => p[0]);
    const ys = pentPoints[i].map(p => p[1]);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const w = maxX - minX, h = maxY - minY;

    const defs = svg.querySelector('defs') 
              || (()=>{
                   const d = document.createElementNS('http://www.w3.org/2000/svg','defs');
                   svg.insertBefore(d, svg.firstChild);
                   return d;
                 })();

    let cp = svg.querySelector('#clip-room2');
    if (!cp) {
      cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
      cp.setAttribute('id','clip-room2');
      const clipPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      clipPoly.setAttribute('points', pentPoints[i].map(p=>p.join(',')).join(' '));
      cp.appendChild(clipPoly);
      defs.appendChild(cp);
    }

    const img = document.createElementNS('http://www.w3.org/2000/svg','image');
    img.setAttributeNS('http://www.w3.org/1999/xlink','href','room2.jpg');

const offsetX = 0;    // 例: +12 で右に12px、-8 で左に8px
const offsetY = 0;  // 例: -10 で上に10px

// 画像サイズは今のまま（等倍の例）
const scale = 2;           // ← 拡大倍率
const newW = w * scale; 
const newH = h * scale;


// 中心基準で配置し、そこからオフセット
const cx = (minX + maxX) / 2;
const cy = (minY + maxY) / 2;
const newX = cx - newW / 2 + offsetX;
const newY = cy - newH / 2 + offsetY;


    img.setAttribute('x', String(newX));
    img.setAttribute('y', String(newY));
    img.setAttribute('width',  String(newW));
    img.setAttribute('height', String(newH));
    img.setAttribute('preserveAspectRatio','xMidYMid slice');
    img.setAttribute('clip-path','url(#clip-room2)');
    img.style.pointerEvents = 'none';

    g.insertBefore(img, g.firstChild);
  }

      if (2 + i === 3) {
    const xs = pentPoints[i].map(p => p[0]);
    const ys = pentPoints[i].map(p => p[1]);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const w = maxX - minX, h = maxY - minY;

    const defs = svg.querySelector('defs') 
              || (()=>{
                   const d = document.createElementNS('http://www.w3.org/2000/svg','defs');
                   svg.insertBefore(d, svg.firstChild);
                   return d;
                 })();

    let cp = svg.querySelector('#clip-room3');
    if (!cp) {
      cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
      cp.setAttribute('id','clip-room3');
      const clipPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      clipPoly.setAttribute('points', pentPoints[i].map(p=>p.join(',')).join(' '));
      cp.appendChild(clipPoly);
      defs.appendChild(cp);
    }

    const img = document.createElementNS('http://www.w3.org/2000/svg','image');
    img.setAttributeNS('http://www.w3.org/1999/xlink','href','room3.jpg');

const offsetX = 0;    // 例: +12 で右に12px、-8 で左に8px
const offsetY = 0;  // 例: -10 で上に10px

const scale = 2;           // ← 拡大倍率
const newW = w * scale; 
const newH = h * scale;


// 中心基準で配置し、そこからオフセット
const cx = (minX + maxX) / 2;
const cy = (minY + maxY) / 2;
const newX = cx - newW / 2 + offsetX;
const newY = cy - newH / 2 + offsetY;


    img.setAttribute('x', String(newX));
    img.setAttribute('y', String(newY));
    img.setAttribute('width',  String(newW));
    img.setAttribute('height', String(newH));
    img.setAttribute('preserveAspectRatio','xMidYMid slice');
    img.setAttribute('clip-path','url(#clip-room3)');
    img.style.pointerEvents = 'none';

    g.insertBefore(img, g.firstChild);
  }

   if (2 + i === 4) {
    const xs = pentPoints[i].map(p => p[0]);
    const ys = pentPoints[i].map(p => p[1]);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const w = maxX - minX, h = maxY - minY;

    const defs = svg.querySelector('defs') 
              || (()=>{
                   const d = document.createElementNS('http://www.w3.org/2000/svg','defs');
                   svg.insertBefore(d, svg.firstChild);
                   return d;
                 })();

    let cp = svg.querySelector('#clip-room4');
    if (!cp) {
      cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
      cp.setAttribute('id','clip-room4');
      const clipPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      clipPoly.setAttribute('points', pentPoints[i].map(p=>p.join(',')).join(' '));
      cp.appendChild(clipPoly);
      defs.appendChild(cp);
    }

    const img = document.createElementNS('http://www.w3.org/2000/svg','image');
    img.setAttributeNS('http://www.w3.org/1999/xlink','href','room4.jpg');

const offsetX = 0;    // 例: +12 で右に12px、-8 で左に8px
const offsetY = 0;  // 例: -10 で上に10px

const scale = 2;           // ← 拡大倍率
const newW = w * scale; 
const newH = h * scale;

// 中心基準で配置し、そこからオフセット
const cx = (minX + maxX) / 2;
const cy = (minY + maxY) / 2;
const newX = cx - newW / 2 + offsetX;
const newY = cy - newH / 2 + offsetY;


    img.setAttribute('x', String(newX));
    img.setAttribute('y', String(newY));
    img.setAttribute('width',  String(newW));
    img.setAttribute('height', String(newH));
    img.setAttribute('preserveAspectRatio','xMidYMid slice');
    img.setAttribute('clip-path','url(#clip-room4)');
    img.style.pointerEvents = 'none';

    g.insertBefore(img, g.firstChild);
  }     
      
        if (2 + i === 5) {
    const xs = pentPoints[i].map(p => p[0]);
    const ys = pentPoints[i].map(p => p[1]);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const w = maxX - minX, h = maxY - minY;

    const defs = svg.querySelector('defs') 
              || (()=>{
                   const d = document.createElementNS('http://www.w3.org/2000/svg','defs');
                   svg.insertBefore(d, svg.firstChild);
                   return d;
                 })();

    let cp = svg.querySelector('#clip-room5');
    if (!cp) {
      cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
      cp.setAttribute('id','clip-room5');
      const clipPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      clipPoly.setAttribute('points', pentPoints[i].map(p=>p.join(',')).join(' '));
      cp.appendChild(clipPoly);
      defs.appendChild(cp);
    }

    const img = document.createElementNS('http://www.w3.org/2000/svg','image');
    img.setAttributeNS('http://www.w3.org/1999/xlink','href','room5.jpg');

 const offsetX = -20;    // 例: +12 で右に12px、-8 で左に8px
const offsetY = -17;  // 例: -10 で上に10px

const scale = 2;           // ← 拡大倍率
const newW = w * scale; 
const newH = h * scale;

// 中心基準で配置し、そこからオフセット
const cx = (minX + maxX) / 2;
const cy = (minY + maxY) / 2;
const newX = cx - newW / 2 + offsetX;
const newY = cy - newH / 2 + offsetY;

img.setAttribute('x', String(newX));   // ← newX に変更
img.setAttribute('y', String(newY));   // ← newY に変更
    img.setAttribute('width',  String(newW));
    img.setAttribute('height', String(newH));
    img.setAttribute('preserveAspectRatio','xMidYMid slice');
    img.setAttribute('clip-path','url(#clip-room5)');
    img.style.pointerEvents = 'none';

    g.insertBefore(img, g.firstChild);
  }
      
    if (2 + i === 7) {
    const xs = pentPoints[i].map(p => p[0]);
    const ys = pentPoints[i].map(p => p[1]);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const w = maxX - minX, h = maxY - minY;

    const defs = svg.querySelector('defs') 
              || (()=>{
                   const d = document.createElementNS('http://www.w3.org/2000/svg','defs');
                   svg.insertBefore(d, svg.firstChild);
                   return d;
                 })();

    let cp = svg.querySelector('#clip-room7');
    if (!cp) {
      cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
      cp.setAttribute('id','clip-room7');
      const clipPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      clipPoly.setAttribute('points', pentPoints[i].map(p=>p.join(',')).join(' '));
      cp.appendChild(clipPoly);
      defs.appendChild(cp);
    }

    const img = document.createElementNS('http://www.w3.org/2000/svg','image');
    img.setAttributeNS('http://www.w3.org/1999/xlink','href','room7.jpg');

 const offsetX = -20;    // 例: +12 で右に12px、-8 で左に8px
const offsetY = -17;  // 例: -10 で上に10px

const scale = 2;           // ← 拡大倍率
const newW = w * scale; 
const newH = h * scale;

// 中心基準で配置し、そこからオフセット
const cx = (minX + maxX) / 2;
const cy = (minY + maxY) / 2;
const newX = cx - newW / 2 + offsetX;
const newY = cy - newH / 2 + offsetY;

img.setAttribute('x', String(newX));   // ← newX に変更
img.setAttribute('y', String(newY));   // ← newY に変更
    img.setAttribute('width',  String(newW));
    img.setAttribute('height', String(newH));
    img.setAttribute('preserveAspectRatio','xMidYMid slice');
    img.setAttribute('clip-path','url(#clip-room7)');
    img.style.pointerEvents = 'none';

    g.insertBefore(img, g.firstChild);
  }


      if (2 + i === 6) {
    // 1) room6 五角形の外接矩形（画像配置用のサイズ）
    const xs = pentPoints[i].map(p => p[0]);
    const ys = pentPoints[i].map(p => p[1]);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const w = maxX - minX, h = maxY - minY;

    // 2) <defs><clipPath> を準備（五角形そのものをクリップに）
    const defs = svg.querySelector('defs')
              || (()=>{
                   const d = document.createElementNS('http://www.w3.org/2000/svg','defs');
                   svg.insertBefore(d, svg.firstChild);
                   return d;
                 })();

    let cp = svg.querySelector('#clip-room6');
    if (!cp) {
      cp = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
      cp.setAttribute('id','clip-room6');
      const clipPoly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      clipPoly.setAttribute('points', pentPoints[i].map(p=>p.join(',')).join(' '));
      cp.appendChild(clipPoly);
      defs.appendChild(cp);
    }

    // 3) 画像を作成してクリップを適用
    const img = document.createElementNS('http://www.w3.org/2000/svg','image');
    img.setAttributeNS('http://www.w3.org/1999/xlink','href','room6.jpg'); // 画像パス
  const scale = 2;       // ← 拡大倍率

const offsetX = 0;    
const offsetY = 0;   // ← 少し下げる（以前は 50）

const newW = w * scale; 
const newH = h * scale;

const cx = (minX + maxX) / 2;
const cy = (minY + maxY) / 2;
const newX = cx - newW / 2 + offsetX;
const newY = cy - newH / 2 + offsetY;


        
img.setAttribute('x', String(newX));   // ← newX に変更
img.setAttribute('y', String(newY));   // ← newY に変更
img.setAttribute('width',  String(newW));
img.setAttribute('height', String(newH));
    img.setAttribute('preserveAspectRatio','xMidYMid slice'); // 中央トリミングで見切れOK
    img.setAttribute('clip-path','url(#clip-room6)');
    img.style.pointerEvents = 'none'; // 画像がクリック判定を邪魔しない

    // 4) レイヤー最背面に配置：星形グループ g の先頭に挿入
    g.insertBefore(img, g.firstChild);
  }
}

    // 席アイコン用レイヤ
    const seatsLayer = document.createElementNS('http://www.w3.org/2000/svg','g');
    seatsLayer.setAttribute('id','seats');
    svg.appendChild(seatsLayer);

    // viewBox 調整
    (function fit(){
      const pad=14, box=svg.getBBox();
      svg.setAttribute('viewBox',[box.x-pad, box.y-pad, box.width+pad*2, box.height+pad*2].join(' '));
    })();

    // 左長方形の矩形を保持（ドラッグ範囲クランプ用）
    state.rectBBox = { x: rectX, y: rectY, w: rectW, h: rectH };

    // 左長方形クリック：同名が既に存在すれば新規出現しない
    rect.addEventListener('click', onRectClickWithDupCheck);
 // === 左長方形に hp.png を挿入 ===
{
  const svg = document.getElementById('art');
  const rect = document.getElementById('leftRect');
  if (svg && rect) {
    // rect の座標とサイズを取得
    const x = parseFloat(rect.getAttribute('x'));
    const y = parseFloat(rect.getAttribute('y'));
    const w = parseFloat(rect.getAttribute('width'));
    const h = parseFloat(rect.getAttribute('height'));

    // 枠と塗りを透明に
    rect.setAttribute('fill', 'none');
    rect.setAttribute('stroke', 'none');

    // 画像を作成
    const img = document.createElementNS('http://www.w3.org/2000/svg','image');
    img.setAttributeNS('http://www.w3.org/1999/xlink','href','hp.png'); 
    img.setAttribute('x', x);
    img.setAttribute('y', y);
    img.setAttribute('width',  w);
    img.setAttribute('height', h);
    img.setAttribute('preserveAspectRatio','xMidYMid slice'); // はみ出し防止
    img.style.pointerEvents = 'none'; // クリック邪魔しない

    // rect の直後に追加
    rect.parentNode.insertBefore(img, rect.nextSibling);
  }
}
 }



// ===== 山札 =====
 const DECKS_DEF = {
  green: { 
    label:'緑', 
    colorClass:'green', 
    // ★ 正体質問カード群
    cards:[
      'あなたは シチズン か シャドウ？<br>だったら装備を渡すか、1ダメージ受けよ。',
      '正体カードを見せよ',
      'あなたは  D / F / G / V / W ?（HP12以上）<br>だったら2ダメージ受けよ。',
      'あなたは  A / B / C / E / U ?（HP11以下）<br>だったら1ダメージ受けよ。',
      'あなたは レイダー か シャドウ？<br>だったら装備を渡すか、1ダメージ受けよ。',
      'あなたは レイダー か シャドウ？<br>だったら装備を渡すか、1ダメージ受けよ。',
      'あなたは レイダー？<br>だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。',
      'あなたは レイダー？<br>だったら1ダメージ受けよ。',
      'あなたは レイダー？<br>だったら1ダメージ受けよ。',
      'あなたは レイダー？<br>だったら❿に移動せよ。<br>既に➓にいる場合、1ダメージ受けよ。',
      'あなたは シャドウ？<br>だったら2ダメージ受けよ。',
      'あなたは シャドウ？<br>だったら❿に移動せよ。<br>既に➓にいる場合、1ダメージ受けよ。',
      'あなたは シャドウ？<br>だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。',
      'あなたは シャドウ？<br>だったら1ダメージ受けよ。',
      'あなたは シチズン か シャドウ？<br>だったら装備を渡すか、1ダメージ受けよ。',
      'あなたは シチズン？<br>だったら❿に移動せよ。<br>既に➓にいる場合、1ダメージ受けよ。',
      'あなたは シチズン？<br>だったら1ダメージ回復せよ。ダメージが0なら、1ダメージ受けよ。',
      'あなたは シャドウ？<br>だったら1ダメージ受けよ。',
      'あなたは シチズン か レイダー？<br>だったら装備を渡すか、1ダメージ受けよ。',
      'あなたは シチズン か レイダー？<br>だったら装備を渡すか、1ダメージ受けよ。'
    ]
  },
white: {
  label:'白',
  colorClass:'white',
  cards:[
    '幸せのクッキー','光臨','いにしえの聖杯','恩恵','闇を祓う鏡',
    'いやしの聖水','いやしの聖水 ','いやしの聖水  ',
    '銀のロザリオ','銀のロザリオ ',
    '幸運のブローチ','裁きの閃光','賢者のローブ','人魚の涙',
    'エクスカリバー','守護天使','神秘のコンパス','虹色のパラソル',
    '封印の知恵','応急手当'
  ],
 equipNames:['いにしえの聖杯','銀のロザリオ','銀のロザリオ ','幸運のブローチ','賢者のローブ','エクスカリバー','神秘のコンパス','虹色のパラソル']
},
  black: {
  label:'黒',
  colorClass:'black',
  cards:[
    '妖刀マサムネ','吸血コウモリ','吸血コウモリ ','吸血コウモリ  ',
    '拳銃R','拳銃L','暴動','バナナの皮',
    'クロスボウガン','死神スコープ','死神スコープ ',
    '三つ目の黒犬','三つ目の黒犬','呪いの人形',
    'サーベル','ガトリング',
    'オリバーの子分','オリバーの子分','オリバーの子分 ',
    '戦慄の闇儀式'
  ],
  equipNames:[
    '拳銃R','拳銃L','ガトリング','妖刀マサムネ',
    'クロスボウガン','死神スコープ','死神スコープ ','サーベル'  ]
},
};

function setupDecks(){
  decksEl.innerHTML = '';

  // ★ 並び順を明示：「緑裏 → 白裏 → 白表 → 黒裏 → 黒表」
  const order = [
    { deck:'green', type:'back' },
    { deck:'white', type:'back' },
    { deck:'white', type:'face' },
    { deck:'black', type:'back' },
    { deck:'black', type:'face' },
  ];

  // クリック用ヘルパ
  function attachFaceClick(faceEl, deckId){
    faceEl.addEventListener('click', async ()=>{
      if (deckId === 'green'){
  dealCardFace.removeAttribute('style');         // 追加
  dealCardFace.className = 'deal-card';          // 追加
  dealCardFace.textContent = '';                 // 追加




        const deckRef = ref(db, `rooms/${state.code}/decks/${deckId}`);
        const snap = await get(deckRef);
        const v = snap.val() || {};
        const idx   = (v.idx ?? -1);
        const order = Array.isArray(v.order) ? v.order : null;
if (idx >= 0){
  const actual = order ? order[idx % order.length] : (idx % DECKS_DEF[deckId].cards.length);
  const card = DECKS_DEF[deckId].cards[actual];

  // ★ 追加
  state.expandedContext = { source: 'deck', deckId, cardName: card };
  dealCardFace.onclick = null;
  {
    const rp = document.getElementById('revealPopover');
    if (rp) rp.classList.add('hidden');
  }

  dealCardFace.textContent = card;
  applyDeckTheme(dealCardFace, 'green');
  show(dealViewer, true);
}




      }else{

        // 白・黒の表は faceEl のテキストを拡大
if (faceEl.textContent){

  // ✨まず完全リセット：前の正体カード枠線などの inline style を除去
  dealCardFace.removeAttribute('style');           // ← 追加
  dealCardFace.className = 'deal-card';            // ← 追加（クラスも初期化）
  dealCardFace.classList.remove('green-layout');   // 既存



 const cardName =
   (faceEl.dataset.cardName && faceEl.dataset.cardName.trim()) ||
   (faceEl.querySelector('.mini-title')?.textContent?.trim()) ||
   faceEl.textContent.trim();dealCardFace.classList.add('white-layout');


// ★ 追加：正体の公開ポップを引き継がないように状態/ハンドラ/ポップをリセット
state.expandedContext = { source: 'deck', deckId, cardName };
dealCardFace.onclick = null;
{
  const rp = document.getElementById('revealPopover');
  if (rp) rp.classList.add('hidden');
}

  // デフォルトはカード名だけ
  dealCardFace.textContent = '';
  const wrapper = document.createElement('div');
  wrapper.style.flex = '1';
  wrapper.style.display = 'flex';
  wrapper.style.flexDirection = 'column';


// 上：カード名（白タイトル用デザイン）
const title = document.createElement('div');
title.textContent = cardName;
title.className = 'white-title';
wrapper.appendChild(title);


// 中：カード画像（カード名.jpg）
const img = document.createElement('img');
img.className = 'item-image';
img.alt = cardName;
img.src = makeWhiteImageSrc(cardName);

img.style.transform = 'scale(0.9)';   // 幅高さを0.8倍
img.style.transformOrigin = 'center'; // 中心基準で縮小


// 画像が見つからない場合は邪魔にならないように非表示
img.addEventListener('error', ()=> img.remove());

wrapper.appendChild(img);


  // 下：白デッキ効果（例）
  if (deckId === 'white'){
    const table = document.createElement('table');
    table.className = 'white-table';
    const tr = document.createElement('tr');
    const td = document.createElement('td');

    // ここでカードごとの効果を判定して入れる
if (cardName.includes('銀のロザリオ')){
  td.textContent = 'ダイスの攻撃によって倒したPLの全ての装備を奪う。';
}else if (cardName.includes('銀のロザリオ ')){
  td.textContent = 'ダイスの攻撃によって倒したPLの全ての装備を奪う。';
}else if (cardName.includes('虹色のパラソル')){
  td.textContent = '攻撃する代わりに攻撃レンジのPLに推理カードを渡す。';
}else if (cardName.includes('エクスカリバー')){
  td.textContent = 'あなたがレイダーなら、攻撃ダメージが 2 上がる。';
}else if (cardName.includes('神秘のコンパス')){
  td.textContent = '移動の時にダイスを二回振って、選ぶことができる。';
}else if (cardName.includes('幸運のブローチ')){
  td.textContent = '市庁舎(8)の効果ダメージを受けない。';
}else if (cardName.includes('賢者のローブ')){
  td.textContent = '与える攻撃ダメージ、受ける攻撃ダメージが 1 減少する。';
}else if (cardName.includes('いにしえの聖杯')){
  td.textContent = '三つ目の黒犬,吸血コウモリ,呪いの人形の効果を受けない。';
}else if (cardName.includes('光臨')){
  td.textContent = 'あなたがレイダーなら、全ダメージを回復する。';
}else if (cardName.includes('守護天使')){
  td.textContent = '次の自分の手番の始めまで、攻撃ダメージを受けない。';
}else if (cardName.includes('封印の知恵')){
  td.textContent = 'この手番の終了後、もう1手番を行う。';
}else if (cardName.includes('応急手当')){
  td.textContent = '任意のPL（自分も可）を選び、そのPLのダメージを7にする。';
}else if (cardName.includes('人魚の涙')){
  td.textContent = '最もダメージが多い人を 3 回復する。';
}else if (cardName.includes('幸せのクッキー')){
  td.textContent = 'あなたが A または U なら、HPを全回復する。';
}else if (cardName.includes('闇を祓う鏡')){
  td.textContent = 'あなたがシャドウ陣営でウルリッヒでないなら、必ず正体カードを公開する。';
}else if (cardName.includes('いやしの聖水')){
  td.textContent = '自分のダメージを 2 回復する。';
}else if (cardName.includes('いやしの聖水 ')){
  td.textContent = '自分のダメージを 2 回復する。';
}else if (cardName.includes('いやしの聖水  ')){
  td.textContent = '自分のダメージを 2 回復する。';
}else if (cardName.includes('恩恵')){
  td.textContent = '自分以外のPLを選んで、6面ダイスを振る。目の数だけそのPLのダメージを回復する。';
}else if (cardName.includes('裁きの閃光')){
  td.textContent = '自分以外のPL全員に 2 ダメージ与える。';
}else{
  td.textContent = '効果未設定';
}

    tr.appendChild(td);
    table.appendChild(tr);
    wrapper.appendChild(table);
  }


// 下：黒デッキ効果（白と同じUI形式）
if (deckId === 'black'){
  const table = document.createElement('table');
  table.className = 'black-table'; // 白と同じ見た目にする
  const tr = document.createElement('tr');
  const td = document.createElement('td');

  // 白と同じように if/else 群を直書きする場合
if (cardName.includes('サーベル')){
  td.textContent = '攻撃ダメージが 1 増加する。';
}else if (cardName.includes('拳銃R')){
  td.textContent = '攻撃ダメージが 1 増加する。';
}else if (cardName.includes('拳銃L')){
  td.textContent = '攻撃ダメージが 1 増加する。';
}else if (cardName.includes('クロスボウガン')){
  td.textContent = '攻撃ダメージが 1 増加する。';
}else if (cardName.includes('妖刀マサムネ')){
  td.textContent = '攻撃レンジのPLに必ず攻撃を行う。4面ダイスだけを使う。';
}else if (cardName.includes('ガトリング')){
  td.textContent = '攻撃レンジのPL全員に攻撃する。';
}else if (cardName.includes('死神スコープ')){
  td.textContent = '攻撃レンジが 1 増加する。';
}else if (cardName.includes('死神スコープ ')){
  td.textContent = '攻撃レンジが 1 増加する。';
}else if (cardName.includes('オリバーの子分')){
  td.textContent = '任意のPLを選んで、装備を1つ奪う。';
}else if (cardName.includes('オリバーの子分 ')){
  td.textContent = '任意のPLを選んで、装備を1つ奪う。';
}else if (cardName.includes('オリバーの子分  ')){
  td.textContent = '任意のPLを選んで、装備を1つ奪う。';
}else if (cardName.includes('吸血コウモリ')){
  td.textContent = '自分以外のPLに2ダメージ与える。';
}else if (cardName.includes('吸血コウモリ ')){
  td.textContent = '自分以外のPLに2ダメージ与える。';
}else if (cardName.includes('吸血コウモリ  ')){
  td.textContent = '自分以外のPLに2ダメージ与える。';
}else if (cardName.includes('三つ目の黒犬')){
  td.textContent = '自分と選んだPLに2ダメージ与える。';
}else if (cardName.includes('三つ目の黒犬 ')){
  td.textContent = '自分と選んだPLに2ダメージ与える。';
}else if (cardName.includes('暴動')){
  td.textContent = 'ダイスを2つ振り、目のエリアにいるPL全員に3ダメージ与える。';
}else if (cardName.includes('バナナの皮')){
  td.textContent = '装備を1つ誰かに渡す。なければ 1 ダメージ受ける。';
}else if (cardName.includes('呪いの人形')){
  td.textContent = 'PLを一人選び、6面ダイスを振る。1-4なら選んだPLに、5-6なら自分に3ダメージ与える。';
}else if (cardName.includes('戦慄の闇儀式')){
  td.textContent = 'あなたがシャドウなら、全回復する。';
  }else{
    td.textContent = '効果未設定';
  }

  tr.appendChild(td);
  table.appendChild(tr);
  wrapper.appendChild(table);
}
dealCardFace.className = 'deal-card';
dealCardFace.innerHTML = '';
dealCardFace.style.background = '';
dealCardFace.style.color = '';


  dealCardFace.appendChild(wrapper);
  applyDeckTheme(dealCardFace, deckId);
  show(dealViewer, true);
}

      }
    });
  }

  // 要素を順番に配置
  order.forEach(({deck:deckId, type})=>{
    const def = DECKS_DEF[deckId];

if (type === 'back'){
  const back = document.createElement('div');
  back.className = `deck-back ${def.colorClass}`;
  back.dataset.deck = deckId;     // ★識別
  back.dataset.role = 'back';
  back.textContent = '';
  back.title = `${def.label}デッキをめくる`;
back.addEventListener('click', (ev)=>{
  // ★ 追加：正体の公開ポップは常に閉じる＋正体用ハンドラも解除
  {
    const rp = document.getElementById('revealPopover');
    if (rp) rp.classList.add('hidden');
    dealCardFace.onclick = null;
    state.expandedContext = { source: 'deck', deckId };
  }

  // ブランクなら「山札を作る（シャッフル）」ポップ
  if (back.classList.contains('blank')) {
    showShufflePopover(back, deckId, ev);
    return;
  }
  // 通常時は既存の山札めくり
  playSfx('sfxDeck');
  advanceDeckGuarded(deckId, state.uid);
});
  // ★ 追加：残り枚数表示用
  const count = document.createElement('div');
  count.className = 'deck-count';
  count.dataset.deck = deckId;
  count.textContent = `${def.cards.length}`;

  // ★ 追加：deckコンテナでまとめる
  const wrapper = document.createElement('div');
  wrapper.className = 'deck';
  wrapper.appendChild(back);
  wrapper.appendChild(count);

  decksEl.appendChild(wrapper);
}else{
  // type === 'face'
const face = document.createElement('div');
face.className = 'deck-face blank'; // ← 追加
face.dataset.deck = deckId;
face.dataset.role = 'face';
face.textContent = '';
attachFaceClick(face, deckId);
decksEl.appendChild(face);

    }
  });

  // ★ 緑の「表」は作らない（orderに含めない）＝表示されない

  // DB同期購読（face要素のテキストを更新）
  const decksRef = ref(db, `rooms/${state.code}/decks`);
const off = onValue(decksRef, (snap)=>{
  const v = snap.val() || {};

  // 白の表
// 白の表（order対応）
{
  const idx   = (v.white?.idx ?? -1);
  const order = Array.isArray(v.white?.order) ? v.white.order : null;
  const faceEl = decksEl.querySelector('.deck-face[data-deck="white"][data-role="face"]');
  if (faceEl){
    if (idx >= 0){
      const actual = order ? order[idx % order.length] : (idx % DECKS_DEF.white.cards.length);
   const cardName = DECKS_DEF.white.cards[actual];

faceEl.dataset.cardName = cardName;   // ← 追加：タイトル用に“名前だけ”保持

const effect   = getWhiteEffectText(cardName);
    faceEl.innerHTML = `
      <div class="mini-title">${cardName}</div>
<img class="mini-image" src="${makeWhiteImageSrc(cardName)}" alt="${cardName}">
      <div class="mini-effect">${effect}</div>
    `;
    faceEl.classList.remove('blank');
    applyDeckTheme(faceEl, 'white');
    }else{
      faceEl.textContent = '';
 delete faceEl.dataset.cardName;   
      faceEl.classList.add('blank');         // ← 追加
      faceEl.style.background = '';          // ← 追加（インライン色を消す）
      faceEl.style.color = '';
    }
  }
}
// 黒の表（order対応）
{
  const idx   = (v.black?.idx ?? -1);
  const order = Array.isArray(v.black?.order) ? v.black.order : null;
  const faceEl = decksEl.querySelector('.deck-face[data-deck="black"][data-role="face"]');
  if (faceEl){
    if (idx >= 0){
      const actual = order ? order[idx % order.length] : (idx % DECKS_DEF.black.cards.length);
      const cardName = DECKS_DEF.black.cards[actual];
      faceEl.dataset.cardName = cardName;  // タイトル/拡大用に保持
      const effect   = getBlackEffectText(cardName);
      faceEl.innerHTML = `
        <div class="mini-title">${cardName}</div>
<img class="mini-image" src="${makeWhiteImageSrc(cardName)}" alt="${cardName}">
        <div class="mini-effect">${effect}</div>
      `;
      faceEl.classList.remove('blank');
      applyDeckTheme(faceEl, 'black');
     }else{
       faceEl.textContent = '';
      delete faceEl.dataset.cardName;
      faceEl.classList.add('blank');         // ← 追加
      faceEl.style.background = '';          // ← 追加
      faceEl.style.color = '';
    }
  }
}

  // 緑は表共有なし（face自体を置いていない）

  // ★ 追加：残り枚数更新
  function updateCount(deckId){
    const idx = (v[deckId]?.idx ?? -1);
    const def = DECKS_DEF[deckId];
    const remain = def.cards.length - (idx + 1);
    const countEl = decksEl.querySelector(`.deck-count[data-deck="${deckId}"]`);
    const backEl  = decksEl.querySelector(`.deck-back[data-deck="${deckId}"]`);

    if (countEl){
      countEl.textContent = remain >= 0 ? remain : def.cards.length;
    }
if (backEl){
  if (remain <= 0){
    backEl.textContent = '';                 // 裏の文字は消す
    backEl.classList.add('blank');           // ★ 点線枠
    backEl.classList.remove('disabled');     // disabled は不要
  }else{
    backEl.textContent = '';
    backEl.classList.remove('blank');        // 通常枠に戻す
  }
}

  }
  updateCount('white');
  updateCount('black');
  updateCount('green');

  refreshDeckEnable();
});
// ★ 緑カード終了フラグを監視
const greenDoneRef = ref(db, `rooms/${state.code}/greenActive`);
onValue(greenDoneRef, (snap)=>{
  const v = snap.val();
  if (v && v.active === false){
dealCardFace.removeAttribute('style');
dealCardFace.className = 'deal-card';
    show(dealViewer, false);  // 強制的に非表示
  stopTimerSfx(); 
  }
});


  // ★ ダイスの共有イベント購読（同期アニメ＆出目表示）
  let lastDiceNonce = null;
  const diceRef = ref(db, `rooms/${state.code}/dice/current`);
  const offDice = onValue(diceRef, (snap)=>{
    const v = snap.val();
    if (!v || !v.nonce || v.nonce === lastDiceNonce) return;
    lastDiceNonce = v.nonce;
  playSfx('sfxDice');

    // 山札クリック残数は0に
    if (typeof setDeckQuota === 'function') setDeckQuota(0);

    // 同期開始までの待機
    const now = Date.now();
    const wait = Math.max(0, (v.startAt || now) - now);

    // d4 / d6 のアニメを同時起動
    setTimeout(()=>{
      // d4アニメ開始
      playDiceAnim(roll4dImg, ['4da1.png','4da2.png','4da3.png'], v.dur4, ()=> {
        roll4dImg.src = `4d${v.result4}.png`;
      });
      // d6アニメ開始
      playDiceAnim(roll6dImg, ['6da1.png','6da2.png','6da3.png'], v.dur6, ()=> {
        roll6dImg.src = `6d${v.result6}.png`;
      });
    }, wait);
  });

  // 共通：指定時間だけフレームを回してからfinishを呼ぶ
  function playDiceAnim(imgEl, frames, durationMs, finish){
    if (!imgEl) return;
    let i = 0;
    const start = Date.now();
    const timer = setInterval(()=>{
      imgEl.src = frames[i % frames.length];
      i++;
      if (Date.now() - start >= durationMs){
        clearInterval(timer);
        finish && finish();
      }
    }, 80);
  }


  state.unsub.push(off);
  state.unsub.push(offDice);
}



  // ルーム制限に従ってクリック可否を判定
  function canFlip(deckId, myRoom){
    if (!myRoom) return false;
    switch(deckId){
      case 'green': return (myRoom===6 || myRoom===7);
      case 'white': return (myRoom===7 || myRoom===2);
      case 'black': return (myRoom===7 || myRoom===3);
      default: return false;
    }
  }

  // ★ 追加：残回数セット＋UI反映
  function setDeckQuota(n){
    state.deckClicksLeft = Math.max(0, Number(n || 0));
    refreshDeckEnable();
  }

  // ★ 置換：山札「裏」のクリック許可＝部屋制限 × 残回数
  function refreshDeckEnable(){
    const backs = decksEl.querySelectorAll('.deck-back'); // 裏のみ
    backs.forEach(back=>{

   // ★追加: ブランク（0枚）のときは常にクリック可能
    const isBlank = back.classList.contains('blank');
    if (isBlank){
      back.classList.remove('disabled');
      back.style.pointerEvents = 'auto';
      back.title = '山札を作る';
      return;
    }
      
      const deckId = back.dataset.deck;
      const roomOk = canFlip(deckId, state.myRoomNumber || null);
      const quotaOk = (state.deckClicksLeft > 0);
      const enabled = roomOk && quotaOk;

      back.classList.toggle('disabled', !enabled);
      back.style.pointerEvents = enabled ? 'auto' : 'none';
      back.title = enabled ? `${DECKS_DEF[deckId].label}デッキをめくる` : 'ダイスを振ると再びめくれます';
    });
    // 表（拡大用）は制限しない
  }



async function advanceDeckGuarded(deckId, flipperUid){
  // ★ 自分のクリック以外ではローカル残回数を消費しない
  if (flipperUid === state.uid){
    if (typeof state.deckClicksLeft === 'number' && state.deckClicksLeft <= 0) return;
  }

  const ok = canFlip(deckId, state.myRoomNumber || null);
  if (!ok) return; // 禁止

  // ★ 自分がクリックした時にだけ1消費し、即UI反映
  if (flipperUid === state.uid && typeof state.deckClicksLeft === 'number'){
    state.deckClicksLeft = Math.max(0, state.deckClicksLeft - 1);
    if (typeof refreshDeckEnable === 'function') refreshDeckEnable();
  }

  await advanceDeck(deckId, flipperUid);

  if (deckId === 'green' && flipperUid === state.uid){
    const deckPath = ref(db, `rooms/${state.code}/decks/${deckId}`);
    const snap = await get(deckPath);
    const v = snap.val() || {};
    const idx   = (v.idx ?? -1);
    const order = Array.isArray(v.order) ? v.order : null;
    if (idx >= 0){
      const actual = order
        ? order[idx % order.length]
        : (idx % DECKS_DEF[deckId].cards.length);
      const card = DECKS_DEF[deckId].cards[actual];

      state.pinDealViewer = true;

      // ▼▼▼ ここから追加：緑カードは下部に薄緑テーブルで内容を表示 ▼▼▼
  dealCardFace.removeAttribute('style');     // 背景/文字色などのインラインを除去
  dealCardFace.className = 'deal-card';      // 付いている white-layout / black-layout も含めてリセット
  dealCardFace.textContent = '';  
      dealCardFace.classList.add('green-layout');  // CSSの専用レイアウトをON
      dealCardFace.innerHTML = '';                 // いったん空に

     // 最上部タイトル（テーブルの外）
     const title = document.createElement('div');
     title.className = 'green-title';
     title.textContent = '推理カード';
     dealCardFace.appendChild(title);

     // ★ 追加：推理カードとテーブルの間に画像を入れる
     const img = document.createElement('img');
     img.src = 'suiri.jpg';
     img.alt = '推理カード画像';
     img.style.maxWidth = '90%';   // 幅をカード内に収める（調整可）
     img.style.margin = '0px auto'; // 上下の余白を付ける
     img.style.display = 'block';  // 中央寄せ
     dealCardFace.appendChild(img);

      // テーブルを生成してカード文言を書き込む（下部に出る）
      const tbl = document.createElement('table');
      tbl.className = 'green-table';
      const tr  = document.createElement('tr');
      const td  = document.createElement('td');
td.innerHTML = card.replace(/n\//g, '<br>');
      tr.appendChild(td);
      tbl.appendChild(tr);
      dealCardFace.appendChild(tbl);
      // ▲▲▲ 追加ここまで ▲▲▲

      // 既存の配色＆表示処理
      applyDeckTheme(dealCardFace, 'green');
      show(dealViewer, true);
      dealCardFace.onclick = ()=> showParticipantSelectPopup(card);

      // ★ 緑カードの返信終了フラグをセット
      const cardKey = `rooms/${state.code}/greenActive`;
    await set(ref(db, cardKey), { text: card, active: true });
    }
  }
}




async function advanceDeck(deckId, flipperUid){
  const def = DECKS_DEF[deckId];
  const deckPath = ref(db, `rooms/${state.code}/decks/${deckId}`);
  const snap = await get(deckPath);
  const v = snap.val() || {};
  const curIdx = (typeof v.idx === 'number') ? v.idx : -1;
  const nextIdx = (curIdx + 1) % def.cards.length;

  // ★ 追加：保存された order があれば、その順番で“実カード番号”を決める
  const order = Array.isArray(v.order) ? v.order : null;
  const actualCardIndex = order ? order[nextIdx] : nextIdx;
  const cardName = def.cards[actualCardIndex];

  // 進行を保存（orderは維持）
  await set(deckPath, { idx: nextIdx, order: order || null, at: Date.now() });

  if ((deckId === 'white' || deckId === 'black') && flipperUid){
    const eqList = Array.isArray(def.equipNames) ? def.equipNames : [];
    // 末尾・先頭空白の差を吸収して判定だけ厳密化（キーは実カード名をそのまま使う）
    const eqSetTrim = new Set(eqList.map(s => String(s).trim()));
    if (eqSetTrim.has(String(cardName).trim())){
      const updates = {};
      updates[`rooms/${state.code}/equipment/${flipperUid}/${cardName}`] = true;
     updates[`rooms/${state.code}/equipment_at`] = Date.now();
      await update(ref(db), updates);
    }
  }
}

// ★ 追加：ブランク時の「山札を作る（シャッフル）」ポップ
function showShufflePopover(targetEl, deckId, ev){
  // 既存を消す
  const old = document.getElementById('shufflePopover');
  if (old) old.remove();

  const pop = document.createElement('div');
  pop.id = 'shufflePopover';
  pop.className = 'popover';

  // 位置（カードの少し上）
  const r = targetEl.getBoundingClientRect();
  pop.style.left = `${r.left + r.width/2}px`;
  pop.style.top  = `${Math.max(8, r.top - 10)}px`;
  pop.style.transform = 'translate(-50%, -100%)';

  // ボタンだけのシンプルUI
  const btn = document.createElement('button');
  btn.textContent = '山札を作る（シャッフル）';
  btn.onclick = async ()=>{
    await rebuildDeck(deckId);   // idx を初期化
    pop.remove();
  };

  pop.appendChild(btn);
  document.body.appendChild(pop);

  // 外側クリックで閉じる
  const closer = (e)=>{
    if (!pop.contains(e.target)) { pop.remove(); document.removeEventListener('mousedown', closer, true); }
  };
  setTimeout(()=> document.addEventListener('mousedown', closer, true), 0);
}

// ★ 追加：デッキ再構築（idx を -1 に戻す）
async function rebuildDeck(deckId){
  const deckPath = ref(db, `rooms/${state.code}/decks/${deckId}`);
  const order = makeShuffledOrder(deckId);
  await set(deckPath, { idx: -1, order, at: Date.now() });
}



// 部屋ごとの説明テキスト
const ROOM_TEXT = {
  1: "次の手番は\n任意の場所に\n移動できる。",
  2: "白カードが引ける",
  3: "黒カードが引ける",
  4: "任意のプレイヤーを\n1回復するか2ダメージ\n与える",
  5: "他プレイヤーの\n装備カードを\n1つ奪う",
  6: "推理カードが\n引ける",
  7: "推理,白,黒の\nカードが引ける",
};

let roomHelpOn = false;
let roomPopEls = []; // 生成した .room-pop の参照

function removeRoomPops(){
  roomPopEls.forEach(el => el.remove());
  roomPopEls = [];
}

function buildRoomPops(){
  const svg = document.getElementById('art');
  if (!svg) return;
  const hits = [...svg.querySelectorAll('.roomhit')];
  if (!hits.length) return;

  removeRoomPops();

/* ROOM_TEXT をそのまま出す（手動改行を使う） */
hits.forEach(hit => {
  const roomNo = Number(hit.dataset.room || 0);
  const div = document.createElement('div');
  div.className = 'room-pop';
  div.textContent = (ROOM_TEXT[roomNo] || "");            // ← wrapEvery を外す
  document.body.appendChild(div);
  roomPopEls.push(div);
});

  positionRoomPops();
}

function positionRoomPops(){
  const svg = document.getElementById('art');
  if (!svg || !roomPopEls.length) return;
  const hits = [...svg.querySelectorAll('.roomhit')];
  hits.forEach((hit, i) => {
    const r = hit.getBoundingClientRect();
    const el = roomPopEls[i];
    if (!el) return;

    const roomNo = Number(hit.dataset.room || 0);

    // デフォルト位置
    let left = r.left + r.width/2;
    let top  = r.top + r.height/2;


    // --- スマホ用調整 ---
    if (window.innerWidth <= 600) {
    if (roomNo === 2) {
  el.style.left = (r.left + 60) + "px";     // 右に10px移動
      el.style.textAlign = "left";         // 左寄せ
      el.style.maxWidth = (window.innerWidth - 2 - r.left) + "px";   el.style.whiteSpace = "nowrap";           // 折り返し防止
    el.style.top = (top + 16) + "px";        // 下に5px
 }else if (roomNo === 6) {
    el.style.left = left + 'px';
    el.style.top  = (top - 10) + 'px';   // ★ 追加
  }else if (roomNo === 7) {
    const leftPx = r.left + 23;              // 左を基準にする
  el.style.transform = 'translate(0, -50%)'; // 中央基準を解除（Xは左基準）
  el.style.left = leftPx + "px";
  el.style.textAlign = "left";

  // 右端2px余白まで。padding(左右8px×2=16)とborder(左右1px×2=2)を考慮
  const padBorder = 18; // 16 + 2
  el.style.maxWidth = Math.max(0, window.innerWidth - 2 - leftPx - padBorder) + "px";

  // 必要なら改行抑制（任意）
  // el.style.whiteSpace = "nowrap";

  el.style.top = (top - 16) + "px";
 }
 else {   if (roomNo ===  5) {
        left -= 40;      }
    if (roomNo === 4 ) {
        left -= 55;      }
      el.style.left = left + 'px';
    el.style.top  = top + 'px';   }}
 else {
      el.style.left = left + 'px';
    el.style.top  = top + 'px';
    }
  });
}




function toggleRoomHelp(){
  roomHelpOn = !roomHelpOn;
  if (roomHelpOn){
    buildRoomPops();
    window.addEventListener('resize', positionRoomPops);
    window.addEventListener('scroll', positionRoomPops, { passive:true });
  }else{
    removeRoomPops();
    window.removeEventListener('resize', positionRoomPops);
    window.removeEventListener('scroll', positionRoomPops);
  }
}

// 図形が描き直されたあとに再配置するためのフック
function ensureRoomTips(){
  if (roomHelpOn){
    buildRoomPops(); // 図面変化に追従
  }
}
  
  // ===== 右側：部屋クリック =====
  async function onRoomClick(ev){
    const svg = document.getElementById('art');
    const el = ev.currentTarget;
    const roomNo = Number(el.dataset.room || 0);

    el.classList.add('flash');
    setTimeout(()=> el.classList.remove('flash'), 140);

    // 既存の同名席があれば“引き継ぎ”（新規生成しない）
    const seatsSnap = await get(ref(db, `rooms/${state.code}/seats`));
    const seats = seatsSnap.val() || {};
    let sameNameUid = null, sameData = null;
    for (const [uid, data] of Object.entries(seats)){
      if ((data?.name||'') === state.name){
        sameNameUid = uid; sameData = data; break;
      }
    }
    if (sameNameUid && sameNameUid !== state.uid){
      // 所有を自分に移す（位置はそのまま）
      await set(ref(db, `rooms/${state.code}/seats/${state.uid}`), { ...sameData, name: state.name, at: Date.now() });
      await remove(ref(db, `rooms/${state.code}/seats/${sameNameUid}`));
      return; // 位置変更は行わない
    }

    // 新規または自分の既存を更新
    const p = toSvgCoords(svg, ev.clientX, ev.clientY);
    await set(ref(db, `rooms/${state.code}/seats/${state.uid}`), {
      name: state.name,
      room: roomNo,
      x: p.x - 12,  // 正方形中心補正
      y: p.y - 12,
      at: Date.now()
    });
  // ★ 右図クリックで山札クリック残数を1回ぶん回復
  if (typeof setDeckQuota === 'function') setDeckQuota(1);
 playSfx('sfxIcon');
  }

  // SVG座標変換
function toSvgCoords(svg, clientX, clientY){
  const pt = svg.createSVGPoint();
  pt.x = clientX; pt.y = clientY;
  const m = svg.getScreenCTM(); if (!m) return {x:0,y:0};
  const sp = pt.matrixTransform(m.inverse());
  return {x: sp.x, y: sp.y};
}

/* ← 追加：タッチ点が左長方形(state.rectBBox)内かを判定 */
function isInLeftRect(clientX, clientY){
  const svg = document.getElementById('art');
  if (!svg || !state.rectBBox) return false;
  const p = toSvgCoords(svg, clientX, clientY);
  const r = state.rectBBox;
  return (p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h);
}

  // ===== 席アイコン描画（色反映） =====
function applyFillAndText(elGroup, colorName){
  const box = elGroup.querySelector('rect');
  const label = elGroup.querySelector('text');
  const {bg, text} = colorToStyle(colorName);
  if (box){ box.style.fill = bg; }     // ← inline style は CSS より強い
  if (label){ label.style.fill = text; }
}


  function renderOrUpdateSeat(uid, data, userColorsMap){
    const svg = document.getElementById('art');
    const layer = document.getElementById('seats');
    if (!svg || !layer || !data) return;

    let g = layer.querySelector(`g[data-uid="${uid}"]`);
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','seaticon');
      g.setAttribute('data-uid', uid);

const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
box.setAttribute('width', 24);
box.setAttribute('height', 24);
box.setAttribute('rx', 10);   // ← 角丸を属性で付与（スマホでも確実）
box.setAttribute('ry', 10);
g.appendChild(box);


      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', 12);
      label.setAttribute('y', 12);
      label.textContent = (data.name || '?');
      g.appendChild(label);

      // ホスト削除ポップ
      g.addEventListener('click', (e)=> maybeShowDeletePopover(e, 'seat', uid));

      layer.appendChild(g);
    }

    // 名前更新
    const text = g.querySelector('text');
    if (text && text.textContent !== (data.name || '?')) text.textContent = (data.name || '?');

    // 色適用（参加者カラー）
    const colorName = userColorsMap?.[uid] || null;
    if (colorName) applyFillAndText(g, colorName);

    // 位置更新
    g.setAttribute('transform', `translate(${data.x},${data.y})`);
  }

  // ===== 左長方形：クランプ =====
  function clampToRect(x, y){
    const r = state.rectBBox;
    const w = 24, h = 24;
    const minX = r.x + 4;
    const maxX = r.x + r.w - w - 4;
    const minY = r.y + 4;
    const maxY = r.y + r.h - h - 4;
    return {
      x: Math.min(maxX, Math.max(minX, x)),
      y: Math.min(maxY, Math.max(minY, y))
    };
  }

  // 左長方形クリック：同名が存在すれば新規出現しない
  async function onRectClickWithDupCheck(ev){
    const svg = document.getElementById('art');
    const myIconRef = ref(db, `rooms/${state.code}/icons/${state.uid}`);

    // 左長方形内で同名が既にあるかチェック
    const allIconsSnap = await get(ref(db, `rooms/${state.code}/icons`));
    const allIcons = allIconsSnap.val() || {};
    const dup = Object.values(allIcons).some(ic => (ic?.name||'') === state.name);
    if (dup) return; // 同名があれば新規出現しない

    // 自分は未配置なら作成、配置済なら無視
    const snap = await get(myIconRef);
    if (snap.exists()) return;

    const p = toSvgCoords(svg, ev.clientX, ev.clientY);
    const pos = clampToRect(p.x - 12, p.y - 12);

await set(myIconRef, { name: state.name, x: pos.x, y: pos.y, placedAt: Date.now(), ver: 1 });
state.localMoveVer[state.uid] = 1; // ★ 自分の初期verを合わせる
  }

  function renderOrUpdateIcon(uid, data, userColorsMap){
    const svg = document.getElementById('art');
    const layer = document.getElementById('icons');
    if (!svg || !layer || !data) return;

    let g = layer.querySelector(`g[data-uid="${uid}"]`);
    if (!g){
      g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','usericon');
      g.setAttribute('data-uid', uid);

const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
box.setAttribute('width', 24);
box.setAttribute('height', 24);
box.setAttribute('rx', 10);   // ← こちらにも同様に
box.setAttribute('ry', 10);
g.appendChild(box);


      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      label.setAttribute('x', 12);
      label.setAttribute('y', 12);
      label.textContent = (data.name || '?');
      g.appendChild(label);

      // ドラッグ
      g.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        state.isPointerDown = true;
        state.draggingUid = uid;
        g.classList.add('dragging');
        const p = toSvgCoords(svg, e.clientX, e.clientY);
        const gx = parseFloat(g.getAttribute('data-x') || data.x || 0);
        const gy = parseFloat(g.getAttribute('data-y') || data.y || 0);
        state.dragOffset.x = p.x - gx;
        state.dragOffset.y = p.y - gy;
        g.setPointerCapture(e.pointerId);
 　　　 g.dataset.dragMoved = '0';              // ★ 追加：ドラッグ判定をリセット

        // ★ キックガード：DBのエコーで元位置に“戻る”のを短時間だけ無視
        state.dragKickGuardUid = uid;
        state.dragKickGuardUntil = Date.now() + 180; // 180ms（環境次第で 150〜300ms）

        installGlobalPointerMove(); // ← 全体リスナーを用意
      });
g.addEventListener('pointerup', (e)=>{
  if (!state.isPointerDown) return;
  state.isPointerDown = false;

  // ★ ドロップ直後だけリモートの古いスナップショットを無視
  state.dragSettleGuardUid = uid;
  state.dragSettleGuardUntil = Date.now() + 200; // 200ms程度でOK(環境で調整可)

  state.draggingUid = null;            // ★ 解除
  g.classList.remove('dragging');
  g.releasePointerCapture(e.pointerId);
});

      g.addEventListener('pointercancel', ()=>{
        state.isPointerDown = false;
        state.draggingUid = null;            // ★ 追加：必ず解除
        g.classList.remove('dragging');

      });
      // （以下続く）

      // （削除）svg.addEventListener('pointermove', ...) は削除して、
      // グローバル installGlobalPointerMove のみに一本化する

      // ホスト削除ポップ
// 左長方形内アイコン：クリックで「上に1個ぶん移動」
// ただし直前にドラッグが走っていた場合は何もしない
g.addEventListener('click', async (e)=>{
  if (g.dataset.dragMoved === '1') {      // ← ドラッグ直後なら無視
    g.dataset.dragMoved = '0';            // リセット
    return;
  }
const curX = parseFloat(g.getAttribute('data-x') || data.x || 0);
const curY = parseFloat(g.getAttribute('data-y') || data.y || 0);
const step = 22;
const pos  = clampToRect(curX, curY - step);

// ① DOMを即時に反映（ここが追加）
g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
g.setAttribute('data-x', pos.x);
g.setAttribute('data-y', pos.y);

// ② バージョンを進めてローカルに記録
const nextVer = (state.localMoveVer[uid] || 0) + 1;
state.localMoveVer[uid] = nextVer;

// ③ クリック反映中はDBエコーで“戻らない”ように短いガード（任意）
state.dragKickGuardUid   = uid;
state.dragKickGuardUntil = Date.now() + 180;

// ④ DB更新
await update(ref(db, `rooms/${state.code}/icons/${uid}`), {
  x: pos.x,
  y: pos.y,
  ver: nextVer
});

});

layer.appendChild(g);

    }

    // 名前更新
    const text = g.querySelector('text');
    if (text && text.textContent !== (data.name || '?')) text.textContent = (data.name || '?' );

    // 色適用（参加者カラー）
    const colorName = userColorsMap?.[uid] || null;
    if (colorName) applyFillAndText(g, colorName);

    // 自分がドラッグ中はリモート更新を抑止＋開始直後の“戻り”も抑止
const now = Date.now();
const draggingNow = (state.isPointerDown && state.draggingUid === uid);
const kickGuard = (state.dragKickGuardUid === uid) && (now < (state.dragKickGuardUntil || 0));
const settleGuard = (state.dragSettleGuardUid === uid) && (now < (state.dragSettleGuardUntil || 0));

// ★ リモート/ローカルのバージョン比較（自分のアイコンのみ適用）
const remoteVer = Number(data.ver || 0);
const localVer  = Number(state.localMoveVer[uid] || 0);
const isStaleForMe = (uid === state.uid) && (remoteVer < localVer);

if (!(draggingNow || kickGuard || settleGuard) && !isStaleForMe) {
  g.setAttribute('transform', `translate(${data.x},${data.y})`);
  g.setAttribute('data-x', data.x);
  g.setAttribute('data-y', data.y);
}

  }

  function throttle(fn, ms){

    let t = 0, lastArgs = null, tid = null;
    return function(...args){
      const now = Date.now();
      if (now - t >= ms){ t = now; fn.apply(this, args); }
      else {
        lastArgs = args; clearTimeout(tid);
        tid = setTimeout(()=>{ t = Date.now(); fn.apply(this, lastArgs); lastArgs = null; }, ms - (now - t));
      }
    };
  }

    // --- グローバルに1回だけ pointermove をインストール ---
  let pointerMoveInstalled = false;
  function installGlobalPointerMove(){
    if (pointerMoveInstalled) return;
    pointerMoveInstalled = true;

const svg = document.getElementById('art');
svg.addEventListener('pointermove', (e)=>{
  if (!state.isPointerDown || !state.draggingUid) return;

  const layer = document.getElementById('icons');
  const g = layer && layer.querySelector(`g[data-uid="${state.draggingUid}"]`);
  if (!g) return;

  const p = toSvgCoords(svg, e.clientX, e.clientY);
  const pos = clampToRect(p.x - state.dragOffset.x, p.y - state.dragOffset.y);
  g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
  g.setAttribute('data-x', pos.x);
  g.setAttribute('data-y', pos.y);

  g.dataset.dragMoved = '1';              // ★ 追加：実移動＝ドラッグ発生

  const uid = state.draggingUid;
  const nextVer = (state.localMoveVer[uid] || 0) + 1;
  state.localMoveVer[uid] = nextVer;


update(ref(db, `rooms/${state.code}/icons/${uid}`), {
  x: pos.x,
  y: pos.y,
  ver: nextVer               // ★ 連番でエコー順序を担保
});
    }, { passive: true });
  }

  // ====== 色選択 ======
  const COLOR_LIST = [
    { id:'red',     name:'赤',    bg:'#9e0d0d' },
    { id:'blue',    name:'青',    bg:'#3d3b80' },
    { id:'black',   name:'黒',    bg:'#000000' },
    { id:'green1',  name:'緑',    bg:'#43a047' },
    { id:'white',   name:'白',    bg:'#ffffff', border:'#111' },
    { id:'green2',  name:'緑',    bg:'#43a047' }, // 指示通り2つ目の緑
    { id:'purple',  name:'紫',    bg:'#8e24aa' },
    { id:'cyan',    name:'水色',  bg:'#26c6da' },
    { id:'orange',  name:'オレンジ', bg:'#fb8c00' },
    { id:'yellow',  name:'黄',  bg:'#e3ed1c' },
  ];
  function colorToStyle(colorName){
    // 背景と文字色の組合せ規定
    const darkText = ['赤','青','黒','緑','紫']; // これらは白文字
    const item = COLOR_LIST.find(c => c.name===colorName || c.id===colorName) || null;
    const bg = item?.bg || '#fff';
    const label = item?.name || '';
    const needWhite = darkText.includes(label) || ['red','blue','black','green1','green2','purple'].includes(item?.id);
    return { bg, text: needWhite ? '#fff' : '#111' };
  }

// === トップ順アイコン生成（色背景＋頭文字＋番号バッジ） ===
function makeTopIcon(name, colorName, index){
  const { bg, text } = colorToStyle(colorName || '');
  const div = document.createElement('div');
  div.className = 'top-icon';
  div.style.background = bg;
  div.style.color = text;
  div.textContent = name || '?';
  return div;
}

// === トップ順アイコンの再描画 ===
// claims: rooms/{code}/colors のスナップ（colorId -> {uid,name,at}）
function renderTopIcons(claims){
  const bar = document.getElementById('topIconBar');
  if (!bar) return;



  const present = state.present || {};
  // 在室者のみ抽出し、色を取った時刻（at）で昇順ソート
  const list = Object.values(claims || {})
    .filter(v => v && v.uid && present[v.uid])
    .sort((a,b) => (a.at || 0) - (b.at || 0));

  bar.innerHTML = '';
  if (!list.length){
    bar.classList.add('hidden');
    return;
  }
  bar.classList.remove('hidden');

  // アクティブ番号（1.5倍）を維持・初期化
  if (typeof state.topActiveIndex !== 'number' || state.topActiveIndex >= list.length){
    state.topActiveIndex = 0;
  }

  list.forEach((v, i) => {
    const colorLabel = present[v.uid]?.color || '';  // participants に保存された色ラベルを使用
    const icon = makeTopIcon(v.name, colorLabel, i);
    if (i === state.topActiveIndex) icon.classList.add('active');

    // 仕様：「拡大されているアイコン」を押した時だけ、次へバトンタッチ
    icon.addEventListener('click', async () => {
      if (i !== state.topActiveIndex) return; // 今拡大中のアイコン以外は無視
      const kids = [...bar.children];
      const next = kids.length ? (state.topActiveIndex + 1) % kids.length : 0;
      // クリック結果を全員に共有
      await set(ref(db, `rooms/${state.code}/ui/topActiveIndex`), next);
    });

    bar.appendChild(icon);
  });
}



/* === 4a: 装備所持用の小アイコンを作る === */
function makeEquipIcon(name, colorName){
  const div = document.createElement('div');
  div.className = 'equip-icon';
  const { bg, text } = colorToStyle(colorName || '');
  div.style.background = bg;
  div.style.color = text;
  div.textContent = name || '?';
  return div;
}

  
  function renderColorGrid(claims){
    colorGrid.innerHTML = '';
    const present = state.present || {};                 // ★ 在籍者表（uidキー）
    COLOR_LIST.forEach(c=>{
      const tile = document.createElement('div');
      tile.className = 'color-tile';
      
          // ★ 追加：背景と文字色を両方適用
    const { bg, text } = colorToStyle(c.id);
    tile.style.background = bg;
    tile.style.color = text;
      
      if (c.border) tile.style.borderColor = c.border;
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = c.name;
      tile.appendChild(label);

      const claim = claims?.[c.id] || null;
         const isPresent = !!(claim && claim.uid && present[claim.uid]);   // ★ 在籍チェック
    if (claim && isPresent){                                          // ★ 在籍者のみ表示
        const o = document.createElement('div');
        o.className = 'owner';
        o.textContent = claim.name || '?';
        tile.appendChild(o);
        if (claim.uid !== state.uid){
          tile.classList.add('taken-by-others');
        }else{
          tile.classList.add('mine');
        }
      }

      tile.addEventListener('click', async ()=>{
        if (state.started) return;
        // 既に他者が取っていれば何もしない
        const snap = await get(ref(db, `rooms/${state.code}/colors/${c.id}`));
        const cur = snap.val();


  // ★ 追加：在籍チェック
  const present = state.present || {};
  const takenByPresentOther = !!(cur && cur.uid && present[cur.uid] && cur.uid !== state.uid);

  if (takenByPresentOther) return;
        
        // 自分が持っている別色の解放
        const colorsSnap = await get(ref(db, `rooms/${state.code}/colors`));
        const all = colorsSnap.val() || {};
        const mine = Object.entries(all).find(([id, v])=> v?.uid === state.uid);
        if (mine) await remove(ref(db, `rooms/${state.code}/colors/${mine[0]}`));

        // この色にセット
        await set(ref(db, `rooms/${state.code}/colors/${c.id}`), { uid: state.uid, name: state.name, at: Date.now() });
        // 参加者カラーにも保存
        await update(ref(db, `rooms/${state.code}/participants/${state.uid}`), { color: c.name });
      });

      colorGrid.appendChild(tile);
    });

  // 合計人数表示（在籍者だけ数える）★
  const countEl = document.getElementById('colorCount');
  if (countEl){
    const uidSet = new Set(
      Object.values(claims || {})
        .map(v => v && v.uid)
        .filter(uid => uid && present[uid])             // ★ 在籍者のみ
    );
    countEl.textContent = `ゲーム参加者合計：${uidSet.size}`;
  }
}


function observeColors(){
  const colorsRef = ref(db, `rooms/${state.code}/colors`);
  const off = onValue(colorsRef, (snap)=>{
    const claims = snap.val() || {};
    state.colorClaims = claims;           // ★ 追加：常に最新をキャッシュ
    renderColorGrid(claims);
renderTopIcons(claims);

  });
  state.unsub.push(off);
}

function buildRoleMiniCard(containerDiv, cardName){
  // 役職メタ（init/rest/kana/faction/hp）は既存の ROLE_META から取得
  const meta = ROLE_META[cardName];
  if (!meta) return;

  // 外枠クラス（役職ごとの枠色）＋背景
  containerDiv.classList.add('role-mini', meta.faction);
  containerDiv.style.backgroundImage = `url("${cardName}.jpg")`;

  // 上段
  const top = document.createElement('div');
  top.className = 'mini-row-top';

  const ini = document.createElement('div');
  ini.className = 'mini-initial';
  ini.textContent = meta.init;

  const rest = document.createElement('div');
  rest.className = 'mini-rest';
  rest.textContent = meta.rest;

  top.appendChild(ini);
  top.appendChild(rest);
  containerDiv.appendChild(top);

  // 中段
  const mid = document.createElement('div');
  mid.className = 'mini-center';

  const nameBar = document.createElement('div');
  nameBar.className = 'mini-name';
  nameBar.textContent = meta.kana;

  const hp = document.createElement('div');
  hp.className = 'mini-hp';
  const hpSpan = document.createElement('span');
  hpSpan.textContent = String(meta.hp);
  hp.appendChild(hpSpan);

  mid.appendChild(nameBar);
  mid.appendChild(hp);
  containerDiv.appendChild(mid);

  // 下段：効果テーブル（役職の説明テキスト；必要なら ROLE_INFO を流用）
  const eff = document.createElement('div');
  eff.className = 'mini-table ' + meta.faction;
eff.innerHTML = (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[cardName])
  ? ROLE_INFO[cardName]
  : '';

  containerDiv.appendChild(eff);
}



  // ▼ 装備一覧の描画（自分の行が先頭に来る）
  function renderEquipments(equipData, participants){
    const equipBar = document.getElementById('equipBar');
    equipBar.innerHTML = '';

    // 並べ替え：自分(uid)を先頭に
    const entries = Object.entries(equipData || {});
    entries.sort(([uidA],[uidB])=>{
      if (uidA === state.uid) return -1;
      if (uidB === state.uid) return 1;
      return 0;
    });

    entries.forEach(([uid, cards])=>{
      const holder = document.createElement('div');
      holder.className = 'equip-holder';

      // 名前＋色アイコン
      const p = participants?.[uid] || {};
      holder.appendChild(makeEquipIcon(p.name, p.color));

      // 装備カード群
// 装備カード群
Object.keys(cards).forEach(cardName=>{
  const cardDiv = document.createElement('div');
  cardDiv.className = 'equip-card';
  cardDiv.textContent = cardName;

  // ① このカードが「誰の装備欄にあるか」を覚えておく
  cardDiv.dataset.ownerUid = uid;
  cardDiv.dataset.source   = 'equip';

  // ② クリックで拡大ビューを開く（配色も適用）
cardDiv.onclick = ()=>{
const raw = String(cardName ?? '');           // ← 生のキー（スペース保持）
const display = raw.trim();       

  // 装備欄からの拡大であることを記録（奪う等の判定で使用）
 state.expandedContext = { source:'equip', ownerUid: uid, cardName: cardName }; // raw
  // 右下カード（正体公開ボタン）の誤作動を防止
  dealCardFace.onclick = null;
  const rp = document.getElementById('revealPopover');
  if (rp) rp.classList.add('hidden');


    if (isRoleCard(display)) {
        showRoleExpanded(display);   // ← 正体カード拡大：背景に `${display}.jpg`
      } else {
        showEquipExpanded(display);  // ← 従来の装備拡大：画像/効果テーブル
      }
  state.pinDealViewer = false;
  show(dealViewer, true);
};


  holder.appendChild(cardDiv);
});

      
      equipBar.appendChild(holder);
    });

    show(equipBar, entries.length > 0);
  }

  // ▼ 装備購読
  function observeEquipments(){
    const equipRef = ref(db, `rooms/${state.code}/equipment`);
    const off = onValue(equipRef, (snap)=>{
      const equipData = snap.val() || {};
      renderEquipments(equipData, state.participants);
    });
    state.unsub.push(off);
  }
  

// ====== 正体カード定義 ======
const ROLE_CARDS = {
  raider: [
    'Eエミ','Eエマ','Eエリカ',
    'Fフェリックス','Fフレディ','Fフェリシア',
    'Gゴードン','Gゴドウィン','Gガラハド'
  ],
  shadow: [
    'Uウルリッヒ','Uウラヌス','Uアルスター',
    'Vヴァンパイア','Vヴェンデッタ','Vヴェノム',
    'Wワーウルフ','Wワイト','Wワルプルギス'
  ],
  citizen: [
    'Aアリス','Aアンジェラ','Aアガサ',
    'Bバイロン','Bベンジャミン','Bブルース',
    'Cクレイグ','Cクレア','Cキャロル',
    'Dダニエル','Dデーヴィッド','Dデボラ'
  ],
};
function isRoleCard(cardName){
  return ROLE_CARDS.shadow.includes(cardName)
      || ROLE_CARDS.raider.includes(cardName)
      || ROLE_CARDS.citizen.includes(cardName);
}


// === 役職メタ情報（英名の残り／カタカナ／陣営／HP） ===
// キーは既存の役職カード名（例：'Aアリス'）
const ROLE_META = {
  // CITIZEN
  'Aアリス':      { init:'A', rest:'- LICE',      kana:'アリス',      faction:'citizen', hp:8  },
  'Aアンジェラ':  { init:'A', rest:'- NGELA',     kana:'アンジェラ',  faction:'citizen', hp:8  },
  'Aアガサ':      { init:'A', rest:'- GATHA',     kana:'アガサ',      faction:'citizen', hp:8  },
  'Bバイロン':    { init:'B', rest:'- YLON',      kana:'バイロン',    faction:'citizen', hp:10 },
  'Bベンジャミン':{ init:'B', rest:'- ENJAMIN',   kana:'ベンジャミン',faction:'citizen', hp:10 },
  'Bブルース':    { init:'B', rest:'- RUCE',      kana:'ブルース',    faction:'citizen', hp:10 },
  'Cクレイグ':    { init:'C', rest:'- RAIG',      kana:'クレイグ',    faction:'citizen', hp:11 },
  'Cキャロル':    { init:'C', rest:'- AROL',      kana:'キャロル',    faction:'citizen', hp:11 },
  'Cクレア':      { init:'C', rest:'- LAIRE',     kana:'クレア',      faction:'citizen', hp:11 },
  'Dダニエル':    { init:'D', rest:'- ANIEL',     kana:'ダニエル',    faction:'citizen', hp:13 },
  'Dデーヴィッド':{ init:'D', rest:'- AVID',      kana:'デーヴィッド',faction:'citizen', hp:13 },
  'Dデボラ':      { init:'D', rest:'- EBORAH',    kana:'デボラ',      faction:'citizen', hp:13 },

  // RAIDER
  'Eエミ':        { init:'E', rest:'- MI',        kana:'映魅',        faction:'raider',  hp:10 }, // 「映魅」指定
  'Eエリカ':      { init:'E', rest:'- RICA',      kana:'エリカ',      faction:'raider',  hp:10 },
  'Eエマ':        { init:'E', rest:'- MA',        kana:'エマ',        faction:'raider',  hp:10 },
  'Fフェリックス':{ init:'F', rest:'- ELIX',      kana:'フェリックス',faction:'raider',  hp:12 },
  'Fフェリシア':  { init:'F', rest:'- ELICIA',    kana:'フェリシア',  faction:'raider',  hp:12 },
  'Fフレディ':    { init:'F', rest:'- REDDIE',    kana:'フレディ',    faction:'raider',  hp:12 },
  'Gゴードン':    { init:'G', rest:'- ORDON',     kana:'ゴードン',    faction:'raider',  hp:14 },
  'Gガラハド':    { init:'G', rest:'- ARAHAD',    kana:'ガラハド',    faction:'raider',  hp:14 },
  'Gゴドウィン':  { init:'G', rest:'- ODWIN',     kana:'ゴドウィン',  faction:'raider',  hp:14 },

  // SHADOW
  'Uウルリッヒ':  { init:'U', rest:'- LRICH',     kana:'ウルリッヒ',  faction:'shadow',  hp:11 },
  'Uウラヌス':    { init:'U', rest:'- RANUS',     kana:'ウラヌス',    faction:'shadow',  hp:11 },
  'Uアルスター':  { init:'U', rest:'- LSTER',     kana:'アルスター',  faction:'shadow',  hp:11 },
  'Vヴェノム':    { init:'V', rest:'- ENOM',      kana:'ヴェノム',    faction:'shadow',  hp:13 },
  'Vヴァンパイア':{ init:'V', rest:'- AMPIRE',    kana:'ヴァンパイア',faction:'shadow',  hp:13 },
  'Vヴェンデッタ':{ init:'V', rest:'- ENDETTA',   kana:'ヴェンデッタ',faction:'shadow',  hp:13 },
  'Wワイト':      { init:'W', rest:'- IGHT',      kana:'ワイト',      faction:'shadow',  hp:14 },
  'Wワルプルギス':{ init:'W', rest:'- ALPURGA',   kana:'ワルプルギス',faction:'shadow',  hp:14 },
  'Wワーウルフ':  { init:'W', rest:'- EREWOLF',   kana:'ワーウルフ',  faction:'shadow',  hp:14 },
};

// 陣営→クラス（丸バッジの色に使う）
const FACTION_CLASS = { citizen:'citizen', raider:'raider', shadow:'shadow' };


const ROLE_INFO = {
  "Aアリス": '<span class="condition">勝利条件</span> 生存している。<br><span class="condition">うさぎさんヒール</span> 手番の初めに使用する。ダメージを全回復する（1回のみ）',
  "Aアンジェラ": '<span class="condition">勝利条件</span> 右隣りのプレイヤーが勝利する。<br><span class="condition">移り気</span> 「勝利条件を左となりのプレイヤーが勝利する」に変更する。（1回のみ）',
  "Aアガサ": '<span class="condition">勝利条件</span> あなたの手番でゲームが終了する。<br><span class="condition">完全犯罪</span> 手番の最後にダイスを2個振り、出目エリアにいるPL全員に3ダメージ。（1回のみ）',
  "Bバイロン": '<span class="condition">勝利条件</span> 装備カードを5枚以上所持する。<br><span class="condition">念力の懐中時計</span> 2以上の攻撃ダメージを与えた場合、代わりに装備を1つ奪うことができる。',
  "Bベンジャミン": '<span class="condition">勝利条件</span> あなた以外のPLが装備を5つ以上所持している。<br><span class="condition">太鼓持ち</span> 手番の最後に使用する。同じエリアのPLに装備を1つ渡すことができる。',
  "Bブルース": '<span class="condition">勝利条件</span> 攻撃でHP12以上のPLを脱落させる。または終了時に9にいる。<br><span class="condition">国士無双</span> 攻撃でHP11以下のPLを脱落させた時、必ず自分の正体を公開する。',
  "Cクレイグ": '<span class="condition">勝利条件</span> 2人脱落している状態で、他PLを「攻撃」して脱落させる。<br><span class="condition">死の饗宴</span> 攻撃後、自分に2ダメージ与えた後、もう一度同じPLを攻撃できる。',
  "Cキャロル": '<span class="condition">勝利条件</span> 最初に脱落する。または、あなたともう1人だけが脱落していない。<br><span class="condition">聖痕</span> 手番の初めに2ダメージ回復する。',
  "Cクレア": '<span class="condition">勝利条件</span> ゲーム終了時にあなたのダメージが「6～8」である。<br><span class="condition">キャスリング</span> 手番の初めに、あなたと他PLのHPを入れ替える。(1回)',
  "Dダニエル": '<span class="condition">勝利条件</span> 最初に脱落する。またはシャドウ全員の脱落と生存。<br><span class="condition">絶叫</span> 一番最初にあなた以外のPLが脱落した時、正体カードを公開しなければならない。',

  "Dデーヴィッド": '<span class="condition">勝利条件</span>「聖杯」「コンパス」「ブローチ」「ロザリオ」のうち3種を所持する。<br><span class="condition">グレイブディガー</span> 手番の初めに脱落者のカードにある任意の装備を1枚獲得する。',

  "Dデボラ": '<span class="condition">勝利条件</span> 5人：ゲーム終了時に最もダメージが多い。6人：あなた以外のシチズンが勝利する。<br><span class="condition">献身的な愛</span> 手番の初めに勝利条件を「脱落する。」に変える。',


  // RAIDER
  "Eエミ":  '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">テレポート</span> 移動の時、出目のエリアに移動するか、その両隣のエリアに移動できる。',
  "Eエリカ": '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">癒しの光</span> 手番終了時に4面ダイスを振って、出目の数だけ他PLを回復できる。',
  "Eエマ": '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">封印の鎖</span> 手番の初めに他PLを1人選んで、ゲーム終了まで特殊能力を封印する。(1回)',
  "Fフェリックス": '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">アストラル・メイス</span> 手番の初めに他PLを1人選び6面ダイスを振ってダメージを与える。(1回)',
  "Fフェリシア": '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">スラム街の天使</span> 手番の初めに任意のPLを選びダメージを「7」にする。(1回)',
  "Fフレディ": '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">ドラゴンアタック</span>正体を公開しているPLへの攻撃が成功した時、+2ダメージする。',
  "Gゴードン": '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">絶対無敵バリア</span> 手番の終了時に使う。あなたの次の手番の初めまであらゆるダーメージを受けない。(1回)',
  "Gガラハド": '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">魔剣の伝承者</span> エクスカリバーを所持している時に攻撃が失敗したらダイスを振り直す。',
  "Gゴドウィン": '<span class="condition">勝利条件</span> シャドウ全員の脱落<br><span class="condition">蘇生装置TYPE-G</span> あなたが脱落した時、既に脱落しているPLを1人7ダメージの状態で復活させる。',

  // SHADOW
  "Uウルリッヒ": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br>あなたが推理カードを受け取った時、ウソをついてもよい。',
  "Uウラヌス": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br><span class="condition">メテオストライク</span> 手番の初めに4-5,10にいるPL1人に3ダメージを与える。',
  "Uアルスター": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br><span class="condition">デル・フリス</span> 2回攻撃ができる。',
  "Vヴェノム": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br><span class="condition">反駁の猛毒</span> あなたを攻撃したPLは、1ダメージ受けるかあなたに装備を渡すか選ぶ。',
  "Vヴァンパイア": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br><span class="condition">吸血</span> 攻撃に成功した時ダメージを2回復する。',
  "Vヴェンデッタ": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br><span class="condition">冥府の大鎌</span> Aあなたの攻撃は4面ダイスのみを使用する。',
  "Wワイト": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br><span class="condition">亡者の王</span> 手番の終了後「脱落しているPLの数だけ」手番を行う。(1回)',
  "Wワルプルギス": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br><span class="condition">重力の虹</span> 攻撃を行う時に任意のPL1人とあなたの位置を交換できる。',
  "Wワーウルフ": '<span class="condition">勝利条件</span> レイダー全員、またはシチズン3人の脱落<br><span class="condition">反撃</span> 攻撃を受けた時、そのPLをただちに攻撃できる。',
};




const ROLE_MINI_INFO = {

"Aアリス": '<span class="condition">勝利条件</span> 生存している。',
"Aアンジェラ": '<span class="condition">勝利条件</span> （能力使用後は）左隣りのプレイヤーが勝利する。',
"Aアガサ": '<span class="condition">勝利条件</span> あなたの手番でゲームが終了する。',
"Bバイロン": '<span class="condition">勝利条件</span> 装備カードを5枚以上所持する。',
"Bベンジャミン": '<span class="condition">勝利条件</span> あなた以外のPLが装備を5つ以上所持している。',
"Bブルース": '<span class="condition">勝利条件</span> 攻撃でHP12以上のPLを脱落させる。または終了時に9にいる。',
"Cクレイグ": '<span class="condition">勝利条件</span> 2人脱落している状態で、他PLを「攻撃」して脱落させる。',
"Cキャロル": '<span class="condition">勝利条件</span> 最初に脱落するか、あなたともう1人だけが脱落していない。',
"Cクレア": '<span class="condition">勝利条件</span> ゲーム終了時にあなたのダメージが「6～8」である。',
"Dダニエル": '<span class="condition">勝利条件</span> 最初に脱落する。またはシャドウ全員の脱落と生存。',
"Dデーヴィッド": '<span class="condition">勝利条件</span> 「聖杯」「コンパス」「ブローチ」「ロザリオ」のうち3種を所持する。',
"Dデボラ": '<span class="condition">勝利条件</span> 自分が脱落する。',



"Eエミ":'<span class="condition">テレポート</span>移動の時、出目のエリアか、その両隣のエリアに移動できる。',
"Eエリカ":'<span class="condition">癒しの光</span>手番終了時に4面ダイスを振り、出目の数だけ他PLを回復できる',
"Eエマ":'<span class="condition">封印の鎖</span>手番の初めに他PLを1人選んで特殊能力を封印する。(1回)',
"Fフェリックス":'<span class="condition">アストラル・メイス</span>手番の初めに他PLを1人選び6面ダイスを振ってダメージを与える。(1回)',
"Fフェリシア":'<span class="condition">スラム街の天使</span>手番の初めに任意のPLを選びダメージを「7」にする。(1回)',
"Fフレディ":'<span class="condition">ドラゴンアタック</span>正体が公開のPLへの攻撃が成功した時、+2ダメージする',
"Gゴードン":'<span class="condition">絶対無敵バリア</span>次の手番の初めまであらゆるダメージを受けない。(1回)',
"Gガラハド":'<span class="condition">魔剣の伝承者</span>エクスカリバー所有時、攻撃が失敗してもダイスを振り直す。',
"Gゴドウィン":'<span class="condition">蘇生装置TYPE-G</span>脱落時、既に脱落しているPLを1人7ダメージの状態で復活させる',
"Uウルリッヒ":'推理カードを受け取った時にウソをついてもよい。',
"Uウラヌス":'<span class="condition">メテオストライク</span>手番の初めに4-5,10にいるPL1人に3ダメージを与える',
"Uアルスター":'<span class="condition">デル・フリス</span>2回攻撃ができる',
"Vヴェノム":'<span class="condition">反駁の猛毒</span>あなたを攻撃したPLは、1ダメージ受けるか装備を渡すか選ぶ',
"Vヴァンパイア":'<span class="condition">吸血</span>攻撃に成功した時ダメージを2回復する',
"Vヴェンデッタ":'<span class="condition">冥府の大鎌</span>あなたの攻撃は4面ダイスのみを使用する',
"Wワイト":'<span class="condition">亡者の王</span>手番の終了後「脱落しているPLの数だけ」手番を行う。(1回)',
"Wワルプルギス":'<span class="condition">重力の虹</span>攻撃を行う時に任意のPL1人とあなたの位置を交換できる',
"Wワーウルフ":'<span class="condition">反撃</span>攻撃を受けた時、そのPLをただちに攻撃できる',

  // 必要なカードだけ入れればOK（無いカードは従来にフォールバック）
};





/** 正体カードの拡大レイアウトを描画 */
/** 正体カード拡大：カード名.jpgを“タイトル/HP/テーブルの後ろ”に重ねて表示する */
function showRoleExpanded(roleKey){


  const meta = ROLE_META[roleKey];
  // メタが無ければ従来通りテキストだけ
  if (!meta){
    dealCardFace.className = 'deal-card role-layout';
    dealCardFace.textContent = roleKey || '？';
    return;
  }

  // ルート初期化（既存レイアウト維持）
  dealCardFace.className = 'deal-card role-layout';
  dealCardFace.innerHTML = '';

  dealCardFace.removeAttribute('style');   // border等も一旦クリア
  dealCardFace.style.background = '';
  dealCardFace.style.color = '';
  colorizeDealFaceByCardName(roleKey);     // citizen/raider/shadow の地色を先に決める

  // ▼ ：陣営ごとの枠線色
  const BORDER_BY_FACTION = { CITIZEN:'#e3ed1c', RAIDER:'#9e0d0d', SHADOW:'#3d3b80' };
  if (meta && meta.faction) {
    dealCardFace.style.border = `4px solid ${BORDER_BY_FACTION[meta.faction.toUpperCase()] || '#111'}`;
    dealCardFace.style.borderRadius = '14px'; // 既存の角丸に合わせる
  }

  // ▼ 背景画像（<カード名>.jpg）を“最初に”追加して最背面に固定
  dealCardFace.style.position = 'relative';  // スタッキング文脈
  const bg = document.createElement('img');
  bg.src = `${roleKey}.jpg`;
  bg.alt = roleKey;
  Object.assign(bg.style, {
    position: 'absolute',
    inset: '0',          // 上下左右0で全面フィット
    width: '100%',
    height: '100%',
    objectFit: 'cover',
    zIndex: '0',         // 最背面
    pointerEvents: 'none',
    borderRadius: '14px' // 角丸に合わせてにじみ防止
  });
  bg.addEventListener('error', () => bg.remove()); // 画像が無ければ除去
  dealCardFace.appendChild(bg);

  // ▼ 上段：イニシャル丸＋陣営ラベル＋英名（既存どおり）
  const row = document.createElement('div');
  row.className = 'role-row';
  row.style.position = 'relative';
  row.style.zIndex = '1'; // 背景より前面に
  const init = document.createElement('div');
  init.className = `role-initial ${FACTION_CLASS[meta.faction]}`;
  init.textContent = meta.init;
  const fac = document.createElement('div');
  fac.className = 'role-faction';
  fac.textContent = meta.faction.toUpperCase(); // CITIZEN / RAIDER / SHADOW
  init.appendChild(fac);
  const rest = document.createElement('div');
  rest.className = 'role-rest';
  rest.textContent = meta.rest;
  row.appendChild(init);
  row.appendChild(rest);

  // ▼ 中段：カタカナ名＋HP丸（既存どおり）
  const mid = document.createElement('div');
  mid.className = 'role-center';
  mid.style.position = 'relative';
  mid.style.zIndex = '1';
  const name = document.createElement('div');
  name.className = 'role-name';
  name.textContent = meta.kana;
  const hp = document.createElement('div');
  hp.className = 'role-hp';
  const hpSpan = document.createElement('span');
  hpSpan.textContent = meta.hp;
  hp.appendChild(hpSpan);
  mid.appendChild(name);
  mid.appendChild(hp);

  // ▼ 下段：各役職のテキストテーブル（既存どおり）
  const infoTable = document.createElement('table');
  infoTable.className =
    'role-table ' +
    (meta.faction === 'raider' ? 'raider' :
     meta.faction === 'shadow' ? 'shadow' : 'citizen');
  infoTable.style.position = 'relative';
  infoTable.style.zIndex = '1';
  const tr = document.createElement('tr');
  const td = document.createElement('td');
  td.innerHTML = ROLE_INFO[roleKey] || "";
  tr.appendChild(td);
  infoTable.appendChild(tr);

  // 追加順（背景→上段→中段→テーブル）
  dealCardFace.appendChild(row);
  dealCardFace.appendChild(mid);
  dealCardFace.appendChild(infoTable);
}



// 人数ごとの役職割り当て
const ROLE_DISTRIBUTION = {
  1: { raider:0, shadow:0, citizen:1 },
  2: { raider:1, shadow:1, citizen:0 },
  3: { raider:2, shadow:1, citizen:0 },
  4: { raider:2, shadow:2, citizen:0 },
  5: { raider:2, shadow:2, citizen:1 },
  6: { raider:2, shadow:2, citizen:2 },
  7: { raider:2, shadow:2, citizen:3 },
  8: { raider:3, shadow:3, citizen:2 },
  9: { raider:3, shadow:3, citizen:3 },
 10: { raider:3, shadow:3, citizen:4 },
};

// 追加：デッキ順インデックス作成（フィッシャー–イェーツ）
function makeShuffledOrder(deckId){
  const def = DECKS_DEF[deckId];
  const order = Array.from({length: def.cards.length}, (_, i)=> i);
  for (let i = order.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [order[i], order[j]] = [order[j], order[i]];
  }
  return order;
}
  
async function hostStartIfNotStarted(){
  const startedRef = ref(db, `rooms/${state.code}/game/started`);
  const startedSnap = await get(startedRef);
  if (startedSnap.val()) return;

// 色選択者だけを配布対象にする
const colorsSnap = await get(ref(db, `rooms/${state.code}/colors`));
const claims = colorsSnap.val() || {};
const uids = [...new Set(Object.values(claims).map(v => v && v.uid).filter(Boolean))];
if (uids.length === 0) return;

const dist = ROLE_DISTRIBUTION[uids.length];
if (!dist) return;

  // 各役職ごとにシャッフル（既存）
  function shuffle(arr){ return [...arr].sort(()=>Math.random()-0.5); }
  const raiders  = shuffle(ROLE_CARDS.raider).slice(0, dist.raider);
  const shadows  = shuffle(ROLE_CARDS.shadow).slice(0, dist.shadow);
  const citizens = shuffle(ROLE_CARDS.citizen).slice(0, dist.citizen);
  const selected = shuffle([...raiders, ...shadows, ...citizens]);

  // 参加者に割り当て（既存）
  const assign = {};
  uids.forEach((uid, i)=>{ assign[uid] = selected[i]; });

  // ★ ここから追加：3デッキを「idx:-1 & 新order」で初期化（＝シャッフル）
  const now = Date.now();
  const decksInit = (id)=> ({ idx: -1, order: makeShuffledOrder(id), at: now });

  const updates = {};
  // 正体カード
  updates[`rooms/${state.code}/deal/v1/cards`] = assign;
  updates[`rooms/${state.code}/deal/v1/at`] = now;
  updates[`rooms/${state.code}/game/started`] = true;

  // ★ デッキ3種の初期化（シャッフル結果を同期保存）
  updates[`rooms/${state.code}/decks/green`] = decksInit('green');
  updates[`rooms/${state.code}/decks/white`] = decksInit('white');
  updates[`rooms/${state.code}/decks/black`] = decksInit('black');

  await update(ref(db), updates);
}

async function hostReset(){
  const now = Date.now();
  const updates = {};
  // 指定どおりの初期化
  updates[`rooms/${state.code}/icons`]            = null;                // テーブルのアイコン削除
  updates[`rooms/${state.code}/equipment`]        = null;                // 装備一覧削除
  updates[`rooms/${state.code}/greenHistory`]     = null;                // 緑履歴削除
  updates[`rooms/${state.code}/deal/v1/cards`]    = null;                // 配布した正体カード削除
  updates[`rooms/${state.code}/greenActive`]      = { active:false, text:null };
  // デッキも初期状態に（表はブランクへ戻る）
  updates[`rooms/${state.code}/decks/green`]      = { idx:-1, order: makeShuffledOrder('green'), at: now };
  updates[`rooms/${state.code}/decks/white`]      = { idx:-1, order: makeShuffledOrder('white'), at: now };
  updates[`rooms/${state.code}/decks/black`]      = { idx:-1, order: makeShuffledOrder('black'), at: now };
updates[`rooms/${state.code}/seats`] = null;   // ★ 右図の席アイコンを全削除
  updates[`rooms/${state.code}/game/started`]     = false;
  updates[`rooms/${state.code}/resetAt`]          = now;
  await update(ref(db), updates);
}

  
  // 自分のカード購読
function observeMyDeal(){
  const myRef = ref(db, `rooms/${state.code}/deal/v1/cards/${state.uid}`);
  const off = onValue(myRef, (snap)=>{
    const val = snap.val();
    const has = !!val;
    show(myDealMini, has);
    if (has){
myDealMini.onclick = ()=>{
  // 自分のカード表示（役職カードなら専用レイアウト）
  if (isRoleCard(val)) {
    showRoleExpanded(val);
  } else {
    dealCardFace.className = 'deal-card';
    dealCardFace.textContent = String(val);
  }


  state.expandedContext = { source: 'mydeal', ownerUid: state.uid, cardName: String(val) };

        
// ★ 正体カードの色分け（拡大ビュー用）
if (ROLE_CARDS.shadow.includes(val)) {
  dealCardFace.style.background = '#3d3b80'; // 青
  dealCardFace.style.color = '#fff';
} else if (ROLE_CARDS.raider.includes(val)) {
  dealCardFace.style.background = '#9e0d0d'; // 赤
  dealCardFace.style.color = '#fff';
} else if (ROLE_CARDS.citizen.includes(val)) {
  dealCardFace.style.background = '#e3ed1c'; // 黄
  dealCardFace.style.color = '#111';
} else {
  // その他カードは白背景に戻す
  dealCardFace.style.background = '#fff';
  dealCardFace.style.color = '#111';
}

show(dealViewer, true);


        // ☆ 追加：拡大カードを押すと「公開する」ポップ表示
dealCardFace.onclick = ()=>{
    const ctx = state.expandedContext || null;
  if (!ctx || ctx.source !== 'mydeal') return;
  const val = ctx.cardName || (dealCardFace.textContent || '').trim();
  if (DECKS_DEF.green.cards.includes(val)){
    // ★ 緑カード用：参加者選択ポップを開く
    showParticipantSelectPopup(val);
    return;
  }

  // ▼ それ以外（正体カードなど）は従来の「公開する」ポップ
  const pop = document.getElementById('revealPopover');
  if (!pop) return;
  pop.classList.remove('hidden');          const r = dealCardFace.getBoundingClientRect();
          // 拡大カードの中央に重ねる
          pop.style.left = (r.left + r.width/2 - 60) + 'px';
          pop.style.top  = (r.top + r.height/2 - 25) + 'px';

          // ☆ 追加：クリックアウェイ（他所をタップでポップを閉じる）
          // キャプチャ段階で拾い、同一タップで即閉じを防ぐため setTimeout
          setTimeout(()=>{
            const onDocClick = (e)=>{
              // ポップ内を押したら閉じない
              if (pop.contains(e.target)) return;
              pop.classList.add('hidden');
              document.removeEventListener('click', onDocClick, true);
            };
            document.addEventListener('click', onDocClick, true);
          }, 0);
        };
      };

    }else{
      myDealMini.onclick = null;
      dealCardFace.onclick = null;
    }
  });
  state.unsub.push(off);
}


function attachSfxListener(){
  if (!state.code) return;
  const sfxRef = ref(db, `rooms/${state.code}/sfx/current`);
  const off = onValue(sfxRef, snap=>{
    const v = snap.val();
    if (!v) return;
    const { id, at, nonce } = v;  // { id:'sfxRaider'|'sfxShadow'|'sfxCitizen', at:ms, nonce:string }
    scheduleSfxAt(id, at, nonce);
  });
  state.unsub.push(off); // 既存の解除配列に追加
}
  

// ☆ 追加：公開ボタンの挙動（1秒間の公開→装備欄の左へ固定）
const btnReveal = document.getElementById('btnReveal');
if (btnReveal){
  btnReveal.onclick = async ()=>{
    const val = state.expandedContext?.cardName || (dealCardFace.textContent || '').trim();
    if (!val) return;

    // 1) 全員に1秒だけ拡大画像を共有
    await set(ref(db, `rooms/${state.code}/reveal/${state.uid}`), { card: val, at: Date.now() });
    setTimeout(()=> remove(ref(db, `rooms/${state.code}/reveal/${state.uid}`)), 1000);

 try{
    const id = roleCardToSfxId(val);   // raider / shadow / citizen を判定
    if (id){
      const payload = {
        id,
        at: Date.now() + 250,          // 250ms 先に再生予約
        nonce: crypto.randomUUID()
      };
      await set(ref(db, `rooms/${state.code}/sfx/current`), payload);
      setTimeout(()=> remove(ref(db, `rooms/${state.code}/sfx/current`)).catch(()=>{}), 5000);
    }
  }catch(e){
    console.error('sfx write failed', e);
  }


    // 2) 装備所持データに追加（左端に来るよう render 側も修正する）
    const updates = {};
    // 既存のカードを壊さずマージしたいので、軽く read→write でもOKだが
    // ここでは単純にこのカードフラグを true で立てる
    updates[`rooms/${state.code}/equipment/${state.uid}/${val}`] = true;
    updates[`rooms/${state.code}/equipment_at`] = Date.now();
    await update(ref(db), updates);



    // 閉じる
    const pop = document.getElementById('revealPopover');
    if (pop) pop.classList.add('hidden');
    show(dealViewer, false);
  };
}

// ☆ 追加：公開購読（全員の画面で1秒だけ拡大カードを表示）
function observeReveals(){
  const refAll = ref(db, `rooms/${state.code}/reveal`);
  const off = onValue(refAll, (snap)=>{
    const all = snap.val() || {};
    const any = Object.values(all)[0];
    if (!any) return;

 // 表示内容（役職カードは専用レイアウト）
 if (isRoleCard(any.card)) {
   showRoleExpanded(any.card);
 } else {
   dealCardFace.className = 'deal-card'; // 既定
  dealCardFace.innerHTML = '';
  dealCardFace.style.background = '';
  dealCardFace.style.color = '';

   dealCardFace.textContent = any.card || '？';
 }

// 配色（デッキ色優先 → 役職カード → それ以外は白）
if (DECKS_DEF.white.cards.includes(any.card)) {
  applyDeckTheme(dealCardFace,'white');
} else if (DECKS_DEF.black.cards.includes(any.card)) {
  applyDeckTheme(dealCardFace,'black');
} else if (DECKS_DEF.green.cards.includes(any.card)) {
  applyDeckTheme(dealCardFace,'green');
} else if (ROLE_CARDS.shadow.includes(any.card)) {
  dealCardFace.style.background = '#3d3b80'; // 青
  dealCardFace.style.color = '#fff';
} else if (ROLE_CARDS.raider.includes(any.card)) {
  dealCardFace.style.background = '#9e0d0d'; // 赤
  dealCardFace.style.color = '#fff';
} else if (ROLE_CARDS.citizen.includes(any.card)) {
  dealCardFace.style.background = '#e3ed1c'; // 黄
  dealCardFace.style.color = '#111';
} else {
  dealCardFace.style.background = '#fff';
  dealCardFace.style.color = '#111';
}


    // 外側タップで閉じない
    state.pinDealViewer = true;
    show(dealViewer, true);

    // 少しして自動クローズ（DB側は1秒で消す仕様）
    setTimeout(()=>{
      state.pinDealViewer = false;
      show(dealViewer,false);
    }, 1200);
  });
  state.unsub.push(off);
}

/// === 追加：緑拡大の“ピン留め”ガード ===
/// dealViewer配下のクリックは、ピン留め中は閉じ処理に届かないよう握りつぶす
function installDealViewerPinGuard(){
  if (state._pinGuardInstalled) return;
  state._pinGuardInstalled = true;

  document.addEventListener('click', (e)=>{
    const viewerOpen = dealViewer && !dealViewer.classList.contains('hidden');
    if (!viewerOpen || !state.pinDealViewer) return;

    // ★ ここを修正：dealViewer配下でも「カード本体(#dealCardFace)」クリックは通す
    const panel = dealViewer.querySelector('.modal-panel');
    const card  = document.getElementById('dealCardFace');

    const clickedInsideViewer = dealViewer.contains(e.target);
    const clickedOnCard       = card && (e.target === card || card.contains(e.target));

    // 背景やパネルをクリックした場合のみ、閉じ処理に届かないよう握り潰す
    if (clickedInsideViewer && !clickedOnCard){
      e.stopImmediatePropagation();
      e.stopPropagation();
      // 必要なら e.preventDefault();
    }
  }, true);
}



// === 緑カード共有：参加者選択ポップ ===
function showParticipantSelectPopup(cardText){
  const ex = document.getElementById('greenSharePopup');
  if (ex) ex.remove();

  const pop = document.createElement('div');
  pop.id = 'greenSharePopup';
  pop.style.cssText = `
    position:fixed; inset:0; z-index:2147483608;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.35);
  `;
  const panel = document.createElement('div');
  panel.className = 'modal-panel';
  panel.innerHTML = `<div style="font-weight:700;margin-bottom:8px">誰に渡す？</div>`;
  const list = document.createElement('div');
  list.style.display = 'grid';
  list.style.gridTemplateColumns = 'repeat(4, 60px)';
  list.style.gap = '8px';

  panel.appendChild(list);
  pop.appendChild(panel);
  document.body.appendChild(pop);

  // 自分以外の参加者を列挙
  get(ref(db, `rooms/${state.code}/participants`)).then(snap=>{
    const ps = snap.val() || {};
    Object.entries(ps).forEach(([uid, info])=>{
      if (uid === state.uid) return;
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = (info?.name || '?');
      btn.style.width = '100%';

    // participants/{uid}.color には「赤/青/白…」等の“表示名”が保存されている想定
      // colorToStyle() は 表示名/ID どちらでも受け取れる実装（COLOR_LISTと対） :contentReference[oaicite:3]{index=3}
      const colorName = info?.color || '';           // 未選択なら空
      const { bg, text } = colorToStyle(colorName);  // <- 既存ヘルパ
      btn.style.background = bg;
      btn.style.color = text;

      
 btn.onclick = async ()=>{
  // 1) 相手に“共有”を書き込む
  await set(ref(db, `rooms/${state.code}/greenShare/${uid}`), {
    card: cardText, from: state.uid, at: Date.now()
  });

  // ※送信時は履歴に書かない（未回答は保存しない）

  // 2) ポップを閉じる
  pop.remove();
};

      list.appendChild(btn);
    });
  });

  // クリックアウェイで閉じる
  setTimeout(()=>{
    const onDocClick = (e)=>{
      if (panel.contains(e.target)) return;
      pop.remove();
      document.removeEventListener('click', onDocClick, true);
    };
    document.addEventListener('click', onDocClick, true);
  }, 0);
}

/// === 追加：受信者用「はい／いいえ」ポップ ===
function showYesNoPopoverForGreen(cardText, fromUid){
  const ex = document.getElementById('greenYesNo');
  if (ex) ex.remove();

  // --- 自分の正体を取得して判定 ---
  (async ()=>{
    // 自分の正体カード文字列（例: 'かかか' 等）を読む
    const myRoleCardSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards/${state.uid}`));
    const myRoleCard = myRoleCardSnap.val() || '';

    // ROLE_CARDS（既存定義）で役職を特定
    // どれにも該当しない場合は null
    let myRole = null;
    if (ROLE_CARDS.raider.includes(myRoleCard))   myRole = 'レイダー';
    else if (ROLE_CARDS.shadow.includes(myRoleCard))  myRole = 'シャドウ';
    else if (ROLE_CARDS.citizen.includes(myRoleCard)) myRole = 'シチズン';
    const isUrlich = (myRoleCard === 'Uウルリッヒ'); // ★ 追加：Uウルリッヒ特例フラグ

    // 質問文に含まれる語と一致するか
    const containsRaider  = cardText.includes('レイダー');
    const containsShadow  = cardText.includes('シャドウ');
    const containsCitizen = cardText.includes('シチズン');

    let shouldYes =
      (myRole === 'レイダー' && containsRaider) ||
      (myRole === 'シャドウ' && containsShadow) ||
      (myRole === 'シチズン' && containsCitizen);

const initial = String(myRoleCard).charAt(0).toUpperCase();

if (cardText.includes('D / F / G / V / W')) {
  shouldYes = ['D','F','G','V','W'].includes(initial);
} else if (cardText.includes('A / B / C / E / U')) {
  shouldYes = ['A','B','C','E','U'].includes(initial);
}
    
    // --- ポップ生成（片方のみ表示） ---
    const pop = document.createElement('div');
    pop.id = 'greenYesNo';
    pop.style.cssText = `
      position:fixed; inset:0; z-index:2147483610;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.4);
    `;
    const panel = document.createElement('div');
    panel.className = 'modal-panel';
    panel.innerHTML = `
      <div style="font-weight:800; margin-bottom:10px">回答してください</div>
      <div style="margin-bottom:8px; font-size:14px">${cardText}</div>
      <div id="ynBtns" style="display:flex; gap:10px; justify-content:center"></div>
    `;
    pop.appendChild(panel);
    document.body.appendChild(pop);

// ボタン生成：通常は役職一致で片方のみ／特例は常に「はい」だけ
const btnWrap = panel.querySelector('#ynBtns');
const yesBtn = document.createElement('button');
yesBtn.id = 'ansYes';
yesBtn.className = 'btn';
yesBtn.textContent = 'はい';

const noBtn = document.createElement('button');
noBtn.id = 'ansNo';
noBtn.className = 'btn';
noBtn.style.background = '#555';
noBtn.textContent = 'いいえ';

// ★ 追加：特例判定
const isRevealOrder = (cardText.trim() === '正体カードを見せよ');

  if (isRevealOrder){
    // 「正体カードを見せよ」のときは従来どおり「はい」だけ
    btnWrap.appendChild(yesBtn);
  }else if (isUrlich){
    // ★ Uウルリッヒ特例：その他の緑カードは常に「はい」「いいえ」両方
    btnWrap.appendChild(yesBtn);
    btnWrap.appendChild(noBtn);
  }else{
    // 従来どおり、質問内容と役職一致で片方のみ
    if (shouldYes) btnWrap.appendChild(yesBtn);
    else           btnWrap.appendChild(noBtn);
  }

async function finish(answer){
  await set(ref(db, `rooms/${state.code}/greenShareResult/${fromUid}`), {
    from: state.uid, answer, card: cardText, at: Date.now()
  });

const h2Ref = ref(db, `rooms/${state.code}/greenHistory`);

// 受信者（= 自分）の現在の表示名と色を取得（state からでも OK）
const myPartSnap = await get(ref(db, `rooms/${state.code}/participants/${state.uid}`));
const myPart = myPartSnap.val() || {};

await set(ref(db, `rooms/${state.code}/greenHistory/${push(h2Ref).key}`), {
  type: 'answered',
  from: fromUid,
  // “誰に”の uid は従来通り保持
  to: state.uid,

  // ▼ デノーマライズ（表示用スナップショット）
  toName: myPart.name || state.name || '?',
  toColor: myPart.color || '',

  // （任意）送信者名も欲しければ追加：
  // fromName: (await get(ref(db, `rooms/${state.code}/participants/${fromUid}/name`))).val() || '',

  card: cardText,
  answer,
  at: Date.now()
});


  // ★ 追加：誰かが回答したら全員終了（全員の表示を消すトリガ）
  await update(ref(db), {
    [`rooms/${state.code}/greenActive/active`]: false
  });
  
  await remove(ref(db, `rooms/${state.code}/greenShare/${state.uid}`));
  state.pinDealViewer = false;
dealCardFace.classList.remove('green-layout');
stopTimerSfx(); 
  show(dealViewer, false);
  pop.remove();
}

yesBtn.onclick = ()=> finish('yes');
// ★ 追加：特例時は「いいえ」を付けない
if (!isRevealOrder){
  noBtn.onclick  = ()=> finish('no');
}


    // 外側クリックで閉じない（誤タップ防止／ピン留め継続）
  })();
}

  
// === 緑カード共有：受信者側購読（自分宛の共有が来たら拡大表示） ===
// === 緑カード共有：受信者側購読（自分宛の共有が来たら拡大表示） ===
function observeGreenShare(){
  const myShareRef = ref(db, `rooms/${state.code}/greenShare/${state.uid}`);
  const off = onValue(myShareRef, (snap)=>{
    const rec = snap.val();
    if (rec?.card){
      // ★ ピン留め（外側タップで閉じない）
      state.pinDealViewer = true;

      // ▼▼▼ ここから変更：送信側と同じ構成（タイトル＋下部テーブル）に統一 ▼▼▼
dealCardFace.removeAttribute('style');
dealCardFace.className = 'deal-card';    
  dealCardFace.classList.add('green-layout');   // レイアウトON
      dealCardFace.innerHTML = '';                  // いったん空に

      // ① 最上部タイトル（テーブルの外）
      const title = document.createElement('div');
      title.className = 'green-title';
      title.textContent = '推理カード';
      dealCardFace.appendChild(title);

     // ★ 追加：推理カードとテーブルの間に画像を入れる
     const img = document.createElement('img');
     img.src = 'suiri.jpg';
     img.alt = '推理カード画像';
     img.style.maxWidth = '90%';   // 幅をカード内に収める（調整可）
     img.style.margin = '0px auto'; // 上下の余白を付ける
     img.style.display = 'block';  // 中央寄せ
     dealCardFace.appendChild(img);

      // ② 下部テーブル（20px／薄緑）
      const tbl = document.createElement('table');
      tbl.className = 'green-table';
      const tr  = document.createElement('tr');
      const td  = document.createElement('td');
 td.innerHTML = rec.card;                     tr.appendChild(td);
      tbl.appendChild(tr);
      dealCardFace.appendChild(tbl);
      // ▲▲▲ 変更ここまで ▲▲▲

      applyDeckTheme(dealCardFace, 'green');
      show(dealViewer, true);
startTimerSfx(); 
      // ★ 拡大をクリック → はい/いいえポップ（送信者uidを渡す）
      dealCardFace.onclick = ()=> showYesNoPopoverForGreen(rec.card, rec.from || '');

      // 受信側はここでは greenShare を消さない（回答時に消す）
    }
  });
  state.unsub.push(off);
}


/// === 追加：送信者側 結果購読（相手の「はい／いいえ」受領で閉じる） ===
function observeGreenResult(){
  const myResultRef = ref(db, `rooms/${state.code}/greenShareResult/${state.uid}`);
  const off = onValue(myResultRef, async (snap)=>{
    const rec = snap.val();
    if (!rec) return;

    const isRevealOrder = (rec.card && rec.card.trim() === '正体カードを見せよ');
    const answeredYes   = (rec.answer === 'yes');

    if (isRevealOrder && answeredYes && rec.from){
      // ★ 相手（回答者）の正体カード文字列を取得
      const otherSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards/${rec.from}`));
      const otherCard = otherSnap.val() || '';

      // 表示内容
// 表示内容（正体カードなら拡大レイアウト、その他は既定表示）
if (isRoleCard(otherCard)) {
  showRoleExpanded(otherCard);
} else {
  dealCardFace.className = 'deal-card';
  dealCardFace.textContent = String(otherCard);
}

      // ★ 正体カードの色分け（拡大ビュー用）
      if (ROLE_CARDS.shadow.includes(otherCard)) {
        dealCardFace.style.background = '#3d3b80'; // 青
        dealCardFace.style.color = '#fff';
      } else if (ROLE_CARDS.raider.includes(otherCard)) {
        dealCardFace.style.background = '#9e0d0d'; // 赤
        dealCardFace.style.color = '#fff';
      } else if (ROLE_CARDS.citizen.includes(otherCard)) {
        dealCardFace.style.background = '#e3ed1c'; // 黄
        dealCardFace.style.color = '#111';
      } else {
        dealCardFace.style.background = '#fff';
        dealCardFace.style.color = '#111';
      }

      // 送信者画面に1.2秒だけ拡大表示
      state.pinDealViewer = true;
      show(dealViewer, true);
      setTimeout(()=>{
        state.pinDealViewer = false;
        show(dealViewer, false);
      }, 1200);
    }else{
      // 従来挙動（閉じるだけ）
      state.pinDealViewer = false;
      show(dealViewer, false);
    }

    // 受領後掃除
    setTimeout(()=> remove(myResultRef), 0);
  });
  state.unsub.push(off);
}



// ★ 緑カード履歴購読（自分がめくった分のみ表示）→ #greenHistory に描画
function observeGreenHistory(){
  const box = document.getElementById('greenHistory');
  if (!box) return;

  const q = query(
    ref(db, `rooms/${state.code}/greenHistory`),
    orderByChild('at'),
    limitToLast(100)
  );

  const off = onValue(q, async (snap)=>{
    const all = snap.val() || {};

    // 1) 自分が「めくった」レコードだけに限定（from === state.uid）
    const mine = Object.values(all)
      .filter(r => r && r.from === state.uid)
      .sort((a,b)=> (a.at||0) - (b.at||0));

// 2) 参加者情報（名前・色）を取得
const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
const ps = psSnap.val() || {};

// 2.5) 全員の正体カードMap（uid → カード文字列）
const roleMapSnap = await get(ref(db, `rooms/${state.code}/deal/v1/cards`));
const roleMap = roleMapSnap.val() || {};

  // 3) 描画：通常は「質問文 → アイコン ：はい／いいえ」
//         特例（正体カードを見せよ）は「アイコン：正体カード」
box.innerHTML = '';
mine.forEach(r=>{
  const to = r.to || '';
const p  = ps[to] || {};
// まず履歴に入っているスナップショットを優先し、無ければ従来どおり participants を参照
const name  = r.toName  || p.name  || '?';
const color = r.toColor || p.color || '';

  const row = document.createElement('div');
  row.className = 'row';

  // 名前アイコン（共通）
  const iconWrap = document.createElement('span');
  iconWrap.style.display = 'inline-flex';
  iconWrap.style.alignItems = 'center';
  iconWrap.appendChild(makeEquipIcon(name, color));

const isRevealOrder = (r.card && r.card.trim() === '正体カードを見せよ');
if (isRevealOrder){
  // ▼ 特例表示：アイコン ＋ 回答者の正体カード（色付き）
// ▼ 特例表示：アイコン ＋ 回答者の正体カード（正体mini → クリックで拡大）
row.appendChild(iconWrap);

const cardName = String(roleMap[to] || '？');       // 回答者(to)の実カード
const mini = document.createElement('div');
mini.className = 'equip-card role-mini';

if (isRoleCard(cardName)) {
  // 名称から正体miniを組み立て（背景 <カード名>.jpg、枠色、イニシャル、HP、効果テーブル等）
  buildRoleMiniCard(mini, cardName);                // ← ここがポイント
  mini.title = cardName;
  mini.style.cursor = 'pointer';

  // クリックで「正体拡大」を参照
  mini.addEventListener('click', ()=>{
    // 履歴由来であることを記録（必要に応じて利用）
    state.expandedContext = { source:'history', ownerUid: to, cardName };

    // 公開UI等は閉じておく
    dealCardFace.onclick = null;
    const rp = document.getElementById('revealPopover');
    if (rp) rp.classList.add('hidden');

    showRoleExpanded(cardName);                     // 正体拡大レイアウト
    state.pinDealViewer = false;
    show(dealViewer, true);
  });
} else {
  // 念のためフォールバック（正体でない/不明なら従来のテキスト表示）
  mini.textContent = cardName;
}




  row.appendChild(mini);
}else{

    // ▼ 従来表示
    const qSpan = document.createElement('span');
qSpan.textContent = String(r.card).replace(/<br\s*\/?>/gi, '');

    const arrow = document.createTextNode(' → ');

    const ansSpan = document.createElement('span');
    const ansText = (r.type === 'answered')
      ? (r.answer === 'yes' ? 'はい' : 'いいえ')
      : '…';
    ansSpan.textContent = `：${ansText}`;

    row.appendChild(qSpan);
    row.appendChild(arrow);
    row.appendChild(iconWrap);
    row.appendChild(ansSpan);
  }
  box.appendChild(row);
});

  });

  state.unsub.push(off);
}


  
  
/* === 4b: 装備所持バーのレンダラ＋購読 === */
function renderEquipmentBar(equipData, participants){
  const bar = document.getElementById('equipBar');
  if (!bar) return;
  bar.innerHTML = '';

const uids = Object.keys(equipData || {}).sort((a,b)=>{
  if (a === state.uid) return -1;
  if (b === state.uid) return 1;
  return 0;
});
  if (uids.length === 0){ bar.classList.add('hidden'); return; }

  uids.forEach(uid=>{
    const cardsObj = equipData[uid] || {};
    const ps = participants?.[uid] || {};
    const holder = document.createElement('div');
    holder.className = 'equip-holder';

    // 所持者アイコン
    holder.appendChild(makeEquipIcon(ps.name || '?', ps.color || ''));

// 装備カードたち
const cardNames = Object.keys(cardsObj);

// ▼ 正体カード群を先頭に、それ以外を後ろに
const roleCards = [...ROLE_CARDS.raider, ...ROLE_CARDS.shadow, ...ROLE_CARDS.citizen];
const roleCardsInHand = cardNames.filter(c => roleCards.includes(c));
const others = cardNames.filter(c => !roleCards.includes(c));
const ordered = [...roleCardsInHand, ...others];

// ▼ 先に役職カードを append → 常に一番左（= 所持者アイコンの直後）
ordered.forEach(cardName=>{
  const c = document.createElement('div');
  c.className = 'equip-card';

  // ▼ 正体カードは「拡大版の縮小版」UI、装備カードは従来UI
  if (isRoleCard(cardName)) {
    // 役職メタ（init/rest/kana/faction/hp）
    const meta = (typeof ROLE_META !== 'undefined') ? ROLE_META[cardName] : null;
    const faction =
      (ROLE_CARDS.shadow && ROLE_CARDS.shadow.includes(cardName))  ? 'shadow'  :
      (ROLE_CARDS.raider && ROLE_CARDS.raider.includes(cardName))  ? 'raider'  :
      (ROLE_CARDS.citizen && ROLE_CARDS.citizen.includes(cardName))? 'citizen' : '';

    // 見た目ベース
    c.classList.add('role-mini');
    if (faction) c.classList.add(faction);                 // 枠色用クラス
    c.style.backgroundImage   = `url("${cardName}.jpg")`;  // 背景＝カード名.jpg
    c.style.backgroundSize    = 'cover';
    c.style.backgroundPosition= 'center';
    c.style.position          = 'relative';
    c.style.overflow          = 'hidden';

    // 上段：イニシャル丸＋イニシャルバー
    const top = document.createElement('div');
    top.className = 'mini-row-top';

    const ini = document.createElement('div');
    ini.className = 'mini-initial';
    ini.textContent = meta?.init ?? '';

    const rest = document.createElement('div');
    rest.className = 'mini-rest';
    rest.textContent = meta?.rest ?? '';

    top.appendChild(ini);
    top.appendChild(rest);
    c.appendChild(top);

    // 中段：名前バー＋HP丸
    const mid = document.createElement('div');
    mid.className = 'mini-center';

    const nameBar = document.createElement('div');
    nameBar.className = 'mini-name';
    nameBar.textContent = meta?.kana ?? cardName;

    const hp = document.createElement('div');
    hp.className = 'mini-hp';
    const hpSpan = document.createElement('span');
    hpSpan.textContent = (meta?.hp != null) ? String(meta.hp) : '';
    hp.appendChild(hpSpan);

    mid.appendChild(nameBar);
    mid.appendChild(hp);
    c.appendChild(mid);

    // 下段：効果テーブル（役職色の下地）
    const eff = document.createElement('div');
    eff.className = 'mini-table';
let html = '';
if (typeof ROLE_MINI_INFO !== 'undefined' && ROLE_MINI_INFO[cardName]) {
  html = ROLE_MINI_INFO[cardName];
} else if (typeof ROLE_INFO !== 'undefined' && ROLE_INFO[cardName]) {
  html = ROLE_INFO[cardName];
}
if (html) {
  eff.innerHTML = html.replace(/<br\s*\/?>/gi, '<br>');
}
    c.appendChild(eff);

  } else {
    // —— 装備カード：従来UI ——
    const title = document.createElement('div');
    title.className = 'equip-title';
    title.textContent = cardName;
    c.appendChild(title);

    const imgEl = document.createElement('img');
    imgEl.className = 'equip-image';
    imgEl.alt = cardName;
    imgEl.src = makeWhiteImageSrc(cardName);
    // imgEl.src = `equip_imgs/${cardName}.jpg`; // サブフォルダならこちら
    imgEl.addEventListener('error', () => imgEl.remove()); // 画像がなければ非表示
    c.appendChild(imgEl);

    // ▼ 効果テーブル（白/黒のみ）
    const isWhite = DECKS_DEF.white.cards.includes(cardName);
    const isBlack = DECKS_DEF.black.cards.includes(cardName);
    const effectText =
      isWhite ? getWhiteEffectText(cardName)
      : isBlack ? getBlackEffectText(cardName)
      : '';
    if (effectText) {
      const table = document.createElement('table');
      table.className = `equip-table ${isWhite ? 'white' : 'black'}`;
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.textContent = effectText;
      tr.appendChild(td);
      table.appendChild(tr);
      c.appendChild(table);
    }

    // デッキ色の背景（役職カードには適用しない）
    if (!c.style.background){
      if (DECKS_DEF.white.cards.includes(cardName)){
        c.style.background = '#ffffff'; c.style.color = '#111';
      } else if (DECKS_DEF.black.cards.includes(cardName)){
        c.style.background = '#000000'; c.style.color = '#fff';
      } else if (DECKS_DEF.green.cards.includes(cardName)){
        c.style.background = '#005731'; c.style.color = '#111';
      }
    }
  }

  // ▼ クリックで拡大（この下に既存のクリック処理本体を続ける）

c.addEventListener('click', ()=>{
  const name = (cardName || '').trim();
  if (!name) return;

 state.expandedContext = { source:'equip', ownerUid: uid, cardName: cardName }; // raw
  // 右下カードの公開UIは閉じる
  dealCardFace.onclick = null;
  const rp = document.getElementById('revealPopover');
  if (rp) rp.classList.add('hidden');

  if (isRoleCard(name)) {
    showRoleExpanded(name);
  } else {
    showEquipExpanded(name);
  }

  state.pinDealViewer = false;
  show(dealViewer, true);
});


  
  holder.appendChild(c);
});



    bar.appendChild(holder);
  });

  // ★ equipBar の一番下に履歴表示用コンテナを（毎回存在を保証）
  let hist = document.getElementById('equipHistory');
  if (!hist){
    hist = document.createElement('div');
    hist.id = 'equipHistory';
    hist.className = 'equip-history';
    bar.appendChild(hist);
  }else if (bar.lastElementChild !== hist){
    bar.appendChild(hist); // 何かで順序が変わっても末尾へ戻す
  }

  bar.classList.remove('hidden');
}

function observeEquipment(){
  const equipRef = ref(db, `rooms/${state.code}/equipment`);
  const off = onValue(equipRef, async (snap)=>{
    const equipData = snap.val() || {};
    // 参加者（色・名前）を併せて取得
    const psSnap = await get(ref(db, `rooms/${state.code}/participants`));
    const participants = psSnap.val() || {};
    renderEquipmentBar(equipData, participants);
  });
  state.unsub.push(off);
}
  
  // ===== ホスト管理 & 削除ポップ =====
async function becomeHostIfVacant(){
  const hostRef = ref(db, `rooms/${state.code}/host`);
  const nameRef = ref(db, `rooms/${state.code}/host_name`);

  // 空いていれば就任し、ホスト名を記録
  const res = await runTransaction(hostRef, cur => cur ?? state.uid);
  if (res.committed && (res.snapshot.val() === state.uid)){
    await set(nameRef, state.name);
  }

  // “同名復帰”の奪還：最後のホスト名と自分の名前が一致したら host を自分に上書き
  const [hostSnap, nameSnap] = await Promise.all([get(hostRef), get(nameRef)]);
  const curHost  = hostSnap.val();
  const hostName = nameSnap.val();
  if (hostName && hostName === state.name && curHost !== state.uid){
    await set(hostRef, state.uid);
  }

  const finalHostSnap = await get(hostRef);
  state.isHost = (finalHostSnap.val() === state.uid);
  show(hostGear, state.isHost);
}

  let popEl = null;
  function closePopover(){ if (popEl){ popEl.remove(); popEl=null; } }
  function maybeShowDeletePopover(ev, kind, uidTarget){
    if (!state.isHost) return;
    closePopover();
    popEl = document.createElement('div');
    popEl.className = 'popover';
    popEl.innerHTML = `<span>この${kind==='icon'?'アイコン':'席'}を削除</span>`;
    const b = document.createElement('button');
    b.textContent = '消す';
    b.onclick = async ()=>{
      if (kind==='icon') await remove(ref(db, `rooms/${state.code}/icons/${uidTarget}`));
      else await remove(ref(db, `rooms/${state.code}/seats/${uidTarget}`));
      closePopover();
    };
    popEl.appendChild(b);
    document.body.appendChild(popEl);
    const x = ev.clientX, y = ev.clientY;
    const r = popEl.getBoundingClientRect();
    popEl.style.left = Math.max(8, x - r.width/2) + 'px';
    popEl.style.top  = (y + 6) + 'px';
    setTimeout(()=>{
      document.addEventListener('click', clickAwayOnce, { once:true });
    },0);
    function clickAwayOnce(e){
      if (!popEl) return;
      if (!popEl.contains(e.target)) closePopover();
    }
  }




  // ===== 入室処理 =====
  async function join(){
    const name = normalizeName(nameInput.value);
    const code = (codeInput.value || "").trim() || random4();

    state.name = name;
    state.code = code;

    // 在室登録
    const meRef = ref(db, `rooms/${code}/participants/${state.uid}`);
    await set(meRef, { name, at: Date.now() });
    onDisconnect(meRef).remove();

    // ホスト就任（空いていれば）
    await becomeHostIfVacant();

    updateHeader();
    show(joinPanel, false);
    show(roomPanel, true);



    // 図形構築
    drawFigure2();
ensureRoomTips();

if (helpBtn){
  // ホストは⚙️があるので「？」は非表示、非ホストのみ表示
  helpBtn.classList.toggle('hidden', !!state.isHost);
  helpBtn.onclick = toggleRoomHelp;
}

ensureRoomTips();

    
    // 左長方形アイコンの同期
    const iconsRef = ref(db, `rooms/${code}/icons`);
    const offIcons = onValue(iconsRef, async (snap)=>{
      const data = snap.val() || {};
      // 参加者カラーを取得して反映
      const psSnap = await get(ref(db, `rooms/${code}/participants`));
      const ps = psSnap.val() || {};
      const colorMap = Object.fromEntries(Object.entries(ps).map(([uid, v])=> [uid, v?.color || null]));
      Object.entries(data).forEach(([uid, icon])=> renderOrUpdateIcon(uid, icon, colorMap));
      const layer = document.getElementById('icons');
      if (layer){
        [...layer.querySelectorAll('g.usericon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          if (!(uid in data)) el.remove();
        });
      }
    });
    state.unsub.push(offIcons);

    // 参加者（在籍者）を購読：state.present に常時保持
const participantsRef = ref(db, `rooms/${code}/participants`);
const offParticipants = onValue(participantsRef, (snap)=>{
  state.present = snap.val() || {};  // uid -> {name, color, ...}
if (state && state.colorClaims) {
  renderTopIcons(state.colorClaims);
}
    if (state && state.colorClaims) {
    renderColorGrid(state.colorClaims);
  }
});
state.unsub.push(offParticipants);
    

    // 席アイコンの同期＋自分の部屋/バッジ（色反映込み）
    const seatsRef = ref(db, `rooms/${code}/seats`);
    const offSeats = onValue(seatsRef, async (snap)=>{
      const data = snap.val() || {};
      // 参加者カラー
      const psSnap = await get(ref(db, `rooms/${code}/participants`));
      const ps = psSnap.val() || {};
      const colorMap = Object.fromEntries(Object.entries(ps).map(([uid, v])=> [uid, v?.color || null]));

      Object.entries(data).forEach(([uid, seat])=> renderOrUpdateSeat(uid, seat, colorMap));
      const layer = document.getElementById('seats');
      if (layer){
        [...layer.querySelectorAll('g.seaticon')].forEach(el=>{
          const uid = el.getAttribute('data-uid');
          if (!(uid in data)) el.remove();
        });
      }
      const mine = data[state.uid];
      state.myRoomNumber = mine?.room ?? null;
      myRoomBadge.textContent = mine ? `部屋：${mine.room}` : '部屋：未選択';
      refreshDeckEnable();
    });
    state.unsub.push(offSeats);

    // 山札UI
    setupDecks();

    // 色選択の購読・表示
    observeColors();
    // スタート状態監視：モーダル制御
    const startedRef = ref(db, `rooms/${code}/game/started`);
    const offStarted = onValue(startedRef, (snap)=>{
      state.started = !!snap.val();
  show(colorModal, !state.started);                  // スタートで全員の色ポップを閉じる
  btnStart.textContent = state.started ? 'リセット' : 'スタート'; // ★ 文言も全員で同期  
    });
    state.unsub.push(offStarted);

const topIdxRef = ref(db, `rooms/${code}/ui/topActiveIndex`);
const offTopIdx = onValue(topIdxRef, async (snap)=>{
  let n = snap.val();
  if (typeof n !== 'number') {
    // 初期化（ホストだけがやる。全員でやると競合するため）
    if (state.isHost) await set(topIdxRef, 0);        // 初期値 0
    n = 0;
  }

  const prev = typeof state.topActiveIndex === 'number' ? state.topActiveIndex : null;


  state.topActiveIndex = n;
  // 最新の色クレームが既にあれば再描画
  if (state && state.colorClaims) renderTopIcons(state.colorClaims);
  // ★ 追加：アクティブが「自分のインデックス」になった“瞬間”だけローカル動作
  // 1) 今のターン順の並び（在籍者かつ色取得時刻順）
  const order = getTurnOrderList();       // [{uid,name,at}, ...]
  const myIdx = order.findIndex(v => v && v.uid === state.uid);

  // 2) 直前と異なり、かつ自分の順番になったら 1秒ポップ＋音
  if (myIdx >= 0 && prev !== null && n === myIdx && prev !== n){
    showYourTurnOnce();
  }

});




state.unsub.push(offTopIdx);




    // 自分の配布カード購読
    observeMyDeal();

    // ☆ 追加：公開の購読（全員に1秒共有を反映）
    observeReveals();
attachSfxListener();
　　observeGreenHistory();
    // ★ 追加：緑カードの個別共有（自分宛）を受信
    observeGreenShare();
　　installDealViewerPinGuard();
　　observeGreenResult();
    // 装備所持の購読と描画
    observeEquipment();
    
    // ホスト設定UI
    hostGear.onclick = ()=>{
      hostPanel.classList.toggle('hidden');
    };

 btnStart.onclick = async ()=>{
   if (!state.isHost) return;
   if (state.started) {
     if (!confirm('リセットしますか？')) return;
     await hostReset();                    // ★ 新設（下記C）
   } else {
     await hostStartIfNotStarted();        // 既存：正体配布＋デッキ初期化
   }
   hostPanel.classList.add('hidden');
 };
    // カードビューア：外側クリックで閉じる
    dealViewer.addEventListener('click', (e)=>{
      if (e.target === dealViewer) show(dealViewer, false);
    });

    // ★ 同名引継ぎ（色／右下カード）
    try{
      await inheritBySameName();
    }catch(err){
      console.warn('inheritBySameName failed once', err);
    }
    // ★ onDisconnect が遅れて旧UIDが participants に残るケースへのフォロー
    setTimeout(()=>{ inheritBySameName().catch(()=>{}); }, 1200);

    state.joined = true;
  }



  // 離脱時
window.addEventListener('beforeunload', ()=>{
  // 1) すべての購読(onValue)を解除
  try {
    (state.unsub || []).forEach(fn => {
      try { typeof fn === 'function' && fn(); } catch {}
    });
  } catch {}

  // 2) 参加者リストから自分を削除（在室表示の掃除）
  try {
    if (state.joined) {
      remove(ref(db, `rooms/${state.code}/participants/${state.uid}`));
    }
  } catch {}
});


  btnJoin.onclick = join;

/* ← 追加：左長方形内タッチ中だけページスクロールを完全抑止 */
document.addEventListener('touchstart', (e)=>{
  const t = e.touches && e.touches[0];
  state.lockScrollOnRect = !!t && isInLeftRect(t.clientX, t.clientY);
}, { passive:true });

document.addEventListener('touchmove', (e)=>{
  if (state.lockScrollOnRect) e.preventDefault();   // iOS 対策：passive:false 必須
}, { passive:false });

document.addEventListener('touchend', ()=>{
  state.lockScrollOnRect = false;
}, { passive:true });

document.addEventListener('touchcancel', ()=>{
  state.lockScrollOnRect = false;
}, { passive:true });

  
  // 事前入力
  try{
    const qs = new URLSearchParams(location.search);
    const qRoom = (qs.get('room')||'').trim();
    const qName = (qs.get('name')||'').trim();
    if (qRoom) codeInput.value = qRoom.slice(0, 12);
    if (qName) nameInput.value = qName.slice(0, 1);
  }catch(_e){}
</script>
</body>
</html>
